function FI(n, e) {
  for (var t = 0; t < e.length; t++) {
    const i = e[t];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const r in i)
        if (r !== "default" && !(r in n)) {
          const s = Object.getOwnPropertyDescriptor(i, r);
          s &&
            Object.defineProperty(
              n,
              r,
              s.get ? s : { enumerable: !0, get: () => i[r] }
            );
        }
    }
  }
  return Object.freeze(
    Object.defineProperty(n, Symbol.toStringTag, { value: "Module" })
  );
}
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r);
  new MutationObserver((r) => {
    for (const s of r)
      if (s.type === "childList")
        for (const o of s.addedNodes)
          o.tagName === "LINK" && o.rel === "modulepreload" && i(o);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(r) {
    const s = {};
    return (
      r.integrity && (s.integrity = r.integrity),
      r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy),
      r.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : r.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function i(r) {
    if (r.ep) return;
    r.ep = !0;
    const s = t(r);
    fetch(r.href, s);
  }
})();
function bb(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default")
    ? n.default
    : n;
}
function NI(n) {
  if (n.__esModule) return n;
  var e = n.default;
  if (typeof e == "function") {
    var t = function i() {
      if (this instanceof i) {
        var r = [null];
        r.push.apply(r, arguments);
        var s = Function.bind.apply(e, r);
        return new s();
      }
      return e.apply(this, arguments);
    };
    t.prototype = e.prototype;
  } else t = {};
  return (
    Object.defineProperty(t, "__esModule", { value: !0 }),
    Object.keys(n).forEach(function (i) {
      var r = Object.getOwnPropertyDescriptor(n, i);
      Object.defineProperty(
        t,
        i,
        r.get
          ? r
          : {
              enumerable: !0,
              get: function () {
                return n[i];
              },
            }
      );
    }),
    t
  );
}
var Bf = {},
  OI = {
    get exports() {
      return Bf;
    },
    set exports(n) {
      Bf = n;
    },
  },
  cg = {},
  H = {},
  kI = {
    get exports() {
      return H;
    },
    set exports(n) {
      H = n;
    },
  },
  Et = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var ph = Symbol.for("react.element"),
  UI = Symbol.for("react.portal"),
  zI = Symbol.for("react.fragment"),
  GI = Symbol.for("react.strict_mode"),
  HI = Symbol.for("react.profiler"),
  VI = Symbol.for("react.provider"),
  WI = Symbol.for("react.context"),
  JI = Symbol.for("react.forward_ref"),
  jI = Symbol.for("react.suspense"),
  XI = Symbol.for("react.memo"),
  KI = Symbol.for("react.lazy"),
  XS = Symbol.iterator;
function YI(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (XS && n[XS]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var Pb = {
    isMounted: function () {
      return !1;
    },
    enqueueForceUpdate: function () {},
    enqueueReplaceState: function () {},
    enqueueSetState: function () {},
  },
  Bb = Object.assign,
  Rb = {};
function Zu(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Rb),
    (this.updater = t || Pb);
}
Zu.prototype.isReactComponent = {};
Zu.prototype.setState = function (n, e) {
  if (typeof n != "object" && typeof n != "function" && n != null)
    throw Error(
      "setState(...): takes an object of state variables to update or a function which returns an object of state variables."
    );
  this.updater.enqueueSetState(this, n, e, "setState");
};
Zu.prototype.forceUpdate = function (n) {
  this.updater.enqueueForceUpdate(this, n, "forceUpdate");
};
function Lb() {}
Lb.prototype = Zu.prototype;
function Y_(n, e, t) {
  (this.props = n),
    (this.context = e),
    (this.refs = Rb),
    (this.updater = t || Pb);
}
var Q_ = (Y_.prototype = new Lb());
Q_.constructor = Y_;
Bb(Q_, Zu.prototype);
Q_.isPureReactComponent = !0;
var KS = Array.isArray,
  Ib = Object.prototype.hasOwnProperty,
  Z_ = { current: null },
  Db = { key: !0, ref: !0, __self: !0, __source: !0 };
function Fb(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  if (e != null)
    for (i in (e.ref !== void 0 && (o = e.ref),
    e.key !== void 0 && (s = "" + e.key),
    e))
      Ib.call(e, i) && !Db.hasOwnProperty(i) && (r[i] = e[i]);
  var a = arguments.length - 2;
  if (a === 1) r.children = t;
  else if (1 < a) {
    for (var l = Array(a), c = 0; c < a; c++) l[c] = arguments[c + 2];
    r.children = l;
  }
  if (n && n.defaultProps)
    for (i in ((a = n.defaultProps), a)) r[i] === void 0 && (r[i] = a[i]);
  return {
    $$typeof: ph,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: Z_.current,
  };
}
function QI(n, e) {
  return {
    $$typeof: ph,
    type: n.type,
    key: e,
    ref: n.ref,
    props: n.props,
    _owner: n._owner,
  };
}
function q_(n) {
  return typeof n == "object" && n !== null && n.$$typeof === ph;
}
function ZI(n) {
  var e = { "=": "=0", ":": "=2" };
  return (
    "$" +
    n.replace(/[=:]/g, function (t) {
      return e[t];
    })
  );
}
var YS = /\/+/g;
function cy(n, e) {
  return typeof n == "object" && n !== null && n.key != null
    ? ZI("" + n.key)
    : e.toString(36);
}
function tm(n, e, t, i, r) {
  var s = typeof n;
  (s === "undefined" || s === "boolean") && (n = null);
  var o = !1;
  if (n === null) o = !0;
  else
    switch (s) {
      case "string":
      case "number":
        o = !0;
        break;
      case "object":
        switch (n.$$typeof) {
          case ph:
          case UI:
            o = !0;
        }
    }
  if (o)
    return (
      (o = n),
      (r = r(o)),
      (n = i === "" ? "." + cy(o, 0) : i),
      KS(r)
        ? ((t = ""),
          n != null && (t = n.replace(YS, "$&/") + "/"),
          tm(r, e, t, "", function (c) {
            return c;
          }))
        : r != null &&
          (q_(r) &&
            (r = QI(
              r,
              t +
                (!r.key || (o && o.key === r.key)
                  ? ""
                  : ("" + r.key).replace(YS, "$&/") + "/") +
                n
            )),
          e.push(r)),
      1
    );
  if (((o = 0), (i = i === "" ? "." : i + ":"), KS(n)))
    for (var a = 0; a < n.length; a++) {
      s = n[a];
      var l = i + cy(s, a);
      o += tm(s, e, t, l, r);
    }
  else if (((l = YI(n)), typeof l == "function"))
    for (n = l.call(n), a = 0; !(s = n.next()).done; )
      (s = s.value), (l = i + cy(s, a++)), (o += tm(s, e, t, l, r));
  else if (s === "object")
    throw (
      ((e = String(n)),
      Error(
        "Objects are not valid as a React child (found: " +
          (e === "[object Object]"
            ? "object with keys {" + Object.keys(n).join(", ") + "}"
            : e) +
          "). If you meant to render a collection of children, use an array instead."
      ))
    );
  return o;
}
function Hd(n, e, t) {
  if (n == null) return n;
  var i = [],
    r = 0;
  return (
    tm(n, i, "", "", function (s) {
      return e.call(t, s, r++);
    }),
    i
  );
}
function qI(n) {
  if (n._status === -1) {
    var e = n._result;
    (e = e()),
      e.then(
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 1), (n._result = t));
        },
        function (t) {
          (n._status === 0 || n._status === -1) &&
            ((n._status = 2), (n._result = t));
        }
      ),
      n._status === -1 && ((n._status = 0), (n._result = e));
  }
  if (n._status === 1) return n._result.default;
  throw n._result;
}
var gi = { current: null },
  nm = { transition: null },
  $I = {
    ReactCurrentDispatcher: gi,
    ReactCurrentBatchConfig: nm,
    ReactCurrentOwner: Z_,
  };
Et.Children = {
  map: Hd,
  forEach: function (n, e, t) {
    Hd(
      n,
      function () {
        e.apply(this, arguments);
      },
      t
    );
  },
  count: function (n) {
    var e = 0;
    return (
      Hd(n, function () {
        e++;
      }),
      e
    );
  },
  toArray: function (n) {
    return (
      Hd(n, function (e) {
        return e;
      }) || []
    );
  },
  only: function (n) {
    if (!q_(n))
      throw Error(
        "React.Children.only expected to receive a single React element child."
      );
    return n;
  },
};
Et.Component = Zu;
Et.Fragment = zI;
Et.Profiler = HI;
Et.PureComponent = Y_;
Et.StrictMode = GI;
Et.Suspense = jI;
Et.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = $I;
Et.cloneElement = function (n, e, t) {
  if (n == null)
    throw Error(
      "React.cloneElement(...): The argument must be a React element, but you passed " +
        n +
        "."
    );
  var i = Bb({}, n.props),
    r = n.key,
    s = n.ref,
    o = n._owner;
  if (e != null) {
    if (
      (e.ref !== void 0 && ((s = e.ref), (o = Z_.current)),
      e.key !== void 0 && (r = "" + e.key),
      n.type && n.type.defaultProps)
    )
      var a = n.type.defaultProps;
    for (l in e)
      Ib.call(e, l) &&
        !Db.hasOwnProperty(l) &&
        (i[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l]);
  }
  var l = arguments.length - 2;
  if (l === 1) i.children = t;
  else if (1 < l) {
    a = Array(l);
    for (var c = 0; c < l; c++) a[c] = arguments[c + 2];
    i.children = a;
  }
  return { $$typeof: ph, type: n.type, key: r, ref: s, props: i, _owner: o };
};
Et.createContext = function (n) {
  return (
    (n = {
      $$typeof: WI,
      _currentValue: n,
      _currentValue2: n,
      _threadCount: 0,
      Provider: null,
      Consumer: null,
      _defaultValue: null,
      _globalName: null,
    }),
    (n.Provider = { $$typeof: VI, _context: n }),
    (n.Consumer = n)
  );
};
Et.createElement = Fb;
Et.createFactory = function (n) {
  var e = Fb.bind(null, n);
  return (e.type = n), e;
};
Et.createRef = function () {
  return { current: null };
};
Et.forwardRef = function (n) {
  return { $$typeof: JI, render: n };
};
Et.isValidElement = q_;
Et.lazy = function (n) {
  return { $$typeof: KI, _payload: { _status: -1, _result: n }, _init: qI };
};
Et.memo = function (n, e) {
  return { $$typeof: XI, type: n, compare: e === void 0 ? null : e };
};
Et.startTransition = function (n) {
  var e = nm.transition;
  nm.transition = {};
  try {
    n();
  } finally {
    nm.transition = e;
  }
};
Et.unstable_act = function () {
  throw Error("act(...) is not supported in production builds of React.");
};
Et.useCallback = function (n, e) {
  return gi.current.useCallback(n, e);
};
Et.useContext = function (n) {
  return gi.current.useContext(n);
};
Et.useDebugValue = function () {};
Et.useDeferredValue = function (n) {
  return gi.current.useDeferredValue(n);
};
Et.useEffect = function (n, e) {
  return gi.current.useEffect(n, e);
};
Et.useId = function () {
  return gi.current.useId();
};
Et.useImperativeHandle = function (n, e, t) {
  return gi.current.useImperativeHandle(n, e, t);
};
Et.useInsertionEffect = function (n, e) {
  return gi.current.useInsertionEffect(n, e);
};
Et.useLayoutEffect = function (n, e) {
  return gi.current.useLayoutEffect(n, e);
};
Et.useMemo = function (n, e) {
  return gi.current.useMemo(n, e);
};
Et.useReducer = function (n, e, t) {
  return gi.current.useReducer(n, e, t);
};
Et.useRef = function (n) {
  return gi.current.useRef(n);
};
Et.useState = function (n) {
  return gi.current.useState(n);
};
Et.useSyncExternalStore = function (n, e, t) {
  return gi.current.useSyncExternalStore(n, e, t);
};
Et.useTransition = function () {
  return gi.current.useTransition();
};
Et.version = "18.2.0";
(function (n) {
  n.exports = Et;
})(kI);
const mh = bb(H),
  Uv = FI({ __proto__: null, default: mh }, [H]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var eD = H,
  tD = Symbol.for("react.element"),
  nD = Symbol.for("react.fragment"),
  iD = Object.prototype.hasOwnProperty,
  rD = eD.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
  sD = { key: !0, ref: !0, __self: !0, __source: !0 };
function Nb(n, e, t) {
  var i,
    r = {},
    s = null,
    o = null;
  t !== void 0 && (s = "" + t),
    e.key !== void 0 && (s = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
  for (i in e) iD.call(e, i) && !sD.hasOwnProperty(i) && (r[i] = e[i]);
  if (n && n.defaultProps)
    for (i in ((e = n.defaultProps), e)) r[i] === void 0 && (r[i] = e[i]);
  return {
    $$typeof: tD,
    type: n,
    key: s,
    ref: o,
    props: r,
    _owner: rD.current,
  };
}
cg.Fragment = nD;
cg.jsx = Nb;
cg.jsxs = Nb;
(function (n) {
  n.exports = cg;
})(OI);
const Ob = Bf.Fragment,
  we = Bf.jsx,
  St = Bf.jsxs;
var zv = {},
  Gv = {},
  oD = {
    get exports() {
      return Gv;
    },
    set exports(n) {
      Gv = n;
    },
  },
  Qi = {},
  Hv = {},
  aD = {
    get exports() {
      return Hv;
    },
    set exports(n) {
      Hv = n;
    },
  },
  kb = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(I, G) {
    var z = I.length;
    I.push(G);
    e: for (; 0 < z; ) {
      var q = (z - 1) >>> 1,
        Q = I[q];
      if (0 < r(Q, G)) (I[q] = G), (I[z] = Q), (z = q);
      else break e;
    }
  }
  function t(I) {
    return I.length === 0 ? null : I[0];
  }
  function i(I) {
    if (I.length === 0) return null;
    var G = I[0],
      z = I.pop();
    if (z !== G) {
      I[0] = z;
      e: for (var q = 0, Q = I.length, ee = Q >>> 1; q < ee; ) {
        var ne = 2 * (q + 1) - 1,
          Ce = I[ne],
          _e = ne + 1,
          $ = I[_e];
        if (0 > r(Ce, z))
          _e < Q && 0 > r($, Ce)
            ? ((I[q] = $), (I[_e] = z), (q = _e))
            : ((I[q] = Ce), (I[ne] = z), (q = ne));
        else if (_e < Q && 0 > r($, z)) (I[q] = $), (I[_e] = z), (q = _e);
        else break e;
      }
    }
    return G;
  }
  function r(I, G) {
    var z = I.sortIndex - G.sortIndex;
    return z !== 0 ? z : I.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    c = [],
    h = 1,
    d = null,
    p = 3,
    m = !1,
    v = !1,
    A = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(I) {
    for (var G = t(c); G !== null; ) {
      if (G.callback === null) i(c);
      else if (G.startTime <= I)
        i(c), (G.sortIndex = G.expirationTime), e(l, G);
      else break;
      G = t(c);
    }
  }
  function w(I) {
    if (((A = !1), S(I), !v))
      if (t(l) !== null) (v = !0), oe(E);
      else {
        var G = t(c);
        G !== null && ae(w, G.startTime - I);
      }
  }
  function E(I, G) {
    (v = !1), A && ((A = !1), g(B), (B = -1)), (m = !0);
    var z = p;
    try {
      for (
        S(G), d = t(l);
        d !== null && (!(d.expirationTime > G) || (I && !U()));

      ) {
        var q = d.callback;
        if (typeof q == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var Q = q(d.expirationTime <= G);
          (G = n.unstable_now()),
            typeof Q == "function" ? (d.callback = Q) : d === t(l) && i(l),
            S(G);
        } else i(l);
        d = t(l);
      }
      if (d !== null) var ee = !0;
      else {
        var ne = t(c);
        ne !== null && ae(w, ne.startTime - G), (ee = !1);
      }
      return ee;
    } finally {
      (d = null), (p = z), (m = !1);
    }
  }
  var P = !1,
    L = null,
    B = -1,
    b = 5,
    R = -1;
  function U() {
    return !(n.unstable_now() - R < b);
  }
  function j() {
    if (L !== null) {
      var I = n.unstable_now();
      R = I;
      var G = !0;
      try {
        G = L(!0, I);
      } finally {
        G ? V() : ((P = !1), (L = null));
      }
    } else P = !1;
  }
  var V;
  if (typeof _ == "function")
    V = function () {
      _(j);
    };
  else if (typeof MessageChannel < "u") {
    var J = new MessageChannel(),
      X = J.port2;
    (J.port1.onmessage = j),
      (V = function () {
        X.postMessage(null);
      });
  } else
    V = function () {
      x(j, 0);
    };
  function oe(I) {
    (L = I), P || ((P = !0), V());
  }
  function ae(I, G) {
    B = x(function () {
      I(n.unstable_now());
    }, G);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (I) {
      I.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      v || m || ((v = !0), oe(E));
    }),
    (n.unstable_forceFrameRate = function (I) {
      0 > I || 125 < I
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (b = 0 < I ? Math.floor(1e3 / I) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (I) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var z = p;
      p = G;
      try {
        return I();
      } finally {
        p = z;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (I, G) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var z = p;
      p = I;
      try {
        return G();
      } finally {
        p = z;
      }
    }),
    (n.unstable_scheduleCallback = function (I, G, z) {
      var q = n.unstable_now();
      switch (
        (typeof z == "object" && z !== null
          ? ((z = z.delay), (z = typeof z == "number" && 0 < z ? q + z : q))
          : (z = q),
        I)
      ) {
        case 1:
          var Q = -1;
          break;
        case 2:
          Q = 250;
          break;
        case 5:
          Q = 1073741823;
          break;
        case 4:
          Q = 1e4;
          break;
        default:
          Q = 5e3;
      }
      return (
        (Q = z + Q),
        (I = {
          id: h++,
          callback: G,
          priorityLevel: I,
          startTime: z,
          expirationTime: Q,
          sortIndex: -1,
        }),
        z > q
          ? ((I.sortIndex = z),
            e(c, I),
            t(l) === null &&
              I === t(c) &&
              (A ? (g(B), (B = -1)) : (A = !0), ae(w, z - q)))
          : ((I.sortIndex = Q), e(l, I), v || m || ((v = !0), oe(E))),
        I
      );
    }),
    (n.unstable_shouldYield = U),
    (n.unstable_wrapCallback = function (I) {
      var G = p;
      return function () {
        var z = p;
        p = G;
        try {
          return I.apply(this, arguments);
        } finally {
          p = z;
        }
      };
    });
})(kb);
(function (n) {
  n.exports = kb;
})(aD);
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var Ub = H,
  Xi = Hv;
function be(n) {
  for (
    var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + n, t = 1;
    t < arguments.length;
    t++
  )
    e += "&args[]=" + encodeURIComponent(arguments[t]);
  return (
    "Minified React error #" +
    n +
    "; visit " +
    e +
    " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
  );
}
var zb = new Set(),
  Rf = {};
function ul(n, e) {
  Lu(n, e), Lu(n + "Capture", e);
}
function Lu(n, e) {
  for (Rf[n] = e, n = 0; n < e.length; n++) zb.add(e[n]);
}
var Vs = !(
    typeof window > "u" ||
    typeof window.document > "u" ||
    typeof window.document.createElement > "u"
  ),
  Vv = Object.prototype.hasOwnProperty,
  lD =
    /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
  QS = {},
  ZS = {};
function uD(n) {
  return Vv.call(ZS, n)
    ? !0
    : Vv.call(QS, n)
    ? !1
    : lD.test(n)
    ? (ZS[n] = !0)
    : ((QS[n] = !0), !1);
}
function cD(n, e, t, i) {
  if (t !== null && t.type === 0) return !1;
  switch (typeof e) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return i
        ? !1
        : t !== null
        ? !t.acceptsBooleans
        : ((n = n.toLowerCase().slice(0, 5)), n !== "data-" && n !== "aria-");
    default:
      return !1;
  }
}
function fD(n, e, t, i) {
  if (e === null || typeof e > "u" || cD(n, e, t, i)) return !0;
  if (i) return !1;
  if (t !== null)
    switch (t.type) {
      case 3:
        return !e;
      case 4:
        return e === !1;
      case 5:
        return isNaN(e);
      case 6:
        return isNaN(e) || 1 > e;
    }
  return !1;
}
function yi(n, e, t, i, r, s, o) {
  (this.acceptsBooleans = e === 2 || e === 3 || e === 4),
    (this.attributeName = i),
    (this.attributeNamespace = r),
    (this.mustUseProperty = t),
    (this.propertyName = n),
    (this.type = e),
    (this.sanitizeURL = s),
    (this.removeEmptyString = o);
}
var Xn = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style"
  .split(" ")
  .forEach(function (n) {
    Xn[n] = new yi(n, 0, !1, n, null, !1, !1);
  });
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"],
].forEach(function (n) {
  var e = n[0];
  Xn[e] = new yi(e, 1, !1, n[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function (n) {
  Xn[n] = new yi(n, 2, !1, n.toLowerCase(), null, !1, !1);
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha",
].forEach(function (n) {
  Xn[n] = new yi(n, 2, !1, n, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope"
  .split(" ")
  .forEach(function (n) {
    Xn[n] = new yi(n, 3, !1, n.toLowerCase(), null, !1, !1);
  });
["checked", "multiple", "muted", "selected"].forEach(function (n) {
  Xn[n] = new yi(n, 3, !0, n, null, !1, !1);
});
["capture", "download"].forEach(function (n) {
  Xn[n] = new yi(n, 4, !1, n, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function (n) {
  Xn[n] = new yi(n, 6, !1, n, null, !1, !1);
});
["rowSpan", "start"].forEach(function (n) {
  Xn[n] = new yi(n, 5, !1, n.toLowerCase(), null, !1, !1);
});
var $_ = /[\-:]([a-z])/g;
function e1(n) {
  return n[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace($_, e1);
    Xn[e] = new yi(e, 1, !1, n, null, !1, !1);
  });
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type"
  .split(" ")
  .forEach(function (n) {
    var e = n.replace($_, e1);
    Xn[e] = new yi(e, 1, !1, n, "http://www.w3.org/1999/xlink", !1, !1);
  });
["xml:base", "xml:lang", "xml:space"].forEach(function (n) {
  var e = n.replace($_, e1);
  Xn[e] = new yi(e, 1, !1, n, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function (n) {
  Xn[n] = new yi(n, 1, !1, n.toLowerCase(), null, !1, !1);
});
Xn.xlinkHref = new yi(
  "xlinkHref",
  1,
  !1,
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  !1
);
["src", "href", "action", "formAction"].forEach(function (n) {
  Xn[n] = new yi(n, 1, !1, n.toLowerCase(), null, !0, !0);
});
function t1(n, e, t, i) {
  var r = Xn.hasOwnProperty(e) ? Xn[e] : null;
  (r !== null
    ? r.type !== 0
    : i ||
      !(2 < e.length) ||
      (e[0] !== "o" && e[0] !== "O") ||
      (e[1] !== "n" && e[1] !== "N")) &&
    (fD(e, t, r, i) && (t = null),
    i || r === null
      ? uD(e) && (t === null ? n.removeAttribute(e) : n.setAttribute(e, "" + t))
      : r.mustUseProperty
      ? (n[r.propertyName] = t === null ? (r.type === 3 ? !1 : "") : t)
      : ((e = r.attributeName),
        (i = r.attributeNamespace),
        t === null
          ? n.removeAttribute(e)
          : ((r = r.type),
            (t = r === 3 || (r === 4 && t === !0) ? "" : "" + t),
            i ? n.setAttributeNS(i, e, t) : n.setAttribute(e, t))));
}
var Qs = Ub.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
  Vd = Symbol.for("react.element"),
  iu = Symbol.for("react.portal"),
  ru = Symbol.for("react.fragment"),
  n1 = Symbol.for("react.strict_mode"),
  Wv = Symbol.for("react.profiler"),
  Gb = Symbol.for("react.provider"),
  Hb = Symbol.for("react.context"),
  i1 = Symbol.for("react.forward_ref"),
  Jv = Symbol.for("react.suspense"),
  jv = Symbol.for("react.suspense_list"),
  r1 = Symbol.for("react.memo"),
  _o = Symbol.for("react.lazy"),
  Vb = Symbol.for("react.offscreen"),
  qS = Symbol.iterator;
function Pc(n) {
  return n === null || typeof n != "object"
    ? null
    : ((n = (qS && n[qS]) || n["@@iterator"]),
      typeof n == "function" ? n : null);
}
var un = Object.assign,
  fy;
function rf(n) {
  if (fy === void 0)
    try {
      throw Error();
    } catch (t) {
      var e = t.stack.trim().match(/\n( *(at )?)/);
      fy = (e && e[1]) || "";
    }
  return (
    `
` +
    fy +
    n
  );
}
var hy = !1;
function dy(n, e) {
  if (!n || hy) return "";
  hy = !0;
  var t = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (e)
      if (
        ((e = function () {
          throw Error();
        }),
        Object.defineProperty(e.prototype, "props", {
          set: function () {
            throw Error();
          },
        }),
        typeof Reflect == "object" && Reflect.construct)
      ) {
        try {
          Reflect.construct(e, []);
        } catch (c) {
          var i = c;
        }
        Reflect.construct(n, [], e);
      } else {
        try {
          e.call();
        } catch (c) {
          i = c;
        }
        n.call(e.prototype);
      }
    else {
      try {
        throw Error();
      } catch (c) {
        i = c;
      }
      n();
    }
  } catch (c) {
    if (c && i && typeof c.stack == "string") {
      for (
        var r = c.stack.split(`
`),
          s = i.stack.split(`
`),
          o = r.length - 1,
          a = s.length - 1;
        1 <= o && 0 <= a && r[o] !== s[a];

      )
        a--;
      for (; 1 <= o && 0 <= a; o--, a--)
        if (r[o] !== s[a]) {
          if (o !== 1 || a !== 1)
            do
              if ((o--, a--, 0 > a || r[o] !== s[a])) {
                var l =
                  `
` + r[o].replace(" at new ", " at ");
                return (
                  n.displayName &&
                    l.includes("<anonymous>") &&
                    (l = l.replace("<anonymous>", n.displayName)),
                  l
                );
              }
            while (1 <= o && 0 <= a);
          break;
        }
    }
  } finally {
    (hy = !1), (Error.prepareStackTrace = t);
  }
  return (n = n ? n.displayName || n.name : "") ? rf(n) : "";
}
function hD(n) {
  switch (n.tag) {
    case 5:
      return rf(n.type);
    case 16:
      return rf("Lazy");
    case 13:
      return rf("Suspense");
    case 19:
      return rf("SuspenseList");
    case 0:
    case 2:
    case 15:
      return (n = dy(n.type, !1)), n;
    case 11:
      return (n = dy(n.type.render, !1)), n;
    case 1:
      return (n = dy(n.type, !0)), n;
    default:
      return "";
  }
}
function Xv(n) {
  if (n == null) return null;
  if (typeof n == "function") return n.displayName || n.name || null;
  if (typeof n == "string") return n;
  switch (n) {
    case ru:
      return "Fragment";
    case iu:
      return "Portal";
    case Wv:
      return "Profiler";
    case n1:
      return "StrictMode";
    case Jv:
      return "Suspense";
    case jv:
      return "SuspenseList";
  }
  if (typeof n == "object")
    switch (n.$$typeof) {
      case Hb:
        return (n.displayName || "Context") + ".Consumer";
      case Gb:
        return (n._context.displayName || "Context") + ".Provider";
      case i1:
        var e = n.render;
        return (
          (n = n.displayName),
          n ||
            ((n = e.displayName || e.name || ""),
            (n = n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")),
          n
        );
      case r1:
        return (
          (e = n.displayName || null), e !== null ? e : Xv(n.type) || "Memo"
        );
      case _o:
        (e = n._payload), (n = n._init);
        try {
          return Xv(n(e));
        } catch {}
    }
  return null;
}
function dD(n) {
  var e = n.type;
  switch (n.tag) {
    case 24:
      return "Cache";
    case 9:
      return (e.displayName || "Context") + ".Consumer";
    case 10:
      return (e._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return (
        (n = e.render),
        (n = n.displayName || n.name || ""),
        e.displayName || (n !== "" ? "ForwardRef(" + n + ")" : "ForwardRef")
      );
    case 7:
      return "Fragment";
    case 5:
      return e;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Xv(e);
    case 8:
      return e === n1 ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof e == "function") return e.displayName || e.name || null;
      if (typeof e == "string") return e;
  }
  return null;
}
function Ho(n) {
  switch (typeof n) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return n;
    case "object":
      return n;
    default:
      return "";
  }
}
function Wb(n) {
  var e = n.type;
  return (
    (n = n.nodeName) &&
    n.toLowerCase() === "input" &&
    (e === "checkbox" || e === "radio")
  );
}
function pD(n) {
  var e = Wb(n) ? "checked" : "value",
    t = Object.getOwnPropertyDescriptor(n.constructor.prototype, e),
    i = "" + n[e];
  if (
    !n.hasOwnProperty(e) &&
    typeof t < "u" &&
    typeof t.get == "function" &&
    typeof t.set == "function"
  ) {
    var r = t.get,
      s = t.set;
    return (
      Object.defineProperty(n, e, {
        configurable: !0,
        get: function () {
          return r.call(this);
        },
        set: function (o) {
          (i = "" + o), s.call(this, o);
        },
      }),
      Object.defineProperty(n, e, { enumerable: t.enumerable }),
      {
        getValue: function () {
          return i;
        },
        setValue: function (o) {
          i = "" + o;
        },
        stopTracking: function () {
          (n._valueTracker = null), delete n[e];
        },
      }
    );
  }
}
function Wd(n) {
  n._valueTracker || (n._valueTracker = pD(n));
}
function Jb(n) {
  if (!n) return !1;
  var e = n._valueTracker;
  if (!e) return !0;
  var t = e.getValue(),
    i = "";
  return (
    n && (i = Wb(n) ? (n.checked ? "true" : "false") : n.value),
    (n = i),
    n !== t ? (e.setValue(n), !0) : !1
  );
}
function Mm(n) {
  if (((n = n || (typeof document < "u" ? document : void 0)), typeof n > "u"))
    return null;
  try {
    return n.activeElement || n.body;
  } catch {
    return n.body;
  }
}
function Kv(n, e) {
  var t = e.checked;
  return un({}, e, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: void 0,
    checked: t ?? n._wrapperState.initialChecked,
  });
}
function $S(n, e) {
  var t = e.defaultValue == null ? "" : e.defaultValue,
    i = e.checked != null ? e.checked : e.defaultChecked;
  (t = Ho(e.value != null ? e.value : t)),
    (n._wrapperState = {
      initialChecked: i,
      initialValue: t,
      controlled:
        e.type === "checkbox" || e.type === "radio"
          ? e.checked != null
          : e.value != null,
    });
}
function jb(n, e) {
  (e = e.checked), e != null && t1(n, "checked", e, !1);
}
function Yv(n, e) {
  jb(n, e);
  var t = Ho(e.value),
    i = e.type;
  if (t != null)
    i === "number"
      ? ((t === 0 && n.value === "") || n.value != t) && (n.value = "" + t)
      : n.value !== "" + t && (n.value = "" + t);
  else if (i === "submit" || i === "reset") {
    n.removeAttribute("value");
    return;
  }
  e.hasOwnProperty("value")
    ? Qv(n, e.type, t)
    : e.hasOwnProperty("defaultValue") && Qv(n, e.type, Ho(e.defaultValue)),
    e.checked == null &&
      e.defaultChecked != null &&
      (n.defaultChecked = !!e.defaultChecked);
}
function ew(n, e, t) {
  if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
    var i = e.type;
    if (
      !(
        (i !== "submit" && i !== "reset") ||
        (e.value !== void 0 && e.value !== null)
      )
    )
      return;
    (e = "" + n._wrapperState.initialValue),
      t || e === n.value || (n.value = e),
      (n.defaultValue = e);
  }
  (t = n.name),
    t !== "" && (n.name = ""),
    (n.defaultChecked = !!n._wrapperState.initialChecked),
    t !== "" && (n.name = t);
}
function Qv(n, e, t) {
  (e !== "number" || Mm(n.ownerDocument) !== n) &&
    (t == null
      ? (n.defaultValue = "" + n._wrapperState.initialValue)
      : n.defaultValue !== "" + t && (n.defaultValue = "" + t));
}
var sf = Array.isArray;
function Mu(n, e, t, i) {
  if (((n = n.options), e)) {
    e = {};
    for (var r = 0; r < t.length; r++) e["$" + t[r]] = !0;
    for (t = 0; t < n.length; t++)
      (r = e.hasOwnProperty("$" + n[t].value)),
        n[t].selected !== r && (n[t].selected = r),
        r && i && (n[t].defaultSelected = !0);
  } else {
    for (t = "" + Ho(t), e = null, r = 0; r < n.length; r++) {
      if (n[r].value === t) {
        (n[r].selected = !0), i && (n[r].defaultSelected = !0);
        return;
      }
      e !== null || n[r].disabled || (e = n[r]);
    }
    e !== null && (e.selected = !0);
  }
}
function Zv(n, e) {
  if (e.dangerouslySetInnerHTML != null) throw Error(be(91));
  return un({}, e, {
    value: void 0,
    defaultValue: void 0,
    children: "" + n._wrapperState.initialValue,
  });
}
function tw(n, e) {
  var t = e.value;
  if (t == null) {
    if (((t = e.children), (e = e.defaultValue), t != null)) {
      if (e != null) throw Error(be(92));
      if (sf(t)) {
        if (1 < t.length) throw Error(be(93));
        t = t[0];
      }
      e = t;
    }
    e == null && (e = ""), (t = e);
  }
  n._wrapperState = { initialValue: Ho(t) };
}
function Xb(n, e) {
  var t = Ho(e.value),
    i = Ho(e.defaultValue);
  t != null &&
    ((t = "" + t),
    t !== n.value && (n.value = t),
    e.defaultValue == null && n.defaultValue !== t && (n.defaultValue = t)),
    i != null && (n.defaultValue = "" + i);
}
function nw(n) {
  var e = n.textContent;
  e === n._wrapperState.initialValue && e !== "" && e !== null && (n.value = e);
}
function Kb(n) {
  switch (n) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function qv(n, e) {
  return n == null || n === "http://www.w3.org/1999/xhtml"
    ? Kb(e)
    : n === "http://www.w3.org/2000/svg" && e === "foreignObject"
    ? "http://www.w3.org/1999/xhtml"
    : n;
}
var Jd,
  Yb = (function (n) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction
      ? function (e, t, i, r) {
          MSApp.execUnsafeLocalFunction(function () {
            return n(e, t, i, r);
          });
        }
      : n;
  })(function (n, e) {
    if (n.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in n)
      n.innerHTML = e;
    else {
      for (
        Jd = Jd || document.createElement("div"),
          Jd.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
          e = Jd.firstChild;
        n.firstChild;

      )
        n.removeChild(n.firstChild);
      for (; e.firstChild; ) n.appendChild(e.firstChild);
    }
  });
function Lf(n, e) {
  if (e) {
    var t = n.firstChild;
    if (t && t === n.lastChild && t.nodeType === 3) {
      t.nodeValue = e;
      return;
    }
  }
  n.textContent = e;
}
var ff = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0,
  },
  mD = ["Webkit", "ms", "Moz", "O"];
Object.keys(ff).forEach(function (n) {
  mD.forEach(function (e) {
    (e = e + n.charAt(0).toUpperCase() + n.substring(1)), (ff[e] = ff[n]);
  });
});
function Qb(n, e, t) {
  return e == null || typeof e == "boolean" || e === ""
    ? ""
    : t || typeof e != "number" || e === 0 || (ff.hasOwnProperty(n) && ff[n])
    ? ("" + e).trim()
    : e + "px";
}
function Zb(n, e) {
  n = n.style;
  for (var t in e)
    if (e.hasOwnProperty(t)) {
      var i = t.indexOf("--") === 0,
        r = Qb(t, e[t], i);
      t === "float" && (t = "cssFloat"), i ? n.setProperty(t, r) : (n[t] = r);
    }
}
var gD = un(
  { menuitem: !0 },
  {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
  }
);
function $v(n, e) {
  if (e) {
    if (gD[n] && (e.children != null || e.dangerouslySetInnerHTML != null))
      throw Error(be(137, n));
    if (e.dangerouslySetInnerHTML != null) {
      if (e.children != null) throw Error(be(60));
      if (
        typeof e.dangerouslySetInnerHTML != "object" ||
        !("__html" in e.dangerouslySetInnerHTML)
      )
        throw Error(be(61));
    }
    if (e.style != null && typeof e.style != "object") throw Error(be(62));
  }
}
function ex(n, e) {
  if (n.indexOf("-") === -1) return typeof e.is == "string";
  switch (n) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
var tx = null;
function s1(n) {
  return (
    (n = n.target || n.srcElement || window),
    n.correspondingUseElement && (n = n.correspondingUseElement),
    n.nodeType === 3 ? n.parentNode : n
  );
}
var nx = null,
  Su = null,
  wu = null;
function iw(n) {
  if ((n = vh(n))) {
    if (typeof nx != "function") throw Error(be(280));
    var e = n.stateNode;
    e && ((e = mg(e)), nx(n.stateNode, n.type, e));
  }
}
function qb(n) {
  Su ? (wu ? wu.push(n) : (wu = [n])) : (Su = n);
}
function $b() {
  if (Su) {
    var n = Su,
      e = wu;
    if (((wu = Su = null), iw(n), e)) for (n = 0; n < e.length; n++) iw(e[n]);
  }
}
function eP(n, e) {
  return n(e);
}
function tP() {}
var py = !1;
function nP(n, e, t) {
  if (py) return n(e, t);
  py = !0;
  try {
    return eP(n, e, t);
  } finally {
    (py = !1), (Su !== null || wu !== null) && (tP(), $b());
  }
}
function If(n, e) {
  var t = n.stateNode;
  if (t === null) return null;
  var i = mg(t);
  if (i === null) return null;
  t = i[e];
  e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (i = !i.disabled) ||
        ((n = n.type),
        (i = !(
          n === "button" ||
          n === "input" ||
          n === "select" ||
          n === "textarea"
        ))),
        (n = !i);
      break e;
    default:
      n = !1;
  }
  if (n) return null;
  if (t && typeof t != "function") throw Error(be(231, e, typeof t));
  return t;
}
var ix = !1;
if (Vs)
  try {
    var Bc = {};
    Object.defineProperty(Bc, "passive", {
      get: function () {
        ix = !0;
      },
    }),
      window.addEventListener("test", Bc, Bc),
      window.removeEventListener("test", Bc, Bc);
  } catch {
    ix = !1;
  }
function yD(n, e, t, i, r, s, o, a, l) {
  var c = Array.prototype.slice.call(arguments, 3);
  try {
    e.apply(t, c);
  } catch (h) {
    this.onError(h);
  }
}
var hf = !1,
  Sm = null,
  wm = !1,
  rx = null,
  vD = {
    onError: function (n) {
      (hf = !0), (Sm = n);
    },
  };
function xD(n, e, t, i, r, s, o, a, l) {
  (hf = !1), (Sm = null), yD.apply(vD, arguments);
}
function _D(n, e, t, i, r, s, o, a, l) {
  if ((xD.apply(this, arguments), hf)) {
    if (hf) {
      var c = Sm;
      (hf = !1), (Sm = null);
    } else throw Error(be(198));
    wm || ((wm = !0), (rx = c));
  }
}
function cl(n) {
  var e = n,
    t = n;
  if (n.alternate) for (; e.return; ) e = e.return;
  else {
    n = e;
    do (e = n), e.flags & 4098 && (t = e.return), (n = e.return);
    while (n);
  }
  return e.tag === 3 ? t : null;
}
function iP(n) {
  if (n.tag === 13) {
    var e = n.memoizedState;
    if (
      (e === null && ((n = n.alternate), n !== null && (e = n.memoizedState)),
      e !== null)
    )
      return e.dehydrated;
  }
  return null;
}
function rw(n) {
  if (cl(n) !== n) throw Error(be(188));
}
function AD(n) {
  var e = n.alternate;
  if (!e) {
    if (((e = cl(n)), e === null)) throw Error(be(188));
    return e !== n ? null : n;
  }
  for (var t = n, i = e; ; ) {
    var r = t.return;
    if (r === null) break;
    var s = r.alternate;
    if (s === null) {
      if (((i = r.return), i !== null)) {
        t = i;
        continue;
      }
      break;
    }
    if (r.child === s.child) {
      for (s = r.child; s; ) {
        if (s === t) return rw(r), n;
        if (s === i) return rw(r), e;
        s = s.sibling;
      }
      throw Error(be(188));
    }
    if (t.return !== i.return) (t = r), (i = s);
    else {
      for (var o = !1, a = r.child; a; ) {
        if (a === t) {
          (o = !0), (t = r), (i = s);
          break;
        }
        if (a === i) {
          (o = !0), (i = r), (t = s);
          break;
        }
        a = a.sibling;
      }
      if (!o) {
        for (a = s.child; a; ) {
          if (a === t) {
            (o = !0), (t = s), (i = r);
            break;
          }
          if (a === i) {
            (o = !0), (i = s), (t = r);
            break;
          }
          a = a.sibling;
        }
        if (!o) throw Error(be(189));
      }
    }
    if (t.alternate !== i) throw Error(be(190));
  }
  if (t.tag !== 3) throw Error(be(188));
  return t.stateNode.current === t ? n : e;
}
function rP(n) {
  return (n = AD(n)), n !== null ? sP(n) : null;
}
function sP(n) {
  if (n.tag === 5 || n.tag === 6) return n;
  for (n = n.child; n !== null; ) {
    var e = sP(n);
    if (e !== null) return e;
    n = n.sibling;
  }
  return null;
}
var oP = Xi.unstable_scheduleCallback,
  sw = Xi.unstable_cancelCallback,
  MD = Xi.unstable_shouldYield,
  SD = Xi.unstable_requestPaint,
  yn = Xi.unstable_now,
  wD = Xi.unstable_getCurrentPriorityLevel,
  o1 = Xi.unstable_ImmediatePriority,
  aP = Xi.unstable_UserBlockingPriority,
  Cm = Xi.unstable_NormalPriority,
  CD = Xi.unstable_LowPriority,
  lP = Xi.unstable_IdlePriority,
  fg = null,
  ss = null;
function ED(n) {
  if (ss && typeof ss.onCommitFiberRoot == "function")
    try {
      ss.onCommitFiberRoot(fg, n, void 0, (n.current.flags & 128) === 128);
    } catch {}
}
var Fr = Math.clz32 ? Math.clz32 : PD,
  TD = Math.log,
  bD = Math.LN2;
function PD(n) {
  return (n >>>= 0), n === 0 ? 32 : (31 - ((TD(n) / bD) | 0)) | 0;
}
var jd = 64,
  Xd = 4194304;
function of(n) {
  switch (n & -n) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return n & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return n & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return n;
  }
}
function Em(n, e) {
  var t = n.pendingLanes;
  if (t === 0) return 0;
  var i = 0,
    r = n.suspendedLanes,
    s = n.pingedLanes,
    o = t & 268435455;
  if (o !== 0) {
    var a = o & ~r;
    a !== 0 ? (i = of(a)) : ((s &= o), s !== 0 && (i = of(s)));
  } else (o = t & ~r), o !== 0 ? (i = of(o)) : s !== 0 && (i = of(s));
  if (i === 0) return 0;
  if (
    e !== 0 &&
    e !== i &&
    !(e & r) &&
    ((r = i & -i), (s = e & -e), r >= s || (r === 16 && (s & 4194240) !== 0))
  )
    return e;
  if ((i & 4 && (i |= t & 16), (e = n.entangledLanes), e !== 0))
    for (n = n.entanglements, e &= i; 0 < e; )
      (t = 31 - Fr(e)), (r = 1 << t), (i |= n[t]), (e &= ~r);
  return i;
}
function BD(n, e) {
  switch (n) {
    case 1:
    case 2:
    case 4:
      return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function RD(n, e) {
  for (
    var t = n.suspendedLanes,
      i = n.pingedLanes,
      r = n.expirationTimes,
      s = n.pendingLanes;
    0 < s;

  ) {
    var o = 31 - Fr(s),
      a = 1 << o,
      l = r[o];
    l === -1
      ? (!(a & t) || a & i) && (r[o] = BD(a, e))
      : l <= e && (n.expiredLanes |= a),
      (s &= ~a);
  }
}
function sx(n) {
  return (
    (n = n.pendingLanes & -1073741825),
    n !== 0 ? n : n & 1073741824 ? 1073741824 : 0
  );
}
function uP() {
  var n = jd;
  return (jd <<= 1), !(jd & 4194240) && (jd = 64), n;
}
function my(n) {
  for (var e = [], t = 0; 31 > t; t++) e.push(n);
  return e;
}
function gh(n, e, t) {
  (n.pendingLanes |= e),
    e !== 536870912 && ((n.suspendedLanes = 0), (n.pingedLanes = 0)),
    (n = n.eventTimes),
    (e = 31 - Fr(e)),
    (n[e] = t);
}
function LD(n, e) {
  var t = n.pendingLanes & ~e;
  (n.pendingLanes = e),
    (n.suspendedLanes = 0),
    (n.pingedLanes = 0),
    (n.expiredLanes &= e),
    (n.mutableReadLanes &= e),
    (n.entangledLanes &= e),
    (e = n.entanglements);
  var i = n.eventTimes;
  for (n = n.expirationTimes; 0 < t; ) {
    var r = 31 - Fr(t),
      s = 1 << r;
    (e[r] = 0), (i[r] = -1), (n[r] = -1), (t &= ~s);
  }
}
function a1(n, e) {
  var t = (n.entangledLanes |= e);
  for (n = n.entanglements; t; ) {
    var i = 31 - Fr(t),
      r = 1 << i;
    (r & e) | (n[i] & e) && (n[i] |= e), (t &= ~r);
  }
}
var kt = 0;
function cP(n) {
  return (n &= -n), 1 < n ? (4 < n ? (n & 268435455 ? 16 : 536870912) : 4) : 1;
}
var fP,
  l1,
  hP,
  dP,
  pP,
  ox = !1,
  Kd = [],
  Bo = null,
  Ro = null,
  Lo = null,
  Df = new Map(),
  Ff = new Map(),
  wo = [],
  ID =
    "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(
      " "
    );
function ow(n, e) {
  switch (n) {
    case "focusin":
    case "focusout":
      Bo = null;
      break;
    case "dragenter":
    case "dragleave":
      Ro = null;
      break;
    case "mouseover":
    case "mouseout":
      Lo = null;
      break;
    case "pointerover":
    case "pointerout":
      Df.delete(e.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Ff.delete(e.pointerId);
  }
}
function Rc(n, e, t, i, r, s) {
  return n === null || n.nativeEvent !== s
    ? ((n = {
        blockedOn: e,
        domEventName: t,
        eventSystemFlags: i,
        nativeEvent: s,
        targetContainers: [r],
      }),
      e !== null && ((e = vh(e)), e !== null && l1(e)),
      n)
    : ((n.eventSystemFlags |= i),
      (e = n.targetContainers),
      r !== null && e.indexOf(r) === -1 && e.push(r),
      n);
}
function DD(n, e, t, i, r) {
  switch (e) {
    case "focusin":
      return (Bo = Rc(Bo, n, e, t, i, r)), !0;
    case "dragenter":
      return (Ro = Rc(Ro, n, e, t, i, r)), !0;
    case "mouseover":
      return (Lo = Rc(Lo, n, e, t, i, r)), !0;
    case "pointerover":
      var s = r.pointerId;
      return Df.set(s, Rc(Df.get(s) || null, n, e, t, i, r)), !0;
    case "gotpointercapture":
      return (
        (s = r.pointerId), Ff.set(s, Rc(Ff.get(s) || null, n, e, t, i, r)), !0
      );
  }
  return !1;
}
function mP(n) {
  var e = Fa(n.target);
  if (e !== null) {
    var t = cl(e);
    if (t !== null) {
      if (((e = t.tag), e === 13)) {
        if (((e = iP(t)), e !== null)) {
          (n.blockedOn = e),
            pP(n.priority, function () {
              hP(t);
            });
          return;
        }
      } else if (e === 3 && t.stateNode.current.memoizedState.isDehydrated) {
        n.blockedOn = t.tag === 3 ? t.stateNode.containerInfo : null;
        return;
      }
    }
  }
  n.blockedOn = null;
}
function im(n) {
  if (n.blockedOn !== null) return !1;
  for (var e = n.targetContainers; 0 < e.length; ) {
    var t = ax(n.domEventName, n.eventSystemFlags, e[0], n.nativeEvent);
    if (t === null) {
      t = n.nativeEvent;
      var i = new t.constructor(t.type, t);
      (tx = i), t.target.dispatchEvent(i), (tx = null);
    } else return (e = vh(t)), e !== null && l1(e), (n.blockedOn = t), !1;
    e.shift();
  }
  return !0;
}
function aw(n, e, t) {
  im(n) && t.delete(e);
}
function FD() {
  (ox = !1),
    Bo !== null && im(Bo) && (Bo = null),
    Ro !== null && im(Ro) && (Ro = null),
    Lo !== null && im(Lo) && (Lo = null),
    Df.forEach(aw),
    Ff.forEach(aw);
}
function Lc(n, e) {
  n.blockedOn === e &&
    ((n.blockedOn = null),
    ox ||
      ((ox = !0),
      Xi.unstable_scheduleCallback(Xi.unstable_NormalPriority, FD)));
}
function Nf(n) {
  function e(r) {
    return Lc(r, n);
  }
  if (0 < Kd.length) {
    Lc(Kd[0], n);
    for (var t = 1; t < Kd.length; t++) {
      var i = Kd[t];
      i.blockedOn === n && (i.blockedOn = null);
    }
  }
  for (
    Bo !== null && Lc(Bo, n),
      Ro !== null && Lc(Ro, n),
      Lo !== null && Lc(Lo, n),
      Df.forEach(e),
      Ff.forEach(e),
      t = 0;
    t < wo.length;
    t++
  )
    (i = wo[t]), i.blockedOn === n && (i.blockedOn = null);
  for (; 0 < wo.length && ((t = wo[0]), t.blockedOn === null); )
    mP(t), t.blockedOn === null && wo.shift();
}
var Cu = Qs.ReactCurrentBatchConfig,
  Tm = !0;
function ND(n, e, t, i) {
  var r = kt,
    s = Cu.transition;
  Cu.transition = null;
  try {
    (kt = 1), u1(n, e, t, i);
  } finally {
    (kt = r), (Cu.transition = s);
  }
}
function OD(n, e, t, i) {
  var r = kt,
    s = Cu.transition;
  Cu.transition = null;
  try {
    (kt = 4), u1(n, e, t, i);
  } finally {
    (kt = r), (Cu.transition = s);
  }
}
function u1(n, e, t, i) {
  if (Tm) {
    var r = ax(n, e, t, i);
    if (r === null) Cy(n, e, i, bm, t), ow(n, i);
    else if (DD(r, n, e, t, i)) i.stopPropagation();
    else if ((ow(n, i), e & 4 && -1 < ID.indexOf(n))) {
      for (; r !== null; ) {
        var s = vh(r);
        if (
          (s !== null && fP(s),
          (s = ax(n, e, t, i)),
          s === null && Cy(n, e, i, bm, t),
          s === r)
        )
          break;
        r = s;
      }
      r !== null && i.stopPropagation();
    } else Cy(n, e, i, null, t);
  }
}
var bm = null;
function ax(n, e, t, i) {
  if (((bm = null), (n = s1(i)), (n = Fa(n)), n !== null))
    if (((e = cl(n)), e === null)) n = null;
    else if (((t = e.tag), t === 13)) {
      if (((n = iP(e)), n !== null)) return n;
      n = null;
    } else if (t === 3) {
      if (e.stateNode.current.memoizedState.isDehydrated)
        return e.tag === 3 ? e.stateNode.containerInfo : null;
      n = null;
    } else e !== n && (n = null);
  return (bm = n), null;
}
function gP(n) {
  switch (n) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (wD()) {
        case o1:
          return 1;
        case aP:
          return 4;
        case Cm:
        case CD:
          return 16;
        case lP:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var Eo = null,
  c1 = null,
  rm = null;
function yP() {
  if (rm) return rm;
  var n,
    e = c1,
    t = e.length,
    i,
    r = "value" in Eo ? Eo.value : Eo.textContent,
    s = r.length;
  for (n = 0; n < t && e[n] === r[n]; n++);
  var o = t - n;
  for (i = 1; i <= o && e[t - i] === r[s - i]; i++);
  return (rm = r.slice(n, 1 < i ? 1 - i : void 0));
}
function sm(n) {
  var e = n.keyCode;
  return (
    "charCode" in n
      ? ((n = n.charCode), n === 0 && e === 13 && (n = 13))
      : (n = e),
    n === 10 && (n = 13),
    32 <= n || n === 13 ? n : 0
  );
}
function Yd() {
  return !0;
}
function lw() {
  return !1;
}
function Zi(n) {
  function e(t, i, r, s, o) {
    (this._reactName = t),
      (this._targetInst = r),
      (this.type = i),
      (this.nativeEvent = s),
      (this.target = o),
      (this.currentTarget = null);
    for (var a in n)
      n.hasOwnProperty(a) && ((t = n[a]), (this[a] = t ? t(s) : s[a]));
    return (
      (this.isDefaultPrevented = (
        s.defaultPrevented != null ? s.defaultPrevented : s.returnValue === !1
      )
        ? Yd
        : lw),
      (this.isPropagationStopped = lw),
      this
    );
  }
  return (
    un(e.prototype, {
      preventDefault: function () {
        this.defaultPrevented = !0;
        var t = this.nativeEvent;
        t &&
          (t.preventDefault
            ? t.preventDefault()
            : typeof t.returnValue != "unknown" && (t.returnValue = !1),
          (this.isDefaultPrevented = Yd));
      },
      stopPropagation: function () {
        var t = this.nativeEvent;
        t &&
          (t.stopPropagation
            ? t.stopPropagation()
            : typeof t.cancelBubble != "unknown" && (t.cancelBubble = !0),
          (this.isPropagationStopped = Yd));
      },
      persist: function () {},
      isPersistent: Yd,
    }),
    e
  );
}
var qu = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function (n) {
      return n.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0,
  },
  f1 = Zi(qu),
  yh = un({}, qu, { view: 0, detail: 0 }),
  kD = Zi(yh),
  gy,
  yy,
  Ic,
  hg = un({}, yh, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: h1,
    button: 0,
    buttons: 0,
    relatedTarget: function (n) {
      return n.relatedTarget === void 0
        ? n.fromElement === n.srcElement
          ? n.toElement
          : n.fromElement
        : n.relatedTarget;
    },
    movementX: function (n) {
      return "movementX" in n
        ? n.movementX
        : (n !== Ic &&
            (Ic && n.type === "mousemove"
              ? ((gy = n.screenX - Ic.screenX), (yy = n.screenY - Ic.screenY))
              : (yy = gy = 0),
            (Ic = n)),
          gy);
    },
    movementY: function (n) {
      return "movementY" in n ? n.movementY : yy;
    },
  }),
  uw = Zi(hg),
  UD = un({}, hg, { dataTransfer: 0 }),
  zD = Zi(UD),
  GD = un({}, yh, { relatedTarget: 0 }),
  vy = Zi(GD),
  HD = un({}, qu, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }),
  VD = Zi(HD),
  WD = un({}, qu, {
    clipboardData: function (n) {
      return "clipboardData" in n ? n.clipboardData : window.clipboardData;
    },
  }),
  JD = Zi(WD),
  jD = un({}, qu, { data: 0 }),
  cw = Zi(jD),
  XD = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified",
  },
  KD = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta",
  },
  YD = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey",
  };
function QD(n) {
  var e = this.nativeEvent;
  return e.getModifierState ? e.getModifierState(n) : (n = YD[n]) ? !!e[n] : !1;
}
function h1() {
  return QD;
}
var ZD = un({}, yh, {
    key: function (n) {
      if (n.key) {
        var e = XD[n.key] || n.key;
        if (e !== "Unidentified") return e;
      }
      return n.type === "keypress"
        ? ((n = sm(n)), n === 13 ? "Enter" : String.fromCharCode(n))
        : n.type === "keydown" || n.type === "keyup"
        ? KD[n.keyCode] || "Unidentified"
        : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: h1,
    charCode: function (n) {
      return n.type === "keypress" ? sm(n) : 0;
    },
    keyCode: function (n) {
      return n.type === "keydown" || n.type === "keyup" ? n.keyCode : 0;
    },
    which: function (n) {
      return n.type === "keypress"
        ? sm(n)
        : n.type === "keydown" || n.type === "keyup"
        ? n.keyCode
        : 0;
    },
  }),
  qD = Zi(ZD),
  $D = un({}, hg, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0,
  }),
  fw = Zi($D),
  eF = un({}, yh, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: h1,
  }),
  tF = Zi(eF),
  nF = un({}, qu, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }),
  iF = Zi(nF),
  rF = un({}, hg, {
    deltaX: function (n) {
      return "deltaX" in n ? n.deltaX : "wheelDeltaX" in n ? -n.wheelDeltaX : 0;
    },
    deltaY: function (n) {
      return "deltaY" in n
        ? n.deltaY
        : "wheelDeltaY" in n
        ? -n.wheelDeltaY
        : "wheelDelta" in n
        ? -n.wheelDelta
        : 0;
    },
    deltaZ: 0,
    deltaMode: 0,
  }),
  sF = Zi(rF),
  oF = [9, 13, 27, 32],
  d1 = Vs && "CompositionEvent" in window,
  df = null;
Vs && "documentMode" in document && (df = document.documentMode);
var aF = Vs && "TextEvent" in window && !df,
  vP = Vs && (!d1 || (df && 8 < df && 11 >= df)),
  hw = String.fromCharCode(32),
  dw = !1;
function xP(n, e) {
  switch (n) {
    case "keyup":
      return oF.indexOf(e.keyCode) !== -1;
    case "keydown":
      return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
function _P(n) {
  return (n = n.detail), typeof n == "object" && "data" in n ? n.data : null;
}
var su = !1;
function lF(n, e) {
  switch (n) {
    case "compositionend":
      return _P(e);
    case "keypress":
      return e.which !== 32 ? null : ((dw = !0), hw);
    case "textInput":
      return (n = e.data), n === hw && dw ? null : n;
    default:
      return null;
  }
}
function uF(n, e) {
  if (su)
    return n === "compositionend" || (!d1 && xP(n, e))
      ? ((n = yP()), (rm = c1 = Eo = null), (su = !1), n)
      : null;
  switch (n) {
    case "paste":
      return null;
    case "keypress":
      if (!(e.ctrlKey || e.altKey || e.metaKey) || (e.ctrlKey && e.altKey)) {
        if (e.char && 1 < e.char.length) return e.char;
        if (e.which) return String.fromCharCode(e.which);
      }
      return null;
    case "compositionend":
      return vP && e.locale !== "ko" ? null : e.data;
    default:
      return null;
  }
}
var cF = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0,
};
function pw(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return e === "input" ? !!cF[n.type] : e === "textarea";
}
function AP(n, e, t, i) {
  qb(i),
    (e = Pm(e, "onChange")),
    0 < e.length &&
      ((t = new f1("onChange", "change", null, t, i)),
      n.push({ event: t, listeners: e }));
}
var pf = null,
  Of = null;
function fF(n) {
  LP(n, 0);
}
function dg(n) {
  var e = lu(n);
  if (Jb(e)) return n;
}
function hF(n, e) {
  if (n === "change") return e;
}
var MP = !1;
if (Vs) {
  var xy;
  if (Vs) {
    var _y = "oninput" in document;
    if (!_y) {
      var mw = document.createElement("div");
      mw.setAttribute("oninput", "return;"),
        (_y = typeof mw.oninput == "function");
    }
    xy = _y;
  } else xy = !1;
  MP = xy && (!document.documentMode || 9 < document.documentMode);
}
function gw() {
  pf && (pf.detachEvent("onpropertychange", SP), (Of = pf = null));
}
function SP(n) {
  if (n.propertyName === "value" && dg(Of)) {
    var e = [];
    AP(e, Of, n, s1(n)), nP(fF, e);
  }
}
function dF(n, e, t) {
  n === "focusin"
    ? (gw(), (pf = e), (Of = t), pf.attachEvent("onpropertychange", SP))
    : n === "focusout" && gw();
}
function pF(n) {
  if (n === "selectionchange" || n === "keyup" || n === "keydown")
    return dg(Of);
}
function mF(n, e) {
  if (n === "click") return dg(e);
}
function gF(n, e) {
  if (n === "input" || n === "change") return dg(e);
}
function yF(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
var zr = typeof Object.is == "function" ? Object.is : yF;
function kf(n, e) {
  if (zr(n, e)) return !0;
  if (typeof n != "object" || n === null || typeof e != "object" || e === null)
    return !1;
  var t = Object.keys(n),
    i = Object.keys(e);
  if (t.length !== i.length) return !1;
  for (i = 0; i < t.length; i++) {
    var r = t[i];
    if (!Vv.call(e, r) || !zr(n[r], e[r])) return !1;
  }
  return !0;
}
function yw(n) {
  for (; n && n.firstChild; ) n = n.firstChild;
  return n;
}
function vw(n, e) {
  var t = yw(n);
  n = 0;
  for (var i; t; ) {
    if (t.nodeType === 3) {
      if (((i = n + t.textContent.length), n <= e && i >= e))
        return { node: t, offset: e - n };
      n = i;
    }
    e: {
      for (; t; ) {
        if (t.nextSibling) {
          t = t.nextSibling;
          break e;
        }
        t = t.parentNode;
      }
      t = void 0;
    }
    t = yw(t);
  }
}
function wP(n, e) {
  return n && e
    ? n === e
      ? !0
      : n && n.nodeType === 3
      ? !1
      : e && e.nodeType === 3
      ? wP(n, e.parentNode)
      : "contains" in n
      ? n.contains(e)
      : n.compareDocumentPosition
      ? !!(n.compareDocumentPosition(e) & 16)
      : !1
    : !1;
}
function CP() {
  for (var n = window, e = Mm(); e instanceof n.HTMLIFrameElement; ) {
    try {
      var t = typeof e.contentWindow.location.href == "string";
    } catch {
      t = !1;
    }
    if (t) n = e.contentWindow;
    else break;
    e = Mm(n.document);
  }
  return e;
}
function p1(n) {
  var e = n && n.nodeName && n.nodeName.toLowerCase();
  return (
    e &&
    ((e === "input" &&
      (n.type === "text" ||
        n.type === "search" ||
        n.type === "tel" ||
        n.type === "url" ||
        n.type === "password")) ||
      e === "textarea" ||
      n.contentEditable === "true")
  );
}
function vF(n) {
  var e = CP(),
    t = n.focusedElem,
    i = n.selectionRange;
  if (
    e !== t &&
    t &&
    t.ownerDocument &&
    wP(t.ownerDocument.documentElement, t)
  ) {
    if (i !== null && p1(t)) {
      if (
        ((e = i.start),
        (n = i.end),
        n === void 0 && (n = e),
        "selectionStart" in t)
      )
        (t.selectionStart = e), (t.selectionEnd = Math.min(n, t.value.length));
      else if (
        ((n = ((e = t.ownerDocument || document) && e.defaultView) || window),
        n.getSelection)
      ) {
        n = n.getSelection();
        var r = t.textContent.length,
          s = Math.min(i.start, r);
        (i = i.end === void 0 ? s : Math.min(i.end, r)),
          !n.extend && s > i && ((r = i), (i = s), (s = r)),
          (r = vw(t, s));
        var o = vw(t, i);
        r &&
          o &&
          (n.rangeCount !== 1 ||
            n.anchorNode !== r.node ||
            n.anchorOffset !== r.offset ||
            n.focusNode !== o.node ||
            n.focusOffset !== o.offset) &&
          ((e = e.createRange()),
          e.setStart(r.node, r.offset),
          n.removeAllRanges(),
          s > i
            ? (n.addRange(e), n.extend(o.node, o.offset))
            : (e.setEnd(o.node, o.offset), n.addRange(e)));
      }
    }
    for (e = [], n = t; (n = n.parentNode); )
      n.nodeType === 1 &&
        e.push({ element: n, left: n.scrollLeft, top: n.scrollTop });
    for (typeof t.focus == "function" && t.focus(), t = 0; t < e.length; t++)
      (n = e[t]),
        (n.element.scrollLeft = n.left),
        (n.element.scrollTop = n.top);
  }
}
var xF = Vs && "documentMode" in document && 11 >= document.documentMode,
  ou = null,
  lx = null,
  mf = null,
  ux = !1;
function xw(n, e, t) {
  var i = t.window === t ? t.document : t.nodeType === 9 ? t : t.ownerDocument;
  ux ||
    ou == null ||
    ou !== Mm(i) ||
    ((i = ou),
    "selectionStart" in i && p1(i)
      ? (i = { start: i.selectionStart, end: i.selectionEnd })
      : ((i = (
          (i.ownerDocument && i.ownerDocument.defaultView) ||
          window
        ).getSelection()),
        (i = {
          anchorNode: i.anchorNode,
          anchorOffset: i.anchorOffset,
          focusNode: i.focusNode,
          focusOffset: i.focusOffset,
        })),
    (mf && kf(mf, i)) ||
      ((mf = i),
      (i = Pm(lx, "onSelect")),
      0 < i.length &&
        ((e = new f1("onSelect", "select", null, e, t)),
        n.push({ event: e, listeners: i }),
        (e.target = ou))));
}
function Qd(n, e) {
  var t = {};
  return (
    (t[n.toLowerCase()] = e.toLowerCase()),
    (t["Webkit" + n] = "webkit" + e),
    (t["Moz" + n] = "moz" + e),
    t
  );
}
var au = {
    animationend: Qd("Animation", "AnimationEnd"),
    animationiteration: Qd("Animation", "AnimationIteration"),
    animationstart: Qd("Animation", "AnimationStart"),
    transitionend: Qd("Transition", "TransitionEnd"),
  },
  Ay = {},
  EP = {};
Vs &&
  ((EP = document.createElement("div").style),
  "AnimationEvent" in window ||
    (delete au.animationend.animation,
    delete au.animationiteration.animation,
    delete au.animationstart.animation),
  "TransitionEvent" in window || delete au.transitionend.transition);
function pg(n) {
  if (Ay[n]) return Ay[n];
  if (!au[n]) return n;
  var e = au[n],
    t;
  for (t in e) if (e.hasOwnProperty(t) && t in EP) return (Ay[n] = e[t]);
  return n;
}
var TP = pg("animationend"),
  bP = pg("animationiteration"),
  PP = pg("animationstart"),
  BP = pg("transitionend"),
  RP = new Map(),
  _w =
    "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
      " "
    );
function qo(n, e) {
  RP.set(n, e), ul(e, [n]);
}
for (var My = 0; My < _w.length; My++) {
  var Sy = _w[My],
    _F = Sy.toLowerCase(),
    AF = Sy[0].toUpperCase() + Sy.slice(1);
  qo(_F, "on" + AF);
}
qo(TP, "onAnimationEnd");
qo(bP, "onAnimationIteration");
qo(PP, "onAnimationStart");
qo("dblclick", "onDoubleClick");
qo("focusin", "onFocus");
qo("focusout", "onBlur");
qo(BP, "onTransitionEnd");
Lu("onMouseEnter", ["mouseout", "mouseover"]);
Lu("onMouseLeave", ["mouseout", "mouseover"]);
Lu("onPointerEnter", ["pointerout", "pointerover"]);
Lu("onPointerLeave", ["pointerout", "pointerover"]);
ul(
  "onChange",
  "change click focusin focusout input keydown keyup selectionchange".split(" ")
);
ul(
  "onSelect",
  "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
    " "
  )
);
ul("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
ul(
  "onCompositionEnd",
  "compositionend focusout keydown keypress keyup mousedown".split(" ")
);
ul(
  "onCompositionStart",
  "compositionstart focusout keydown keypress keyup mousedown".split(" ")
);
ul(
  "onCompositionUpdate",
  "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
);
var af =
    "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
      " "
    ),
  MF = new Set("cancel close invalid load scroll toggle".split(" ").concat(af));
function Aw(n, e, t) {
  var i = n.type || "unknown-event";
  (n.currentTarget = t), _D(i, e, void 0, n), (n.currentTarget = null);
}
function LP(n, e) {
  e = (e & 4) !== 0;
  for (var t = 0; t < n.length; t++) {
    var i = n[t],
      r = i.event;
    i = i.listeners;
    e: {
      var s = void 0;
      if (e)
        for (var o = i.length - 1; 0 <= o; o--) {
          var a = i[o],
            l = a.instance,
            c = a.currentTarget;
          if (((a = a.listener), l !== s && r.isPropagationStopped())) break e;
          Aw(r, a, c), (s = l);
        }
      else
        for (o = 0; o < i.length; o++) {
          if (
            ((a = i[o]),
            (l = a.instance),
            (c = a.currentTarget),
            (a = a.listener),
            l !== s && r.isPropagationStopped())
          )
            break e;
          Aw(r, a, c), (s = l);
        }
    }
  }
  if (wm) throw ((n = rx), (wm = !1), (rx = null), n);
}
function Xt(n, e) {
  var t = e[px];
  t === void 0 && (t = e[px] = new Set());
  var i = n + "__bubble";
  t.has(i) || (IP(e, n, 2, !1), t.add(i));
}
function wy(n, e, t) {
  var i = 0;
  e && (i |= 4), IP(t, n, i, e);
}
var Zd = "_reactListening" + Math.random().toString(36).slice(2);
function Uf(n) {
  if (!n[Zd]) {
    (n[Zd] = !0),
      zb.forEach(function (t) {
        t !== "selectionchange" && (MF.has(t) || wy(t, !1, n), wy(t, !0, n));
      });
    var e = n.nodeType === 9 ? n : n.ownerDocument;
    e === null || e[Zd] || ((e[Zd] = !0), wy("selectionchange", !1, e));
  }
}
function IP(n, e, t, i) {
  switch (gP(e)) {
    case 1:
      var r = ND;
      break;
    case 4:
      r = OD;
      break;
    default:
      r = u1;
  }
  (t = r.bind(null, e, t, n)),
    (r = void 0),
    !ix ||
      (e !== "touchstart" && e !== "touchmove" && e !== "wheel") ||
      (r = !0),
    i
      ? r !== void 0
        ? n.addEventListener(e, t, { capture: !0, passive: r })
        : n.addEventListener(e, t, !0)
      : r !== void 0
      ? n.addEventListener(e, t, { passive: r })
      : n.addEventListener(e, t, !1);
}
function Cy(n, e, t, i, r) {
  var s = i;
  if (!(e & 1) && !(e & 2) && i !== null)
    e: for (;;) {
      if (i === null) return;
      var o = i.tag;
      if (o === 3 || o === 4) {
        var a = i.stateNode.containerInfo;
        if (a === r || (a.nodeType === 8 && a.parentNode === r)) break;
        if (o === 4)
          for (o = i.return; o !== null; ) {
            var l = o.tag;
            if (
              (l === 3 || l === 4) &&
              ((l = o.stateNode.containerInfo),
              l === r || (l.nodeType === 8 && l.parentNode === r))
            )
              return;
            o = o.return;
          }
        for (; a !== null; ) {
          if (((o = Fa(a)), o === null)) return;
          if (((l = o.tag), l === 5 || l === 6)) {
            i = s = o;
            continue e;
          }
          a = a.parentNode;
        }
      }
      i = i.return;
    }
  nP(function () {
    var c = s,
      h = s1(t),
      d = [];
    e: {
      var p = RP.get(n);
      if (p !== void 0) {
        var m = f1,
          v = n;
        switch (n) {
          case "keypress":
            if (sm(t) === 0) break e;
          case "keydown":
          case "keyup":
            m = qD;
            break;
          case "focusin":
            (v = "focus"), (m = vy);
            break;
          case "focusout":
            (v = "blur"), (m = vy);
            break;
          case "beforeblur":
          case "afterblur":
            m = vy;
            break;
          case "click":
            if (t.button === 2) break e;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            m = uw;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            m = zD;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            m = tF;
            break;
          case TP:
          case bP:
          case PP:
            m = VD;
            break;
          case BP:
            m = iF;
            break;
          case "scroll":
            m = kD;
            break;
          case "wheel":
            m = sF;
            break;
          case "copy":
          case "cut":
          case "paste":
            m = JD;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            m = fw;
        }
        var A = (e & 4) !== 0,
          x = !A && n === "scroll",
          g = A ? (p !== null ? p + "Capture" : null) : p;
        A = [];
        for (var _ = c, S; _ !== null; ) {
          S = _;
          var w = S.stateNode;
          if (
            (S.tag === 5 &&
              w !== null &&
              ((S = w),
              g !== null && ((w = If(_, g)), w != null && A.push(zf(_, w, S)))),
            x)
          )
            break;
          _ = _.return;
        }
        0 < A.length &&
          ((p = new m(p, v, null, t, h)), d.push({ event: p, listeners: A }));
      }
    }
    if (!(e & 7)) {
      e: {
        if (
          ((p = n === "mouseover" || n === "pointerover"),
          (m = n === "mouseout" || n === "pointerout"),
          p &&
            t !== tx &&
            (v = t.relatedTarget || t.fromElement) &&
            (Fa(v) || v[Ws]))
        )
          break e;
        if (
          (m || p) &&
          ((p =
            h.window === h
              ? h
              : (p = h.ownerDocument)
              ? p.defaultView || p.parentWindow
              : window),
          m
            ? ((v = t.relatedTarget || t.toElement),
              (m = c),
              (v = v ? Fa(v) : null),
              v !== null &&
                ((x = cl(v)), v !== x || (v.tag !== 5 && v.tag !== 6)) &&
                (v = null))
            : ((m = null), (v = c)),
          m !== v)
        ) {
          if (
            ((A = uw),
            (w = "onMouseLeave"),
            (g = "onMouseEnter"),
            (_ = "mouse"),
            (n === "pointerout" || n === "pointerover") &&
              ((A = fw),
              (w = "onPointerLeave"),
              (g = "onPointerEnter"),
              (_ = "pointer")),
            (x = m == null ? p : lu(m)),
            (S = v == null ? p : lu(v)),
            (p = new A(w, _ + "leave", m, t, h)),
            (p.target = x),
            (p.relatedTarget = S),
            (w = null),
            Fa(h) === c &&
              ((A = new A(g, _ + "enter", v, t, h)),
              (A.target = S),
              (A.relatedTarget = x),
              (w = A)),
            (x = w),
            m && v)
          )
            t: {
              for (A = m, g = v, _ = 0, S = A; S; S = Rl(S)) _++;
              for (S = 0, w = g; w; w = Rl(w)) S++;
              for (; 0 < _ - S; ) (A = Rl(A)), _--;
              for (; 0 < S - _; ) (g = Rl(g)), S--;
              for (; _--; ) {
                if (A === g || (g !== null && A === g.alternate)) break t;
                (A = Rl(A)), (g = Rl(g));
              }
              A = null;
            }
          else A = null;
          m !== null && Mw(d, p, m, A, !1),
            v !== null && x !== null && Mw(d, x, v, A, !0);
        }
      }
      e: {
        if (
          ((p = c ? lu(c) : window),
          (m = p.nodeName && p.nodeName.toLowerCase()),
          m === "select" || (m === "input" && p.type === "file"))
        )
          var E = hF;
        else if (pw(p))
          if (MP) E = gF;
          else {
            E = pF;
            var P = dF;
          }
        else
          (m = p.nodeName) &&
            m.toLowerCase() === "input" &&
            (p.type === "checkbox" || p.type === "radio") &&
            (E = mF);
        if (E && (E = E(n, c))) {
          AP(d, E, t, h);
          break e;
        }
        P && P(n, p, c),
          n === "focusout" &&
            (P = p._wrapperState) &&
            P.controlled &&
            p.type === "number" &&
            Qv(p, "number", p.value);
      }
      switch (((P = c ? lu(c) : window), n)) {
        case "focusin":
          (pw(P) || P.contentEditable === "true") &&
            ((ou = P), (lx = c), (mf = null));
          break;
        case "focusout":
          mf = lx = ou = null;
          break;
        case "mousedown":
          ux = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          (ux = !1), xw(d, t, h);
          break;
        case "selectionchange":
          if (xF) break;
        case "keydown":
        case "keyup":
          xw(d, t, h);
      }
      var L;
      if (d1)
        e: {
          switch (n) {
            case "compositionstart":
              var B = "onCompositionStart";
              break e;
            case "compositionend":
              B = "onCompositionEnd";
              break e;
            case "compositionupdate":
              B = "onCompositionUpdate";
              break e;
          }
          B = void 0;
        }
      else
        su
          ? xP(n, t) && (B = "onCompositionEnd")
          : n === "keydown" && t.keyCode === 229 && (B = "onCompositionStart");
      B &&
        (vP &&
          t.locale !== "ko" &&
          (su || B !== "onCompositionStart"
            ? B === "onCompositionEnd" && su && (L = yP())
            : ((Eo = h),
              (c1 = "value" in Eo ? Eo.value : Eo.textContent),
              (su = !0))),
        (P = Pm(c, B)),
        0 < P.length &&
          ((B = new cw(B, n, null, t, h)),
          d.push({ event: B, listeners: P }),
          L ? (B.data = L) : ((L = _P(t)), L !== null && (B.data = L)))),
        (L = aF ? lF(n, t) : uF(n, t)) &&
          ((c = Pm(c, "onBeforeInput")),
          0 < c.length &&
            ((h = new cw("onBeforeInput", "beforeinput", null, t, h)),
            d.push({ event: h, listeners: c }),
            (h.data = L)));
    }
    LP(d, e);
  });
}
function zf(n, e, t) {
  return { instance: n, listener: e, currentTarget: t };
}
function Pm(n, e) {
  for (var t = e + "Capture", i = []; n !== null; ) {
    var r = n,
      s = r.stateNode;
    r.tag === 5 &&
      s !== null &&
      ((r = s),
      (s = If(n, t)),
      s != null && i.unshift(zf(n, s, r)),
      (s = If(n, e)),
      s != null && i.push(zf(n, s, r))),
      (n = n.return);
  }
  return i;
}
function Rl(n) {
  if (n === null) return null;
  do n = n.return;
  while (n && n.tag !== 5);
  return n || null;
}
function Mw(n, e, t, i, r) {
  for (var s = e._reactName, o = []; t !== null && t !== i; ) {
    var a = t,
      l = a.alternate,
      c = a.stateNode;
    if (l !== null && l === i) break;
    a.tag === 5 &&
      c !== null &&
      ((a = c),
      r
        ? ((l = If(t, s)), l != null && o.unshift(zf(t, l, a)))
        : r || ((l = If(t, s)), l != null && o.push(zf(t, l, a)))),
      (t = t.return);
  }
  o.length !== 0 && n.push({ event: e, listeners: o });
}
var SF = /\r\n?/g,
  wF = /\u0000|\uFFFD/g;
function Sw(n) {
  return (typeof n == "string" ? n : "" + n)
    .replace(
      SF,
      `
`
    )
    .replace(wF, "");
}
function qd(n, e, t) {
  if (((e = Sw(e)), Sw(n) !== e && t)) throw Error(be(425));
}
function Bm() {}
var cx = null,
  fx = null;
function hx(n, e) {
  return (
    n === "textarea" ||
    n === "noscript" ||
    typeof e.children == "string" ||
    typeof e.children == "number" ||
    (typeof e.dangerouslySetInnerHTML == "object" &&
      e.dangerouslySetInnerHTML !== null &&
      e.dangerouslySetInnerHTML.__html != null)
  );
}
var dx = typeof setTimeout == "function" ? setTimeout : void 0,
  CF = typeof clearTimeout == "function" ? clearTimeout : void 0,
  ww = typeof Promise == "function" ? Promise : void 0,
  EF =
    typeof queueMicrotask == "function"
      ? queueMicrotask
      : typeof ww < "u"
      ? function (n) {
          return ww.resolve(null).then(n).catch(TF);
        }
      : dx;
function TF(n) {
  setTimeout(function () {
    throw n;
  });
}
function Ey(n, e) {
  var t = e,
    i = 0;
  do {
    var r = t.nextSibling;
    if ((n.removeChild(t), r && r.nodeType === 8))
      if (((t = r.data), t === "/$")) {
        if (i === 0) {
          n.removeChild(r), Nf(e);
          return;
        }
        i--;
      } else (t !== "$" && t !== "$?" && t !== "$!") || i++;
    t = r;
  } while (t);
  Nf(e);
}
function Io(n) {
  for (; n != null; n = n.nextSibling) {
    var e = n.nodeType;
    if (e === 1 || e === 3) break;
    if (e === 8) {
      if (((e = n.data), e === "$" || e === "$!" || e === "$?")) break;
      if (e === "/$") return null;
    }
  }
  return n;
}
function Cw(n) {
  n = n.previousSibling;
  for (var e = 0; n; ) {
    if (n.nodeType === 8) {
      var t = n.data;
      if (t === "$" || t === "$!" || t === "$?") {
        if (e === 0) return n;
        e--;
      } else t === "/$" && e++;
    }
    n = n.previousSibling;
  }
  return null;
}
var $u = Math.random().toString(36).slice(2),
  rs = "__reactFiber$" + $u,
  Gf = "__reactProps$" + $u,
  Ws = "__reactContainer$" + $u,
  px = "__reactEvents$" + $u,
  bF = "__reactListeners$" + $u,
  PF = "__reactHandles$" + $u;
function Fa(n) {
  var e = n[rs];
  if (e) return e;
  for (var t = n.parentNode; t; ) {
    if ((e = t[Ws] || t[rs])) {
      if (
        ((t = e.alternate),
        e.child !== null || (t !== null && t.child !== null))
      )
        for (n = Cw(n); n !== null; ) {
          if ((t = n[rs])) return t;
          n = Cw(n);
        }
      return e;
    }
    (n = t), (t = n.parentNode);
  }
  return null;
}
function vh(n) {
  return (
    (n = n[rs] || n[Ws]),
    !n || (n.tag !== 5 && n.tag !== 6 && n.tag !== 13 && n.tag !== 3) ? null : n
  );
}
function lu(n) {
  if (n.tag === 5 || n.tag === 6) return n.stateNode;
  throw Error(be(33));
}
function mg(n) {
  return n[Gf] || null;
}
var mx = [],
  uu = -1;
function $o(n) {
  return { current: n };
}
function Yt(n) {
  0 > uu || ((n.current = mx[uu]), (mx[uu] = null), uu--);
}
function jt(n, e) {
  uu++, (mx[uu] = n.current), (n.current = e);
}
var Vo = {},
  si = $o(Vo),
  Pi = $o(!1),
  $a = Vo;
function Iu(n, e) {
  var t = n.type.contextTypes;
  if (!t) return Vo;
  var i = n.stateNode;
  if (i && i.__reactInternalMemoizedUnmaskedChildContext === e)
    return i.__reactInternalMemoizedMaskedChildContext;
  var r = {},
    s;
  for (s in t) r[s] = e[s];
  return (
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = e),
      (n.__reactInternalMemoizedMaskedChildContext = r)),
    r
  );
}
function Bi(n) {
  return (n = n.childContextTypes), n != null;
}
function Rm() {
  Yt(Pi), Yt(si);
}
function Ew(n, e, t) {
  if (si.current !== Vo) throw Error(be(168));
  jt(si, e), jt(Pi, t);
}
function DP(n, e, t) {
  var i = n.stateNode;
  if (((e = e.childContextTypes), typeof i.getChildContext != "function"))
    return t;
  i = i.getChildContext();
  for (var r in i) if (!(r in e)) throw Error(be(108, dD(n) || "Unknown", r));
  return un({}, t, i);
}
function Lm(n) {
  return (
    (n =
      ((n = n.stateNode) && n.__reactInternalMemoizedMergedChildContext) || Vo),
    ($a = si.current),
    jt(si, n),
    jt(Pi, Pi.current),
    !0
  );
}
function Tw(n, e, t) {
  var i = n.stateNode;
  if (!i) throw Error(be(169));
  t
    ? ((n = DP(n, e, $a)),
      (i.__reactInternalMemoizedMergedChildContext = n),
      Yt(Pi),
      Yt(si),
      jt(si, n))
    : Yt(Pi),
    jt(Pi, t);
}
var Bs = null,
  gg = !1,
  Ty = !1;
function FP(n) {
  Bs === null ? (Bs = [n]) : Bs.push(n);
}
function BF(n) {
  (gg = !0), FP(n);
}
function ea() {
  if (!Ty && Bs !== null) {
    Ty = !0;
    var n = 0,
      e = kt;
    try {
      var t = Bs;
      for (kt = 1; n < t.length; n++) {
        var i = t[n];
        do i = i(!0);
        while (i !== null);
      }
      (Bs = null), (gg = !1);
    } catch (r) {
      throw (Bs !== null && (Bs = Bs.slice(n + 1)), oP(o1, ea), r);
    } finally {
      (kt = e), (Ty = !1);
    }
  }
  return null;
}
var cu = [],
  fu = 0,
  Im = null,
  Dm = 0,
  fr = [],
  hr = 0,
  el = null,
  Ds = 1,
  Fs = "";
function Ca(n, e) {
  (cu[fu++] = Dm), (cu[fu++] = Im), (Im = n), (Dm = e);
}
function NP(n, e, t) {
  (fr[hr++] = Ds), (fr[hr++] = Fs), (fr[hr++] = el), (el = n);
  var i = Ds;
  n = Fs;
  var r = 32 - Fr(i) - 1;
  (i &= ~(1 << r)), (t += 1);
  var s = 32 - Fr(e) + r;
  if (30 < s) {
    var o = r - (r % 5);
    (s = (i & ((1 << o) - 1)).toString(32)),
      (i >>= o),
      (r -= o),
      (Ds = (1 << (32 - Fr(e) + r)) | (t << r) | i),
      (Fs = s + n);
  } else (Ds = (1 << s) | (t << r) | i), (Fs = n);
}
function m1(n) {
  n.return !== null && (Ca(n, 1), NP(n, 1, 0));
}
function g1(n) {
  for (; n === Im; )
    (Im = cu[--fu]), (cu[fu] = null), (Dm = cu[--fu]), (cu[fu] = null);
  for (; n === el; )
    (el = fr[--hr]),
      (fr[hr] = null),
      (Fs = fr[--hr]),
      (fr[hr] = null),
      (Ds = fr[--hr]),
      (fr[hr] = null);
}
var Ji = null,
  Hi = null,
  $t = !1,
  Ir = null;
function OP(n, e) {
  var t = pr(5, null, null, 0);
  (t.elementType = "DELETED"),
    (t.stateNode = e),
    (t.return = n),
    (e = n.deletions),
    e === null ? ((n.deletions = [t]), (n.flags |= 16)) : e.push(t);
}
function bw(n, e) {
  switch (n.tag) {
    case 5:
      var t = n.type;
      return (
        (e =
          e.nodeType !== 1 || t.toLowerCase() !== e.nodeName.toLowerCase()
            ? null
            : e),
        e !== null
          ? ((n.stateNode = e), (Ji = n), (Hi = Io(e.firstChild)), !0)
          : !1
      );
    case 6:
      return (
        (e = n.pendingProps === "" || e.nodeType !== 3 ? null : e),
        e !== null ? ((n.stateNode = e), (Ji = n), (Hi = null), !0) : !1
      );
    case 13:
      return (
        (e = e.nodeType !== 8 ? null : e),
        e !== null
          ? ((t = el !== null ? { id: Ds, overflow: Fs } : null),
            (n.memoizedState = {
              dehydrated: e,
              treeContext: t,
              retryLane: 1073741824,
            }),
            (t = pr(18, null, null, 0)),
            (t.stateNode = e),
            (t.return = n),
            (n.child = t),
            (Ji = n),
            (Hi = null),
            !0)
          : !1
      );
    default:
      return !1;
  }
}
function gx(n) {
  return (n.mode & 1) !== 0 && (n.flags & 128) === 0;
}
function yx(n) {
  if ($t) {
    var e = Hi;
    if (e) {
      var t = e;
      if (!bw(n, e)) {
        if (gx(n)) throw Error(be(418));
        e = Io(t.nextSibling);
        var i = Ji;
        e && bw(n, e)
          ? OP(i, t)
          : ((n.flags = (n.flags & -4097) | 2), ($t = !1), (Ji = n));
      }
    } else {
      if (gx(n)) throw Error(be(418));
      (n.flags = (n.flags & -4097) | 2), ($t = !1), (Ji = n);
    }
  }
}
function Pw(n) {
  for (n = n.return; n !== null && n.tag !== 5 && n.tag !== 3 && n.tag !== 13; )
    n = n.return;
  Ji = n;
}
function $d(n) {
  if (n !== Ji) return !1;
  if (!$t) return Pw(n), ($t = !0), !1;
  var e;
  if (
    ((e = n.tag !== 3) &&
      !(e = n.tag !== 5) &&
      ((e = n.type),
      (e = e !== "head" && e !== "body" && !hx(n.type, n.memoizedProps))),
    e && (e = Hi))
  ) {
    if (gx(n)) throw (kP(), Error(be(418)));
    for (; e; ) OP(n, e), (e = Io(e.nextSibling));
  }
  if ((Pw(n), n.tag === 13)) {
    if (((n = n.memoizedState), (n = n !== null ? n.dehydrated : null), !n))
      throw Error(be(317));
    e: {
      for (n = n.nextSibling, e = 0; n; ) {
        if (n.nodeType === 8) {
          var t = n.data;
          if (t === "/$") {
            if (e === 0) {
              Hi = Io(n.nextSibling);
              break e;
            }
            e--;
          } else (t !== "$" && t !== "$!" && t !== "$?") || e++;
        }
        n = n.nextSibling;
      }
      Hi = null;
    }
  } else Hi = Ji ? Io(n.stateNode.nextSibling) : null;
  return !0;
}
function kP() {
  for (var n = Hi; n; ) n = Io(n.nextSibling);
}
function Du() {
  (Hi = Ji = null), ($t = !1);
}
function y1(n) {
  Ir === null ? (Ir = [n]) : Ir.push(n);
}
var RF = Qs.ReactCurrentBatchConfig;
function Br(n, e) {
  if (n && n.defaultProps) {
    (e = un({}, e)), (n = n.defaultProps);
    for (var t in n) e[t] === void 0 && (e[t] = n[t]);
    return e;
  }
  return e;
}
var Fm = $o(null),
  Nm = null,
  hu = null,
  v1 = null;
function x1() {
  v1 = hu = Nm = null;
}
function _1(n) {
  var e = Fm.current;
  Yt(Fm), (n._currentValue = e);
}
function vx(n, e, t) {
  for (; n !== null; ) {
    var i = n.alternate;
    if (
      ((n.childLanes & e) !== e
        ? ((n.childLanes |= e), i !== null && (i.childLanes |= e))
        : i !== null && (i.childLanes & e) !== e && (i.childLanes |= e),
      n === t)
    )
      break;
    n = n.return;
  }
}
function Eu(n, e) {
  (Nm = n),
    (v1 = hu = null),
    (n = n.dependencies),
    n !== null &&
      n.firstContext !== null &&
      (n.lanes & e && (bi = !0), (n.firstContext = null));
}
function gr(n) {
  var e = n._currentValue;
  if (v1 !== n)
    if (((n = { context: n, memoizedValue: e, next: null }), hu === null)) {
      if (Nm === null) throw Error(be(308));
      (hu = n), (Nm.dependencies = { lanes: 0, firstContext: n });
    } else hu = hu.next = n;
  return e;
}
var Na = null;
function A1(n) {
  Na === null ? (Na = [n]) : Na.push(n);
}
function UP(n, e, t, i) {
  var r = e.interleaved;
  return (
    r === null ? ((t.next = t), A1(e)) : ((t.next = r.next), (r.next = t)),
    (e.interleaved = t),
    Js(n, i)
  );
}
function Js(n, e) {
  n.lanes |= e;
  var t = n.alternate;
  for (t !== null && (t.lanes |= e), t = n, n = n.return; n !== null; )
    (n.childLanes |= e),
      (t = n.alternate),
      t !== null && (t.childLanes |= e),
      (t = n),
      (n = n.return);
  return t.tag === 3 ? t.stateNode : null;
}
var Ao = !1;
function M1(n) {
  n.updateQueue = {
    baseState: n.memoizedState,
    firstBaseUpdate: null,
    lastBaseUpdate: null,
    shared: { pending: null, interleaved: null, lanes: 0 },
    effects: null,
  };
}
function zP(n, e) {
  (n = n.updateQueue),
    e.updateQueue === n &&
      (e.updateQueue = {
        baseState: n.baseState,
        firstBaseUpdate: n.firstBaseUpdate,
        lastBaseUpdate: n.lastBaseUpdate,
        shared: n.shared,
        effects: n.effects,
      });
}
function Us(n, e) {
  return {
    eventTime: n,
    lane: e,
    tag: 0,
    payload: null,
    callback: null,
    next: null,
  };
}
function Do(n, e, t) {
  var i = n.updateQueue;
  if (i === null) return null;
  if (((i = i.shared), Bt & 2)) {
    var r = i.pending;
    return (
      r === null ? (e.next = e) : ((e.next = r.next), (r.next = e)),
      (i.pending = e),
      Js(n, t)
    );
  }
  return (
    (r = i.interleaved),
    r === null ? ((e.next = e), A1(i)) : ((e.next = r.next), (r.next = e)),
    (i.interleaved = e),
    Js(n, t)
  );
}
function om(n, e, t) {
  if (
    ((e = e.updateQueue), e !== null && ((e = e.shared), (t & 4194240) !== 0))
  ) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), a1(n, t);
  }
}
function Bw(n, e) {
  var t = n.updateQueue,
    i = n.alternate;
  if (i !== null && ((i = i.updateQueue), t === i)) {
    var r = null,
      s = null;
    if (((t = t.firstBaseUpdate), t !== null)) {
      do {
        var o = {
          eventTime: t.eventTime,
          lane: t.lane,
          tag: t.tag,
          payload: t.payload,
          callback: t.callback,
          next: null,
        };
        s === null ? (r = s = o) : (s = s.next = o), (t = t.next);
      } while (t !== null);
      s === null ? (r = s = e) : (s = s.next = e);
    } else r = s = e;
    (t = {
      baseState: i.baseState,
      firstBaseUpdate: r,
      lastBaseUpdate: s,
      shared: i.shared,
      effects: i.effects,
    }),
      (n.updateQueue = t);
    return;
  }
  (n = t.lastBaseUpdate),
    n === null ? (t.firstBaseUpdate = e) : (n.next = e),
    (t.lastBaseUpdate = e);
}
function Om(n, e, t, i) {
  var r = n.updateQueue;
  Ao = !1;
  var s = r.firstBaseUpdate,
    o = r.lastBaseUpdate,
    a = r.shared.pending;
  if (a !== null) {
    r.shared.pending = null;
    var l = a,
      c = l.next;
    (l.next = null), o === null ? (s = c) : (o.next = c), (o = l);
    var h = n.alternate;
    h !== null &&
      ((h = h.updateQueue),
      (a = h.lastBaseUpdate),
      a !== o &&
        (a === null ? (h.firstBaseUpdate = c) : (a.next = c),
        (h.lastBaseUpdate = l)));
  }
  if (s !== null) {
    var d = r.baseState;
    (o = 0), (h = c = l = null), (a = s);
    do {
      var p = a.lane,
        m = a.eventTime;
      if ((i & p) === p) {
        h !== null &&
          (h = h.next =
            {
              eventTime: m,
              lane: 0,
              tag: a.tag,
              payload: a.payload,
              callback: a.callback,
              next: null,
            });
        e: {
          var v = n,
            A = a;
          switch (((p = e), (m = t), A.tag)) {
            case 1:
              if (((v = A.payload), typeof v == "function")) {
                d = v.call(m, d, p);
                break e;
              }
              d = v;
              break e;
            case 3:
              v.flags = (v.flags & -65537) | 128;
            case 0:
              if (
                ((v = A.payload),
                (p = typeof v == "function" ? v.call(m, d, p) : v),
                p == null)
              )
                break e;
              d = un({}, d, p);
              break e;
            case 2:
              Ao = !0;
          }
        }
        a.callback !== null &&
          a.lane !== 0 &&
          ((n.flags |= 64),
          (p = r.effects),
          p === null ? (r.effects = [a]) : p.push(a));
      } else
        (m = {
          eventTime: m,
          lane: p,
          tag: a.tag,
          payload: a.payload,
          callback: a.callback,
          next: null,
        }),
          h === null ? ((c = h = m), (l = d)) : (h = h.next = m),
          (o |= p);
      if (((a = a.next), a === null)) {
        if (((a = r.shared.pending), a === null)) break;
        (p = a),
          (a = p.next),
          (p.next = null),
          (r.lastBaseUpdate = p),
          (r.shared.pending = null);
      }
    } while (1);
    if (
      (h === null && (l = d),
      (r.baseState = l),
      (r.firstBaseUpdate = c),
      (r.lastBaseUpdate = h),
      (e = r.shared.interleaved),
      e !== null)
    ) {
      r = e;
      do (o |= r.lane), (r = r.next);
      while (r !== e);
    } else s === null && (r.shared.lanes = 0);
    (nl |= o), (n.lanes = o), (n.memoizedState = d);
  }
}
function Rw(n, e, t) {
  if (((n = e.effects), (e.effects = null), n !== null))
    for (e = 0; e < n.length; e++) {
      var i = n[e],
        r = i.callback;
      if (r !== null) {
        if (((i.callback = null), (i = t), typeof r != "function"))
          throw Error(be(191, r));
        r.call(i);
      }
    }
}
var GP = new Ub.Component().refs;
function xx(n, e, t, i) {
  (e = n.memoizedState),
    (t = t(i, e)),
    (t = t == null ? e : un({}, e, t)),
    (n.memoizedState = t),
    n.lanes === 0 && (n.updateQueue.baseState = t);
}
var yg = {
  isMounted: function (n) {
    return (n = n._reactInternals) ? cl(n) === n : !1;
  },
  enqueueSetState: function (n, e, t) {
    n = n._reactInternals;
    var i = pi(),
      r = No(n),
      s = Us(i, r);
    (s.payload = e),
      t != null && (s.callback = t),
      (e = Do(n, s, r)),
      e !== null && (Nr(e, n, r, i), om(e, n, r));
  },
  enqueueReplaceState: function (n, e, t) {
    n = n._reactInternals;
    var i = pi(),
      r = No(n),
      s = Us(i, r);
    (s.tag = 1),
      (s.payload = e),
      t != null && (s.callback = t),
      (e = Do(n, s, r)),
      e !== null && (Nr(e, n, r, i), om(e, n, r));
  },
  enqueueForceUpdate: function (n, e) {
    n = n._reactInternals;
    var t = pi(),
      i = No(n),
      r = Us(t, i);
    (r.tag = 2),
      e != null && (r.callback = e),
      (e = Do(n, r, i)),
      e !== null && (Nr(e, n, i, t), om(e, n, i));
  },
};
function Lw(n, e, t, i, r, s, o) {
  return (
    (n = n.stateNode),
    typeof n.shouldComponentUpdate == "function"
      ? n.shouldComponentUpdate(i, s, o)
      : e.prototype && e.prototype.isPureReactComponent
      ? !kf(t, i) || !kf(r, s)
      : !0
  );
}
function HP(n, e, t) {
  var i = !1,
    r = Vo,
    s = e.contextType;
  return (
    typeof s == "object" && s !== null
      ? (s = gr(s))
      : ((r = Bi(e) ? $a : si.current),
        (i = e.contextTypes),
        (s = (i = i != null) ? Iu(n, r) : Vo)),
    (e = new e(t, s)),
    (n.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null),
    (e.updater = yg),
    (n.stateNode = e),
    (e._reactInternals = n),
    i &&
      ((n = n.stateNode),
      (n.__reactInternalMemoizedUnmaskedChildContext = r),
      (n.__reactInternalMemoizedMaskedChildContext = s)),
    e
  );
}
function Iw(n, e, t, i) {
  (n = e.state),
    typeof e.componentWillReceiveProps == "function" &&
      e.componentWillReceiveProps(t, i),
    typeof e.UNSAFE_componentWillReceiveProps == "function" &&
      e.UNSAFE_componentWillReceiveProps(t, i),
    e.state !== n && yg.enqueueReplaceState(e, e.state, null);
}
function _x(n, e, t, i) {
  var r = n.stateNode;
  (r.props = t), (r.state = n.memoizedState), (r.refs = GP), M1(n);
  var s = e.contextType;
  typeof s == "object" && s !== null
    ? (r.context = gr(s))
    : ((s = Bi(e) ? $a : si.current), (r.context = Iu(n, s))),
    (r.state = n.memoizedState),
    (s = e.getDerivedStateFromProps),
    typeof s == "function" && (xx(n, e, s, t), (r.state = n.memoizedState)),
    typeof e.getDerivedStateFromProps == "function" ||
      typeof r.getSnapshotBeforeUpdate == "function" ||
      (typeof r.UNSAFE_componentWillMount != "function" &&
        typeof r.componentWillMount != "function") ||
      ((e = r.state),
      typeof r.componentWillMount == "function" && r.componentWillMount(),
      typeof r.UNSAFE_componentWillMount == "function" &&
        r.UNSAFE_componentWillMount(),
      e !== r.state && yg.enqueueReplaceState(r, r.state, null),
      Om(n, t, r, i),
      (r.state = n.memoizedState)),
    typeof r.componentDidMount == "function" && (n.flags |= 4194308);
}
function Dc(n, e, t) {
  if (
    ((n = t.ref), n !== null && typeof n != "function" && typeof n != "object")
  ) {
    if (t._owner) {
      if (((t = t._owner), t)) {
        if (t.tag !== 1) throw Error(be(309));
        var i = t.stateNode;
      }
      if (!i) throw Error(be(147, n));
      var r = i,
        s = "" + n;
      return e !== null &&
        e.ref !== null &&
        typeof e.ref == "function" &&
        e.ref._stringRef === s
        ? e.ref
        : ((e = function (o) {
            var a = r.refs;
            a === GP && (a = r.refs = {}),
              o === null ? delete a[s] : (a[s] = o);
          }),
          (e._stringRef = s),
          e);
    }
    if (typeof n != "string") throw Error(be(284));
    if (!t._owner) throw Error(be(290, n));
  }
  return n;
}
function ep(n, e) {
  throw (
    ((n = Object.prototype.toString.call(e)),
    Error(
      be(
        31,
        n === "[object Object]"
          ? "object with keys {" + Object.keys(e).join(", ") + "}"
          : n
      )
    ))
  );
}
function Dw(n) {
  var e = n._init;
  return e(n._payload);
}
function VP(n) {
  function e(g, _) {
    if (n) {
      var S = g.deletions;
      S === null ? ((g.deletions = [_]), (g.flags |= 16)) : S.push(_);
    }
  }
  function t(g, _) {
    if (!n) return null;
    for (; _ !== null; ) e(g, _), (_ = _.sibling);
    return null;
  }
  function i(g, _) {
    for (g = new Map(); _ !== null; )
      _.key !== null ? g.set(_.key, _) : g.set(_.index, _), (_ = _.sibling);
    return g;
  }
  function r(g, _) {
    return (g = Oo(g, _)), (g.index = 0), (g.sibling = null), g;
  }
  function s(g, _, S) {
    return (
      (g.index = S),
      n
        ? ((S = g.alternate),
          S !== null
            ? ((S = S.index), S < _ ? ((g.flags |= 2), _) : S)
            : ((g.flags |= 2), _))
        : ((g.flags |= 1048576), _)
    );
  }
  function o(g) {
    return n && g.alternate === null && (g.flags |= 2), g;
  }
  function a(g, _, S, w) {
    return _ === null || _.tag !== 6
      ? ((_ = Dy(S, g.mode, w)), (_.return = g), _)
      : ((_ = r(_, S)), (_.return = g), _);
  }
  function l(g, _, S, w) {
    var E = S.type;
    return E === ru
      ? h(g, _, S.props.children, w, S.key)
      : _ !== null &&
        (_.elementType === E ||
          (typeof E == "object" &&
            E !== null &&
            E.$$typeof === _o &&
            Dw(E) === _.type))
      ? ((w = r(_, S.props)), (w.ref = Dc(g, _, S)), (w.return = g), w)
      : ((w = hm(S.type, S.key, S.props, null, g.mode, w)),
        (w.ref = Dc(g, _, S)),
        (w.return = g),
        w);
  }
  function c(g, _, S, w) {
    return _ === null ||
      _.tag !== 4 ||
      _.stateNode.containerInfo !== S.containerInfo ||
      _.stateNode.implementation !== S.implementation
      ? ((_ = Fy(S, g.mode, w)), (_.return = g), _)
      : ((_ = r(_, S.children || [])), (_.return = g), _);
  }
  function h(g, _, S, w, E) {
    return _ === null || _.tag !== 7
      ? ((_ = ja(S, g.mode, w, E)), (_.return = g), _)
      : ((_ = r(_, S)), (_.return = g), _);
  }
  function d(g, _, S) {
    if ((typeof _ == "string" && _ !== "") || typeof _ == "number")
      return (_ = Dy("" + _, g.mode, S)), (_.return = g), _;
    if (typeof _ == "object" && _ !== null) {
      switch (_.$$typeof) {
        case Vd:
          return (
            (S = hm(_.type, _.key, _.props, null, g.mode, S)),
            (S.ref = Dc(g, null, _)),
            (S.return = g),
            S
          );
        case iu:
          return (_ = Fy(_, g.mode, S)), (_.return = g), _;
        case _o:
          var w = _._init;
          return d(g, w(_._payload), S);
      }
      if (sf(_) || Pc(_))
        return (_ = ja(_, g.mode, S, null)), (_.return = g), _;
      ep(g, _);
    }
    return null;
  }
  function p(g, _, S, w) {
    var E = _ !== null ? _.key : null;
    if ((typeof S == "string" && S !== "") || typeof S == "number")
      return E !== null ? null : a(g, _, "" + S, w);
    if (typeof S == "object" && S !== null) {
      switch (S.$$typeof) {
        case Vd:
          return S.key === E ? l(g, _, S, w) : null;
        case iu:
          return S.key === E ? c(g, _, S, w) : null;
        case _o:
          return (E = S._init), p(g, _, E(S._payload), w);
      }
      if (sf(S) || Pc(S)) return E !== null ? null : h(g, _, S, w, null);
      ep(g, S);
    }
    return null;
  }
  function m(g, _, S, w, E) {
    if ((typeof w == "string" && w !== "") || typeof w == "number")
      return (g = g.get(S) || null), a(_, g, "" + w, E);
    if (typeof w == "object" && w !== null) {
      switch (w.$$typeof) {
        case Vd:
          return (g = g.get(w.key === null ? S : w.key) || null), l(_, g, w, E);
        case iu:
          return (g = g.get(w.key === null ? S : w.key) || null), c(_, g, w, E);
        case _o:
          var P = w._init;
          return m(g, _, S, P(w._payload), E);
      }
      if (sf(w) || Pc(w)) return (g = g.get(S) || null), h(_, g, w, E, null);
      ep(_, w);
    }
    return null;
  }
  function v(g, _, S, w) {
    for (
      var E = null, P = null, L = _, B = (_ = 0), b = null;
      L !== null && B < S.length;
      B++
    ) {
      L.index > B ? ((b = L), (L = null)) : (b = L.sibling);
      var R = p(g, L, S[B], w);
      if (R === null) {
        L === null && (L = b);
        break;
      }
      n && L && R.alternate === null && e(g, L),
        (_ = s(R, _, B)),
        P === null ? (E = R) : (P.sibling = R),
        (P = R),
        (L = b);
    }
    if (B === S.length) return t(g, L), $t && Ca(g, B), E;
    if (L === null) {
      for (; B < S.length; B++)
        (L = d(g, S[B], w)),
          L !== null &&
            ((_ = s(L, _, B)), P === null ? (E = L) : (P.sibling = L), (P = L));
      return $t && Ca(g, B), E;
    }
    for (L = i(g, L); B < S.length; B++)
      (b = m(L, g, B, S[B], w)),
        b !== null &&
          (n && b.alternate !== null && L.delete(b.key === null ? B : b.key),
          (_ = s(b, _, B)),
          P === null ? (E = b) : (P.sibling = b),
          (P = b));
    return (
      n &&
        L.forEach(function (U) {
          return e(g, U);
        }),
      $t && Ca(g, B),
      E
    );
  }
  function A(g, _, S, w) {
    var E = Pc(S);
    if (typeof E != "function") throw Error(be(150));
    if (((S = E.call(S)), S == null)) throw Error(be(151));
    for (
      var P = (E = null), L = _, B = (_ = 0), b = null, R = S.next();
      L !== null && !R.done;
      B++, R = S.next()
    ) {
      L.index > B ? ((b = L), (L = null)) : (b = L.sibling);
      var U = p(g, L, R.value, w);
      if (U === null) {
        L === null && (L = b);
        break;
      }
      n && L && U.alternate === null && e(g, L),
        (_ = s(U, _, B)),
        P === null ? (E = U) : (P.sibling = U),
        (P = U),
        (L = b);
    }
    if (R.done) return t(g, L), $t && Ca(g, B), E;
    if (L === null) {
      for (; !R.done; B++, R = S.next())
        (R = d(g, R.value, w)),
          R !== null &&
            ((_ = s(R, _, B)), P === null ? (E = R) : (P.sibling = R), (P = R));
      return $t && Ca(g, B), E;
    }
    for (L = i(g, L); !R.done; B++, R = S.next())
      (R = m(L, g, B, R.value, w)),
        R !== null &&
          (n && R.alternate !== null && L.delete(R.key === null ? B : R.key),
          (_ = s(R, _, B)),
          P === null ? (E = R) : (P.sibling = R),
          (P = R));
    return (
      n &&
        L.forEach(function (j) {
          return e(g, j);
        }),
      $t && Ca(g, B),
      E
    );
  }
  function x(g, _, S, w) {
    if (
      (typeof S == "object" &&
        S !== null &&
        S.type === ru &&
        S.key === null &&
        (S = S.props.children),
      typeof S == "object" && S !== null)
    ) {
      switch (S.$$typeof) {
        case Vd:
          e: {
            for (var E = S.key, P = _; P !== null; ) {
              if (P.key === E) {
                if (((E = S.type), E === ru)) {
                  if (P.tag === 7) {
                    t(g, P.sibling),
                      (_ = r(P, S.props.children)),
                      (_.return = g),
                      (g = _);
                    break e;
                  }
                } else if (
                  P.elementType === E ||
                  (typeof E == "object" &&
                    E !== null &&
                    E.$$typeof === _o &&
                    Dw(E) === P.type)
                ) {
                  t(g, P.sibling),
                    (_ = r(P, S.props)),
                    (_.ref = Dc(g, P, S)),
                    (_.return = g),
                    (g = _);
                  break e;
                }
                t(g, P);
                break;
              } else e(g, P);
              P = P.sibling;
            }
            S.type === ru
              ? ((_ = ja(S.props.children, g.mode, w, S.key)),
                (_.return = g),
                (g = _))
              : ((w = hm(S.type, S.key, S.props, null, g.mode, w)),
                (w.ref = Dc(g, _, S)),
                (w.return = g),
                (g = w));
          }
          return o(g);
        case iu:
          e: {
            for (P = S.key; _ !== null; ) {
              if (_.key === P)
                if (
                  _.tag === 4 &&
                  _.stateNode.containerInfo === S.containerInfo &&
                  _.stateNode.implementation === S.implementation
                ) {
                  t(g, _.sibling),
                    (_ = r(_, S.children || [])),
                    (_.return = g),
                    (g = _);
                  break e;
                } else {
                  t(g, _);
                  break;
                }
              else e(g, _);
              _ = _.sibling;
            }
            (_ = Fy(S, g.mode, w)), (_.return = g), (g = _);
          }
          return o(g);
        case _o:
          return (P = S._init), x(g, _, P(S._payload), w);
      }
      if (sf(S)) return v(g, _, S, w);
      if (Pc(S)) return A(g, _, S, w);
      ep(g, S);
    }
    return (typeof S == "string" && S !== "") || typeof S == "number"
      ? ((S = "" + S),
        _ !== null && _.tag === 6
          ? (t(g, _.sibling), (_ = r(_, S)), (_.return = g), (g = _))
          : (t(g, _), (_ = Dy(S, g.mode, w)), (_.return = g), (g = _)),
        o(g))
      : t(g, _);
  }
  return x;
}
var Fu = VP(!0),
  WP = VP(!1),
  xh = {},
  os = $o(xh),
  Hf = $o(xh),
  Vf = $o(xh);
function Oa(n) {
  if (n === xh) throw Error(be(174));
  return n;
}
function S1(n, e) {
  switch ((jt(Vf, e), jt(Hf, n), jt(os, xh), (n = e.nodeType), n)) {
    case 9:
    case 11:
      e = (e = e.documentElement) ? e.namespaceURI : qv(null, "");
      break;
    default:
      (n = n === 8 ? e.parentNode : e),
        (e = n.namespaceURI || null),
        (n = n.tagName),
        (e = qv(e, n));
  }
  Yt(os), jt(os, e);
}
function Nu() {
  Yt(os), Yt(Hf), Yt(Vf);
}
function JP(n) {
  Oa(Vf.current);
  var e = Oa(os.current),
    t = qv(e, n.type);
  e !== t && (jt(Hf, n), jt(os, t));
}
function w1(n) {
  Hf.current === n && (Yt(os), Yt(Hf));
}
var nn = $o(0);
function km(n) {
  for (var e = n; e !== null; ) {
    if (e.tag === 13) {
      var t = e.memoizedState;
      if (
        t !== null &&
        ((t = t.dehydrated), t === null || t.data === "$?" || t.data === "$!")
      )
        return e;
    } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
      if (e.flags & 128) return e;
    } else if (e.child !== null) {
      (e.child.return = e), (e = e.child);
      continue;
    }
    if (e === n) break;
    for (; e.sibling === null; ) {
      if (e.return === null || e.return === n) return null;
      e = e.return;
    }
    (e.sibling.return = e.return), (e = e.sibling);
  }
  return null;
}
var by = [];
function C1() {
  for (var n = 0; n < by.length; n++)
    by[n]._workInProgressVersionPrimary = null;
  by.length = 0;
}
var am = Qs.ReactCurrentDispatcher,
  Py = Qs.ReactCurrentBatchConfig,
  tl = 0,
  ln = null,
  Tn = null,
  On = null,
  Um = !1,
  gf = !1,
  Wf = 0,
  LF = 0;
function $n() {
  throw Error(be(321));
}
function E1(n, e) {
  if (e === null) return !1;
  for (var t = 0; t < e.length && t < n.length; t++)
    if (!zr(n[t], e[t])) return !1;
  return !0;
}
function T1(n, e, t, i, r, s) {
  if (
    ((tl = s),
    (ln = e),
    (e.memoizedState = null),
    (e.updateQueue = null),
    (e.lanes = 0),
    (am.current = n === null || n.memoizedState === null ? NF : OF),
    (n = t(i, r)),
    gf)
  ) {
    s = 0;
    do {
      if (((gf = !1), (Wf = 0), 25 <= s)) throw Error(be(301));
      (s += 1),
        (On = Tn = null),
        (e.updateQueue = null),
        (am.current = kF),
        (n = t(i, r));
    } while (gf);
  }
  if (
    ((am.current = zm),
    (e = Tn !== null && Tn.next !== null),
    (tl = 0),
    (On = Tn = ln = null),
    (Um = !1),
    e)
  )
    throw Error(be(300));
  return n;
}
function b1() {
  var n = Wf !== 0;
  return (Wf = 0), n;
}
function ns() {
  var n = {
    memoizedState: null,
    baseState: null,
    baseQueue: null,
    queue: null,
    next: null,
  };
  return On === null ? (ln.memoizedState = On = n) : (On = On.next = n), On;
}
function yr() {
  if (Tn === null) {
    var n = ln.alternate;
    n = n !== null ? n.memoizedState : null;
  } else n = Tn.next;
  var e = On === null ? ln.memoizedState : On.next;
  if (e !== null) (On = e), (Tn = n);
  else {
    if (n === null) throw Error(be(310));
    (Tn = n),
      (n = {
        memoizedState: Tn.memoizedState,
        baseState: Tn.baseState,
        baseQueue: Tn.baseQueue,
        queue: Tn.queue,
        next: null,
      }),
      On === null ? (ln.memoizedState = On = n) : (On = On.next = n);
  }
  return On;
}
function Jf(n, e) {
  return typeof e == "function" ? e(n) : e;
}
function By(n) {
  var e = yr(),
    t = e.queue;
  if (t === null) throw Error(be(311));
  t.lastRenderedReducer = n;
  var i = Tn,
    r = i.baseQueue,
    s = t.pending;
  if (s !== null) {
    if (r !== null) {
      var o = r.next;
      (r.next = s.next), (s.next = o);
    }
    (i.baseQueue = r = s), (t.pending = null);
  }
  if (r !== null) {
    (s = r.next), (i = i.baseState);
    var a = (o = null),
      l = null,
      c = s;
    do {
      var h = c.lane;
      if ((tl & h) === h)
        l !== null &&
          (l = l.next =
            {
              lane: 0,
              action: c.action,
              hasEagerState: c.hasEagerState,
              eagerState: c.eagerState,
              next: null,
            }),
          (i = c.hasEagerState ? c.eagerState : n(i, c.action));
      else {
        var d = {
          lane: h,
          action: c.action,
          hasEagerState: c.hasEagerState,
          eagerState: c.eagerState,
          next: null,
        };
        l === null ? ((a = l = d), (o = i)) : (l = l.next = d),
          (ln.lanes |= h),
          (nl |= h);
      }
      c = c.next;
    } while (c !== null && c !== s);
    l === null ? (o = i) : (l.next = a),
      zr(i, e.memoizedState) || (bi = !0),
      (e.memoizedState = i),
      (e.baseState = o),
      (e.baseQueue = l),
      (t.lastRenderedState = i);
  }
  if (((n = t.interleaved), n !== null)) {
    r = n;
    do (s = r.lane), (ln.lanes |= s), (nl |= s), (r = r.next);
    while (r !== n);
  } else r === null && (t.lanes = 0);
  return [e.memoizedState, t.dispatch];
}
function Ry(n) {
  var e = yr(),
    t = e.queue;
  if (t === null) throw Error(be(311));
  t.lastRenderedReducer = n;
  var i = t.dispatch,
    r = t.pending,
    s = e.memoizedState;
  if (r !== null) {
    t.pending = null;
    var o = (r = r.next);
    do (s = n(s, o.action)), (o = o.next);
    while (o !== r);
    zr(s, e.memoizedState) || (bi = !0),
      (e.memoizedState = s),
      e.baseQueue === null && (e.baseState = s),
      (t.lastRenderedState = s);
  }
  return [s, i];
}
function jP() {}
function XP(n, e) {
  var t = ln,
    i = yr(),
    r = e(),
    s = !zr(i.memoizedState, r);
  if (
    (s && ((i.memoizedState = r), (bi = !0)),
    (i = i.queue),
    P1(QP.bind(null, t, i, n), [n]),
    i.getSnapshot !== e || s || (On !== null && On.memoizedState.tag & 1))
  ) {
    if (
      ((t.flags |= 2048),
      jf(9, YP.bind(null, t, i, r, e), void 0, null),
      Un === null)
    )
      throw Error(be(349));
    tl & 30 || KP(t, e, r);
  }
  return r;
}
function KP(n, e, t) {
  (n.flags |= 16384),
    (n = { getSnapshot: e, value: t }),
    (e = ln.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (ln.updateQueue = e),
        (e.stores = [n]))
      : ((t = e.stores), t === null ? (e.stores = [n]) : t.push(n));
}
function YP(n, e, t, i) {
  (e.value = t), (e.getSnapshot = i), ZP(e) && qP(n);
}
function QP(n, e, t) {
  return t(function () {
    ZP(e) && qP(n);
  });
}
function ZP(n) {
  var e = n.getSnapshot;
  n = n.value;
  try {
    var t = e();
    return !zr(n, t);
  } catch {
    return !0;
  }
}
function qP(n) {
  var e = Js(n, 1);
  e !== null && Nr(e, n, 1, -1);
}
function Fw(n) {
  var e = ns();
  return (
    typeof n == "function" && (n = n()),
    (e.memoizedState = e.baseState = n),
    (n = {
      pending: null,
      interleaved: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: Jf,
      lastRenderedState: n,
    }),
    (e.queue = n),
    (n = n.dispatch = FF.bind(null, ln, n)),
    [e.memoizedState, n]
  );
}
function jf(n, e, t, i) {
  return (
    (n = { tag: n, create: e, destroy: t, deps: i, next: null }),
    (e = ln.updateQueue),
    e === null
      ? ((e = { lastEffect: null, stores: null }),
        (ln.updateQueue = e),
        (e.lastEffect = n.next = n))
      : ((t = e.lastEffect),
        t === null
          ? (e.lastEffect = n.next = n)
          : ((i = t.next), (t.next = n), (n.next = i), (e.lastEffect = n))),
    n
  );
}
function $P() {
  return yr().memoizedState;
}
function lm(n, e, t, i) {
  var r = ns();
  (ln.flags |= n),
    (r.memoizedState = jf(1 | e, t, void 0, i === void 0 ? null : i));
}
function vg(n, e, t, i) {
  var r = yr();
  i = i === void 0 ? null : i;
  var s = void 0;
  if (Tn !== null) {
    var o = Tn.memoizedState;
    if (((s = o.destroy), i !== null && E1(i, o.deps))) {
      r.memoizedState = jf(e, t, s, i);
      return;
    }
  }
  (ln.flags |= n), (r.memoizedState = jf(1 | e, t, s, i));
}
function Nw(n, e) {
  return lm(8390656, 8, n, e);
}
function P1(n, e) {
  return vg(2048, 8, n, e);
}
function e2(n, e) {
  return vg(4, 2, n, e);
}
function t2(n, e) {
  return vg(4, 4, n, e);
}
function n2(n, e) {
  if (typeof e == "function")
    return (
      (n = n()),
      e(n),
      function () {
        e(null);
      }
    );
  if (e != null)
    return (
      (n = n()),
      (e.current = n),
      function () {
        e.current = null;
      }
    );
}
function i2(n, e, t) {
  return (
    (t = t != null ? t.concat([n]) : null), vg(4, 4, n2.bind(null, e, n), t)
  );
}
function B1() {}
function r2(n, e) {
  var t = yr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && E1(e, i[1])
    ? i[0]
    : ((t.memoizedState = [n, e]), n);
}
function s2(n, e) {
  var t = yr();
  e = e === void 0 ? null : e;
  var i = t.memoizedState;
  return i !== null && e !== null && E1(e, i[1])
    ? i[0]
    : ((n = n()), (t.memoizedState = [n, e]), n);
}
function o2(n, e, t) {
  return tl & 21
    ? (zr(t, e) || ((t = uP()), (ln.lanes |= t), (nl |= t), (n.baseState = !0)),
      e)
    : (n.baseState && ((n.baseState = !1), (bi = !0)), (n.memoizedState = t));
}
function IF(n, e) {
  var t = kt;
  (kt = t !== 0 && 4 > t ? t : 4), n(!0);
  var i = Py.transition;
  Py.transition = {};
  try {
    n(!1), e();
  } finally {
    (kt = t), (Py.transition = i);
  }
}
function a2() {
  return yr().memoizedState;
}
function DF(n, e, t) {
  var i = No(n);
  if (
    ((t = {
      lane: i,
      action: t,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
    l2(n))
  )
    u2(e, t);
  else if (((t = UP(n, e, t, i)), t !== null)) {
    var r = pi();
    Nr(t, n, i, r), c2(t, e, i);
  }
}
function FF(n, e, t) {
  var i = No(n),
    r = { lane: i, action: t, hasEagerState: !1, eagerState: null, next: null };
  if (l2(n)) u2(e, r);
  else {
    var s = n.alternate;
    if (
      n.lanes === 0 &&
      (s === null || s.lanes === 0) &&
      ((s = e.lastRenderedReducer), s !== null)
    )
      try {
        var o = e.lastRenderedState,
          a = s(o, t);
        if (((r.hasEagerState = !0), (r.eagerState = a), zr(a, o))) {
          var l = e.interleaved;
          l === null
            ? ((r.next = r), A1(e))
            : ((r.next = l.next), (l.next = r)),
            (e.interleaved = r);
          return;
        }
      } catch {
      } finally {
      }
    (t = UP(n, e, r, i)),
      t !== null && ((r = pi()), Nr(t, n, i, r), c2(t, e, i));
  }
}
function l2(n) {
  var e = n.alternate;
  return n === ln || (e !== null && e === ln);
}
function u2(n, e) {
  gf = Um = !0;
  var t = n.pending;
  t === null ? (e.next = e) : ((e.next = t.next), (t.next = e)),
    (n.pending = e);
}
function c2(n, e, t) {
  if (t & 4194240) {
    var i = e.lanes;
    (i &= n.pendingLanes), (t |= i), (e.lanes = t), a1(n, t);
  }
}
var zm = {
    readContext: gr,
    useCallback: $n,
    useContext: $n,
    useEffect: $n,
    useImperativeHandle: $n,
    useInsertionEffect: $n,
    useLayoutEffect: $n,
    useMemo: $n,
    useReducer: $n,
    useRef: $n,
    useState: $n,
    useDebugValue: $n,
    useDeferredValue: $n,
    useTransition: $n,
    useMutableSource: $n,
    useSyncExternalStore: $n,
    useId: $n,
    unstable_isNewReconciler: !1,
  },
  NF = {
    readContext: gr,
    useCallback: function (n, e) {
      return (ns().memoizedState = [n, e === void 0 ? null : e]), n;
    },
    useContext: gr,
    useEffect: Nw,
    useImperativeHandle: function (n, e, t) {
      return (
        (t = t != null ? t.concat([n]) : null),
        lm(4194308, 4, n2.bind(null, e, n), t)
      );
    },
    useLayoutEffect: function (n, e) {
      return lm(4194308, 4, n, e);
    },
    useInsertionEffect: function (n, e) {
      return lm(4, 2, n, e);
    },
    useMemo: function (n, e) {
      var t = ns();
      return (
        (e = e === void 0 ? null : e), (n = n()), (t.memoizedState = [n, e]), n
      );
    },
    useReducer: function (n, e, t) {
      var i = ns();
      return (
        (e = t !== void 0 ? t(e) : e),
        (i.memoizedState = i.baseState = e),
        (n = {
          pending: null,
          interleaved: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: n,
          lastRenderedState: e,
        }),
        (i.queue = n),
        (n = n.dispatch = DF.bind(null, ln, n)),
        [i.memoizedState, n]
      );
    },
    useRef: function (n) {
      var e = ns();
      return (n = { current: n }), (e.memoizedState = n);
    },
    useState: Fw,
    useDebugValue: B1,
    useDeferredValue: function (n) {
      return (ns().memoizedState = n);
    },
    useTransition: function () {
      var n = Fw(!1),
        e = n[0];
      return (n = IF.bind(null, n[1])), (ns().memoizedState = n), [e, n];
    },
    useMutableSource: function () {},
    useSyncExternalStore: function (n, e, t) {
      var i = ln,
        r = ns();
      if ($t) {
        if (t === void 0) throw Error(be(407));
        t = t();
      } else {
        if (((t = e()), Un === null)) throw Error(be(349));
        tl & 30 || KP(i, e, t);
      }
      r.memoizedState = t;
      var s = { value: t, getSnapshot: e };
      return (
        (r.queue = s),
        Nw(QP.bind(null, i, s, n), [n]),
        (i.flags |= 2048),
        jf(9, YP.bind(null, i, s, t, e), void 0, null),
        t
      );
    },
    useId: function () {
      var n = ns(),
        e = Un.identifierPrefix;
      if ($t) {
        var t = Fs,
          i = Ds;
        (t = (i & ~(1 << (32 - Fr(i) - 1))).toString(32) + t),
          (e = ":" + e + "R" + t),
          (t = Wf++),
          0 < t && (e += "H" + t.toString(32)),
          (e += ":");
      } else (t = LF++), (e = ":" + e + "r" + t.toString(32) + ":");
      return (n.memoizedState = e);
    },
    unstable_isNewReconciler: !1,
  },
  OF = {
    readContext: gr,
    useCallback: r2,
    useContext: gr,
    useEffect: P1,
    useImperativeHandle: i2,
    useInsertionEffect: e2,
    useLayoutEffect: t2,
    useMemo: s2,
    useReducer: By,
    useRef: $P,
    useState: function () {
      return By(Jf);
    },
    useDebugValue: B1,
    useDeferredValue: function (n) {
      var e = yr();
      return o2(e, Tn.memoizedState, n);
    },
    useTransition: function () {
      var n = By(Jf)[0],
        e = yr().memoizedState;
      return [n, e];
    },
    useMutableSource: jP,
    useSyncExternalStore: XP,
    useId: a2,
    unstable_isNewReconciler: !1,
  },
  kF = {
    readContext: gr,
    useCallback: r2,
    useContext: gr,
    useEffect: P1,
    useImperativeHandle: i2,
    useInsertionEffect: e2,
    useLayoutEffect: t2,
    useMemo: s2,
    useReducer: Ry,
    useRef: $P,
    useState: function () {
      return Ry(Jf);
    },
    useDebugValue: B1,
    useDeferredValue: function (n) {
      var e = yr();
      return Tn === null ? (e.memoizedState = n) : o2(e, Tn.memoizedState, n);
    },
    useTransition: function () {
      var n = Ry(Jf)[0],
        e = yr().memoizedState;
      return [n, e];
    },
    useMutableSource: jP,
    useSyncExternalStore: XP,
    useId: a2,
    unstable_isNewReconciler: !1,
  };
function Ou(n, e) {
  try {
    var t = "",
      i = e;
    do (t += hD(i)), (i = i.return);
    while (i);
    var r = t;
  } catch (s) {
    r =
      `
Error generating stack: ` +
      s.message +
      `
` +
      s.stack;
  }
  return { value: n, source: e, stack: r, digest: null };
}
function Ly(n, e, t) {
  return { value: n, source: null, stack: t ?? null, digest: e ?? null };
}
function Ax(n, e) {
  try {
    console.error(e.value);
  } catch (t) {
    setTimeout(function () {
      throw t;
    });
  }
}
var UF = typeof WeakMap == "function" ? WeakMap : Map;
function f2(n, e, t) {
  (t = Us(-1, t)), (t.tag = 3), (t.payload = { element: null });
  var i = e.value;
  return (
    (t.callback = function () {
      Hm || ((Hm = !0), (Rx = i)), Ax(n, e);
    }),
    t
  );
}
function h2(n, e, t) {
  (t = Us(-1, t)), (t.tag = 3);
  var i = n.type.getDerivedStateFromError;
  if (typeof i == "function") {
    var r = e.value;
    (t.payload = function () {
      return i(r);
    }),
      (t.callback = function () {
        Ax(n, e);
      });
  }
  var s = n.stateNode;
  return (
    s !== null &&
      typeof s.componentDidCatch == "function" &&
      (t.callback = function () {
        Ax(n, e),
          typeof i != "function" &&
            (Fo === null ? (Fo = new Set([this])) : Fo.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
          componentStack: o !== null ? o : "",
        });
      }),
    t
  );
}
function Ow(n, e, t) {
  var i = n.pingCache;
  if (i === null) {
    i = n.pingCache = new UF();
    var r = new Set();
    i.set(e, r);
  } else (r = i.get(e)), r === void 0 && ((r = new Set()), i.set(e, r));
  r.has(t) || (r.add(t), (n = $F.bind(null, n, e, t)), e.then(n, n));
}
function kw(n) {
  do {
    var e;
    if (
      ((e = n.tag === 13) &&
        ((e = n.memoizedState), (e = e !== null ? e.dehydrated !== null : !0)),
      e)
    )
      return n;
    n = n.return;
  } while (n !== null);
  return null;
}
function Uw(n, e, t, i, r) {
  return n.mode & 1
    ? ((n.flags |= 65536), (n.lanes = r), n)
    : (n === e
        ? (n.flags |= 65536)
        : ((n.flags |= 128),
          (t.flags |= 131072),
          (t.flags &= -52805),
          t.tag === 1 &&
            (t.alternate === null
              ? (t.tag = 17)
              : ((e = Us(-1, 1)), (e.tag = 2), Do(t, e, 1))),
          (t.lanes |= 1)),
      n);
}
var zF = Qs.ReactCurrentOwner,
  bi = !1;
function di(n, e, t, i) {
  e.child = n === null ? WP(e, null, t, i) : Fu(e, n.child, t, i);
}
function zw(n, e, t, i, r) {
  t = t.render;
  var s = e.ref;
  return (
    Eu(e, r),
    (i = T1(n, e, t, i, s, r)),
    (t = b1()),
    n !== null && !bi
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        js(n, e, r))
      : ($t && t && m1(e), (e.flags |= 1), di(n, e, i, r), e.child)
  );
}
function Gw(n, e, t, i, r) {
  if (n === null) {
    var s = t.type;
    return typeof s == "function" &&
      !k1(s) &&
      s.defaultProps === void 0 &&
      t.compare === null &&
      t.defaultProps === void 0
      ? ((e.tag = 15), (e.type = s), d2(n, e, s, i, r))
      : ((n = hm(t.type, null, i, e, e.mode, r)),
        (n.ref = e.ref),
        (n.return = e),
        (e.child = n));
  }
  if (((s = n.child), !(n.lanes & r))) {
    var o = s.memoizedProps;
    if (
      ((t = t.compare), (t = t !== null ? t : kf), t(o, i) && n.ref === e.ref)
    )
      return js(n, e, r);
  }
  return (
    (e.flags |= 1),
    (n = Oo(s, i)),
    (n.ref = e.ref),
    (n.return = e),
    (e.child = n)
  );
}
function d2(n, e, t, i, r) {
  if (n !== null) {
    var s = n.memoizedProps;
    if (kf(s, i) && n.ref === e.ref)
      if (((bi = !1), (e.pendingProps = i = s), (n.lanes & r) !== 0))
        n.flags & 131072 && (bi = !0);
      else return (e.lanes = n.lanes), js(n, e, r);
  }
  return Mx(n, e, t, i, r);
}
function p2(n, e, t) {
  var i = e.pendingProps,
    r = i.children,
    s = n !== null ? n.memoizedState : null;
  if (i.mode === "hidden")
    if (!(e.mode & 1))
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        jt(pu, zi),
        (zi |= t);
    else {
      if (!(t & 1073741824))
        return (
          (n = s !== null ? s.baseLanes | t : t),
          (e.lanes = e.childLanes = 1073741824),
          (e.memoizedState = {
            baseLanes: n,
            cachePool: null,
            transitions: null,
          }),
          (e.updateQueue = null),
          jt(pu, zi),
          (zi |= n),
          null
        );
      (e.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }),
        (i = s !== null ? s.baseLanes : t),
        jt(pu, zi),
        (zi |= i);
    }
  else
    s !== null ? ((i = s.baseLanes | t), (e.memoizedState = null)) : (i = t),
      jt(pu, zi),
      (zi |= i);
  return di(n, e, r, t), e.child;
}
function m2(n, e) {
  var t = e.ref;
  ((n === null && t !== null) || (n !== null && n.ref !== t)) &&
    ((e.flags |= 512), (e.flags |= 2097152));
}
function Mx(n, e, t, i, r) {
  var s = Bi(t) ? $a : si.current;
  return (
    (s = Iu(e, s)),
    Eu(e, r),
    (t = T1(n, e, t, i, s, r)),
    (i = b1()),
    n !== null && !bi
      ? ((e.updateQueue = n.updateQueue),
        (e.flags &= -2053),
        (n.lanes &= ~r),
        js(n, e, r))
      : ($t && i && m1(e), (e.flags |= 1), di(n, e, t, r), e.child)
  );
}
function Hw(n, e, t, i, r) {
  if (Bi(t)) {
    var s = !0;
    Lm(e);
  } else s = !1;
  if ((Eu(e, r), e.stateNode === null))
    um(n, e), HP(e, t, i), _x(e, t, i, r), (i = !0);
  else if (n === null) {
    var o = e.stateNode,
      a = e.memoizedProps;
    o.props = a;
    var l = o.context,
      c = t.contextType;
    typeof c == "object" && c !== null
      ? (c = gr(c))
      : ((c = Bi(t) ? $a : si.current), (c = Iu(e, c)));
    var h = t.getDerivedStateFromProps,
      d =
        typeof h == "function" ||
        typeof o.getSnapshotBeforeUpdate == "function";
    d ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== i || l !== c) && Iw(e, o, i, c)),
      (Ao = !1);
    var p = e.memoizedState;
    (o.state = p),
      Om(e, i, o, r),
      (l = e.memoizedState),
      a !== i || p !== l || Pi.current || Ao
        ? (typeof h == "function" && (xx(e, t, h, i), (l = e.memoizedState)),
          (a = Ao || Lw(e, t, a, i, p, l, c))
            ? (d ||
                (typeof o.UNSAFE_componentWillMount != "function" &&
                  typeof o.componentWillMount != "function") ||
                (typeof o.componentWillMount == "function" &&
                  o.componentWillMount(),
                typeof o.UNSAFE_componentWillMount == "function" &&
                  o.UNSAFE_componentWillMount()),
              typeof o.componentDidMount == "function" && (e.flags |= 4194308))
            : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
              (e.memoizedProps = i),
              (e.memoizedState = l)),
          (o.props = i),
          (o.state = l),
          (o.context = c),
          (i = a))
        : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
          (i = !1));
  } else {
    (o = e.stateNode),
      zP(n, e),
      (a = e.memoizedProps),
      (c = e.type === e.elementType ? a : Br(e.type, a)),
      (o.props = c),
      (d = e.pendingProps),
      (p = o.context),
      (l = t.contextType),
      typeof l == "object" && l !== null
        ? (l = gr(l))
        : ((l = Bi(t) ? $a : si.current), (l = Iu(e, l)));
    var m = t.getDerivedStateFromProps;
    (h =
      typeof m == "function" ||
      typeof o.getSnapshotBeforeUpdate == "function") ||
      (typeof o.UNSAFE_componentWillReceiveProps != "function" &&
        typeof o.componentWillReceiveProps != "function") ||
      ((a !== d || p !== l) && Iw(e, o, i, l)),
      (Ao = !1),
      (p = e.memoizedState),
      (o.state = p),
      Om(e, i, o, r);
    var v = e.memoizedState;
    a !== d || p !== v || Pi.current || Ao
      ? (typeof m == "function" && (xx(e, t, m, i), (v = e.memoizedState)),
        (c = Ao || Lw(e, t, c, i, p, v, l) || !1)
          ? (h ||
              (typeof o.UNSAFE_componentWillUpdate != "function" &&
                typeof o.componentWillUpdate != "function") ||
              (typeof o.componentWillUpdate == "function" &&
                o.componentWillUpdate(i, v, l),
              typeof o.UNSAFE_componentWillUpdate == "function" &&
                o.UNSAFE_componentWillUpdate(i, v, l)),
            typeof o.componentDidUpdate == "function" && (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024))
          : (typeof o.componentDidUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 4),
            typeof o.getSnapshotBeforeUpdate != "function" ||
              (a === n.memoizedProps && p === n.memoizedState) ||
              (e.flags |= 1024),
            (e.memoizedProps = i),
            (e.memoizedState = v)),
        (o.props = i),
        (o.state = v),
        (o.context = l),
        (i = c))
      : (typeof o.componentDidUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" ||
          (a === n.memoizedProps && p === n.memoizedState) ||
          (e.flags |= 1024),
        (i = !1));
  }
  return Sx(n, e, t, i, s, r);
}
function Sx(n, e, t, i, r, s) {
  m2(n, e);
  var o = (e.flags & 128) !== 0;
  if (!i && !o) return r && Tw(e, t, !1), js(n, e, s);
  (i = e.stateNode), (zF.current = e);
  var a =
    o && typeof t.getDerivedStateFromError != "function" ? null : i.render();
  return (
    (e.flags |= 1),
    n !== null && o
      ? ((e.child = Fu(e, n.child, null, s)), (e.child = Fu(e, null, a, s)))
      : di(n, e, a, s),
    (e.memoizedState = i.state),
    r && Tw(e, t, !0),
    e.child
  );
}
function g2(n) {
  var e = n.stateNode;
  e.pendingContext
    ? Ew(n, e.pendingContext, e.pendingContext !== e.context)
    : e.context && Ew(n, e.context, !1),
    S1(n, e.containerInfo);
}
function Vw(n, e, t, i, r) {
  return Du(), y1(r), (e.flags |= 256), di(n, e, t, i), e.child;
}
var wx = { dehydrated: null, treeContext: null, retryLane: 0 };
function Cx(n) {
  return { baseLanes: n, cachePool: null, transitions: null };
}
function y2(n, e, t) {
  var i = e.pendingProps,
    r = nn.current,
    s = !1,
    o = (e.flags & 128) !== 0,
    a;
  if (
    ((a = o) ||
      (a = n !== null && n.memoizedState === null ? !1 : (r & 2) !== 0),
    a
      ? ((s = !0), (e.flags &= -129))
      : (n === null || n.memoizedState !== null) && (r |= 1),
    jt(nn, r & 1),
    n === null)
  )
    return (
      yx(e),
      (n = e.memoizedState),
      n !== null && ((n = n.dehydrated), n !== null)
        ? (e.mode & 1
            ? n.data === "$!"
              ? (e.lanes = 8)
              : (e.lanes = 1073741824)
            : (e.lanes = 1),
          null)
        : ((o = i.children),
          (n = i.fallback),
          s
            ? ((i = e.mode),
              (s = e.child),
              (o = { mode: "hidden", children: o }),
              !(i & 1) && s !== null
                ? ((s.childLanes = 0), (s.pendingProps = o))
                : (s = Ag(o, i, 0, null)),
              (n = ja(n, i, t, null)),
              (s.return = e),
              (n.return = e),
              (s.sibling = n),
              (e.child = s),
              (e.child.memoizedState = Cx(t)),
              (e.memoizedState = wx),
              n)
            : R1(e, o))
    );
  if (((r = n.memoizedState), r !== null && ((a = r.dehydrated), a !== null)))
    return GF(n, e, o, i, a, r, t);
  if (s) {
    (s = i.fallback), (o = e.mode), (r = n.child), (a = r.sibling);
    var l = { mode: "hidden", children: i.children };
    return (
      !(o & 1) && e.child !== r
        ? ((i = e.child),
          (i.childLanes = 0),
          (i.pendingProps = l),
          (e.deletions = null))
        : ((i = Oo(r, l)), (i.subtreeFlags = r.subtreeFlags & 14680064)),
      a !== null ? (s = Oo(a, s)) : ((s = ja(s, o, t, null)), (s.flags |= 2)),
      (s.return = e),
      (i.return = e),
      (i.sibling = s),
      (e.child = i),
      (i = s),
      (s = e.child),
      (o = n.child.memoizedState),
      (o =
        o === null
          ? Cx(t)
          : {
              baseLanes: o.baseLanes | t,
              cachePool: null,
              transitions: o.transitions,
            }),
      (s.memoizedState = o),
      (s.childLanes = n.childLanes & ~t),
      (e.memoizedState = wx),
      i
    );
  }
  return (
    (s = n.child),
    (n = s.sibling),
    (i = Oo(s, { mode: "visible", children: i.children })),
    !(e.mode & 1) && (i.lanes = t),
    (i.return = e),
    (i.sibling = null),
    n !== null &&
      ((t = e.deletions),
      t === null ? ((e.deletions = [n]), (e.flags |= 16)) : t.push(n)),
    (e.child = i),
    (e.memoizedState = null),
    i
  );
}
function R1(n, e) {
  return (
    (e = Ag({ mode: "visible", children: e }, n.mode, 0, null)),
    (e.return = n),
    (n.child = e)
  );
}
function tp(n, e, t, i) {
  return (
    i !== null && y1(i),
    Fu(e, n.child, null, t),
    (n = R1(e, e.pendingProps.children)),
    (n.flags |= 2),
    (e.memoizedState = null),
    n
  );
}
function GF(n, e, t, i, r, s, o) {
  if (t)
    return e.flags & 256
      ? ((e.flags &= -257), (i = Ly(Error(be(422)))), tp(n, e, o, i))
      : e.memoizedState !== null
      ? ((e.child = n.child), (e.flags |= 128), null)
      : ((s = i.fallback),
        (r = e.mode),
        (i = Ag({ mode: "visible", children: i.children }, r, 0, null)),
        (s = ja(s, r, o, null)),
        (s.flags |= 2),
        (i.return = e),
        (s.return = e),
        (i.sibling = s),
        (e.child = i),
        e.mode & 1 && Fu(e, n.child, null, o),
        (e.child.memoizedState = Cx(o)),
        (e.memoizedState = wx),
        s);
  if (!(e.mode & 1)) return tp(n, e, o, null);
  if (r.data === "$!") {
    if (((i = r.nextSibling && r.nextSibling.dataset), i)) var a = i.dgst;
    return (
      (i = a), (s = Error(be(419))), (i = Ly(s, i, void 0)), tp(n, e, o, i)
    );
  }
  if (((a = (o & n.childLanes) !== 0), bi || a)) {
    if (((i = Un), i !== null)) {
      switch (o & -o) {
        case 4:
          r = 2;
          break;
        case 16:
          r = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          r = 32;
          break;
        case 536870912:
          r = 268435456;
          break;
        default:
          r = 0;
      }
      (r = r & (i.suspendedLanes | o) ? 0 : r),
        r !== 0 &&
          r !== s.retryLane &&
          ((s.retryLane = r), Js(n, r), Nr(i, n, r, -1));
    }
    return O1(), (i = Ly(Error(be(421)))), tp(n, e, o, i);
  }
  return r.data === "$?"
    ? ((e.flags |= 128),
      (e.child = n.child),
      (e = eN.bind(null, n)),
      (r._reactRetry = e),
      null)
    : ((n = s.treeContext),
      (Hi = Io(r.nextSibling)),
      (Ji = e),
      ($t = !0),
      (Ir = null),
      n !== null &&
        ((fr[hr++] = Ds),
        (fr[hr++] = Fs),
        (fr[hr++] = el),
        (Ds = n.id),
        (Fs = n.overflow),
        (el = e)),
      (e = R1(e, i.children)),
      (e.flags |= 4096),
      e);
}
function Ww(n, e, t) {
  n.lanes |= e;
  var i = n.alternate;
  i !== null && (i.lanes |= e), vx(n.return, e, t);
}
function Iy(n, e, t, i, r) {
  var s = n.memoizedState;
  s === null
    ? (n.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: i,
        tail: t,
        tailMode: r,
      })
    : ((s.isBackwards = e),
      (s.rendering = null),
      (s.renderingStartTime = 0),
      (s.last = i),
      (s.tail = t),
      (s.tailMode = r));
}
function v2(n, e, t) {
  var i = e.pendingProps,
    r = i.revealOrder,
    s = i.tail;
  if ((di(n, e, i.children, t), (i = nn.current), i & 2))
    (i = (i & 1) | 2), (e.flags |= 128);
  else {
    if (n !== null && n.flags & 128)
      e: for (n = e.child; n !== null; ) {
        if (n.tag === 13) n.memoizedState !== null && Ww(n, t, e);
        else if (n.tag === 19) Ww(n, t, e);
        else if (n.child !== null) {
          (n.child.return = n), (n = n.child);
          continue;
        }
        if (n === e) break e;
        for (; n.sibling === null; ) {
          if (n.return === null || n.return === e) break e;
          n = n.return;
        }
        (n.sibling.return = n.return), (n = n.sibling);
      }
    i &= 1;
  }
  if ((jt(nn, i), !(e.mode & 1))) e.memoizedState = null;
  else
    switch (r) {
      case "forwards":
        for (t = e.child, r = null; t !== null; )
          (n = t.alternate),
            n !== null && km(n) === null && (r = t),
            (t = t.sibling);
        (t = r),
          t === null
            ? ((r = e.child), (e.child = null))
            : ((r = t.sibling), (t.sibling = null)),
          Iy(e, !1, r, t, s);
        break;
      case "backwards":
        for (t = null, r = e.child, e.child = null; r !== null; ) {
          if (((n = r.alternate), n !== null && km(n) === null)) {
            e.child = r;
            break;
          }
          (n = r.sibling), (r.sibling = t), (t = r), (r = n);
        }
        Iy(e, !0, t, null, s);
        break;
      case "together":
        Iy(e, !1, null, null, void 0);
        break;
      default:
        e.memoizedState = null;
    }
  return e.child;
}
function um(n, e) {
  !(e.mode & 1) &&
    n !== null &&
    ((n.alternate = null), (e.alternate = null), (e.flags |= 2));
}
function js(n, e, t) {
  if (
    (n !== null && (e.dependencies = n.dependencies),
    (nl |= e.lanes),
    !(t & e.childLanes))
  )
    return null;
  if (n !== null && e.child !== n.child) throw Error(be(153));
  if (e.child !== null) {
    for (
      n = e.child, t = Oo(n, n.pendingProps), e.child = t, t.return = e;
      n.sibling !== null;

    )
      (n = n.sibling), (t = t.sibling = Oo(n, n.pendingProps)), (t.return = e);
    t.sibling = null;
  }
  return e.child;
}
function HF(n, e, t) {
  switch (e.tag) {
    case 3:
      g2(e), Du();
      break;
    case 5:
      JP(e);
      break;
    case 1:
      Bi(e.type) && Lm(e);
      break;
    case 4:
      S1(e, e.stateNode.containerInfo);
      break;
    case 10:
      var i = e.type._context,
        r = e.memoizedProps.value;
      jt(Fm, i._currentValue), (i._currentValue = r);
      break;
    case 13:
      if (((i = e.memoizedState), i !== null))
        return i.dehydrated !== null
          ? (jt(nn, nn.current & 1), (e.flags |= 128), null)
          : t & e.child.childLanes
          ? y2(n, e, t)
          : (jt(nn, nn.current & 1),
            (n = js(n, e, t)),
            n !== null ? n.sibling : null);
      jt(nn, nn.current & 1);
      break;
    case 19:
      if (((i = (t & e.childLanes) !== 0), n.flags & 128)) {
        if (i) return v2(n, e, t);
        e.flags |= 128;
      }
      if (
        ((r = e.memoizedState),
        r !== null &&
          ((r.rendering = null), (r.tail = null), (r.lastEffect = null)),
        jt(nn, nn.current),
        i)
      )
        break;
      return null;
    case 22:
    case 23:
      return (e.lanes = 0), p2(n, e, t);
  }
  return js(n, e, t);
}
var x2, Ex, _2, A2;
x2 = function (n, e) {
  for (var t = e.child; t !== null; ) {
    if (t.tag === 5 || t.tag === 6) n.appendChild(t.stateNode);
    else if (t.tag !== 4 && t.child !== null) {
      (t.child.return = t), (t = t.child);
      continue;
    }
    if (t === e) break;
    for (; t.sibling === null; ) {
      if (t.return === null || t.return === e) return;
      t = t.return;
    }
    (t.sibling.return = t.return), (t = t.sibling);
  }
};
Ex = function () {};
_2 = function (n, e, t, i) {
  var r = n.memoizedProps;
  if (r !== i) {
    (n = e.stateNode), Oa(os.current);
    var s = null;
    switch (t) {
      case "input":
        (r = Kv(n, r)), (i = Kv(n, i)), (s = []);
        break;
      case "select":
        (r = un({}, r, { value: void 0 })),
          (i = un({}, i, { value: void 0 })),
          (s = []);
        break;
      case "textarea":
        (r = Zv(n, r)), (i = Zv(n, i)), (s = []);
        break;
      default:
        typeof r.onClick != "function" &&
          typeof i.onClick == "function" &&
          (n.onclick = Bm);
    }
    $v(t, i);
    var o;
    t = null;
    for (c in r)
      if (!i.hasOwnProperty(c) && r.hasOwnProperty(c) && r[c] != null)
        if (c === "style") {
          var a = r[c];
          for (o in a) a.hasOwnProperty(o) && (t || (t = {}), (t[o] = ""));
        } else
          c !== "dangerouslySetInnerHTML" &&
            c !== "children" &&
            c !== "suppressContentEditableWarning" &&
            c !== "suppressHydrationWarning" &&
            c !== "autoFocus" &&
            (Rf.hasOwnProperty(c)
              ? s || (s = [])
              : (s = s || []).push(c, null));
    for (c in i) {
      var l = i[c];
      if (
        ((a = r != null ? r[c] : void 0),
        i.hasOwnProperty(c) && l !== a && (l != null || a != null))
      )
        if (c === "style")
          if (a) {
            for (o in a)
              !a.hasOwnProperty(o) ||
                (l && l.hasOwnProperty(o)) ||
                (t || (t = {}), (t[o] = ""));
            for (o in l)
              l.hasOwnProperty(o) &&
                a[o] !== l[o] &&
                (t || (t = {}), (t[o] = l[o]));
          } else t || (s || (s = []), s.push(c, t)), (t = l);
        else
          c === "dangerouslySetInnerHTML"
            ? ((l = l ? l.__html : void 0),
              (a = a ? a.__html : void 0),
              l != null && a !== l && (s = s || []).push(c, l))
            : c === "children"
            ? (typeof l != "string" && typeof l != "number") ||
              (s = s || []).push(c, "" + l)
            : c !== "suppressContentEditableWarning" &&
              c !== "suppressHydrationWarning" &&
              (Rf.hasOwnProperty(c)
                ? (l != null && c === "onScroll" && Xt("scroll", n),
                  s || a === l || (s = []))
                : (s = s || []).push(c, l));
    }
    t && (s = s || []).push("style", t);
    var c = s;
    (e.updateQueue = c) && (e.flags |= 4);
  }
};
A2 = function (n, e, t, i) {
  t !== i && (e.flags |= 4);
};
function Fc(n, e) {
  if (!$t)
    switch (n.tailMode) {
      case "hidden":
        e = n.tail;
        for (var t = null; e !== null; )
          e.alternate !== null && (t = e), (e = e.sibling);
        t === null ? (n.tail = null) : (t.sibling = null);
        break;
      case "collapsed":
        t = n.tail;
        for (var i = null; t !== null; )
          t.alternate !== null && (i = t), (t = t.sibling);
        i === null
          ? e || n.tail === null
            ? (n.tail = null)
            : (n.tail.sibling = null)
          : (i.sibling = null);
    }
}
function ei(n) {
  var e = n.alternate !== null && n.alternate.child === n.child,
    t = 0,
    i = 0;
  if (e)
    for (var r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags & 14680064),
        (i |= r.flags & 14680064),
        (r.return = n),
        (r = r.sibling);
  else
    for (r = n.child; r !== null; )
      (t |= r.lanes | r.childLanes),
        (i |= r.subtreeFlags),
        (i |= r.flags),
        (r.return = n),
        (r = r.sibling);
  return (n.subtreeFlags |= i), (n.childLanes = t), e;
}
function VF(n, e, t) {
  var i = e.pendingProps;
  switch ((g1(e), e.tag)) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return ei(e), null;
    case 1:
      return Bi(e.type) && Rm(), ei(e), null;
    case 3:
      return (
        (i = e.stateNode),
        Nu(),
        Yt(Pi),
        Yt(si),
        C1(),
        i.pendingContext &&
          ((i.context = i.pendingContext), (i.pendingContext = null)),
        (n === null || n.child === null) &&
          ($d(e)
            ? (e.flags |= 4)
            : n === null ||
              (n.memoizedState.isDehydrated && !(e.flags & 256)) ||
              ((e.flags |= 1024), Ir !== null && (Dx(Ir), (Ir = null)))),
        Ex(n, e),
        ei(e),
        null
      );
    case 5:
      w1(e);
      var r = Oa(Vf.current);
      if (((t = e.type), n !== null && e.stateNode != null))
        _2(n, e, t, i, r),
          n.ref !== e.ref && ((e.flags |= 512), (e.flags |= 2097152));
      else {
        if (!i) {
          if (e.stateNode === null) throw Error(be(166));
          return ei(e), null;
        }
        if (((n = Oa(os.current)), $d(e))) {
          (i = e.stateNode), (t = e.type);
          var s = e.memoizedProps;
          switch (((i[rs] = e), (i[Gf] = s), (n = (e.mode & 1) !== 0), t)) {
            case "dialog":
              Xt("cancel", i), Xt("close", i);
              break;
            case "iframe":
            case "object":
            case "embed":
              Xt("load", i);
              break;
            case "video":
            case "audio":
              for (r = 0; r < af.length; r++) Xt(af[r], i);
              break;
            case "source":
              Xt("error", i);
              break;
            case "img":
            case "image":
            case "link":
              Xt("error", i), Xt("load", i);
              break;
            case "details":
              Xt("toggle", i);
              break;
            case "input":
              $S(i, s), Xt("invalid", i);
              break;
            case "select":
              (i._wrapperState = { wasMultiple: !!s.multiple }),
                Xt("invalid", i);
              break;
            case "textarea":
              tw(i, s), Xt("invalid", i);
          }
          $v(t, s), (r = null);
          for (var o in s)
            if (s.hasOwnProperty(o)) {
              var a = s[o];
              o === "children"
                ? typeof a == "string"
                  ? i.textContent !== a &&
                    (s.suppressHydrationWarning !== !0 &&
                      qd(i.textContent, a, n),
                    (r = ["children", a]))
                  : typeof a == "number" &&
                    i.textContent !== "" + a &&
                    (s.suppressHydrationWarning !== !0 &&
                      qd(i.textContent, a, n),
                    (r = ["children", "" + a]))
                : Rf.hasOwnProperty(o) &&
                  a != null &&
                  o === "onScroll" &&
                  Xt("scroll", i);
            }
          switch (t) {
            case "input":
              Wd(i), ew(i, s, !0);
              break;
            case "textarea":
              Wd(i), nw(i);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof s.onClick == "function" && (i.onclick = Bm);
          }
          (i = r), (e.updateQueue = i), i !== null && (e.flags |= 4);
        } else {
          (o = r.nodeType === 9 ? r : r.ownerDocument),
            n === "http://www.w3.org/1999/xhtml" && (n = Kb(t)),
            n === "http://www.w3.org/1999/xhtml"
              ? t === "script"
                ? ((n = o.createElement("div")),
                  (n.innerHTML = "<script></script>"),
                  (n = n.removeChild(n.firstChild)))
                : typeof i.is == "string"
                ? (n = o.createElement(t, { is: i.is }))
                : ((n = o.createElement(t)),
                  t === "select" &&
                    ((o = n),
                    i.multiple
                      ? (o.multiple = !0)
                      : i.size && (o.size = i.size)))
              : (n = o.createElementNS(n, t)),
            (n[rs] = e),
            (n[Gf] = i),
            x2(n, e, !1, !1),
            (e.stateNode = n);
          e: {
            switch (((o = ex(t, i)), t)) {
              case "dialog":
                Xt("cancel", n), Xt("close", n), (r = i);
                break;
              case "iframe":
              case "object":
              case "embed":
                Xt("load", n), (r = i);
                break;
              case "video":
              case "audio":
                for (r = 0; r < af.length; r++) Xt(af[r], n);
                r = i;
                break;
              case "source":
                Xt("error", n), (r = i);
                break;
              case "img":
              case "image":
              case "link":
                Xt("error", n), Xt("load", n), (r = i);
                break;
              case "details":
                Xt("toggle", n), (r = i);
                break;
              case "input":
                $S(n, i), (r = Kv(n, i)), Xt("invalid", n);
                break;
              case "option":
                r = i;
                break;
              case "select":
                (n._wrapperState = { wasMultiple: !!i.multiple }),
                  (r = un({}, i, { value: void 0 })),
                  Xt("invalid", n);
                break;
              case "textarea":
                tw(n, i), (r = Zv(n, i)), Xt("invalid", n);
                break;
              default:
                r = i;
            }
            $v(t, r), (a = r);
            for (s in a)
              if (a.hasOwnProperty(s)) {
                var l = a[s];
                s === "style"
                  ? Zb(n, l)
                  : s === "dangerouslySetInnerHTML"
                  ? ((l = l ? l.__html : void 0), l != null && Yb(n, l))
                  : s === "children"
                  ? typeof l == "string"
                    ? (t !== "textarea" || l !== "") && Lf(n, l)
                    : typeof l == "number" && Lf(n, "" + l)
                  : s !== "suppressContentEditableWarning" &&
                    s !== "suppressHydrationWarning" &&
                    s !== "autoFocus" &&
                    (Rf.hasOwnProperty(s)
                      ? l != null && s === "onScroll" && Xt("scroll", n)
                      : l != null && t1(n, s, l, o));
              }
            switch (t) {
              case "input":
                Wd(n), ew(n, i, !1);
                break;
              case "textarea":
                Wd(n), nw(n);
                break;
              case "option":
                i.value != null && n.setAttribute("value", "" + Ho(i.value));
                break;
              case "select":
                (n.multiple = !!i.multiple),
                  (s = i.value),
                  s != null
                    ? Mu(n, !!i.multiple, s, !1)
                    : i.defaultValue != null &&
                      Mu(n, !!i.multiple, i.defaultValue, !0);
                break;
              default:
                typeof r.onClick == "function" && (n.onclick = Bm);
            }
            switch (t) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                i = !!i.autoFocus;
                break e;
              case "img":
                i = !0;
                break e;
              default:
                i = !1;
            }
          }
          i && (e.flags |= 4);
        }
        e.ref !== null && ((e.flags |= 512), (e.flags |= 2097152));
      }
      return ei(e), null;
    case 6:
      if (n && e.stateNode != null) A2(n, e, n.memoizedProps, i);
      else {
        if (typeof i != "string" && e.stateNode === null) throw Error(be(166));
        if (((t = Oa(Vf.current)), Oa(os.current), $d(e))) {
          if (
            ((i = e.stateNode),
            (t = e.memoizedProps),
            (i[rs] = e),
            (s = i.nodeValue !== t) && ((n = Ji), n !== null))
          )
            switch (n.tag) {
              case 3:
                qd(i.nodeValue, t, (n.mode & 1) !== 0);
                break;
              case 5:
                n.memoizedProps.suppressHydrationWarning !== !0 &&
                  qd(i.nodeValue, t, (n.mode & 1) !== 0);
            }
          s && (e.flags |= 4);
        } else
          (i = (t.nodeType === 9 ? t : t.ownerDocument).createTextNode(i)),
            (i[rs] = e),
            (e.stateNode = i);
      }
      return ei(e), null;
    case 13:
      if (
        (Yt(nn),
        (i = e.memoizedState),
        n === null ||
          (n.memoizedState !== null && n.memoizedState.dehydrated !== null))
      ) {
        if ($t && Hi !== null && e.mode & 1 && !(e.flags & 128))
          kP(), Du(), (e.flags |= 98560), (s = !1);
        else if (((s = $d(e)), i !== null && i.dehydrated !== null)) {
          if (n === null) {
            if (!s) throw Error(be(318));
            if (
              ((s = e.memoizedState),
              (s = s !== null ? s.dehydrated : null),
              !s)
            )
              throw Error(be(317));
            s[rs] = e;
          } else
            Du(), !(e.flags & 128) && (e.memoizedState = null), (e.flags |= 4);
          ei(e), (s = !1);
        } else Ir !== null && (Dx(Ir), (Ir = null)), (s = !0);
        if (!s) return e.flags & 65536 ? e : null;
      }
      return e.flags & 128
        ? ((e.lanes = t), e)
        : ((i = i !== null),
          i !== (n !== null && n.memoizedState !== null) &&
            i &&
            ((e.child.flags |= 8192),
            e.mode & 1 &&
              (n === null || nn.current & 1 ? bn === 0 && (bn = 3) : O1())),
          e.updateQueue !== null && (e.flags |= 4),
          ei(e),
          null);
    case 4:
      return (
        Nu(), Ex(n, e), n === null && Uf(e.stateNode.containerInfo), ei(e), null
      );
    case 10:
      return _1(e.type._context), ei(e), null;
    case 17:
      return Bi(e.type) && Rm(), ei(e), null;
    case 19:
      if ((Yt(nn), (s = e.memoizedState), s === null)) return ei(e), null;
      if (((i = (e.flags & 128) !== 0), (o = s.rendering), o === null))
        if (i) Fc(s, !1);
        else {
          if (bn !== 0 || (n !== null && n.flags & 128))
            for (n = e.child; n !== null; ) {
              if (((o = km(n)), o !== null)) {
                for (
                  e.flags |= 128,
                    Fc(s, !1),
                    i = o.updateQueue,
                    i !== null && ((e.updateQueue = i), (e.flags |= 4)),
                    e.subtreeFlags = 0,
                    i = t,
                    t = e.child;
                  t !== null;

                )
                  (s = t),
                    (n = i),
                    (s.flags &= 14680066),
                    (o = s.alternate),
                    o === null
                      ? ((s.childLanes = 0),
                        (s.lanes = n),
                        (s.child = null),
                        (s.subtreeFlags = 0),
                        (s.memoizedProps = null),
                        (s.memoizedState = null),
                        (s.updateQueue = null),
                        (s.dependencies = null),
                        (s.stateNode = null))
                      : ((s.childLanes = o.childLanes),
                        (s.lanes = o.lanes),
                        (s.child = o.child),
                        (s.subtreeFlags = 0),
                        (s.deletions = null),
                        (s.memoizedProps = o.memoizedProps),
                        (s.memoizedState = o.memoizedState),
                        (s.updateQueue = o.updateQueue),
                        (s.type = o.type),
                        (n = o.dependencies),
                        (s.dependencies =
                          n === null
                            ? null
                            : {
                                lanes: n.lanes,
                                firstContext: n.firstContext,
                              })),
                    (t = t.sibling);
                return jt(nn, (nn.current & 1) | 2), e.child;
              }
              n = n.sibling;
            }
          s.tail !== null &&
            yn() > ku &&
            ((e.flags |= 128), (i = !0), Fc(s, !1), (e.lanes = 4194304));
        }
      else {
        if (!i)
          if (((n = km(o)), n !== null)) {
            if (
              ((e.flags |= 128),
              (i = !0),
              (t = n.updateQueue),
              t !== null && ((e.updateQueue = t), (e.flags |= 4)),
              Fc(s, !0),
              s.tail === null && s.tailMode === "hidden" && !o.alternate && !$t)
            )
              return ei(e), null;
          } else
            2 * yn() - s.renderingStartTime > ku &&
              t !== 1073741824 &&
              ((e.flags |= 128), (i = !0), Fc(s, !1), (e.lanes = 4194304));
        s.isBackwards
          ? ((o.sibling = e.child), (e.child = o))
          : ((t = s.last),
            t !== null ? (t.sibling = o) : (e.child = o),
            (s.last = o));
      }
      return s.tail !== null
        ? ((e = s.tail),
          (s.rendering = e),
          (s.tail = e.sibling),
          (s.renderingStartTime = yn()),
          (e.sibling = null),
          (t = nn.current),
          jt(nn, i ? (t & 1) | 2 : t & 1),
          e)
        : (ei(e), null);
    case 22:
    case 23:
      return (
        N1(),
        (i = e.memoizedState !== null),
        n !== null && (n.memoizedState !== null) !== i && (e.flags |= 8192),
        i && e.mode & 1
          ? zi & 1073741824 && (ei(e), e.subtreeFlags & 6 && (e.flags |= 8192))
          : ei(e),
        null
      );
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(be(156, e.tag));
}
function WF(n, e) {
  switch ((g1(e), e.tag)) {
    case 1:
      return (
        Bi(e.type) && Rm(),
        (n = e.flags),
        n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 3:
      return (
        Nu(),
        Yt(Pi),
        Yt(si),
        C1(),
        (n = e.flags),
        n & 65536 && !(n & 128) ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 5:
      return w1(e), null;
    case 13:
      if (
        (Yt(nn), (n = e.memoizedState), n !== null && n.dehydrated !== null)
      ) {
        if (e.alternate === null) throw Error(be(340));
        Du();
      }
      return (
        (n = e.flags), n & 65536 ? ((e.flags = (n & -65537) | 128), e) : null
      );
    case 19:
      return Yt(nn), null;
    case 4:
      return Nu(), null;
    case 10:
      return _1(e.type._context), null;
    case 22:
    case 23:
      return N1(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var np = !1,
  ii = !1,
  JF = typeof WeakSet == "function" ? WeakSet : Set,
  ze = null;
function du(n, e) {
  var t = n.ref;
  if (t !== null)
    if (typeof t == "function")
      try {
        t(null);
      } catch (i) {
        hn(n, e, i);
      }
    else t.current = null;
}
function Tx(n, e, t) {
  try {
    t();
  } catch (i) {
    hn(n, e, i);
  }
}
var Jw = !1;
function jF(n, e) {
  if (((cx = Tm), (n = CP()), p1(n))) {
    if ("selectionStart" in n)
      var t = { start: n.selectionStart, end: n.selectionEnd };
    else
      e: {
        t = ((t = n.ownerDocument) && t.defaultView) || window;
        var i = t.getSelection && t.getSelection();
        if (i && i.rangeCount !== 0) {
          t = i.anchorNode;
          var r = i.anchorOffset,
            s = i.focusNode;
          i = i.focusOffset;
          try {
            t.nodeType, s.nodeType;
          } catch {
            t = null;
            break e;
          }
          var o = 0,
            a = -1,
            l = -1,
            c = 0,
            h = 0,
            d = n,
            p = null;
          t: for (;;) {
            for (
              var m;
              d !== t || (r !== 0 && d.nodeType !== 3) || (a = o + r),
                d !== s || (i !== 0 && d.nodeType !== 3) || (l = o + i),
                d.nodeType === 3 && (o += d.nodeValue.length),
                (m = d.firstChild) !== null;

            )
              (p = d), (d = m);
            for (;;) {
              if (d === n) break t;
              if (
                (p === t && ++c === r && (a = o),
                p === s && ++h === i && (l = o),
                (m = d.nextSibling) !== null)
              )
                break;
              (d = p), (p = d.parentNode);
            }
            d = m;
          }
          t = a === -1 || l === -1 ? null : { start: a, end: l };
        } else t = null;
      }
    t = t || { start: 0, end: 0 };
  } else t = null;
  for (
    fx = { focusedElem: n, selectionRange: t }, Tm = !1, ze = e;
    ze !== null;

  )
    if (((e = ze), (n = e.child), (e.subtreeFlags & 1028) !== 0 && n !== null))
      (n.return = e), (ze = n);
    else
      for (; ze !== null; ) {
        e = ze;
        try {
          var v = e.alternate;
          if (e.flags & 1024)
            switch (e.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (v !== null) {
                  var A = v.memoizedProps,
                    x = v.memoizedState,
                    g = e.stateNode,
                    _ = g.getSnapshotBeforeUpdate(
                      e.elementType === e.type ? A : Br(e.type, A),
                      x
                    );
                  g.__reactInternalSnapshotBeforeUpdate = _;
                }
                break;
              case 3:
                var S = e.stateNode.containerInfo;
                S.nodeType === 1
                  ? (S.textContent = "")
                  : S.nodeType === 9 &&
                    S.documentElement &&
                    S.removeChild(S.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(be(163));
            }
        } catch (w) {
          hn(e, e.return, w);
        }
        if (((n = e.sibling), n !== null)) {
          (n.return = e.return), (ze = n);
          break;
        }
        ze = e.return;
      }
  return (v = Jw), (Jw = !1), v;
}
function yf(n, e, t) {
  var i = e.updateQueue;
  if (((i = i !== null ? i.lastEffect : null), i !== null)) {
    var r = (i = i.next);
    do {
      if ((r.tag & n) === n) {
        var s = r.destroy;
        (r.destroy = void 0), s !== void 0 && Tx(e, t, s);
      }
      r = r.next;
    } while (r !== i);
  }
}
function xg(n, e) {
  if (
    ((e = e.updateQueue), (e = e !== null ? e.lastEffect : null), e !== null)
  ) {
    var t = (e = e.next);
    do {
      if ((t.tag & n) === n) {
        var i = t.create;
        t.destroy = i();
      }
      t = t.next;
    } while (t !== e);
  }
}
function bx(n) {
  var e = n.ref;
  if (e !== null) {
    var t = n.stateNode;
    switch (n.tag) {
      case 5:
        n = t;
        break;
      default:
        n = t;
    }
    typeof e == "function" ? e(n) : (e.current = n);
  }
}
function M2(n) {
  var e = n.alternate;
  e !== null && ((n.alternate = null), M2(e)),
    (n.child = null),
    (n.deletions = null),
    (n.sibling = null),
    n.tag === 5 &&
      ((e = n.stateNode),
      e !== null &&
        (delete e[rs], delete e[Gf], delete e[px], delete e[bF], delete e[PF])),
    (n.stateNode = null),
    (n.return = null),
    (n.dependencies = null),
    (n.memoizedProps = null),
    (n.memoizedState = null),
    (n.pendingProps = null),
    (n.stateNode = null),
    (n.updateQueue = null);
}
function S2(n) {
  return n.tag === 5 || n.tag === 3 || n.tag === 4;
}
function jw(n) {
  e: for (;;) {
    for (; n.sibling === null; ) {
      if (n.return === null || S2(n.return)) return null;
      n = n.return;
    }
    for (
      n.sibling.return = n.return, n = n.sibling;
      n.tag !== 5 && n.tag !== 6 && n.tag !== 18;

    ) {
      if (n.flags & 2 || n.child === null || n.tag === 4) continue e;
      (n.child.return = n), (n = n.child);
    }
    if (!(n.flags & 2)) return n.stateNode;
  }
}
function Px(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode),
      e
        ? t.nodeType === 8
          ? t.parentNode.insertBefore(n, e)
          : t.insertBefore(n, e)
        : (t.nodeType === 8
            ? ((e = t.parentNode), e.insertBefore(n, t))
            : ((e = t), e.appendChild(n)),
          (t = t._reactRootContainer),
          t != null || e.onclick !== null || (e.onclick = Bm));
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Px(n, e, t), n = n.sibling; n !== null; ) Px(n, e, t), (n = n.sibling);
}
function Bx(n, e, t) {
  var i = n.tag;
  if (i === 5 || i === 6)
    (n = n.stateNode), e ? t.insertBefore(n, e) : t.appendChild(n);
  else if (i !== 4 && ((n = n.child), n !== null))
    for (Bx(n, e, t), n = n.sibling; n !== null; ) Bx(n, e, t), (n = n.sibling);
}
var Vn = null,
  Rr = !1;
function uo(n, e, t) {
  for (t = t.child; t !== null; ) w2(n, e, t), (t = t.sibling);
}
function w2(n, e, t) {
  if (ss && typeof ss.onCommitFiberUnmount == "function")
    try {
      ss.onCommitFiberUnmount(fg, t);
    } catch {}
  switch (t.tag) {
    case 5:
      ii || du(t, e);
    case 6:
      var i = Vn,
        r = Rr;
      (Vn = null),
        uo(n, e, t),
        (Vn = i),
        (Rr = r),
        Vn !== null &&
          (Rr
            ? ((n = Vn),
              (t = t.stateNode),
              n.nodeType === 8 ? n.parentNode.removeChild(t) : n.removeChild(t))
            : Vn.removeChild(t.stateNode));
      break;
    case 18:
      Vn !== null &&
        (Rr
          ? ((n = Vn),
            (t = t.stateNode),
            n.nodeType === 8
              ? Ey(n.parentNode, t)
              : n.nodeType === 1 && Ey(n, t),
            Nf(n))
          : Ey(Vn, t.stateNode));
      break;
    case 4:
      (i = Vn),
        (r = Rr),
        (Vn = t.stateNode.containerInfo),
        (Rr = !0),
        uo(n, e, t),
        (Vn = i),
        (Rr = r);
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (
        !ii &&
        ((i = t.updateQueue), i !== null && ((i = i.lastEffect), i !== null))
      ) {
        r = i = i.next;
        do {
          var s = r,
            o = s.destroy;
          (s = s.tag),
            o !== void 0 && (s & 2 || s & 4) && Tx(t, e, o),
            (r = r.next);
        } while (r !== i);
      }
      uo(n, e, t);
      break;
    case 1:
      if (
        !ii &&
        (du(t, e),
        (i = t.stateNode),
        typeof i.componentWillUnmount == "function")
      )
        try {
          (i.props = t.memoizedProps),
            (i.state = t.memoizedState),
            i.componentWillUnmount();
        } catch (a) {
          hn(t, e, a);
        }
      uo(n, e, t);
      break;
    case 21:
      uo(n, e, t);
      break;
    case 22:
      t.mode & 1
        ? ((ii = (i = ii) || t.memoizedState !== null), uo(n, e, t), (ii = i))
        : uo(n, e, t);
      break;
    default:
      uo(n, e, t);
  }
}
function Xw(n) {
  var e = n.updateQueue;
  if (e !== null) {
    n.updateQueue = null;
    var t = n.stateNode;
    t === null && (t = n.stateNode = new JF()),
      e.forEach(function (i) {
        var r = tN.bind(null, n, i);
        t.has(i) || (t.add(i), i.then(r, r));
      });
  }
}
function Er(n, e) {
  var t = e.deletions;
  if (t !== null)
    for (var i = 0; i < t.length; i++) {
      var r = t[i];
      try {
        var s = n,
          o = e,
          a = o;
        e: for (; a !== null; ) {
          switch (a.tag) {
            case 5:
              (Vn = a.stateNode), (Rr = !1);
              break e;
            case 3:
              (Vn = a.stateNode.containerInfo), (Rr = !0);
              break e;
            case 4:
              (Vn = a.stateNode.containerInfo), (Rr = !0);
              break e;
          }
          a = a.return;
        }
        if (Vn === null) throw Error(be(160));
        w2(s, o, r), (Vn = null), (Rr = !1);
        var l = r.alternate;
        l !== null && (l.return = null), (r.return = null);
      } catch (c) {
        hn(r, e, c);
      }
    }
  if (e.subtreeFlags & 12854)
    for (e = e.child; e !== null; ) C2(e, n), (e = e.sibling);
}
function C2(n, e) {
  var t = n.alternate,
    i = n.flags;
  switch (n.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if ((Er(e, n), es(n), i & 4)) {
        try {
          yf(3, n, n.return), xg(3, n);
        } catch (A) {
          hn(n, n.return, A);
        }
        try {
          yf(5, n, n.return);
        } catch (A) {
          hn(n, n.return, A);
        }
      }
      break;
    case 1:
      Er(e, n), es(n), i & 512 && t !== null && du(t, t.return);
      break;
    case 5:
      if (
        (Er(e, n),
        es(n),
        i & 512 && t !== null && du(t, t.return),
        n.flags & 32)
      ) {
        var r = n.stateNode;
        try {
          Lf(r, "");
        } catch (A) {
          hn(n, n.return, A);
        }
      }
      if (i & 4 && ((r = n.stateNode), r != null)) {
        var s = n.memoizedProps,
          o = t !== null ? t.memoizedProps : s,
          a = n.type,
          l = n.updateQueue;
        if (((n.updateQueue = null), l !== null))
          try {
            a === "input" && s.type === "radio" && s.name != null && jb(r, s),
              ex(a, o);
            var c = ex(a, s);
            for (o = 0; o < l.length; o += 2) {
              var h = l[o],
                d = l[o + 1];
              h === "style"
                ? Zb(r, d)
                : h === "dangerouslySetInnerHTML"
                ? Yb(r, d)
                : h === "children"
                ? Lf(r, d)
                : t1(r, h, d, c);
            }
            switch (a) {
              case "input":
                Yv(r, s);
                break;
              case "textarea":
                Xb(r, s);
                break;
              case "select":
                var p = r._wrapperState.wasMultiple;
                r._wrapperState.wasMultiple = !!s.multiple;
                var m = s.value;
                m != null
                  ? Mu(r, !!s.multiple, m, !1)
                  : p !== !!s.multiple &&
                    (s.defaultValue != null
                      ? Mu(r, !!s.multiple, s.defaultValue, !0)
                      : Mu(r, !!s.multiple, s.multiple ? [] : "", !1));
            }
            r[Gf] = s;
          } catch (A) {
            hn(n, n.return, A);
          }
      }
      break;
    case 6:
      if ((Er(e, n), es(n), i & 4)) {
        if (n.stateNode === null) throw Error(be(162));
        (r = n.stateNode), (s = n.memoizedProps);
        try {
          r.nodeValue = s;
        } catch (A) {
          hn(n, n.return, A);
        }
      }
      break;
    case 3:
      if (
        (Er(e, n), es(n), i & 4 && t !== null && t.memoizedState.isDehydrated)
      )
        try {
          Nf(e.containerInfo);
        } catch (A) {
          hn(n, n.return, A);
        }
      break;
    case 4:
      Er(e, n), es(n);
      break;
    case 13:
      Er(e, n),
        es(n),
        (r = n.child),
        r.flags & 8192 &&
          ((s = r.memoizedState !== null),
          (r.stateNode.isHidden = s),
          !s ||
            (r.alternate !== null && r.alternate.memoizedState !== null) ||
            (D1 = yn())),
        i & 4 && Xw(n);
      break;
    case 22:
      if (
        ((h = t !== null && t.memoizedState !== null),
        n.mode & 1 ? ((ii = (c = ii) || h), Er(e, n), (ii = c)) : Er(e, n),
        es(n),
        i & 8192)
      ) {
        if (
          ((c = n.memoizedState !== null),
          (n.stateNode.isHidden = c) && !h && n.mode & 1)
        )
          for (ze = n, h = n.child; h !== null; ) {
            for (d = ze = h; ze !== null; ) {
              switch (((p = ze), (m = p.child), p.tag)) {
                case 0:
                case 11:
                case 14:
                case 15:
                  yf(4, p, p.return);
                  break;
                case 1:
                  du(p, p.return);
                  var v = p.stateNode;
                  if (typeof v.componentWillUnmount == "function") {
                    (i = p), (t = p.return);
                    try {
                      (e = i),
                        (v.props = e.memoizedProps),
                        (v.state = e.memoizedState),
                        v.componentWillUnmount();
                    } catch (A) {
                      hn(i, t, A);
                    }
                  }
                  break;
                case 5:
                  du(p, p.return);
                  break;
                case 22:
                  if (p.memoizedState !== null) {
                    Yw(d);
                    continue;
                  }
              }
              m !== null ? ((m.return = p), (ze = m)) : Yw(d);
            }
            h = h.sibling;
          }
        e: for (h = null, d = n; ; ) {
          if (d.tag === 5) {
            if (h === null) {
              h = d;
              try {
                (r = d.stateNode),
                  c
                    ? ((s = r.style),
                      typeof s.setProperty == "function"
                        ? s.setProperty("display", "none", "important")
                        : (s.display = "none"))
                    : ((a = d.stateNode),
                      (l = d.memoizedProps.style),
                      (o =
                        l != null && l.hasOwnProperty("display")
                          ? l.display
                          : null),
                      (a.style.display = Qb("display", o)));
              } catch (A) {
                hn(n, n.return, A);
              }
            }
          } else if (d.tag === 6) {
            if (h === null)
              try {
                d.stateNode.nodeValue = c ? "" : d.memoizedProps;
              } catch (A) {
                hn(n, n.return, A);
              }
          } else if (
            ((d.tag !== 22 && d.tag !== 23) ||
              d.memoizedState === null ||
              d === n) &&
            d.child !== null
          ) {
            (d.child.return = d), (d = d.child);
            continue;
          }
          if (d === n) break e;
          for (; d.sibling === null; ) {
            if (d.return === null || d.return === n) break e;
            h === d && (h = null), (d = d.return);
          }
          h === d && (h = null), (d.sibling.return = d.return), (d = d.sibling);
        }
      }
      break;
    case 19:
      Er(e, n), es(n), i & 4 && Xw(n);
      break;
    case 21:
      break;
    default:
      Er(e, n), es(n);
  }
}
function es(n) {
  var e = n.flags;
  if (e & 2) {
    try {
      e: {
        for (var t = n.return; t !== null; ) {
          if (S2(t)) {
            var i = t;
            break e;
          }
          t = t.return;
        }
        throw Error(be(160));
      }
      switch (i.tag) {
        case 5:
          var r = i.stateNode;
          i.flags & 32 && (Lf(r, ""), (i.flags &= -33));
          var s = jw(n);
          Bx(n, s, r);
          break;
        case 3:
        case 4:
          var o = i.stateNode.containerInfo,
            a = jw(n);
          Px(n, a, o);
          break;
        default:
          throw Error(be(161));
      }
    } catch (l) {
      hn(n, n.return, l);
    }
    n.flags &= -3;
  }
  e & 4096 && (n.flags &= -4097);
}
function XF(n, e, t) {
  (ze = n), E2(n);
}
function E2(n, e, t) {
  for (var i = (n.mode & 1) !== 0; ze !== null; ) {
    var r = ze,
      s = r.child;
    if (r.tag === 22 && i) {
      var o = r.memoizedState !== null || np;
      if (!o) {
        var a = r.alternate,
          l = (a !== null && a.memoizedState !== null) || ii;
        a = np;
        var c = ii;
        if (((np = o), (ii = l) && !c))
          for (ze = r; ze !== null; )
            (o = ze),
              (l = o.child),
              o.tag === 22 && o.memoizedState !== null
                ? Qw(r)
                : l !== null
                ? ((l.return = o), (ze = l))
                : Qw(r);
        for (; s !== null; ) (ze = s), E2(s), (s = s.sibling);
        (ze = r), (np = a), (ii = c);
      }
      Kw(n);
    } else
      r.subtreeFlags & 8772 && s !== null ? ((s.return = r), (ze = s)) : Kw(n);
  }
}
function Kw(n) {
  for (; ze !== null; ) {
    var e = ze;
    if (e.flags & 8772) {
      var t = e.alternate;
      try {
        if (e.flags & 8772)
          switch (e.tag) {
            case 0:
            case 11:
            case 15:
              ii || xg(5, e);
              break;
            case 1:
              var i = e.stateNode;
              if (e.flags & 4 && !ii)
                if (t === null) i.componentDidMount();
                else {
                  var r =
                    e.elementType === e.type
                      ? t.memoizedProps
                      : Br(e.type, t.memoizedProps);
                  i.componentDidUpdate(
                    r,
                    t.memoizedState,
                    i.__reactInternalSnapshotBeforeUpdate
                  );
                }
              var s = e.updateQueue;
              s !== null && Rw(e, s, i);
              break;
            case 3:
              var o = e.updateQueue;
              if (o !== null) {
                if (((t = null), e.child !== null))
                  switch (e.child.tag) {
                    case 5:
                      t = e.child.stateNode;
                      break;
                    case 1:
                      t = e.child.stateNode;
                  }
                Rw(e, o, t);
              }
              break;
            case 5:
              var a = e.stateNode;
              if (t === null && e.flags & 4) {
                t = a;
                var l = e.memoizedProps;
                switch (e.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    l.autoFocus && t.focus();
                    break;
                  case "img":
                    l.src && (t.src = l.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (e.memoizedState === null) {
                var c = e.alternate;
                if (c !== null) {
                  var h = c.memoizedState;
                  if (h !== null) {
                    var d = h.dehydrated;
                    d !== null && Nf(d);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(be(163));
          }
        ii || (e.flags & 512 && bx(e));
      } catch (p) {
        hn(e, e.return, p);
      }
    }
    if (e === n) {
      ze = null;
      break;
    }
    if (((t = e.sibling), t !== null)) {
      (t.return = e.return), (ze = t);
      break;
    }
    ze = e.return;
  }
}
function Yw(n) {
  for (; ze !== null; ) {
    var e = ze;
    if (e === n) {
      ze = null;
      break;
    }
    var t = e.sibling;
    if (t !== null) {
      (t.return = e.return), (ze = t);
      break;
    }
    ze = e.return;
  }
}
function Qw(n) {
  for (; ze !== null; ) {
    var e = ze;
    try {
      switch (e.tag) {
        case 0:
        case 11:
        case 15:
          var t = e.return;
          try {
            xg(4, e);
          } catch (l) {
            hn(e, t, l);
          }
          break;
        case 1:
          var i = e.stateNode;
          if (typeof i.componentDidMount == "function") {
            var r = e.return;
            try {
              i.componentDidMount();
            } catch (l) {
              hn(e, r, l);
            }
          }
          var s = e.return;
          try {
            bx(e);
          } catch (l) {
            hn(e, s, l);
          }
          break;
        case 5:
          var o = e.return;
          try {
            bx(e);
          } catch (l) {
            hn(e, o, l);
          }
      }
    } catch (l) {
      hn(e, e.return, l);
    }
    if (e === n) {
      ze = null;
      break;
    }
    var a = e.sibling;
    if (a !== null) {
      (a.return = e.return), (ze = a);
      break;
    }
    ze = e.return;
  }
}
var KF = Math.ceil,
  Gm = Qs.ReactCurrentDispatcher,
  L1 = Qs.ReactCurrentOwner,
  mr = Qs.ReactCurrentBatchConfig,
  Bt = 0,
  Un = null,
  wn = null,
  Jn = 0,
  zi = 0,
  pu = $o(0),
  bn = 0,
  Xf = null,
  nl = 0,
  _g = 0,
  I1 = 0,
  vf = null,
  Ci = null,
  D1 = 0,
  ku = 1 / 0,
  Ps = null,
  Hm = !1,
  Rx = null,
  Fo = null,
  ip = !1,
  To = null,
  Vm = 0,
  xf = 0,
  Lx = null,
  cm = -1,
  fm = 0;
function pi() {
  return Bt & 6 ? yn() : cm !== -1 ? cm : (cm = yn());
}
function No(n) {
  return n.mode & 1
    ? Bt & 2 && Jn !== 0
      ? Jn & -Jn
      : RF.transition !== null
      ? (fm === 0 && (fm = uP()), fm)
      : ((n = kt),
        n !== 0 || ((n = window.event), (n = n === void 0 ? 16 : gP(n.type))),
        n)
    : 1;
}
function Nr(n, e, t, i) {
  if (50 < xf) throw ((xf = 0), (Lx = null), Error(be(185)));
  gh(n, t, i),
    (!(Bt & 2) || n !== Un) &&
      (n === Un && (!(Bt & 2) && (_g |= t), bn === 4 && Co(n, Jn)),
      Ri(n, i),
      t === 1 && Bt === 0 && !(e.mode & 1) && ((ku = yn() + 500), gg && ea()));
}
function Ri(n, e) {
  var t = n.callbackNode;
  RD(n, e);
  var i = Em(n, n === Un ? Jn : 0);
  if (i === 0)
    t !== null && sw(t), (n.callbackNode = null), (n.callbackPriority = 0);
  else if (((e = i & -i), n.callbackPriority !== e)) {
    if ((t != null && sw(t), e === 1))
      n.tag === 0 ? BF(Zw.bind(null, n)) : FP(Zw.bind(null, n)),
        EF(function () {
          !(Bt & 6) && ea();
        }),
        (t = null);
    else {
      switch (cP(i)) {
        case 1:
          t = o1;
          break;
        case 4:
          t = aP;
          break;
        case 16:
          t = Cm;
          break;
        case 536870912:
          t = lP;
          break;
        default:
          t = Cm;
      }
      t = D2(t, T2.bind(null, n));
    }
    (n.callbackPriority = e), (n.callbackNode = t);
  }
}
function T2(n, e) {
  if (((cm = -1), (fm = 0), Bt & 6)) throw Error(be(327));
  var t = n.callbackNode;
  if (Tu() && n.callbackNode !== t) return null;
  var i = Em(n, n === Un ? Jn : 0);
  if (i === 0) return null;
  if (i & 30 || i & n.expiredLanes || e) e = Wm(n, i);
  else {
    e = i;
    var r = Bt;
    Bt |= 2;
    var s = P2();
    (Un !== n || Jn !== e) && ((Ps = null), (ku = yn() + 500), Ja(n, e));
    do
      try {
        ZF();
        break;
      } catch (a) {
        b2(n, a);
      }
    while (1);
    x1(),
      (Gm.current = s),
      (Bt = r),
      wn !== null ? (e = 0) : ((Un = null), (Jn = 0), (e = bn));
  }
  if (e !== 0) {
    if (
      (e === 2 && ((r = sx(n)), r !== 0 && ((i = r), (e = Ix(n, r)))), e === 1)
    )
      throw ((t = Xf), Ja(n, 0), Co(n, i), Ri(n, yn()), t);
    if (e === 6) Co(n, i);
    else {
      if (
        ((r = n.current.alternate),
        !(i & 30) &&
          !YF(r) &&
          ((e = Wm(n, i)),
          e === 2 && ((s = sx(n)), s !== 0 && ((i = s), (e = Ix(n, s)))),
          e === 1))
      )
        throw ((t = Xf), Ja(n, 0), Co(n, i), Ri(n, yn()), t);
      switch (((n.finishedWork = r), (n.finishedLanes = i), e)) {
        case 0:
        case 1:
          throw Error(be(345));
        case 2:
          Ea(n, Ci, Ps);
          break;
        case 3:
          if (
            (Co(n, i), (i & 130023424) === i && ((e = D1 + 500 - yn()), 10 < e))
          ) {
            if (Em(n, 0) !== 0) break;
            if (((r = n.suspendedLanes), (r & i) !== i)) {
              pi(), (n.pingedLanes |= n.suspendedLanes & r);
              break;
            }
            n.timeoutHandle = dx(Ea.bind(null, n, Ci, Ps), e);
            break;
          }
          Ea(n, Ci, Ps);
          break;
        case 4:
          if ((Co(n, i), (i & 4194240) === i)) break;
          for (e = n.eventTimes, r = -1; 0 < i; ) {
            var o = 31 - Fr(i);
            (s = 1 << o), (o = e[o]), o > r && (r = o), (i &= ~s);
          }
          if (
            ((i = r),
            (i = yn() - i),
            (i =
              (120 > i
                ? 120
                : 480 > i
                ? 480
                : 1080 > i
                ? 1080
                : 1920 > i
                ? 1920
                : 3e3 > i
                ? 3e3
                : 4320 > i
                ? 4320
                : 1960 * KF(i / 1960)) - i),
            10 < i)
          ) {
            n.timeoutHandle = dx(Ea.bind(null, n, Ci, Ps), i);
            break;
          }
          Ea(n, Ci, Ps);
          break;
        case 5:
          Ea(n, Ci, Ps);
          break;
        default:
          throw Error(be(329));
      }
    }
  }
  return Ri(n, yn()), n.callbackNode === t ? T2.bind(null, n) : null;
}
function Ix(n, e) {
  var t = vf;
  return (
    n.current.memoizedState.isDehydrated && (Ja(n, e).flags |= 256),
    (n = Wm(n, e)),
    n !== 2 && ((e = Ci), (Ci = t), e !== null && Dx(e)),
    n
  );
}
function Dx(n) {
  Ci === null ? (Ci = n) : Ci.push.apply(Ci, n);
}
function YF(n) {
  for (var e = n; ; ) {
    if (e.flags & 16384) {
      var t = e.updateQueue;
      if (t !== null && ((t = t.stores), t !== null))
        for (var i = 0; i < t.length; i++) {
          var r = t[i],
            s = r.getSnapshot;
          r = r.value;
          try {
            if (!zr(s(), r)) return !1;
          } catch {
            return !1;
          }
        }
    }
    if (((t = e.child), e.subtreeFlags & 16384 && t !== null))
      (t.return = e), (e = t);
    else {
      if (e === n) break;
      for (; e.sibling === null; ) {
        if (e.return === null || e.return === n) return !0;
        e = e.return;
      }
      (e.sibling.return = e.return), (e = e.sibling);
    }
  }
  return !0;
}
function Co(n, e) {
  for (
    e &= ~I1,
      e &= ~_g,
      n.suspendedLanes |= e,
      n.pingedLanes &= ~e,
      n = n.expirationTimes;
    0 < e;

  ) {
    var t = 31 - Fr(e),
      i = 1 << t;
    (n[t] = -1), (e &= ~i);
  }
}
function Zw(n) {
  if (Bt & 6) throw Error(be(327));
  Tu();
  var e = Em(n, 0);
  if (!(e & 1)) return Ri(n, yn()), null;
  var t = Wm(n, e);
  if (n.tag !== 0 && t === 2) {
    var i = sx(n);
    i !== 0 && ((e = i), (t = Ix(n, i)));
  }
  if (t === 1) throw ((t = Xf), Ja(n, 0), Co(n, e), Ri(n, yn()), t);
  if (t === 6) throw Error(be(345));
  return (
    (n.finishedWork = n.current.alternate),
    (n.finishedLanes = e),
    Ea(n, Ci, Ps),
    Ri(n, yn()),
    null
  );
}
function F1(n, e) {
  var t = Bt;
  Bt |= 1;
  try {
    return n(e);
  } finally {
    (Bt = t), Bt === 0 && ((ku = yn() + 500), gg && ea());
  }
}
function il(n) {
  To !== null && To.tag === 0 && !(Bt & 6) && Tu();
  var e = Bt;
  Bt |= 1;
  var t = mr.transition,
    i = kt;
  try {
    if (((mr.transition = null), (kt = 1), n)) return n();
  } finally {
    (kt = i), (mr.transition = t), (Bt = e), !(Bt & 6) && ea();
  }
}
function N1() {
  (zi = pu.current), Yt(pu);
}
function Ja(n, e) {
  (n.finishedWork = null), (n.finishedLanes = 0);
  var t = n.timeoutHandle;
  if ((t !== -1 && ((n.timeoutHandle = -1), CF(t)), wn !== null))
    for (t = wn.return; t !== null; ) {
      var i = t;
      switch ((g1(i), i.tag)) {
        case 1:
          (i = i.type.childContextTypes), i != null && Rm();
          break;
        case 3:
          Nu(), Yt(Pi), Yt(si), C1();
          break;
        case 5:
          w1(i);
          break;
        case 4:
          Nu();
          break;
        case 13:
          Yt(nn);
          break;
        case 19:
          Yt(nn);
          break;
        case 10:
          _1(i.type._context);
          break;
        case 22:
        case 23:
          N1();
      }
      t = t.return;
    }
  if (
    ((Un = n),
    (wn = n = Oo(n.current, null)),
    (Jn = zi = e),
    (bn = 0),
    (Xf = null),
    (I1 = _g = nl = 0),
    (Ci = vf = null),
    Na !== null)
  ) {
    for (e = 0; e < Na.length; e++)
      if (((t = Na[e]), (i = t.interleaved), i !== null)) {
        t.interleaved = null;
        var r = i.next,
          s = t.pending;
        if (s !== null) {
          var o = s.next;
          (s.next = r), (i.next = o);
        }
        t.pending = i;
      }
    Na = null;
  }
  return n;
}
function b2(n, e) {
  do {
    var t = wn;
    try {
      if ((x1(), (am.current = zm), Um)) {
        for (var i = ln.memoizedState; i !== null; ) {
          var r = i.queue;
          r !== null && (r.pending = null), (i = i.next);
        }
        Um = !1;
      }
      if (
        ((tl = 0),
        (On = Tn = ln = null),
        (gf = !1),
        (Wf = 0),
        (L1.current = null),
        t === null || t.return === null)
      ) {
        (bn = 1), (Xf = e), (wn = null);
        break;
      }
      e: {
        var s = n,
          o = t.return,
          a = t,
          l = e;
        if (
          ((e = Jn),
          (a.flags |= 32768),
          l !== null && typeof l == "object" && typeof l.then == "function")
        ) {
          var c = l,
            h = a,
            d = h.tag;
          if (!(h.mode & 1) && (d === 0 || d === 11 || d === 15)) {
            var p = h.alternate;
            p
              ? ((h.updateQueue = p.updateQueue),
                (h.memoizedState = p.memoizedState),
                (h.lanes = p.lanes))
              : ((h.updateQueue = null), (h.memoizedState = null));
          }
          var m = kw(o);
          if (m !== null) {
            (m.flags &= -257),
              Uw(m, o, a, s, e),
              m.mode & 1 && Ow(s, c, e),
              (e = m),
              (l = c);
            var v = e.updateQueue;
            if (v === null) {
              var A = new Set();
              A.add(l), (e.updateQueue = A);
            } else v.add(l);
            break e;
          } else {
            if (!(e & 1)) {
              Ow(s, c, e), O1();
              break e;
            }
            l = Error(be(426));
          }
        } else if ($t && a.mode & 1) {
          var x = kw(o);
          if (x !== null) {
            !(x.flags & 65536) && (x.flags |= 256),
              Uw(x, o, a, s, e),
              y1(Ou(l, a));
            break e;
          }
        }
        (s = l = Ou(l, a)),
          bn !== 4 && (bn = 2),
          vf === null ? (vf = [s]) : vf.push(s),
          (s = o);
        do {
          switch (s.tag) {
            case 3:
              (s.flags |= 65536), (e &= -e), (s.lanes |= e);
              var g = f2(s, l, e);
              Bw(s, g);
              break e;
            case 1:
              a = l;
              var _ = s.type,
                S = s.stateNode;
              if (
                !(s.flags & 128) &&
                (typeof _.getDerivedStateFromError == "function" ||
                  (S !== null &&
                    typeof S.componentDidCatch == "function" &&
                    (Fo === null || !Fo.has(S))))
              ) {
                (s.flags |= 65536), (e &= -e), (s.lanes |= e);
                var w = h2(s, a, e);
                Bw(s, w);
                break e;
              }
          }
          s = s.return;
        } while (s !== null);
      }
      R2(t);
    } catch (E) {
      (e = E), wn === t && t !== null && (wn = t = t.return);
      continue;
    }
    break;
  } while (1);
}
function P2() {
  var n = Gm.current;
  return (Gm.current = zm), n === null ? zm : n;
}
function O1() {
  (bn === 0 || bn === 3 || bn === 2) && (bn = 4),
    Un === null || (!(nl & 268435455) && !(_g & 268435455)) || Co(Un, Jn);
}
function Wm(n, e) {
  var t = Bt;
  Bt |= 2;
  var i = P2();
  (Un !== n || Jn !== e) && ((Ps = null), Ja(n, e));
  do
    try {
      QF();
      break;
    } catch (r) {
      b2(n, r);
    }
  while (1);
  if ((x1(), (Bt = t), (Gm.current = i), wn !== null)) throw Error(be(261));
  return (Un = null), (Jn = 0), bn;
}
function QF() {
  for (; wn !== null; ) B2(wn);
}
function ZF() {
  for (; wn !== null && !MD(); ) B2(wn);
}
function B2(n) {
  var e = I2(n.alternate, n, zi);
  (n.memoizedProps = n.pendingProps),
    e === null ? R2(n) : (wn = e),
    (L1.current = null);
}
function R2(n) {
  var e = n;
  do {
    var t = e.alternate;
    if (((n = e.return), e.flags & 32768)) {
      if (((t = WF(t, e)), t !== null)) {
        (t.flags &= 32767), (wn = t);
        return;
      }
      if (n !== null)
        (n.flags |= 32768), (n.subtreeFlags = 0), (n.deletions = null);
      else {
        (bn = 6), (wn = null);
        return;
      }
    } else if (((t = VF(t, e, zi)), t !== null)) {
      wn = t;
      return;
    }
    if (((e = e.sibling), e !== null)) {
      wn = e;
      return;
    }
    wn = e = n;
  } while (e !== null);
  bn === 0 && (bn = 5);
}
function Ea(n, e, t) {
  var i = kt,
    r = mr.transition;
  try {
    (mr.transition = null), (kt = 1), qF(n, e, t, i);
  } finally {
    (mr.transition = r), (kt = i);
  }
  return null;
}
function qF(n, e, t, i) {
  do Tu();
  while (To !== null);
  if (Bt & 6) throw Error(be(327));
  t = n.finishedWork;
  var r = n.finishedLanes;
  if (t === null) return null;
  if (((n.finishedWork = null), (n.finishedLanes = 0), t === n.current))
    throw Error(be(177));
  (n.callbackNode = null), (n.callbackPriority = 0);
  var s = t.lanes | t.childLanes;
  if (
    (LD(n, s),
    n === Un && ((wn = Un = null), (Jn = 0)),
    (!(t.subtreeFlags & 2064) && !(t.flags & 2064)) ||
      ip ||
      ((ip = !0),
      D2(Cm, function () {
        return Tu(), null;
      })),
    (s = (t.flags & 15990) !== 0),
    t.subtreeFlags & 15990 || s)
  ) {
    (s = mr.transition), (mr.transition = null);
    var o = kt;
    kt = 1;
    var a = Bt;
    (Bt |= 4),
      (L1.current = null),
      jF(n, t),
      C2(t, n),
      vF(fx),
      (Tm = !!cx),
      (fx = cx = null),
      (n.current = t),
      XF(t),
      SD(),
      (Bt = a),
      (kt = o),
      (mr.transition = s);
  } else n.current = t;
  if (
    (ip && ((ip = !1), (To = n), (Vm = r)),
    (s = n.pendingLanes),
    s === 0 && (Fo = null),
    ED(t.stateNode),
    Ri(n, yn()),
    e !== null)
  )
    for (i = n.onRecoverableError, t = 0; t < e.length; t++)
      (r = e[t]), i(r.value, { componentStack: r.stack, digest: r.digest });
  if (Hm) throw ((Hm = !1), (n = Rx), (Rx = null), n);
  return (
    Vm & 1 && n.tag !== 0 && Tu(),
    (s = n.pendingLanes),
    s & 1 ? (n === Lx ? xf++ : ((xf = 0), (Lx = n))) : (xf = 0),
    ea(),
    null
  );
}
function Tu() {
  if (To !== null) {
    var n = cP(Vm),
      e = mr.transition,
      t = kt;
    try {
      if (((mr.transition = null), (kt = 16 > n ? 16 : n), To === null))
        var i = !1;
      else {
        if (((n = To), (To = null), (Vm = 0), Bt & 6)) throw Error(be(331));
        var r = Bt;
        for (Bt |= 4, ze = n.current; ze !== null; ) {
          var s = ze,
            o = s.child;
          if (ze.flags & 16) {
            var a = s.deletions;
            if (a !== null) {
              for (var l = 0; l < a.length; l++) {
                var c = a[l];
                for (ze = c; ze !== null; ) {
                  var h = ze;
                  switch (h.tag) {
                    case 0:
                    case 11:
                    case 15:
                      yf(8, h, s);
                  }
                  var d = h.child;
                  if (d !== null) (d.return = h), (ze = d);
                  else
                    for (; ze !== null; ) {
                      h = ze;
                      var p = h.sibling,
                        m = h.return;
                      if ((M2(h), h === c)) {
                        ze = null;
                        break;
                      }
                      if (p !== null) {
                        (p.return = m), (ze = p);
                        break;
                      }
                      ze = m;
                    }
                }
              }
              var v = s.alternate;
              if (v !== null) {
                var A = v.child;
                if (A !== null) {
                  v.child = null;
                  do {
                    var x = A.sibling;
                    (A.sibling = null), (A = x);
                  } while (A !== null);
                }
              }
              ze = s;
            }
          }
          if (s.subtreeFlags & 2064 && o !== null) (o.return = s), (ze = o);
          else
            e: for (; ze !== null; ) {
              if (((s = ze), s.flags & 2048))
                switch (s.tag) {
                  case 0:
                  case 11:
                  case 15:
                    yf(9, s, s.return);
                }
              var g = s.sibling;
              if (g !== null) {
                (g.return = s.return), (ze = g);
                break e;
              }
              ze = s.return;
            }
        }
        var _ = n.current;
        for (ze = _; ze !== null; ) {
          o = ze;
          var S = o.child;
          if (o.subtreeFlags & 2064 && S !== null) (S.return = o), (ze = S);
          else
            e: for (o = _; ze !== null; ) {
              if (((a = ze), a.flags & 2048))
                try {
                  switch (a.tag) {
                    case 0:
                    case 11:
                    case 15:
                      xg(9, a);
                  }
                } catch (E) {
                  hn(a, a.return, E);
                }
              if (a === o) {
                ze = null;
                break e;
              }
              var w = a.sibling;
              if (w !== null) {
                (w.return = a.return), (ze = w);
                break e;
              }
              ze = a.return;
            }
        }
        if (
          ((Bt = r), ea(), ss && typeof ss.onPostCommitFiberRoot == "function")
        )
          try {
            ss.onPostCommitFiberRoot(fg, n);
          } catch {}
        i = !0;
      }
      return i;
    } finally {
      (kt = t), (mr.transition = e);
    }
  }
  return !1;
}
function qw(n, e, t) {
  (e = Ou(t, e)),
    (e = f2(n, e, 1)),
    (n = Do(n, e, 1)),
    (e = pi()),
    n !== null && (gh(n, 1, e), Ri(n, e));
}
function hn(n, e, t) {
  if (n.tag === 3) qw(n, n, t);
  else
    for (; e !== null; ) {
      if (e.tag === 3) {
        qw(e, n, t);
        break;
      } else if (e.tag === 1) {
        var i = e.stateNode;
        if (
          typeof e.type.getDerivedStateFromError == "function" ||
          (typeof i.componentDidCatch == "function" &&
            (Fo === null || !Fo.has(i)))
        ) {
          (n = Ou(t, n)),
            (n = h2(e, n, 1)),
            (e = Do(e, n, 1)),
            (n = pi()),
            e !== null && (gh(e, 1, n), Ri(e, n));
          break;
        }
      }
      e = e.return;
    }
}
function $F(n, e, t) {
  var i = n.pingCache;
  i !== null && i.delete(e),
    (e = pi()),
    (n.pingedLanes |= n.suspendedLanes & t),
    Un === n &&
      (Jn & t) === t &&
      (bn === 4 || (bn === 3 && (Jn & 130023424) === Jn && 500 > yn() - D1)
        ? Ja(n, 0)
        : (I1 |= t)),
    Ri(n, e);
}
function L2(n, e) {
  e === 0 &&
    (n.mode & 1
      ? ((e = Xd), (Xd <<= 1), !(Xd & 130023424) && (Xd = 4194304))
      : (e = 1));
  var t = pi();
  (n = Js(n, e)), n !== null && (gh(n, e, t), Ri(n, t));
}
function eN(n) {
  var e = n.memoizedState,
    t = 0;
  e !== null && (t = e.retryLane), L2(n, t);
}
function tN(n, e) {
  var t = 0;
  switch (n.tag) {
    case 13:
      var i = n.stateNode,
        r = n.memoizedState;
      r !== null && (t = r.retryLane);
      break;
    case 19:
      i = n.stateNode;
      break;
    default:
      throw Error(be(314));
  }
  i !== null && i.delete(e), L2(n, t);
}
var I2;
I2 = function (n, e, t) {
  if (n !== null)
    if (n.memoizedProps !== e.pendingProps || Pi.current) bi = !0;
    else {
      if (!(n.lanes & t) && !(e.flags & 128)) return (bi = !1), HF(n, e, t);
      bi = !!(n.flags & 131072);
    }
  else (bi = !1), $t && e.flags & 1048576 && NP(e, Dm, e.index);
  switch (((e.lanes = 0), e.tag)) {
    case 2:
      var i = e.type;
      um(n, e), (n = e.pendingProps);
      var r = Iu(e, si.current);
      Eu(e, t), (r = T1(null, e, i, n, r, t));
      var s = b1();
      return (
        (e.flags |= 1),
        typeof r == "object" &&
        r !== null &&
        typeof r.render == "function" &&
        r.$$typeof === void 0
          ? ((e.tag = 1),
            (e.memoizedState = null),
            (e.updateQueue = null),
            Bi(i) ? ((s = !0), Lm(e)) : (s = !1),
            (e.memoizedState =
              r.state !== null && r.state !== void 0 ? r.state : null),
            M1(e),
            (r.updater = yg),
            (e.stateNode = r),
            (r._reactInternals = e),
            _x(e, i, n, t),
            (e = Sx(null, e, i, !0, s, t)))
          : ((e.tag = 0), $t && s && m1(e), di(null, e, r, t), (e = e.child)),
        e
      );
    case 16:
      i = e.elementType;
      e: {
        switch (
          (um(n, e),
          (n = e.pendingProps),
          (r = i._init),
          (i = r(i._payload)),
          (e.type = i),
          (r = e.tag = iN(i)),
          (n = Br(i, n)),
          r)
        ) {
          case 0:
            e = Mx(null, e, i, n, t);
            break e;
          case 1:
            e = Hw(null, e, i, n, t);
            break e;
          case 11:
            e = zw(null, e, i, n, t);
            break e;
          case 14:
            e = Gw(null, e, i, Br(i.type, n), t);
            break e;
        }
        throw Error(be(306, i, ""));
      }
      return e;
    case 0:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Br(i, r)),
        Mx(n, e, i, r, t)
      );
    case 1:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Br(i, r)),
        Hw(n, e, i, r, t)
      );
    case 3:
      e: {
        if ((g2(e), n === null)) throw Error(be(387));
        (i = e.pendingProps),
          (s = e.memoizedState),
          (r = s.element),
          zP(n, e),
          Om(e, i, null, t);
        var o = e.memoizedState;
        if (((i = o.element), s.isDehydrated))
          if (
            ((s = {
              element: i,
              isDehydrated: !1,
              cache: o.cache,
              pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
              transitions: o.transitions,
            }),
            (e.updateQueue.baseState = s),
            (e.memoizedState = s),
            e.flags & 256)
          ) {
            (r = Ou(Error(be(423)), e)), (e = Vw(n, e, i, t, r));
            break e;
          } else if (i !== r) {
            (r = Ou(Error(be(424)), e)), (e = Vw(n, e, i, t, r));
            break e;
          } else
            for (
              Hi = Io(e.stateNode.containerInfo.firstChild),
                Ji = e,
                $t = !0,
                Ir = null,
                t = WP(e, null, i, t),
                e.child = t;
              t;

            )
              (t.flags = (t.flags & -3) | 4096), (t = t.sibling);
        else {
          if ((Du(), i === r)) {
            e = js(n, e, t);
            break e;
          }
          di(n, e, i, t);
        }
        e = e.child;
      }
      return e;
    case 5:
      return (
        JP(e),
        n === null && yx(e),
        (i = e.type),
        (r = e.pendingProps),
        (s = n !== null ? n.memoizedProps : null),
        (o = r.children),
        hx(i, r) ? (o = null) : s !== null && hx(i, s) && (e.flags |= 32),
        m2(n, e),
        di(n, e, o, t),
        e.child
      );
    case 6:
      return n === null && yx(e), null;
    case 13:
      return y2(n, e, t);
    case 4:
      return (
        S1(e, e.stateNode.containerInfo),
        (i = e.pendingProps),
        n === null ? (e.child = Fu(e, null, i, t)) : di(n, e, i, t),
        e.child
      );
    case 11:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Br(i, r)),
        zw(n, e, i, r, t)
      );
    case 7:
      return di(n, e, e.pendingProps, t), e.child;
    case 8:
      return di(n, e, e.pendingProps.children, t), e.child;
    case 12:
      return di(n, e, e.pendingProps.children, t), e.child;
    case 10:
      e: {
        if (
          ((i = e.type._context),
          (r = e.pendingProps),
          (s = e.memoizedProps),
          (o = r.value),
          jt(Fm, i._currentValue),
          (i._currentValue = o),
          s !== null)
        )
          if (zr(s.value, o)) {
            if (s.children === r.children && !Pi.current) {
              e = js(n, e, t);
              break e;
            }
          } else
            for (s = e.child, s !== null && (s.return = e); s !== null; ) {
              var a = s.dependencies;
              if (a !== null) {
                o = s.child;
                for (var l = a.firstContext; l !== null; ) {
                  if (l.context === i) {
                    if (s.tag === 1) {
                      (l = Us(-1, t & -t)), (l.tag = 2);
                      var c = s.updateQueue;
                      if (c !== null) {
                        c = c.shared;
                        var h = c.pending;
                        h === null
                          ? (l.next = l)
                          : ((l.next = h.next), (h.next = l)),
                          (c.pending = l);
                      }
                    }
                    (s.lanes |= t),
                      (l = s.alternate),
                      l !== null && (l.lanes |= t),
                      vx(s.return, t, e),
                      (a.lanes |= t);
                    break;
                  }
                  l = l.next;
                }
              } else if (s.tag === 10) o = s.type === e.type ? null : s.child;
              else if (s.tag === 18) {
                if (((o = s.return), o === null)) throw Error(be(341));
                (o.lanes |= t),
                  (a = o.alternate),
                  a !== null && (a.lanes |= t),
                  vx(o, t, e),
                  (o = s.sibling);
              } else o = s.child;
              if (o !== null) o.return = s;
              else
                for (o = s; o !== null; ) {
                  if (o === e) {
                    o = null;
                    break;
                  }
                  if (((s = o.sibling), s !== null)) {
                    (s.return = o.return), (o = s);
                    break;
                  }
                  o = o.return;
                }
              s = o;
            }
        di(n, e, r.children, t), (e = e.child);
      }
      return e;
    case 9:
      return (
        (r = e.type),
        (i = e.pendingProps.children),
        Eu(e, t),
        (r = gr(r)),
        (i = i(r)),
        (e.flags |= 1),
        di(n, e, i, t),
        e.child
      );
    case 14:
      return (
        (i = e.type),
        (r = Br(i, e.pendingProps)),
        (r = Br(i.type, r)),
        Gw(n, e, i, r, t)
      );
    case 15:
      return d2(n, e, e.type, e.pendingProps, t);
    case 17:
      return (
        (i = e.type),
        (r = e.pendingProps),
        (r = e.elementType === i ? r : Br(i, r)),
        um(n, e),
        (e.tag = 1),
        Bi(i) ? ((n = !0), Lm(e)) : (n = !1),
        Eu(e, t),
        HP(e, i, r),
        _x(e, i, r, t),
        Sx(null, e, i, !0, n, t)
      );
    case 19:
      return v2(n, e, t);
    case 22:
      return p2(n, e, t);
  }
  throw Error(be(156, e.tag));
};
function D2(n, e) {
  return oP(n, e);
}
function nN(n, e, t, i) {
  (this.tag = n),
    (this.key = t),
    (this.sibling =
      this.child =
      this.return =
      this.stateNode =
      this.type =
      this.elementType =
        null),
    (this.index = 0),
    (this.ref = null),
    (this.pendingProps = e),
    (this.dependencies =
      this.memoizedState =
      this.updateQueue =
      this.memoizedProps =
        null),
    (this.mode = i),
    (this.subtreeFlags = this.flags = 0),
    (this.deletions = null),
    (this.childLanes = this.lanes = 0),
    (this.alternate = null);
}
function pr(n, e, t, i) {
  return new nN(n, e, t, i);
}
function k1(n) {
  return (n = n.prototype), !(!n || !n.isReactComponent);
}
function iN(n) {
  if (typeof n == "function") return k1(n) ? 1 : 0;
  if (n != null) {
    if (((n = n.$$typeof), n === i1)) return 11;
    if (n === r1) return 14;
  }
  return 2;
}
function Oo(n, e) {
  var t = n.alternate;
  return (
    t === null
      ? ((t = pr(n.tag, e, n.key, n.mode)),
        (t.elementType = n.elementType),
        (t.type = n.type),
        (t.stateNode = n.stateNode),
        (t.alternate = n),
        (n.alternate = t))
      : ((t.pendingProps = e),
        (t.type = n.type),
        (t.flags = 0),
        (t.subtreeFlags = 0),
        (t.deletions = null)),
    (t.flags = n.flags & 14680064),
    (t.childLanes = n.childLanes),
    (t.lanes = n.lanes),
    (t.child = n.child),
    (t.memoizedProps = n.memoizedProps),
    (t.memoizedState = n.memoizedState),
    (t.updateQueue = n.updateQueue),
    (e = n.dependencies),
    (t.dependencies =
      e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }),
    (t.sibling = n.sibling),
    (t.index = n.index),
    (t.ref = n.ref),
    t
  );
}
function hm(n, e, t, i, r, s) {
  var o = 2;
  if (((i = n), typeof n == "function")) k1(n) && (o = 1);
  else if (typeof n == "string") o = 5;
  else
    e: switch (n) {
      case ru:
        return ja(t.children, r, s, e);
      case n1:
        (o = 8), (r |= 8);
        break;
      case Wv:
        return (
          (n = pr(12, t, e, r | 2)), (n.elementType = Wv), (n.lanes = s), n
        );
      case Jv:
        return (n = pr(13, t, e, r)), (n.elementType = Jv), (n.lanes = s), n;
      case jv:
        return (n = pr(19, t, e, r)), (n.elementType = jv), (n.lanes = s), n;
      case Vb:
        return Ag(t, r, s, e);
      default:
        if (typeof n == "object" && n !== null)
          switch (n.$$typeof) {
            case Gb:
              o = 10;
              break e;
            case Hb:
              o = 9;
              break e;
            case i1:
              o = 11;
              break e;
            case r1:
              o = 14;
              break e;
            case _o:
              (o = 16), (i = null);
              break e;
          }
        throw Error(be(130, n == null ? n : typeof n, ""));
    }
  return (
    (e = pr(o, t, e, r)), (e.elementType = n), (e.type = i), (e.lanes = s), e
  );
}
function ja(n, e, t, i) {
  return (n = pr(7, n, i, e)), (n.lanes = t), n;
}
function Ag(n, e, t, i) {
  return (
    (n = pr(22, n, i, e)),
    (n.elementType = Vb),
    (n.lanes = t),
    (n.stateNode = { isHidden: !1 }),
    n
  );
}
function Dy(n, e, t) {
  return (n = pr(6, n, null, e)), (n.lanes = t), n;
}
function Fy(n, e, t) {
  return (
    (e = pr(4, n.children !== null ? n.children : [], n.key, e)),
    (e.lanes = t),
    (e.stateNode = {
      containerInfo: n.containerInfo,
      pendingChildren: null,
      implementation: n.implementation,
    }),
    e
  );
}
function rN(n, e, t, i, r) {
  (this.tag = e),
    (this.containerInfo = n),
    (this.finishedWork =
      this.pingCache =
      this.current =
      this.pendingChildren =
        null),
    (this.timeoutHandle = -1),
    (this.callbackNode = this.pendingContext = this.context = null),
    (this.callbackPriority = 0),
    (this.eventTimes = my(0)),
    (this.expirationTimes = my(-1)),
    (this.entangledLanes =
      this.finishedLanes =
      this.mutableReadLanes =
      this.expiredLanes =
      this.pingedLanes =
      this.suspendedLanes =
      this.pendingLanes =
        0),
    (this.entanglements = my(0)),
    (this.identifierPrefix = i),
    (this.onRecoverableError = r),
    (this.mutableSourceEagerHydrationData = null);
}
function U1(n, e, t, i, r, s, o, a, l) {
  return (
    (n = new rN(n, e, t, a, l)),
    e === 1 ? ((e = 1), s === !0 && (e |= 8)) : (e = 0),
    (s = pr(3, null, null, e)),
    (n.current = s),
    (s.stateNode = n),
    (s.memoizedState = {
      element: i,
      isDehydrated: t,
      cache: null,
      transitions: null,
      pendingSuspenseBoundaries: null,
    }),
    M1(s),
    n
  );
}
function sN(n, e, t) {
  var i = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return {
    $$typeof: iu,
    key: i == null ? null : "" + i,
    children: n,
    containerInfo: e,
    implementation: t,
  };
}
function F2(n) {
  if (!n) return Vo;
  n = n._reactInternals;
  e: {
    if (cl(n) !== n || n.tag !== 1) throw Error(be(170));
    var e = n;
    do {
      switch (e.tag) {
        case 3:
          e = e.stateNode.context;
          break e;
        case 1:
          if (Bi(e.type)) {
            e = e.stateNode.__reactInternalMemoizedMergedChildContext;
            break e;
          }
      }
      e = e.return;
    } while (e !== null);
    throw Error(be(171));
  }
  if (n.tag === 1) {
    var t = n.type;
    if (Bi(t)) return DP(n, t, e);
  }
  return e;
}
function N2(n, e, t, i, r, s, o, a, l) {
  return (
    (n = U1(t, i, !0, n, r, s, o, a, l)),
    (n.context = F2(null)),
    (t = n.current),
    (i = pi()),
    (r = No(t)),
    (s = Us(i, r)),
    (s.callback = e ?? null),
    Do(t, s, r),
    (n.current.lanes = r),
    gh(n, r, i),
    Ri(n, i),
    n
  );
}
function Mg(n, e, t, i) {
  var r = e.current,
    s = pi(),
    o = No(r);
  return (
    (t = F2(t)),
    e.context === null ? (e.context = t) : (e.pendingContext = t),
    (e = Us(s, o)),
    (e.payload = { element: n }),
    (i = i === void 0 ? null : i),
    i !== null && (e.callback = i),
    (n = Do(r, e, o)),
    n !== null && (Nr(n, r, o, s), om(n, r, o)),
    o
  );
}
function Jm(n) {
  if (((n = n.current), !n.child)) return null;
  switch (n.child.tag) {
    case 5:
      return n.child.stateNode;
    default:
      return n.child.stateNode;
  }
}
function $w(n, e) {
  if (((n = n.memoizedState), n !== null && n.dehydrated !== null)) {
    var t = n.retryLane;
    n.retryLane = t !== 0 && t < e ? t : e;
  }
}
function z1(n, e) {
  $w(n, e), (n = n.alternate) && $w(n, e);
}
function oN() {
  return null;
}
var O2 =
  typeof reportError == "function"
    ? reportError
    : function (n) {
        console.error(n);
      };
function G1(n) {
  this._internalRoot = n;
}
Sg.prototype.render = G1.prototype.render = function (n) {
  var e = this._internalRoot;
  if (e === null) throw Error(be(409));
  Mg(n, e, null, null);
};
Sg.prototype.unmount = G1.prototype.unmount = function () {
  var n = this._internalRoot;
  if (n !== null) {
    this._internalRoot = null;
    var e = n.containerInfo;
    il(function () {
      Mg(null, n, null, null);
    }),
      (e[Ws] = null);
  }
};
function Sg(n) {
  this._internalRoot = n;
}
Sg.prototype.unstable_scheduleHydration = function (n) {
  if (n) {
    var e = dP();
    n = { blockedOn: null, target: n, priority: e };
    for (var t = 0; t < wo.length && e !== 0 && e < wo[t].priority; t++);
    wo.splice(t, 0, n), t === 0 && mP(n);
  }
};
function H1(n) {
  return !(!n || (n.nodeType !== 1 && n.nodeType !== 9 && n.nodeType !== 11));
}
function wg(n) {
  return !(
    !n ||
    (n.nodeType !== 1 &&
      n.nodeType !== 9 &&
      n.nodeType !== 11 &&
      (n.nodeType !== 8 || n.nodeValue !== " react-mount-point-unstable "))
  );
}
function eC() {}
function aN(n, e, t, i, r) {
  if (r) {
    if (typeof i == "function") {
      var s = i;
      i = function () {
        var c = Jm(o);
        s.call(c);
      };
    }
    var o = N2(e, i, n, 0, null, !1, !1, "", eC);
    return (
      (n._reactRootContainer = o),
      (n[Ws] = o.current),
      Uf(n.nodeType === 8 ? n.parentNode : n),
      il(),
      o
    );
  }
  for (; (r = n.lastChild); ) n.removeChild(r);
  if (typeof i == "function") {
    var a = i;
    i = function () {
      var c = Jm(l);
      a.call(c);
    };
  }
  var l = U1(n, 0, !1, null, null, !1, !1, "", eC);
  return (
    (n._reactRootContainer = l),
    (n[Ws] = l.current),
    Uf(n.nodeType === 8 ? n.parentNode : n),
    il(function () {
      Mg(e, l, t, i);
    }),
    l
  );
}
function Cg(n, e, t, i, r) {
  var s = t._reactRootContainer;
  if (s) {
    var o = s;
    if (typeof r == "function") {
      var a = r;
      r = function () {
        var l = Jm(o);
        a.call(l);
      };
    }
    Mg(e, o, n, r);
  } else o = aN(t, e, n, r, i);
  return Jm(o);
}
fP = function (n) {
  switch (n.tag) {
    case 3:
      var e = n.stateNode;
      if (e.current.memoizedState.isDehydrated) {
        var t = of(e.pendingLanes);
        t !== 0 &&
          (a1(e, t | 1), Ri(e, yn()), !(Bt & 6) && ((ku = yn() + 500), ea()));
      }
      break;
    case 13:
      il(function () {
        var i = Js(n, 1);
        if (i !== null) {
          var r = pi();
          Nr(i, n, 1, r);
        }
      }),
        z1(n, 1);
  }
};
l1 = function (n) {
  if (n.tag === 13) {
    var e = Js(n, 134217728);
    if (e !== null) {
      var t = pi();
      Nr(e, n, 134217728, t);
    }
    z1(n, 134217728);
  }
};
hP = function (n) {
  if (n.tag === 13) {
    var e = No(n),
      t = Js(n, e);
    if (t !== null) {
      var i = pi();
      Nr(t, n, e, i);
    }
    z1(n, e);
  }
};
dP = function () {
  return kt;
};
pP = function (n, e) {
  var t = kt;
  try {
    return (kt = n), e();
  } finally {
    kt = t;
  }
};
nx = function (n, e, t) {
  switch (e) {
    case "input":
      if ((Yv(n, t), (e = t.name), t.type === "radio" && e != null)) {
        for (t = n; t.parentNode; ) t = t.parentNode;
        for (
          t = t.querySelectorAll(
            "input[name=" + JSON.stringify("" + e) + '][type="radio"]'
          ),
            e = 0;
          e < t.length;
          e++
        ) {
          var i = t[e];
          if (i !== n && i.form === n.form) {
            var r = mg(i);
            if (!r) throw Error(be(90));
            Jb(i), Yv(i, r);
          }
        }
      }
      break;
    case "textarea":
      Xb(n, t);
      break;
    case "select":
      (e = t.value), e != null && Mu(n, !!t.multiple, e, !1);
  }
};
eP = F1;
tP = il;
var lN = { usingClientEntryPoint: !1, Events: [vh, lu, mg, qb, $b, F1] },
  Nc = {
    findFiberByHostInstance: Fa,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom",
  },
  uN = {
    bundleType: Nc.bundleType,
    version: Nc.version,
    rendererPackageName: Nc.rendererPackageName,
    rendererConfig: Nc.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: Qs.ReactCurrentDispatcher,
    findHostInstanceByFiber: function (n) {
      return (n = rP(n)), n === null ? null : n.stateNode;
    },
    findFiberByHostInstance: Nc.findFiberByHostInstance || oN,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608",
  };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var rp = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!rp.isDisabled && rp.supportsFiber)
    try {
      (fg = rp.inject(uN)), (ss = rp);
    } catch {}
}
Qi.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = lN;
Qi.createPortal = function (n, e) {
  var t = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!H1(e)) throw Error(be(200));
  return sN(n, e, null, t);
};
Qi.createRoot = function (n, e) {
  if (!H1(n)) throw Error(be(299));
  var t = !1,
    i = "",
    r = O2;
  return (
    e != null &&
      (e.unstable_strictMode === !0 && (t = !0),
      e.identifierPrefix !== void 0 && (i = e.identifierPrefix),
      e.onRecoverableError !== void 0 && (r = e.onRecoverableError)),
    (e = U1(n, 1, !1, null, null, t, !1, i, r)),
    (n[Ws] = e.current),
    Uf(n.nodeType === 8 ? n.parentNode : n),
    new G1(e)
  );
};
Qi.findDOMNode = function (n) {
  if (n == null) return null;
  if (n.nodeType === 1) return n;
  var e = n._reactInternals;
  if (e === void 0)
    throw typeof n.render == "function"
      ? Error(be(188))
      : ((n = Object.keys(n).join(",")), Error(be(268, n)));
  return (n = rP(e)), (n = n === null ? null : n.stateNode), n;
};
Qi.flushSync = function (n) {
  return il(n);
};
Qi.hydrate = function (n, e, t) {
  if (!wg(e)) throw Error(be(200));
  return Cg(null, n, e, !0, t);
};
Qi.hydrateRoot = function (n, e, t) {
  if (!H1(n)) throw Error(be(405));
  var i = (t != null && t.hydratedSources) || null,
    r = !1,
    s = "",
    o = O2;
  if (
    (t != null &&
      (t.unstable_strictMode === !0 && (r = !0),
      t.identifierPrefix !== void 0 && (s = t.identifierPrefix),
      t.onRecoverableError !== void 0 && (o = t.onRecoverableError)),
    (e = N2(e, null, n, 1, t ?? null, r, !1, s, o)),
    (n[Ws] = e.current),
    Uf(n),
    i)
  )
    for (n = 0; n < i.length; n++)
      (t = i[n]),
        (r = t._getVersion),
        (r = r(t._source)),
        e.mutableSourceEagerHydrationData == null
          ? (e.mutableSourceEagerHydrationData = [t, r])
          : e.mutableSourceEagerHydrationData.push(t, r);
  return new Sg(e);
};
Qi.render = function (n, e, t) {
  if (!wg(e)) throw Error(be(200));
  return Cg(null, n, e, !1, t);
};
Qi.unmountComponentAtNode = function (n) {
  if (!wg(n)) throw Error(be(40));
  return n._reactRootContainer
    ? (il(function () {
        Cg(null, null, n, !1, function () {
          (n._reactRootContainer = null), (n[Ws] = null);
        });
      }),
      !0)
    : !1;
};
Qi.unstable_batchedUpdates = F1;
Qi.unstable_renderSubtreeIntoContainer = function (n, e, t, i) {
  if (!wg(t)) throw Error(be(200));
  if (n == null || n._reactInternals === void 0) throw Error(be(38));
  return Cg(n, e, t, !1, i);
};
Qi.version = "18.2.0-next-9e3b772b8-20220608";
(function (n) {
  function e() {
    if (
      !(
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" ||
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"
      )
    )
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
  }
  e(), (n.exports = Qi);
})(oD);
var k2,
  tC = Gv;
(k2 = zv.createRoot = tC.createRoot), (zv.hydrateRoot = tC.hydrateRoot);
/**
 * @remix-run/router v1.5.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Kf() {
  return (
    (Kf = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    Kf.apply(this, arguments)
  );
}
var ka;
(function (n) {
  (n.Pop = "POP"), (n.Push = "PUSH"), (n.Replace = "REPLACE");
})(ka || (ka = {}));
const nC = "popstate";
function cN(n) {
  n === void 0 && (n = {});
  function e(i, r) {
    let { pathname: s, search: o, hash: a } = i.location;
    return Fx(
      "",
      { pathname: s, search: o, hash: a },
      (r.state && r.state.usr) || null,
      (r.state && r.state.key) || "default"
    );
  }
  function t(i, r) {
    return typeof r == "string" ? r : jm(r);
  }
  return hN(e, t, null, n);
}
function ko(n, e) {
  if (n === !1 || n === null || typeof n > "u") throw new Error(e);
}
function fN() {
  return Math.random().toString(36).substr(2, 8);
}
function iC(n, e) {
  return { usr: n.state, key: n.key, idx: e };
}
function Fx(n, e, t, i) {
  return (
    t === void 0 && (t = null),
    Kf(
      { pathname: typeof n == "string" ? n : n.pathname, search: "", hash: "" },
      typeof e == "string" ? Eg(e) : e,
      { state: t, key: (e && e.key) || i || fN() }
    )
  );
}
function jm(n) {
  let { pathname: e = "/", search: t = "", hash: i = "" } = n;
  return (
    t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t),
    i && i !== "#" && (e += i.charAt(0) === "#" ? i : "#" + i),
    e
  );
}
function Eg(n) {
  let e = {};
  if (n) {
    let t = n.indexOf("#");
    t >= 0 && ((e.hash = n.substr(t)), (n = n.substr(0, t)));
    let i = n.indexOf("?");
    i >= 0 && ((e.search = n.substr(i)), (n = n.substr(0, i))),
      n && (e.pathname = n);
  }
  return e;
}
function hN(n, e, t, i) {
  i === void 0 && (i = {});
  let { window: r = document.defaultView, v5Compat: s = !1 } = i,
    o = r.history,
    a = ka.Pop,
    l = null,
    c = h();
  c == null && ((c = 0), o.replaceState(Kf({}, o.state, { idx: c }), ""));
  function h() {
    return (o.state || { idx: null }).idx;
  }
  function d() {
    a = ka.Pop;
    let x = h(),
      g = x == null ? null : x - c;
    (c = x), l && l({ action: a, location: A.location, delta: g });
  }
  function p(x, g) {
    a = ka.Push;
    let _ = Fx(A.location, x, g);
    t && t(_, x), (c = h() + 1);
    let S = iC(_, c),
      w = A.createHref(_);
    try {
      o.pushState(S, "", w);
    } catch {
      r.location.assign(w);
    }
    s && l && l({ action: a, location: A.location, delta: 1 });
  }
  function m(x, g) {
    a = ka.Replace;
    let _ = Fx(A.location, x, g);
    t && t(_, x), (c = h());
    let S = iC(_, c),
      w = A.createHref(_);
    o.replaceState(S, "", w),
      s && l && l({ action: a, location: A.location, delta: 0 });
  }
  function v(x) {
    let g = r.location.origin !== "null" ? r.location.origin : r.location.href,
      _ = typeof x == "string" ? x : jm(x);
    return (
      ko(
        g,
        "No window.location.(origin|href) available to create URL for href: " +
          _
      ),
      new URL(_, g)
    );
  }
  let A = {
    get action() {
      return a;
    },
    get location() {
      return n(r, o);
    },
    listen(x) {
      if (l) throw new Error("A history only accepts one active listener");
      return (
        r.addEventListener(nC, d),
        (l = x),
        () => {
          r.removeEventListener(nC, d), (l = null);
        }
      );
    },
    createHref(x) {
      return e(r, x);
    },
    createURL: v,
    encodeLocation(x) {
      let g = v(x);
      return { pathname: g.pathname, search: g.search, hash: g.hash };
    },
    push: p,
    replace: m,
    go(x) {
      return o.go(x);
    },
  };
  return A;
}
var rC;
(function (n) {
  (n.data = "data"),
    (n.deferred = "deferred"),
    (n.redirect = "redirect"),
    (n.error = "error");
})(rC || (rC = {}));
function U2(n, e) {
  if (e === "/") return n;
  if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
  let t = e.endsWith("/") ? e.length - 1 : e.length,
    i = n.charAt(t);
  return i && i !== "/" ? null : n.slice(t) || "/";
}
function dN(n, e) {
  e === void 0 && (e = "/");
  let {
    pathname: t,
    search: i = "",
    hash: r = "",
  } = typeof n == "string" ? Eg(n) : n;
  return {
    pathname: t ? (t.startsWith("/") ? t : pN(t, e)) : e,
    search: mN(i),
    hash: gN(r),
  };
}
function pN(n, e) {
  let t = e.replace(/\/+$/, "").split("/");
  return (
    n.split("/").forEach((r) => {
      r === ".." ? t.length > 1 && t.pop() : r !== "." && t.push(r);
    }),
    t.length > 1 ? t.join("/") : "/"
  );
}
function Ny(n, e, t, i) {
  return (
    "Cannot include a '" +
    n +
    "' character in a manually specified " +
    ("`to." +
      e +
      "` field [" +
      JSON.stringify(i) +
      "].  Please separate it out to the ") +
    ("`to." + t + "` field. Alternatively you may provide the full path as ") +
    'a string in <Link to="..."> and the router will parse it for you.'
  );
}
function z2(n) {
  return n.filter(
    (e, t) => t === 0 || (e.route.path && e.route.path.length > 0)
  );
}
function G2(n, e, t, i) {
  i === void 0 && (i = !1);
  let r;
  typeof n == "string"
    ? (r = Eg(n))
    : ((r = Kf({}, n)),
      ko(
        !r.pathname || !r.pathname.includes("?"),
        Ny("?", "pathname", "search", r)
      ),
      ko(
        !r.pathname || !r.pathname.includes("#"),
        Ny("#", "pathname", "hash", r)
      ),
      ko(!r.search || !r.search.includes("#"), Ny("#", "search", "hash", r)));
  let s = n === "" || r.pathname === "",
    o = s ? "/" : r.pathname,
    a;
  if (i || o == null) a = t;
  else {
    let d = e.length - 1;
    if (o.startsWith("..")) {
      let p = o.split("/");
      for (; p[0] === ".."; ) p.shift(), (d -= 1);
      r.pathname = p.join("/");
    }
    a = d >= 0 ? e[d] : "/";
  }
  let l = dN(r, a),
    c = o && o !== "/" && o.endsWith("/"),
    h = (s || o === ".") && t.endsWith("/");
  return !l.pathname.endsWith("/") && (c || h) && (l.pathname += "/"), l;
}
const H2 = (n) => n.join("/").replace(/\/\/+/g, "/"),
  mN = (n) => (!n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n),
  gN = (n) => (!n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n);
/**
 * React Router v6.10.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function yN(n, e) {
  return (n === e && (n !== 0 || 1 / n === 1 / e)) || (n !== n && e !== e);
}
const vN = typeof Object.is == "function" ? Object.is : yN,
  { useState: xN, useEffect: _N, useLayoutEffect: AN, useDebugValue: MN } = Uv;
function SN(n, e, t) {
  const i = e(),
    [{ inst: r }, s] = xN({ inst: { value: i, getSnapshot: e } });
  return (
    AN(() => {
      (r.value = i), (r.getSnapshot = e), Oy(r) && s({ inst: r });
    }, [n, i, e]),
    _N(
      () => (
        Oy(r) && s({ inst: r }),
        n(() => {
          Oy(r) && s({ inst: r });
        })
      ),
      [n]
    ),
    MN(i),
    i
  );
}
function Oy(n) {
  const e = n.getSnapshot,
    t = n.value;
  try {
    const i = e();
    return !vN(t, i);
  } catch {
    return !0;
  }
}
function wN(n, e, t) {
  return e();
}
const CN =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  EN = !CN,
  TN = EN ? wN : SN;
"useSyncExternalStore" in Uv && ((n) => n.useSyncExternalStore)(Uv);
const Tg = H.createContext(null),
  V1 = H.createContext(null),
  V2 = H.createContext({ outlet: null, matches: [] });
function bN(n, e) {
  let { relative: t } = e === void 0 ? {} : e;
  bg() || ko(!1);
  let { basename: i, navigator: r } = H.useContext(Tg),
    { hash: s, pathname: o, search: a } = W2(n, { relative: t }),
    l = o;
  return (
    i !== "/" && (l = o === "/" ? i : H2([i, o])),
    r.createHref({ pathname: l, search: a, hash: s })
  );
}
function bg() {
  return H.useContext(V1) != null;
}
function W1() {
  return bg() || ko(!1), H.useContext(V1).location;
}
function PN() {
  bg() || ko(!1);
  let { basename: n, navigator: e } = H.useContext(Tg),
    { matches: t } = H.useContext(V2),
    { pathname: i } = W1(),
    r = JSON.stringify(z2(t).map((a) => a.pathnameBase)),
    s = H.useRef(!1);
  return (
    H.useEffect(() => {
      s.current = !0;
    }),
    H.useCallback(
      function (a, l) {
        if ((l === void 0 && (l = {}), !s.current)) return;
        if (typeof a == "number") {
          e.go(a);
          return;
        }
        let c = G2(a, JSON.parse(r), i, l.relative === "path");
        n !== "/" &&
          (c.pathname = c.pathname === "/" ? n : H2([n, c.pathname])),
          (l.replace ? e.replace : e.push)(c, l.state, l);
      },
      [n, e, r, i]
    )
  );
}
function W2(n, e) {
  let { relative: t } = e === void 0 ? {} : e,
    { matches: i } = H.useContext(V2),
    { pathname: r } = W1(),
    s = JSON.stringify(z2(i).map((o) => o.pathnameBase));
  return H.useMemo(() => G2(n, JSON.parse(s), r, t === "path"), [n, s, r, t]);
}
var sC;
(function (n) {
  (n.UseBlocker = "useBlocker"), (n.UseRevalidator = "useRevalidator");
})(sC || (sC = {}));
var oC;
(function (n) {
  (n.UseBlocker = "useBlocker"),
    (n.UseLoaderData = "useLoaderData"),
    (n.UseActionData = "useActionData"),
    (n.UseRouteError = "useRouteError"),
    (n.UseNavigation = "useNavigation"),
    (n.UseRouteLoaderData = "useRouteLoaderData"),
    (n.UseMatches = "useMatches"),
    (n.UseRevalidator = "useRevalidator");
})(oC || (oC = {}));
function BN(n) {
  let {
    basename: e = "/",
    children: t = null,
    location: i,
    navigationType: r = ka.Pop,
    navigator: s,
    static: o = !1,
  } = n;
  bg() && ko(!1);
  let a = e.replace(/^\/*/, "/"),
    l = H.useMemo(() => ({ basename: a, navigator: s, static: o }), [a, s, o]);
  typeof i == "string" && (i = Eg(i));
  let {
      pathname: c = "/",
      search: h = "",
      hash: d = "",
      state: p = null,
      key: m = "default",
    } = i,
    v = H.useMemo(() => {
      let A = U2(c, a);
      return A == null
        ? null
        : {
            location: { pathname: A, search: h, hash: d, state: p, key: m },
            navigationType: r,
          };
    }, [a, c, h, d, p, m, r]);
  return v == null
    ? null
    : H.createElement(
        Tg.Provider,
        { value: l },
        H.createElement(V1.Provider, { children: t, value: v })
      );
}
var aC;
(function (n) {
  (n[(n.pending = 0)] = "pending"),
    (n[(n.success = 1)] = "success"),
    (n[(n.error = 2)] = "error");
})(aC || (aC = {}));
new Promise(() => {});
/**
 * React Router DOM v6.10.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */ function Nx() {
  return (
    (Nx = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    Nx.apply(this, arguments)
  );
}
function RN(n, e) {
  if (n == null) return {};
  var t = {},
    i = Object.keys(n),
    r,
    s;
  for (s = 0; s < i.length; s++)
    (r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]);
  return t;
}
function LN(n) {
  return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey);
}
function IN(n, e) {
  return n.button === 0 && (!e || e === "_self") && !LN(n);
}
const DN = [
  "onClick",
  "relative",
  "reloadDocument",
  "replace",
  "state",
  "target",
  "to",
  "preventScrollReset",
];
function FN(n) {
  let { basename: e, children: t, window: i } = n,
    r = H.useRef();
  r.current == null && (r.current = cN({ window: i, v5Compat: !0 }));
  let s = r.current,
    [o, a] = H.useState({ action: s.action, location: s.location });
  return (
    H.useLayoutEffect(() => s.listen(a), [s]),
    H.createElement(BN, {
      basename: e,
      children: t,
      location: o.location,
      navigationType: o.action,
      navigator: s,
    })
  );
}
const NN =
    typeof window < "u" &&
    typeof window.document < "u" &&
    typeof window.document.createElement < "u",
  ON = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
  kN = H.forwardRef(function (e, t) {
    let {
        onClick: i,
        relative: r,
        reloadDocument: s,
        replace: o,
        state: a,
        target: l,
        to: c,
        preventScrollReset: h,
      } = e,
      d = RN(e, DN),
      { basename: p } = H.useContext(Tg),
      m,
      v = !1;
    if (typeof c == "string" && ON.test(c) && ((m = c), NN)) {
      let _ = new URL(window.location.href),
        S = c.startsWith("//") ? new URL(_.protocol + c) : new URL(c),
        w = U2(S.pathname, p);
      S.origin === _.origin && w != null
        ? (c = w + S.search + S.hash)
        : (v = !0);
    }
    let A = bN(c, { relative: r }),
      x = UN(c, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: h,
        relative: r,
      });
    function g(_) {
      i && i(_), _.defaultPrevented || x(_);
    }
    return H.createElement(
      "a",
      Nx({}, d, { href: m || A, onClick: v || s ? i : g, ref: t, target: l })
    );
  });
var lC;
(function (n) {
  (n.UseScrollRestoration = "useScrollRestoration"),
    (n.UseSubmitImpl = "useSubmitImpl"),
    (n.UseFetcher = "useFetcher");
})(lC || (lC = {}));
var uC;
(function (n) {
  (n.UseFetchers = "useFetchers"),
    (n.UseScrollRestoration = "useScrollRestoration");
})(uC || (uC = {}));
function UN(n, e) {
  let {
      target: t,
      replace: i,
      state: r,
      preventScrollReset: s,
      relative: o,
    } = e === void 0 ? {} : e,
    a = PN(),
    l = W1(),
    c = W2(n, { relative: o });
  return H.useCallback(
    (h) => {
      if (IN(h, t)) {
        h.preventDefault();
        let d = i !== void 0 ? i : jm(l) === jm(c);
        a(n, { replace: d, state: r, preventScrollReset: s, relative: o });
      }
    },
    [l, a, c, i, r, t, n, s, o]
  );
}
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Pg = "151",
  Ta = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  ba = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  J2 = 0,
  Ox = 1,
  j2 = 2,
  zN = 3,
  X2 = 0,
  Bg = 1,
  _f = 2,
  Ua = 3,
  cs = 0,
  mi = 1,
  dr = 2,
  GN = 2,
  zs = 0,
  Xa = 1,
  kx = 2,
  Ux = 3,
  zx = 4,
  K2 = 5,
  Ia = 100,
  Y2 = 101,
  Q2 = 102,
  Gx = 103,
  Hx = 104,
  Z2 = 200,
  q2 = 201,
  $2 = 202,
  eB = 203,
  J1 = 204,
  j1 = 205,
  tB = 206,
  nB = 207,
  iB = 208,
  rB = 209,
  sB = 210,
  oB = 0,
  aB = 1,
  lB = 2,
  Xm = 3,
  uB = 4,
  cB = 5,
  fB = 6,
  hB = 7,
  _h = 0,
  dB = 1,
  pB = 2,
  Or = 0,
  mB = 1,
  gB = 2,
  yB = 3,
  X1 = 4,
  vB = 5,
  Rg = 300,
  Wo = 301,
  Jo = 302,
  Yf = 303,
  Qf = 304,
  ec = 306,
  jo = 1e3,
  Wn = 1001,
  Uu = 1002,
  dn = 1003,
  Zf = 1004,
  HN = 1004,
  bu = 1005,
  VN = 1005,
  rn = 1006,
  Lg = 1007,
  WN = 1007,
  fs = 1008,
  JN = 1008,
  Xs = 1009,
  xB = 1010,
  _B = 1011,
  K1 = 1012,
  AB = 1013,
  bo = 1014,
  Ns = 1015,
  zu = 1016,
  MB = 1017,
  SB = 1018,
  Ka = 1020,
  wB = 1021,
  Ti = 1023,
  CB = 1024,
  EB = 1025,
  Uo = 1026,
  rl = 1027,
  TB = 1028,
  bB = 1029,
  PB = 1030,
  BB = 1031,
  RB = 1033,
  dm = 33776,
  pm = 33777,
  mm = 33778,
  gm = 33779,
  Vx = 35840,
  Wx = 35841,
  Jx = 35842,
  jx = 35843,
  LB = 36196,
  Xx = 37492,
  Kx = 37496,
  Yx = 37808,
  Qx = 37809,
  Zx = 37810,
  qx = 37811,
  $x = 37812,
  e_ = 37813,
  t_ = 37814,
  n_ = 37815,
  i_ = 37816,
  r_ = 37817,
  s_ = 37818,
  o_ = 37819,
  a_ = 37820,
  l_ = 37821,
  ym = 36492,
  IB = 36283,
  u_ = 36284,
  c_ = 36285,
  f_ = 36286,
  DB = 2200,
  FB = 2201,
  NB = 2202,
  Gu = 2300,
  sl = 2301,
  vm = 2302,
  za = 2400,
  Ga = 2401,
  qf = 2402,
  Ig = 2500,
  Y1 = 2501,
  jN = 0,
  OB = 1,
  Q1 = 2,
  Ks = 3e3,
  Tt = 3001,
  kB = 3200,
  UB = 3201,
  Zs = 0,
  zB = 1,
  XN = "",
  Lr = "srgb",
  Hu = "srgb-linear",
  Z1 = "display-p3",
  KN = 0,
  xm = 7680,
  YN = 7681,
  QN = 7682,
  ZN = 7683,
  qN = 34055,
  $N = 34056,
  eO = 5386,
  tO = 512,
  nO = 513,
  iO = 514,
  rO = 515,
  sO = 516,
  oO = 517,
  aO = 518,
  GB = 519,
  $f = 35044,
  Ya = 35048,
  lO = 35040,
  uO = 35045,
  cO = 35049,
  fO = 35041,
  hO = 35046,
  dO = 35050,
  pO = 35042,
  mO = "100",
  h_ = "300 es",
  Km = 1035;
class ds {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const i = this._listeners;
    i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const i = this._listeners;
    return i[e] !== void 0 && i[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const r = this._listeners[e];
    if (r !== void 0) {
      const s = r.indexOf(t);
      s !== -1 && r.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e.type];
    if (i !== void 0) {
      e.target = this;
      const r = i.slice(0);
      for (let s = 0, o = r.length; s < o; s++) r[s].call(this, e);
      e.target = null;
    }
  }
}
const ti = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let cC = 1234567;
const Qa = Math.PI / 180,
  Vu = 180 / Math.PI;
function ji() {
  const n = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    i = (Math.random() * 4294967295) | 0;
  return (
    ti[n & 255] +
    ti[(n >> 8) & 255] +
    ti[(n >> 16) & 255] +
    ti[(n >> 24) & 255] +
    "-" +
    ti[e & 255] +
    ti[(e >> 8) & 255] +
    "-" +
    ti[((e >> 16) & 15) | 64] +
    ti[(e >> 24) & 255] +
    "-" +
    ti[(t & 63) | 128] +
    ti[(t >> 8) & 255] +
    "-" +
    ti[(t >> 16) & 255] +
    ti[(t >> 24) & 255] +
    ti[i & 255] +
    ti[(i >> 8) & 255] +
    ti[(i >> 16) & 255] +
    ti[(i >> 24) & 255]
  ).toLowerCase();
}
function pn(n, e, t) {
  return Math.max(e, Math.min(t, n));
}
function q1(n, e) {
  return ((n % e) + e) % e;
}
function gO(n, e, t, i, r) {
  return i + ((n - e) * (r - i)) / (t - e);
}
function yO(n, e, t) {
  return n !== e ? (t - n) / (e - n) : 0;
}
function Af(n, e, t) {
  return (1 - t) * n + t * e;
}
function vO(n, e, t, i) {
  return Af(n, e, 1 - Math.exp(-t * i));
}
function xO(n, e = 1) {
  return e - Math.abs(q1(n, e * 2) - e);
}
function _O(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * (3 - 2 * n));
}
function AO(n, e, t) {
  return n <= e
    ? 0
    : n >= t
    ? 1
    : ((n = (n - e) / (t - e)), n * n * n * (n * (n * 6 - 15) + 10));
}
function MO(n, e) {
  return n + Math.floor(Math.random() * (e - n + 1));
}
function SO(n, e) {
  return n + Math.random() * (e - n);
}
function wO(n) {
  return n * (0.5 - Math.random());
}
function CO(n) {
  n !== void 0 && (cC = n);
  let e = (cC += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function EO(n) {
  return n * Qa;
}
function TO(n) {
  return n * Vu;
}
function d_(n) {
  return (n & (n - 1)) === 0 && n !== 0;
}
function HB(n) {
  return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2));
}
function VB(n) {
  return Math.pow(2, Math.floor(Math.log(n) / Math.LN2));
}
function bO(n, e, t, i, r) {
  const s = Math.cos,
    o = Math.sin,
    a = s(t / 2),
    l = o(t / 2),
    c = s((e + i) / 2),
    h = o((e + i) / 2),
    d = s((e - i) / 2),
    p = o((e - i) / 2),
    m = s((i - e) / 2),
    v = o((i - e) / 2);
  switch (r) {
    case "XYX":
      n.set(a * h, l * d, l * p, a * c);
      break;
    case "YZY":
      n.set(l * p, a * h, l * d, a * c);
      break;
    case "ZXZ":
      n.set(l * d, l * p, a * h, a * c);
      break;
    case "XZX":
      n.set(a * h, l * v, l * m, a * c);
      break;
    case "YXY":
      n.set(l * m, a * h, l * v, a * c);
      break;
    case "ZYZ":
      n.set(l * v, l * m, a * h, a * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          r
      );
  }
}
function Vi(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return n / 65535;
    case Uint8Array:
      return n / 255;
    case Int16Array:
      return Math.max(n / 32767, -1);
    case Int8Array:
      return Math.max(n / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function gt(n, e) {
  switch (e.constructor) {
    case Float32Array:
      return n;
    case Uint16Array:
      return Math.round(n * 65535);
    case Uint8Array:
      return Math.round(n * 255);
    case Int16Array:
      return Math.round(n * 32767);
    case Int8Array:
      return Math.round(n * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const $1 = {
  DEG2RAD: Qa,
  RAD2DEG: Vu,
  generateUUID: ji,
  clamp: pn,
  euclideanModulo: q1,
  mapLinear: gO,
  inverseLerp: yO,
  lerp: Af,
  damp: vO,
  pingpong: xO,
  smoothstep: _O,
  smootherstep: AO,
  randInt: MO,
  randFloat: SO,
  randFloatSpread: wO,
  seededRandom: CO,
  degToRad: EO,
  radToDeg: TO,
  isPowerOfTwo: d_,
  ceilPowerOfTwo: HB,
  floorPowerOfTwo: VB,
  setQuaternionFromProperEuler: bO,
  normalize: gt,
  denormalize: Vi,
};
class ge {
  constructor(e = 0, t = 0) {
    (ge.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = e.elements;
    return (
      (this.x = r[0] * t + r[3] * i + r[6]),
      (this.y = r[1] * t + r[4] * i + r[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(pn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = this.x - e.x,
      o = this.y - e.y;
    return (this.x = s * i - o * r + e.x), (this.y = s * r + o * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class wt {
  constructor() {
    (wt.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
  }
  set(e, t, i, r, s, o, a, l, c) {
    const h = this.elements;
    return (
      (h[0] = e),
      (h[1] = r),
      (h[2] = a),
      (h[3] = t),
      (h[4] = s),
      (h[5] = l),
      (h[6] = i),
      (h[7] = o),
      (h[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      i.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[3],
      l = i[6],
      c = i[1],
      h = i[4],
      d = i[7],
      p = i[2],
      m = i[5],
      v = i[8],
      A = r[0],
      x = r[3],
      g = r[6],
      _ = r[1],
      S = r[4],
      w = r[7],
      E = r[2],
      P = r[5],
      L = r[8];
    return (
      (s[0] = o * A + a * _ + l * E),
      (s[3] = o * x + a * S + l * P),
      (s[6] = o * g + a * w + l * L),
      (s[1] = c * A + h * _ + d * E),
      (s[4] = c * x + h * S + d * P),
      (s[7] = c * g + h * w + d * L),
      (s[2] = p * A + m * _ + v * E),
      (s[5] = p * x + m * S + v * P),
      (s[8] = p * g + m * w + v * L),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      h = e[8];
    return (
      t * o * h - t * a * c - i * s * h + i * a * l + r * s * c - r * o * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      h = e[8],
      d = h * o - a * c,
      p = a * l - h * s,
      m = c * s - o * l,
      v = t * d + i * p + r * m;
    if (v === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const A = 1 / v;
    return (
      (e[0] = d * A),
      (e[1] = (r * c - h * i) * A),
      (e[2] = (a * i - r * o) * A),
      (e[3] = p * A),
      (e[4] = (h * t - r * l) * A),
      (e[5] = (r * s - a * t) * A),
      (e[6] = m * A),
      (e[7] = (i * l - c * t) * A),
      (e[8] = (o * t - i * s) * A),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, i, r, s, o, a) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        i * l,
        i * c,
        -i * (l * o + c * a) + o + e,
        -r * c,
        r * l,
        -r * (-c * o + l * a) + a + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(ky.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(ky.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(ky.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 9; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const ky = new wt();
function WB(n) {
  for (let e = n.length - 1; e >= 0; --e) if (n[e] >= 65535) return !0;
  return !1;
}
const PO = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
};
function mu(n, e) {
  return new PO[n](e);
}
function eh(n) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", n);
}
function Pu(n) {
  return n < 0.04045
    ? n * 0.0773993808
    : Math.pow(n * 0.9478672986 + 0.0521327014, 2.4);
}
function Uy(n) {
  return n < 0.0031308 ? n * 12.92 : 1.055 * Math.pow(n, 0.41666) - 0.055;
}
const BO = new wt().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  RO = new wt().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ]);
function LO(n) {
  return n.convertSRGBToLinear().applyMatrix3(RO);
}
function IO(n) {
  return n.applyMatrix3(BO).convertLinearToSRGB();
}
const DO = { [Hu]: (n) => n, [Lr]: (n) => n.convertSRGBToLinear(), [Z1]: LO },
  FO = { [Hu]: (n) => n, [Lr]: (n) => n.convertLinearToSRGB(), [Z1]: IO },
  Si = {
    enabled: !1,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(n) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !n);
    },
    get workingColorSpace() {
      return Hu;
    },
    set workingColorSpace(n) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (n, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return n;
      const i = DO[e],
        r = FO[t];
      if (i === void 0 || r === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${t}".`
        );
      return r(i(n));
    },
    fromWorkingColorSpace: function (n, e) {
      return this.convert(n, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (n, e) {
      return this.convert(n, e, this.workingColorSpace);
    },
  };
let Ll;
class eA {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      Ll === void 0 && (Ll = eh("canvas")),
        (Ll.width = e.width),
        (Ll.height = e.height);
      const i = Ll.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = Ll);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = eh("canvas");
      (t.width = e.width), (t.height = e.height);
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const r = i.getImageData(0, 0, e.width, e.height),
        s = r.data;
      for (let o = 0; o < s.length; o++) s[o] = Pu(s[o] / 255) * 255;
      return i.putImageData(r, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let i = 0; i < t.length; i++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[i] = Math.floor(Pu(t[i] / 255) * 255))
          : (t[i] = Pu(t[i]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
class Ha {
  constructor(e = null) {
    (this.isSource = !0),
      (this.uuid = ji()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const i = { uuid: this.uuid, url: "" },
      r = this.data;
    if (r !== null) {
      let s;
      if (Array.isArray(r)) {
        s = [];
        for (let o = 0, a = r.length; o < a; o++)
          r[o].isDataTexture ? s.push(zy(r[o].image)) : s.push(zy(r[o]));
      } else s = zy(r);
      i.url = s;
    }
    return t || (e.images[this.uuid] = i), i;
  }
}
function zy(n) {
  return (typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && n instanceof ImageBitmap)
    ? eA.getDataURL(n)
    : n.data
    ? {
        data: Array.from(n.data),
        width: n.width,
        height: n.height,
        type: n.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let NO = 0;
class en extends ds {
  constructor(
    e = en.DEFAULT_IMAGE,
    t = en.DEFAULT_MAPPING,
    i = Wn,
    r = Wn,
    s = rn,
    o = fs,
    a = Ti,
    l = Xs,
    c = en.DEFAULT_ANISOTROPY,
    h = Ks
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: NO++ }),
      (this.uuid = ji()),
      (this.name = ""),
      (this.source = new Ha(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = i),
      (this.wrapT = r),
      (this.magFilter = s),
      (this.minFilter = o),
      (this.anisotropy = c),
      (this.format = a),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new ge(0, 0)),
      (this.repeat = new ge(1, 1)),
      (this.center = new ge(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new wt()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = h),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.encoding = e.encoding),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const i = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      t || (e.textures[this.uuid] = i),
      i
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== Rg) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case jo:
          e.x = e.x - Math.floor(e.x);
          break;
        case Wn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Uu:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case jo:
          e.y = e.y - Math.floor(e.y);
          break;
        case Wn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Uu:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
}
en.DEFAULT_IMAGE = null;
en.DEFAULT_MAPPING = Rg;
en.DEFAULT_ANISOTROPY = 1;
class Ot {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (Ot.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      (this.w = r);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, i, r) {
    return (this.x = e), (this.y = t), (this.z = i), (this.w = r), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = this.w,
      o = e.elements;
    return (
      (this.x = o[0] * t + o[4] * i + o[8] * r + o[12] * s),
      (this.y = o[1] * t + o[5] * i + o[9] * r + o[13] * s),
      (this.z = o[2] * t + o[6] * i + o[10] * r + o[14] * s),
      (this.w = o[3] * t + o[7] * i + o[11] * r + o[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, i, r, s;
    const l = e.elements,
      c = l[0],
      h = l[4],
      d = l[8],
      p = l[1],
      m = l[5],
      v = l[9],
      A = l[2],
      x = l[6],
      g = l[10];
    if (
      Math.abs(h - p) < 0.01 &&
      Math.abs(d - A) < 0.01 &&
      Math.abs(v - x) < 0.01
    ) {
      if (
        Math.abs(h + p) < 0.1 &&
        Math.abs(d + A) < 0.1 &&
        Math.abs(v + x) < 0.1 &&
        Math.abs(c + m + g - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const S = (c + 1) / 2,
        w = (m + 1) / 2,
        E = (g + 1) / 2,
        P = (h + p) / 4,
        L = (d + A) / 4,
        B = (v + x) / 4;
      return (
        S > w && S > E
          ? S < 0.01
            ? ((i = 0), (r = 0.707106781), (s = 0.707106781))
            : ((i = Math.sqrt(S)), (r = P / i), (s = L / i))
          : w > E
          ? w < 0.01
            ? ((i = 0.707106781), (r = 0), (s = 0.707106781))
            : ((r = Math.sqrt(w)), (i = P / r), (s = B / r))
          : E < 0.01
          ? ((i = 0.707106781), (r = 0.707106781), (s = 0))
          : ((s = Math.sqrt(E)), (i = L / s), (r = B / s)),
        this.set(i, r, s, t),
        this
      );
    }
    let _ = Math.sqrt(
      (x - v) * (x - v) + (d - A) * (d - A) + (p - h) * (p - h)
    );
    return (
      Math.abs(_) < 0.001 && (_ = 1),
      (this.x = (x - v) / _),
      (this.y = (d - A) / _),
      (this.z = (p - h) / _),
      (this.w = Math.acos((c + m + g - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      (this.w = e.w + (t.w - e.w) * i),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class Gr extends ds {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Ot(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Ot(0, 0, e, t));
    const r = { width: e, height: t, depth: 1 };
    (this.texture = new en(
      r,
      i.mapping,
      i.wrapS,
      i.wrapT,
      i.magFilter,
      i.minFilter,
      i.format,
      i.type,
      i.anisotropy,
      i.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        i.generateMipmaps !== void 0 ? i.generateMipmaps : !1),
      (this.texture.internalFormat =
        i.internalFormat !== void 0 ? i.internalFormat : null),
      (this.texture.minFilter = i.minFilter !== void 0 ? i.minFilter : rn),
      (this.depthBuffer = i.depthBuffer !== void 0 ? i.depthBuffer : !0),
      (this.stencilBuffer = i.stencilBuffer !== void 0 ? i.stencilBuffer : !1),
      (this.depthTexture = i.depthTexture !== void 0 ? i.depthTexture : null),
      (this.samples = i.samples !== void 0 ? i.samples : 0);
  }
  setSize(e, t, i = 1) {
    (this.width !== e || this.height !== t || this.depth !== i) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Ha(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class Dg extends en {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = dn),
      (this.minFilter = dn),
      (this.wrapR = Wn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class OO extends Gr {
  constructor(e = 1, t = 1, i = 1) {
    super(e, t),
      (this.isWebGLArrayRenderTarget = !0),
      (this.depth = i),
      (this.texture = new Dg(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class tA extends en {
  constructor(e = null, t = 1, i = 1, r = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: r }),
      (this.magFilter = dn),
      (this.minFilter = dn),
      (this.wrapR = Wn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class kO extends Gr {
  constructor(e = 1, t = 1, i = 1) {
    super(e, t),
      (this.isWebGL3DRenderTarget = !0),
      (this.depth = i),
      (this.texture = new tA(null, e, t, i)),
      (this.texture.isRenderTargetTexture = !0);
  }
}
class UO extends Gr {
  constructor(e = 1, t = 1, i = 1, r = {}) {
    super(e, t, r), (this.isWebGLMultipleRenderTargets = !0);
    const s = this.texture;
    this.texture = [];
    for (let o = 0; o < i; o++)
      (this.texture[o] = s.clone()),
        (this.texture[o].isRenderTargetTexture = !0);
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      (this.width = e), (this.height = t), (this.depth = i);
      for (let r = 0, s = this.texture.length; r < s; r++)
        (this.texture[r].image.width = e),
          (this.texture[r].image.height = t),
          (this.texture[r].image.depth = i);
      this.dispose();
    }
    return this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t), this;
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.viewport.set(0, 0, this.width, this.height),
      this.scissor.set(0, 0, this.width, this.height),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0);
    for (let t = 0, i = e.texture.length; t < i; t++)
      (this.texture[t] = e.texture[t].clone()),
        (this.texture[t].isRenderTargetTexture = !0);
    return this;
  }
}
class jn {
  constructor(e = 0, t = 0, i = 0, r = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r);
  }
  static slerpFlat(e, t, i, r, s, o, a) {
    let l = i[r + 0],
      c = i[r + 1],
      h = i[r + 2],
      d = i[r + 3];
    const p = s[o + 0],
      m = s[o + 1],
      v = s[o + 2],
      A = s[o + 3];
    if (a === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = d);
      return;
    }
    if (a === 1) {
      (e[t + 0] = p), (e[t + 1] = m), (e[t + 2] = v), (e[t + 3] = A);
      return;
    }
    if (d !== A || l !== p || c !== m || h !== v) {
      let x = 1 - a;
      const g = l * p + c * m + h * v + d * A,
        _ = g >= 0 ? 1 : -1,
        S = 1 - g * g;
      if (S > Number.EPSILON) {
        const E = Math.sqrt(S),
          P = Math.atan2(E, g * _);
        (x = Math.sin(x * P) / E), (a = Math.sin(a * P) / E);
      }
      const w = a * _;
      if (
        ((l = l * x + p * w),
        (c = c * x + m * w),
        (h = h * x + v * w),
        (d = d * x + A * w),
        x === 1 - a)
      ) {
        const E = 1 / Math.sqrt(l * l + c * c + h * h + d * d);
        (l *= E), (c *= E), (h *= E), (d *= E);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = h), (e[t + 3] = d);
  }
  static multiplyQuaternionsFlat(e, t, i, r, s, o) {
    const a = i[r],
      l = i[r + 1],
      c = i[r + 2],
      h = i[r + 3],
      d = s[o],
      p = s[o + 1],
      m = s[o + 2],
      v = s[o + 3];
    return (
      (e[t] = a * v + h * d + l * m - c * p),
      (e[t + 1] = l * v + h * p + c * d - a * m),
      (e[t + 2] = c * v + h * m + a * p - l * d),
      (e[t + 3] = h * v - a * d - l * p - c * m),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, r) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._order,
      a = Math.cos,
      l = Math.sin,
      c = a(i / 2),
      h = a(r / 2),
      d = a(s / 2),
      p = l(i / 2),
      m = l(r / 2),
      v = l(s / 2);
    switch (o) {
      case "XYZ":
        (this._x = p * h * d + c * m * v),
          (this._y = c * m * d - p * h * v),
          (this._z = c * h * v + p * m * d),
          (this._w = c * h * d - p * m * v);
        break;
      case "YXZ":
        (this._x = p * h * d + c * m * v),
          (this._y = c * m * d - p * h * v),
          (this._z = c * h * v - p * m * d),
          (this._w = c * h * d + p * m * v);
        break;
      case "ZXY":
        (this._x = p * h * d - c * m * v),
          (this._y = c * m * d + p * h * v),
          (this._z = c * h * v + p * m * d),
          (this._w = c * h * d - p * m * v);
        break;
      case "ZYX":
        (this._x = p * h * d - c * m * v),
          (this._y = c * m * d + p * h * v),
          (this._z = c * h * v - p * m * d),
          (this._w = c * h * d + p * m * v);
        break;
      case "YZX":
        (this._x = p * h * d + c * m * v),
          (this._y = c * m * d + p * h * v),
          (this._z = c * h * v - p * m * d),
          (this._w = c * h * d - p * m * v);
        break;
      case "XZY":
        (this._x = p * h * d - c * m * v),
          (this._y = c * m * d - p * h * v),
          (this._z = c * h * v + p * m * d),
          (this._w = c * h * d + p * m * v);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      r = Math.sin(i);
    return (
      (this._x = e.x * r),
      (this._y = e.y * r),
      (this._z = e.z * r),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      r = t[4],
      s = t[8],
      o = t[1],
      a = t[5],
      l = t[9],
      c = t[2],
      h = t[6],
      d = t[10],
      p = i + a + d;
    if (p > 0) {
      const m = 0.5 / Math.sqrt(p + 1);
      (this._w = 0.25 / m),
        (this._x = (h - l) * m),
        (this._y = (s - c) * m),
        (this._z = (o - r) * m);
    } else if (i > a && i > d) {
      const m = 2 * Math.sqrt(1 + i - a - d);
      (this._w = (h - l) / m),
        (this._x = 0.25 * m),
        (this._y = (r + o) / m),
        (this._z = (s + c) / m);
    } else if (a > d) {
      const m = 2 * Math.sqrt(1 + a - i - d);
      (this._w = (s - c) / m),
        (this._x = (r + o) / m),
        (this._y = 0.25 * m),
        (this._z = (l + h) / m);
    } else {
      const m = 2 * Math.sqrt(1 + d - i - a);
      (this._w = (o - r) / m),
        (this._x = (s + c) / m),
        (this._y = (l + h) / m),
        (this._z = 0.25 * m);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(pn(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (i === 0) return this;
    const r = Math.min(1, t / i);
    return this.slerp(e, r), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      r = e._y,
      s = e._z,
      o = e._w,
      a = t._x,
      l = t._y,
      c = t._z,
      h = t._w;
    return (
      (this._x = i * h + o * a + r * c - s * l),
      (this._y = r * h + o * l + s * a - i * c),
      (this._z = s * h + o * c + i * l - r * a),
      (this._w = o * h - i * a - r * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const i = this._x,
      r = this._y,
      s = this._z,
      o = this._w;
    let a = o * e._w + i * e._x + r * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = o), (this._x = i), (this._y = r), (this._z = s), this;
    const l = 1 - a * a;
    if (l <= Number.EPSILON) {
      const m = 1 - t;
      return (
        (this._w = m * o + t * this._w),
        (this._x = m * i + t * this._x),
        (this._y = m * r + t * this._y),
        (this._z = m * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const c = Math.sqrt(l),
      h = Math.atan2(c, a),
      d = Math.sin((1 - t) * h) / c,
      p = Math.sin(t * h) / c;
    return (
      (this._w = o * d + this._w * p),
      (this._x = i * d + this._x * p),
      (this._y = r * d + this._y * p),
      (this._z = s * d + this._z * p),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      r = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(r),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(r)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class F {
  constructor(e = 0, t = 0, i = 0) {
    (F.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      i === void 0 && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(fC.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(fC.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * r),
      (this.y = s[1] * t + s[4] * i + s[7] * r),
      (this.z = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements,
      o = 1 / (s[3] * t + s[7] * i + s[11] * r + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * r + s[12]) * o),
      (this.y = (s[1] * t + s[5] * i + s[9] * r + s[13]) * o),
      (this.z = (s[2] * t + s[6] * i + s[10] * r + s[14]) * o),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.x,
      o = e.y,
      a = e.z,
      l = e.w,
      c = l * t + o * r - a * i,
      h = l * i + a * t - s * r,
      d = l * r + s * i - o * t,
      p = -s * t - o * i - a * r;
    return (
      (this.x = c * l + p * -s + h * -a - d * -o),
      (this.y = h * l + p * -o + d * -s - c * -a),
      (this.z = d * l + p * -a + c * -o - h * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      r = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * r),
      (this.y = s[1] * t + s[5] * i + s[9] * r),
      (this.z = s[2] * t + s[6] * i + s[10] * r),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = t.x,
      a = t.y,
      l = t.z;
    return (
      (this.x = r * l - s * a),
      (this.y = s * o - i * l),
      (this.z = i * a - r * o),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return Gy.copy(this).projectOnVector(e), this.sub(Gy);
  }
  reflect(e) {
    return this.sub(Gy.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(pn(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      r = this.z - e.z;
    return t * t + i * i + r * r;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const r = Math.sin(t) * e;
    return (
      (this.x = r * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = r * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      r = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = r), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2);
    return (
      (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Gy = new F(),
  fC = new jn();
class Hr {
  constructor(
    e = new F(1 / 0, 1 / 0, 1 / 0),
    t = new F(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(Ms.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(Ms.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = Ms.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        Il.copy(e.boundingBox),
        Il.applyMatrix4(e.matrixWorld),
        this.union(Il);
    else {
      const r = e.geometry;
      if (r !== void 0)
        if (t && r.attributes !== void 0 && r.attributes.position !== void 0) {
          const s = r.attributes.position;
          for (let o = 0, a = s.count; o < a; o++)
            Ms.fromBufferAttribute(s, o).applyMatrix4(e.matrixWorld),
              this.expandByPoint(Ms);
        } else
          r.boundingBox === null && r.computeBoundingBox(),
            Il.copy(r.boundingBox),
            Il.applyMatrix4(e.matrixWorld),
            this.union(Il);
    }
    const i = e.children;
    for (let r = 0, s = i.length; r < s; r++) this.expandByObject(i[r], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Ms),
      Ms.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(Oc),
      sp.subVectors(this.max, Oc),
      Dl.subVectors(e.a, Oc),
      Fl.subVectors(e.b, Oc),
      Nl.subVectors(e.c, Oc),
      co.subVectors(Fl, Dl),
      fo.subVectors(Nl, Fl),
      ma.subVectors(Dl, Nl);
    let t = [
      0,
      -co.z,
      co.y,
      0,
      -fo.z,
      fo.y,
      0,
      -ma.z,
      ma.y,
      co.z,
      0,
      -co.x,
      fo.z,
      0,
      -fo.x,
      ma.z,
      0,
      -ma.x,
      -co.y,
      co.x,
      0,
      -fo.y,
      fo.x,
      0,
      -ma.y,
      ma.x,
      0,
    ];
    return !Hy(t, Dl, Fl, Nl, sp) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !Hy(t, Dl, Fl, Nl, sp))
      ? !1
      : (op.crossVectors(co, fo),
        (t = [op.x, op.y, op.z]),
        Hy(t, Dl, Fl, Nl, sp));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Ms).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Ms).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (As[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        As[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        As[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        As[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        As[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        As[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        As[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        As[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(As),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const As = [
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
    new F(),
  ],
  Ms = new F(),
  Il = new Hr(),
  Dl = new F(),
  Fl = new F(),
  Nl = new F(),
  co = new F(),
  fo = new F(),
  ma = new F(),
  Oc = new F(),
  sp = new F(),
  op = new F(),
  ga = new F();
function Hy(n, e, t, i, r) {
  for (let s = 0, o = n.length - 3; s <= o; s += 3) {
    ga.fromArray(n, s);
    const a =
        r.x * Math.abs(ga.x) + r.y * Math.abs(ga.y) + r.z * Math.abs(ga.z),
      l = e.dot(ga),
      c = t.dot(ga),
      h = i.dot(ga);
    if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a) return !1;
  }
  return !0;
}
const zO = new Hr(),
  kc = new F(),
  Vy = new F();
class Vr {
  constructor(e = new F(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    t !== void 0 ? i.copy(t) : zO.setFromPoints(e).getCenter(i);
    let r = 0;
    for (let s = 0, o = e.length; s < o; s++)
      r = Math.max(r, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(r)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    kc.subVectors(e, this.center);
    const t = kc.lengthSq();
    if (t > this.radius * this.radius) {
      const i = Math.sqrt(t),
        r = (i - this.radius) * 0.5;
      this.center.addScaledVector(kc, r / i), (this.radius += r);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (Vy.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(kc.copy(e.center).add(Vy)),
            this.expandByPoint(kc.copy(e.center).sub(Vy))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ss = new F(),
  Wy = new F(),
  ap = new F(),
  ho = new F(),
  Jy = new F(),
  lp = new F(),
  jy = new F();
class Ah {
  constructor(e = new F(), t = new F(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ss)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Ss.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Ss.copy(this.origin).addScaledVector(this.direction, t),
        Ss.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, r) {
    Wy.copy(e).add(t).multiplyScalar(0.5),
      ap.copy(t).sub(e).normalize(),
      ho.copy(this.origin).sub(Wy);
    const s = e.distanceTo(t) * 0.5,
      o = -this.direction.dot(ap),
      a = ho.dot(this.direction),
      l = -ho.dot(ap),
      c = ho.lengthSq(),
      h = Math.abs(1 - o * o);
    let d, p, m, v;
    if (h > 0)
      if (((d = o * l - a), (p = o * a - l), (v = s * h), d >= 0))
        if (p >= -v)
          if (p <= v) {
            const A = 1 / h;
            (d *= A),
              (p *= A),
              (m = d * (d + o * p + 2 * a) + p * (o * d + p + 2 * l) + c);
          } else
            (p = s),
              (d = Math.max(0, -(o * p + a))),
              (m = -d * d + p * (p + 2 * l) + c);
        else
          (p = -s),
            (d = Math.max(0, -(o * p + a))),
            (m = -d * d + p * (p + 2 * l) + c);
      else
        p <= -v
          ? ((d = Math.max(0, -(-o * s + a))),
            (p = d > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + p * (p + 2 * l) + c))
          : p <= v
          ? ((d = 0),
            (p = Math.min(Math.max(-s, -l), s)),
            (m = p * (p + 2 * l) + c))
          : ((d = Math.max(0, -(o * s + a))),
            (p = d > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (m = -d * d + p * (p + 2 * l) + c));
    else
      (p = o > 0 ? -s : s),
        (d = Math.max(0, -(o * p + a))),
        (m = -d * d + p * (p + 2 * l) + c);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, d),
      r && r.copy(Wy).addScaledVector(ap, p),
      m
    );
  }
  intersectSphere(e, t) {
    Ss.subVectors(e.center, this.origin);
    const i = Ss.dot(this.direction),
      r = Ss.dot(Ss) - i * i,
      s = e.radius * e.radius;
    if (r > s) return null;
    const o = Math.sqrt(s - r),
      a = i - o,
      l = i + o;
    return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return i === null ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, r, s, o, a, l;
    const c = 1 / this.direction.x,
      h = 1 / this.direction.y,
      d = 1 / this.direction.z,
      p = this.origin;
    return (
      c >= 0
        ? ((i = (e.min.x - p.x) * c), (r = (e.max.x - p.x) * c))
        : ((i = (e.max.x - p.x) * c), (r = (e.min.x - p.x) * c)),
      h >= 0
        ? ((s = (e.min.y - p.y) * h), (o = (e.max.y - p.y) * h))
        : ((s = (e.max.y - p.y) * h), (o = (e.min.y - p.y) * h)),
      i > o ||
      s > r ||
      ((s > i || isNaN(i)) && (i = s),
      (o < r || isNaN(r)) && (r = o),
      d >= 0
        ? ((a = (e.min.z - p.z) * d), (l = (e.max.z - p.z) * d))
        : ((a = (e.max.z - p.z) * d), (l = (e.min.z - p.z) * d)),
      i > l || a > r) ||
      ((a > i || i !== i) && (i = a), (l < r || r !== r) && (r = l), r < 0)
        ? null
        : this.at(i >= 0 ? i : r, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Ss) !== null;
  }
  intersectTriangle(e, t, i, r, s) {
    Jy.subVectors(t, e), lp.subVectors(i, e), jy.crossVectors(Jy, lp);
    let o = this.direction.dot(jy),
      a;
    if (o > 0) {
      if (r) return null;
      a = 1;
    } else if (o < 0) (a = -1), (o = -o);
    else return null;
    ho.subVectors(this.origin, e);
    const l = a * this.direction.dot(lp.crossVectors(ho, lp));
    if (l < 0) return null;
    const c = a * this.direction.dot(Jy.cross(ho));
    if (c < 0 || l + c > o) return null;
    const h = -a * ho.dot(jy);
    return h < 0 ? null : this.at(h / o, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class st {
  constructor() {
    (st.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  set(e, t, i, r, s, o, a, l, c, h, d, p, m, v, A, x) {
    const g = this.elements;
    return (
      (g[0] = e),
      (g[4] = t),
      (g[8] = i),
      (g[12] = r),
      (g[1] = s),
      (g[5] = o),
      (g[9] = a),
      (g[13] = l),
      (g[2] = c),
      (g[6] = h),
      (g[10] = d),
      (g[14] = p),
      (g[3] = m),
      (g[7] = v),
      (g[11] = A),
      (g[15] = x),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new st().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      r = 1 / Ol.setFromMatrixColumn(e, 0).length(),
      s = 1 / Ol.setFromMatrixColumn(e, 1).length(),
      o = 1 / Ol.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * r),
      (t[1] = i[1] * r),
      (t[2] = i[2] * r),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * o),
      (t[9] = i[9] * o),
      (t[10] = i[10] * o),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z,
      o = Math.cos(i),
      a = Math.sin(i),
      l = Math.cos(r),
      c = Math.sin(r),
      h = Math.cos(s),
      d = Math.sin(s);
    if (e.order === "XYZ") {
      const p = o * h,
        m = o * d,
        v = a * h,
        A = a * d;
      (t[0] = l * h),
        (t[4] = -l * d),
        (t[8] = c),
        (t[1] = m + v * c),
        (t[5] = p - A * c),
        (t[9] = -a * l),
        (t[2] = A - p * c),
        (t[6] = v + m * c),
        (t[10] = o * l);
    } else if (e.order === "YXZ") {
      const p = l * h,
        m = l * d,
        v = c * h,
        A = c * d;
      (t[0] = p + A * a),
        (t[4] = v * a - m),
        (t[8] = o * c),
        (t[1] = o * d),
        (t[5] = o * h),
        (t[9] = -a),
        (t[2] = m * a - v),
        (t[6] = A + p * a),
        (t[10] = o * l);
    } else if (e.order === "ZXY") {
      const p = l * h,
        m = l * d,
        v = c * h,
        A = c * d;
      (t[0] = p - A * a),
        (t[4] = -o * d),
        (t[8] = v + m * a),
        (t[1] = m + v * a),
        (t[5] = o * h),
        (t[9] = A - p * a),
        (t[2] = -o * c),
        (t[6] = a),
        (t[10] = o * l);
    } else if (e.order === "ZYX") {
      const p = o * h,
        m = o * d,
        v = a * h,
        A = a * d;
      (t[0] = l * h),
        (t[4] = v * c - m),
        (t[8] = p * c + A),
        (t[1] = l * d),
        (t[5] = A * c + p),
        (t[9] = m * c - v),
        (t[2] = -c),
        (t[6] = a * l),
        (t[10] = o * l);
    } else if (e.order === "YZX") {
      const p = o * l,
        m = o * c,
        v = a * l,
        A = a * c;
      (t[0] = l * h),
        (t[4] = A - p * d),
        (t[8] = v * d + m),
        (t[1] = d),
        (t[5] = o * h),
        (t[9] = -a * h),
        (t[2] = -c * h),
        (t[6] = m * d + v),
        (t[10] = p - A * d);
    } else if (e.order === "XZY") {
      const p = o * l,
        m = o * c,
        v = a * l,
        A = a * c;
      (t[0] = l * h),
        (t[4] = -d),
        (t[8] = c * h),
        (t[1] = p * d + A),
        (t[5] = o * h),
        (t[9] = m * d - v),
        (t[2] = v * d - m),
        (t[6] = a * h),
        (t[10] = A * d + p);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(GO, e, HO);
  }
  lookAt(e, t, i) {
    const r = this.elements;
    return (
      ki.subVectors(e, t),
      ki.lengthSq() === 0 && (ki.z = 1),
      ki.normalize(),
      po.crossVectors(i, ki),
      po.lengthSq() === 0 &&
        (Math.abs(i.z) === 1 ? (ki.x += 1e-4) : (ki.z += 1e-4),
        ki.normalize(),
        po.crossVectors(i, ki)),
      po.normalize(),
      up.crossVectors(ki, po),
      (r[0] = po.x),
      (r[4] = up.x),
      (r[8] = ki.x),
      (r[1] = po.y),
      (r[5] = up.y),
      (r[9] = ki.y),
      (r[2] = po.z),
      (r[6] = up.z),
      (r[10] = ki.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      r = t.elements,
      s = this.elements,
      o = i[0],
      a = i[4],
      l = i[8],
      c = i[12],
      h = i[1],
      d = i[5],
      p = i[9],
      m = i[13],
      v = i[2],
      A = i[6],
      x = i[10],
      g = i[14],
      _ = i[3],
      S = i[7],
      w = i[11],
      E = i[15],
      P = r[0],
      L = r[4],
      B = r[8],
      b = r[12],
      R = r[1],
      U = r[5],
      j = r[9],
      V = r[13],
      J = r[2],
      X = r[6],
      oe = r[10],
      ae = r[14],
      I = r[3],
      G = r[7],
      z = r[11],
      q = r[15];
    return (
      (s[0] = o * P + a * R + l * J + c * I),
      (s[4] = o * L + a * U + l * X + c * G),
      (s[8] = o * B + a * j + l * oe + c * z),
      (s[12] = o * b + a * V + l * ae + c * q),
      (s[1] = h * P + d * R + p * J + m * I),
      (s[5] = h * L + d * U + p * X + m * G),
      (s[9] = h * B + d * j + p * oe + m * z),
      (s[13] = h * b + d * V + p * ae + m * q),
      (s[2] = v * P + A * R + x * J + g * I),
      (s[6] = v * L + A * U + x * X + g * G),
      (s[10] = v * B + A * j + x * oe + g * z),
      (s[14] = v * b + A * V + x * ae + g * q),
      (s[3] = _ * P + S * R + w * J + E * I),
      (s[7] = _ * L + S * U + w * X + E * G),
      (s[11] = _ * B + S * j + w * oe + E * z),
      (s[15] = _ * b + S * V + w * ae + E * q),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      r = e[8],
      s = e[12],
      o = e[1],
      a = e[5],
      l = e[9],
      c = e[13],
      h = e[2],
      d = e[6],
      p = e[10],
      m = e[14],
      v = e[3],
      A = e[7],
      x = e[11],
      g = e[15];
    return (
      v *
        (+s * l * d -
          r * c * d -
          s * a * p +
          i * c * p +
          r * a * m -
          i * l * m) +
      A *
        (+t * l * m -
          t * c * p +
          s * o * p -
          r * o * m +
          r * c * h -
          s * l * h) +
      x *
        (+t * c * d -
          t * a * m -
          s * o * d +
          i * o * m +
          s * a * h -
          i * c * h) +
      g *
        (-r * a * h - t * l * d + t * a * p + r * o * d - i * o * p + i * l * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const r = this.elements;
    return (
      e.isVector3
        ? ((r[12] = e.x), (r[13] = e.y), (r[14] = e.z))
        : ((r[12] = e), (r[13] = t), (r[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      r = e[2],
      s = e[3],
      o = e[4],
      a = e[5],
      l = e[6],
      c = e[7],
      h = e[8],
      d = e[9],
      p = e[10],
      m = e[11],
      v = e[12],
      A = e[13],
      x = e[14],
      g = e[15],
      _ = d * x * c - A * p * c + A * l * m - a * x * m - d * l * g + a * p * g,
      S = v * p * c - h * x * c - v * l * m + o * x * m + h * l * g - o * p * g,
      w = h * A * c - v * d * c + v * a * m - o * A * m - h * a * g + o * d * g,
      E = v * d * l - h * A * l - v * a * p + o * A * p + h * a * x - o * d * x,
      P = t * _ + i * S + r * w + s * E;
    if (P === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const L = 1 / P;
    return (
      (e[0] = _ * L),
      (e[1] =
        (A * p * s -
          d * x * s -
          A * r * m +
          i * x * m +
          d * r * g -
          i * p * g) *
        L),
      (e[2] =
        (a * x * s -
          A * l * s +
          A * r * c -
          i * x * c -
          a * r * g +
          i * l * g) *
        L),
      (e[3] =
        (d * l * s -
          a * p * s -
          d * r * c +
          i * p * c +
          a * r * m -
          i * l * m) *
        L),
      (e[4] = S * L),
      (e[5] =
        (h * x * s -
          v * p * s +
          v * r * m -
          t * x * m -
          h * r * g +
          t * p * g) *
        L),
      (e[6] =
        (v * l * s -
          o * x * s -
          v * r * c +
          t * x * c +
          o * r * g -
          t * l * g) *
        L),
      (e[7] =
        (o * p * s -
          h * l * s +
          h * r * c -
          t * p * c -
          o * r * m +
          t * l * m) *
        L),
      (e[8] = w * L),
      (e[9] =
        (v * d * s -
          h * A * s -
          v * i * m +
          t * A * m +
          h * i * g -
          t * d * g) *
        L),
      (e[10] =
        (o * A * s -
          v * a * s +
          v * i * c -
          t * A * c -
          o * i * g +
          t * a * g) *
        L),
      (e[11] =
        (h * a * s -
          o * d * s -
          h * i * c +
          t * d * c +
          o * i * m -
          t * a * m) *
        L),
      (e[12] = E * L),
      (e[13] =
        (h * A * r -
          v * d * r +
          v * i * p -
          t * A * p -
          h * i * x +
          t * d * x) *
        L),
      (e[14] =
        (v * a * r -
          o * A * r -
          v * i * l +
          t * A * l +
          o * i * x -
          t * a * x) *
        L),
      (e[15] =
        (o * d * r -
          h * a * r +
          h * i * l -
          t * d * l -
          o * i * p +
          t * a * p) *
        L),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      r = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= r),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= r),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= r),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= r),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      r = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, r));
  }
  makeTranslation(e, t, i) {
    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      r = Math.sin(t),
      s = 1 - i,
      o = e.x,
      a = e.y,
      l = e.z,
      c = s * o,
      h = s * a;
    return (
      this.set(
        c * o + i,
        c * a - r * l,
        c * l + r * a,
        0,
        c * a + r * l,
        h * a + i,
        h * l - r * o,
        0,
        c * l - r * a,
        h * l + r * o,
        s * l * l + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, r, s, o) {
    return this.set(1, i, s, 0, e, 1, o, 0, t, r, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const r = this.elements,
      s = t._x,
      o = t._y,
      a = t._z,
      l = t._w,
      c = s + s,
      h = o + o,
      d = a + a,
      p = s * c,
      m = s * h,
      v = s * d,
      A = o * h,
      x = o * d,
      g = a * d,
      _ = l * c,
      S = l * h,
      w = l * d,
      E = i.x,
      P = i.y,
      L = i.z;
    return (
      (r[0] = (1 - (A + g)) * E),
      (r[1] = (m + w) * E),
      (r[2] = (v - S) * E),
      (r[3] = 0),
      (r[4] = (m - w) * P),
      (r[5] = (1 - (p + g)) * P),
      (r[6] = (x + _) * P),
      (r[7] = 0),
      (r[8] = (v + S) * L),
      (r[9] = (x - _) * L),
      (r[10] = (1 - (p + A)) * L),
      (r[11] = 0),
      (r[12] = e.x),
      (r[13] = e.y),
      (r[14] = e.z),
      (r[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const r = this.elements;
    let s = Ol.set(r[0], r[1], r[2]).length();
    const o = Ol.set(r[4], r[5], r[6]).length(),
      a = Ol.set(r[8], r[9], r[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = r[12]),
      (e.y = r[13]),
      (e.z = r[14]),
      Tr.copy(this);
    const c = 1 / s,
      h = 1 / o,
      d = 1 / a;
    return (
      (Tr.elements[0] *= c),
      (Tr.elements[1] *= c),
      (Tr.elements[2] *= c),
      (Tr.elements[4] *= h),
      (Tr.elements[5] *= h),
      (Tr.elements[6] *= h),
      (Tr.elements[8] *= d),
      (Tr.elements[9] *= d),
      (Tr.elements[10] *= d),
      t.setFromRotationMatrix(Tr),
      (i.x = s),
      (i.y = o),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, r, s, o) {
    const a = this.elements,
      l = (2 * s) / (t - e),
      c = (2 * s) / (i - r),
      h = (t + e) / (t - e),
      d = (i + r) / (i - r),
      p = -(o + s) / (o - s),
      m = (-2 * o * s) / (o - s);
    return (
      (a[0] = l),
      (a[4] = 0),
      (a[8] = h),
      (a[12] = 0),
      (a[1] = 0),
      (a[5] = c),
      (a[9] = d),
      (a[13] = 0),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = p),
      (a[14] = m),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = -1),
      (a[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, r, s, o) {
    const a = this.elements,
      l = 1 / (t - e),
      c = 1 / (i - r),
      h = 1 / (o - s),
      d = (t + e) * l,
      p = (i + r) * c,
      m = (o + s) * h;
    return (
      (a[0] = 2 * l),
      (a[4] = 0),
      (a[8] = 0),
      (a[12] = -d),
      (a[1] = 0),
      (a[5] = 2 * c),
      (a[9] = 0),
      (a[13] = -p),
      (a[2] = 0),
      (a[6] = 0),
      (a[10] = -2 * h),
      (a[14] = -m),
      (a[3] = 0),
      (a[7] = 0),
      (a[11] = 0),
      (a[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let r = 0; r < 16; r++) if (t[r] !== i[r]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const Ol = new F(),
  Tr = new st(),
  GO = new F(0, 0, 0),
  HO = new F(1, 1, 1),
  po = new F(),
  up = new F(),
  ki = new F(),
  hC = new st(),
  dC = new jn();
class fl {
  constructor(e = 0, t = 0, i = 0, r = fl.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, r = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = r),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const r = e.elements,
      s = r[0],
      o = r[4],
      a = r[8],
      l = r[1],
      c = r[5],
      h = r[9],
      d = r[2],
      p = r[6],
      m = r[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(pn(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, m)), (this._z = Math.atan2(-o, s)))
            : ((this._x = Math.atan2(p, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-pn(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, m)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-d, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(pn(p, -1, 1))),
          Math.abs(p) < 0.9999999
            ? ((this._y = Math.atan2(-d, m)), (this._z = Math.atan2(-o, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-pn(d, -1, 1))),
          Math.abs(d) < 0.9999999
            ? ((this._x = Math.atan2(p, m)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-o, c)));
        break;
      case "YZX":
        (this._z = Math.asin(pn(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-h, c)), (this._y = Math.atan2(-d, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, m)));
        break;
      case "XZY":
        (this._z = Math.asin(-pn(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(p, c)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-h, m)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), i === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      hC.makeRotationFromQuaternion(e), this.setFromRotationMatrix(hC, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return dC.setFromEuler(this), this.setFromQuaternion(dC, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
fl.DEFAULT_ORDER = "XYZ";
class Za {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let VO = 0;
const pC = new F(),
  kl = new jn(),
  ws = new st(),
  cp = new F(),
  Uc = new F(),
  WO = new F(),
  JO = new jn(),
  mC = new F(1, 0, 0),
  gC = new F(0, 1, 0),
  yC = new F(0, 0, 1),
  jO = { type: "added" },
  vC = { type: "removed" };
class Pt extends ds {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: VO++ }),
      (this.uuid = ji()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Pt.DEFAULT_UP.clone());
    const e = new F(),
      t = new fl(),
      i = new jn(),
      r = new F(1, 1, 1);
    function s() {
      i.setFromEuler(t, !1);
    }
    function o() {
      t.setFromQuaternion(i, void 0, !1);
    }
    t._onChange(s),
      i._onChange(o),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: r },
        modelViewMatrix: { value: new st() },
        normalMatrix: { value: new wt() },
      }),
      (this.matrix = new st()),
      (this.matrixWorld = new st()),
      (this.matrixAutoUpdate = Pt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Pt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new Za()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return kl.setFromAxisAngle(e, t), this.quaternion.multiply(kl), this;
  }
  rotateOnWorldAxis(e, t) {
    return kl.setFromAxisAngle(e, t), this.quaternion.premultiply(kl), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(mC, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(gC, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(yC, e);
  }
  translateOnAxis(e, t) {
    return (
      pC.copy(e).applyQuaternion(this.quaternion),
      this.position.add(pC.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(mC, e);
  }
  translateY(e) {
    return this.translateOnAxis(gC, e);
  }
  translateZ(e) {
    return this.translateOnAxis(yC, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(ws.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? cp.copy(e) : cp.set(e, t, i);
    const r = this.parent;
    this.updateWorldMatrix(!0, !1),
      Uc.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? ws.lookAt(Uc, cp, this.up)
        : ws.lookAt(cp, Uc, this.up),
      this.quaternion.setFromRotationMatrix(ws),
      r &&
        (ws.extractRotation(r.matrixWorld),
        kl.setFromRotationMatrix(ws),
        this.quaternion.premultiply(kl.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(jO))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(vC)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(vC);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      ws.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), ws.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(ws),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, r = this.children.length; i < r; i++) {
      const o = this.children[i].getObjectByProperty(e, t);
      if (o !== void 0) return o;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let r = 0, s = this.children.length; r < s; r++) {
      const o = this.children[r].getObjectsByProperty(e, t);
      o.length > 0 && (i = i.concat(o));
    }
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Uc, e, WO), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Uc, JO, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (e === !0 &&
        i !== null &&
        i.matrixWorldAutoUpdate === !0 &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const r = this.children;
      for (let s = 0, o = r.length; s < o; s++) {
        const a = r[s];
        a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const r = {};
    (r.uuid = this.uuid),
      (r.type = this.type),
      this.name !== "" && (r.name = this.name),
      this.castShadow === !0 && (r.castShadow = !0),
      this.receiveShadow === !0 && (r.receiveShadow = !0),
      this.visible === !1 && (r.visible = !1),
      this.frustumCulled === !1 && (r.frustumCulled = !1),
      this.renderOrder !== 0 && (r.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (r.userData = this.userData),
      (r.layers = this.layers.mask),
      (r.matrix = this.matrix.toArray()),
      (r.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((r.type = "InstancedMesh"),
        (r.count = this.count),
        (r.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (r.instanceColor = this.instanceColor.toJSON()));
    function s(a, l) {
      return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (r.background = this.background.toJSON())
          : this.background.isTexture &&
            (r.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (r.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      r.geometry = s(e.geometries, this.geometry);
      const a = this.geometry.parameters;
      if (a !== void 0 && a.shapes !== void 0) {
        const l = a.shapes;
        if (Array.isArray(l))
          for (let c = 0, h = l.length; c < h; c++) {
            const d = l[c];
            s(e.shapes, d);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((r.bindMode = this.bindMode),
        (r.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (r.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const a = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          a.push(s(e.materials, this.material[l]));
        r.material = a;
      } else r.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      r.children = [];
      for (let a = 0; a < this.children.length; a++)
        r.children.push(this.children[a].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      r.animations = [];
      for (let a = 0; a < this.animations.length; a++) {
        const l = this.animations[a];
        r.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const a = o(e.geometries),
        l = o(e.materials),
        c = o(e.textures),
        h = o(e.images),
        d = o(e.shapes),
        p = o(e.skeletons),
        m = o(e.animations),
        v = o(e.nodes);
      a.length > 0 && (i.geometries = a),
        l.length > 0 && (i.materials = l),
        c.length > 0 && (i.textures = c),
        h.length > 0 && (i.images = h),
        d.length > 0 && (i.shapes = d),
        p.length > 0 && (i.skeletons = p),
        m.length > 0 && (i.animations = m),
        v.length > 0 && (i.nodes = v);
    }
    return (i.object = r), i;
    function o(a) {
      const l = [];
      for (const c in a) {
        const h = a[c];
        delete h.metadata, l.push(h);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let i = 0; i < e.children.length; i++) {
        const r = e.children[i];
        this.add(r.clone());
      }
    return this;
  }
}
Pt.DEFAULT_UP = new F(0, 1, 0);
Pt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Pt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const br = new F(),
  Cs = new F(),
  Xy = new F(),
  Es = new F(),
  Ul = new F(),
  zl = new F(),
  xC = new F(),
  Ky = new F(),
  Yy = new F(),
  Qy = new F();
let fp = !1;
class Ei {
  constructor(e = new F(), t = new F(), i = new F()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, r) {
    r.subVectors(i, t), br.subVectors(e, t), r.cross(br);
    const s = r.lengthSq();
    return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, r, s) {
    br.subVectors(r, t), Cs.subVectors(i, t), Xy.subVectors(e, t);
    const o = br.dot(br),
      a = br.dot(Cs),
      l = br.dot(Xy),
      c = Cs.dot(Cs),
      h = Cs.dot(Xy),
      d = o * c - a * a;
    if (d === 0) return s.set(-2, -1, -1);
    const p = 1 / d,
      m = (c * l - a * h) * p,
      v = (o * h - a * l) * p;
    return s.set(1 - m - v, v, m);
  }
  static containsPoint(e, t, i, r) {
    return (
      this.getBarycoord(e, t, i, r, Es),
      Es.x >= 0 && Es.y >= 0 && Es.x + Es.y <= 1
    );
  }
  static getUV(e, t, i, r, s, o, a, l) {
    return (
      fp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (fp = !0)),
      this.getInterpolation(e, t, i, r, s, o, a, l)
    );
  }
  static getInterpolation(e, t, i, r, s, o, a, l) {
    return (
      this.getBarycoord(e, t, i, r, Es),
      l.setScalar(0),
      l.addScaledVector(s, Es.x),
      l.addScaledVector(o, Es.y),
      l.addScaledVector(a, Es.z),
      l
    );
  }
  static isFrontFacing(e, t, i, r) {
    return br.subVectors(i, t), Cs.subVectors(e, t), br.cross(Cs).dot(r) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, r) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[r]), this;
  }
  setFromAttributeAndIndices(e, t, i, r) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, r),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      br.subVectors(this.c, this.b),
      Cs.subVectors(this.a, this.b),
      br.cross(Cs).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ei.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Ei.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, r, s) {
    return (
      fp === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (fp = !0)),
      Ei.getInterpolation(e, this.a, this.b, this.c, t, i, r, s)
    );
  }
  getInterpolation(e, t, i, r, s) {
    return Ei.getInterpolation(e, this.a, this.b, this.c, t, i, r, s);
  }
  containsPoint(e) {
    return Ei.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ei.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      r = this.b,
      s = this.c;
    let o, a;
    Ul.subVectors(r, i), zl.subVectors(s, i), Ky.subVectors(e, i);
    const l = Ul.dot(Ky),
      c = zl.dot(Ky);
    if (l <= 0 && c <= 0) return t.copy(i);
    Yy.subVectors(e, r);
    const h = Ul.dot(Yy),
      d = zl.dot(Yy);
    if (h >= 0 && d <= h) return t.copy(r);
    const p = l * d - h * c;
    if (p <= 0 && l >= 0 && h <= 0)
      return (o = l / (l - h)), t.copy(i).addScaledVector(Ul, o);
    Qy.subVectors(e, s);
    const m = Ul.dot(Qy),
      v = zl.dot(Qy);
    if (v >= 0 && m <= v) return t.copy(s);
    const A = m * c - l * v;
    if (A <= 0 && c >= 0 && v <= 0)
      return (a = c / (c - v)), t.copy(i).addScaledVector(zl, a);
    const x = h * v - m * d;
    if (x <= 0 && d - h >= 0 && m - v >= 0)
      return (
        xC.subVectors(s, r),
        (a = (d - h) / (d - h + (m - v))),
        t.copy(r).addScaledVector(xC, a)
      );
    const g = 1 / (x + A + p);
    return (
      (o = A * g),
      (a = p * g),
      t.copy(i).addScaledVector(Ul, o).addScaledVector(zl, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let XO = 0;
class Cn extends ds {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: XO++ }),
      (this.uuid = ji()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Xa),
      (this.side = cs),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = J1),
      (this.blendDst = j1),
      (this.blendEquation = Ia),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = Xm),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = GB),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = xm),
      (this.stencilZFail = xm),
      (this.stencilZPass = xm),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const i = e[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const r = this[t];
        if (r === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        r && r.isColor
          ? r.set(i)
          : r && r.isVector3 && i && i.isVector3
          ? r.copy(i)
          : (this[t] = i);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const i = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.color && this.color.isColor && (i.color = this.color.getHex()),
      this.roughness !== void 0 && (i.roughness = this.roughness),
      this.metalness !== void 0 && (i.metalness = this.metalness),
      this.sheen !== void 0 && (i.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (i.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (i.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (i.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (i.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (i.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (i.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (i.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (i.shininess = this.shininess),
      this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (i.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (i.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (i.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (i.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (i.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (i.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (i.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (i.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((i.lightMap = this.lightMap.toJSON(e).uuid),
        (i.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((i.aoMap = this.aoMap.toJSON(e).uuid),
        (i.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((i.bumpMap = this.bumpMap.toJSON(e).uuid),
        (i.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((i.normalMap = this.normalMap.toJSON(e).uuid),
        (i.normalMapType = this.normalMapType),
        (i.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((i.displacementMap = this.displacementMap.toJSON(e).uuid),
        (i.displacementScale = this.displacementScale),
        (i.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (i.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (i.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (i.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (i.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (i.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((i.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (i.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (i.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (i.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (i.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (i.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (i.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (i.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (i.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (i.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (i.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (i.size = this.size),
      this.shadowSide !== null && (i.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (i.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Xa && (i.blending = this.blending),
      this.side !== cs && (i.side = this.side),
      this.vertexColors && (i.vertexColors = !0),
      this.opacity < 1 && (i.opacity = this.opacity),
      this.transparent === !0 && (i.transparent = this.transparent),
      (i.depthFunc = this.depthFunc),
      (i.depthTest = this.depthTest),
      (i.depthWrite = this.depthWrite),
      (i.colorWrite = this.colorWrite),
      (i.stencilWrite = this.stencilWrite),
      (i.stencilWriteMask = this.stencilWriteMask),
      (i.stencilFunc = this.stencilFunc),
      (i.stencilRef = this.stencilRef),
      (i.stencilFuncMask = this.stencilFuncMask),
      (i.stencilFail = this.stencilFail),
      (i.stencilZFail = this.stencilZFail),
      (i.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (i.rotation = this.rotation),
      this.polygonOffset === !0 && (i.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (i.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (i.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (i.linewidth = this.linewidth),
      this.dashSize !== void 0 && (i.dashSize = this.dashSize),
      this.gapSize !== void 0 && (i.gapSize = this.gapSize),
      this.scale !== void 0 && (i.scale = this.scale),
      this.dithering === !0 && (i.dithering = !0),
      this.alphaTest > 0 && (i.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (i.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (i.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (i.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (i.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (i.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (i.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (i.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (i.flatShading = this.flatShading),
      this.visible === !1 && (i.visible = !1),
      this.toneMapped === !1 && (i.toneMapped = !1),
      this.fog === !1 && (i.fog = !1),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData);
    function r(s) {
      const o = [];
      for (const a in s) {
        const l = s[a];
        delete l.metadata, o.push(l);
      }
      return o;
    }
    if (t) {
      const s = r(e.textures),
        o = r(e.images);
      s.length > 0 && (i.textures = s), o.length > 0 && (i.images = o);
    }
    return i;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let i = null;
    if (t !== null) {
      const r = t.length;
      i = new Array(r);
      for (let s = 0; s !== r; ++s) i[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = i),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const JB = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Pr = { h: 0, s: 0, l: 0 },
  hp = { h: 0, s: 0, l: 0 };
function Zy(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * 6 * (2 / 3 - t)
      : n
  );
}
class Ie {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      t === void 0 && i === void 0 ? this.set(e) : this.setRGB(e, t, i)
    );
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : typeof e == "number"
        ? this.setHex(e)
        : typeof e == "string" && this.setStyle(e),
      this
    );
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Lr) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      Si.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, r = Si.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      Si.toWorkingColorSpace(this, r),
      this
    );
  }
  setHSL(e, t, i, r = Si.workingColorSpace) {
    if (((e = q1(e, 1)), (t = pn(t, 0, 1)), (i = pn(i, 0, 1)), t === 0))
      this.r = this.g = this.b = i;
    else {
      const s = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        o = 2 * i - s;
      (this.r = Zy(o, s, e + 1 / 3)),
        (this.g = Zy(o, s, e)),
        (this.b = Zy(o, s, e - 1 / 3));
    }
    return Si.toWorkingColorSpace(this, r), this;
  }
  setStyle(e, t = Lr) {
    function i(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let r;
    if ((r = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const o = r[1],
        a = r[2];
      switch (o) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              (this.r = Math.min(255, parseInt(s[1], 10)) / 255),
              (this.g = Math.min(255, parseInt(s[2], 10)) / 255),
              (this.b = Math.min(255, parseInt(s[3], 10)) / 255),
              Si.toWorkingColorSpace(this, t),
              i(s[4]),
              this
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              (this.r = Math.min(100, parseInt(s[1], 10)) / 100),
              (this.g = Math.min(100, parseInt(s[2], 10)) / 100),
              (this.b = Math.min(100, parseInt(s[3], 10)) / 100),
              Si.toWorkingColorSpace(this, t),
              i(s[4]),
              this
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          ) {
            const l = parseFloat(s[1]) / 360,
              c = parseFloat(s[2]) / 100,
              h = parseFloat(s[3]) / 100;
            return i(s[4]), this.setHSL(l, c, h, t);
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((r = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = r[1],
        o = s.length;
      if (o === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (o === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Lr) {
    const i = JB[e.toLowerCase()];
    return (
      i !== void 0
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Pu(e.r)), (this.g = Pu(e.g)), (this.b = Pu(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Uy(e.r)), (this.g = Uy(e.g)), (this.b = Uy(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Lr) {
    return (
      Si.fromWorkingColorSpace(ni.copy(this), e),
      (pn(ni.r * 255, 0, 255) << 16) ^
        (pn(ni.g * 255, 0, 255) << 8) ^
        (pn(ni.b * 255, 0, 255) << 0)
    );
  }
  getHexString(e = Lr) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = Si.workingColorSpace) {
    Si.fromWorkingColorSpace(ni.copy(this), t);
    const i = ni.r,
      r = ni.g,
      s = ni.b,
      o = Math.max(i, r, s),
      a = Math.min(i, r, s);
    let l, c;
    const h = (a + o) / 2;
    if (a === o) (l = 0), (c = 0);
    else {
      const d = o - a;
      switch (((c = h <= 0.5 ? d / (o + a) : d / (2 - o - a)), o)) {
        case i:
          l = (r - s) / d + (r < s ? 6 : 0);
          break;
        case r:
          l = (s - i) / d + 2;
          break;
        case s:
          l = (i - r) / d + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = h), e;
  }
  getRGB(e, t = Si.workingColorSpace) {
    return (
      Si.fromWorkingColorSpace(ni.copy(this), t),
      (e.r = ni.r),
      (e.g = ni.g),
      (e.b = ni.b),
      e
    );
  }
  getStyle(e = Lr) {
    Si.fromWorkingColorSpace(ni.copy(this), e);
    const t = ni.r,
      i = ni.g,
      r = ni.b;
    return e !== Lr
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${r.toFixed(3)})`
      : `rgb(${(t * 255) | 0},${(i * 255) | 0},${(r * 255) | 0})`;
  }
  offsetHSL(e, t, i) {
    return (
      this.getHSL(Pr),
      (Pr.h += e),
      (Pr.s += t),
      (Pr.l += i),
      this.setHSL(Pr.h, Pr.s, Pr.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Pr), e.getHSL(hp);
    const i = Af(Pr.h, hp.h, t),
      r = Af(Pr.s, hp.s, t),
      s = Af(Pr.l, hp.l, t);
    return this.setHSL(i, r, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      r = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * r),
      (this.g = s[1] * t + s[4] * i + s[7] * r),
      (this.b = s[2] * t + s[5] * i + s[8] * r),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ni = new Ie();
Ie.NAMES = JB;
class Wi extends Cn {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = _h),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Rs = KO();
function KO() {
  const n = new ArrayBuffer(4),
    e = new Float32Array(n),
    t = new Uint32Array(n),
    i = new Uint32Array(512),
    r = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const c = l - 127;
    c < -27
      ? ((i[l] = 0), (i[l | 256] = 32768), (r[l] = 24), (r[l | 256] = 24))
      : c < -14
      ? ((i[l] = 1024 >> (-c - 14)),
        (i[l | 256] = (1024 >> (-c - 14)) | 32768),
        (r[l] = -c - 1),
        (r[l | 256] = -c - 1))
      : c <= 15
      ? ((i[l] = (c + 15) << 10),
        (i[l | 256] = ((c + 15) << 10) | 32768),
        (r[l] = 13),
        (r[l | 256] = 13))
      : c < 128
      ? ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 24), (r[l | 256] = 24))
      : ((i[l] = 31744), (i[l | 256] = 64512), (r[l] = 13), (r[l | 256] = 13));
  }
  const s = new Uint32Array(2048),
    o = new Uint32Array(64),
    a = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let c = l << 13,
      h = 0;
    for (; !(c & 8388608); ) (c <<= 1), (h -= 8388608);
    (c &= -8388609), (h += 947912704), (s[l] = c | h);
  }
  for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) o[l] = l << 23;
  (o[31] = 1199570944), (o[32] = 2147483648);
  for (let l = 33; l < 63; ++l) o[l] = 2147483648 + ((l - 32) << 23);
  o[63] = 3347054592;
  for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: i,
    shiftTable: r,
    mantissaTable: s,
    exponentTable: o,
    offsetTable: a,
  };
}
function wi(n) {
  Math.abs(n) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (n = pn(n, -65504, 65504)),
    (Rs.floatView[0] = n);
  const e = Rs.uint32View[0],
    t = (e >> 23) & 511;
  return Rs.baseTable[t] + ((e & 8388607) >> Rs.shiftTable[t]);
}
function lf(n) {
  const e = n >> 10;
  return (
    (Rs.uint32View[0] =
      Rs.mantissaTable[Rs.offsetTable[e] + (n & 1023)] + Rs.exponentTable[e]),
    Rs.floatView[0]
  );
}
const YO = { toHalfFloat: wi, fromHalfFloat: lf },
  Mn = new F(),
  dp = new ge();
class Dt {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = $f),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let r = 0, s = this.itemSize; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, i = this.count; t < i; t++)
        dp.fromBufferAttribute(this, t),
          dp.applyMatrix3(e),
          this.setXY(t, dp.x, dp.y);
    else if (this.itemSize === 3)
      for (let t = 0, i = this.count; t < i; t++)
        Mn.fromBufferAttribute(this, t),
          Mn.applyMatrix3(e),
          this.setXYZ(t, Mn.x, Mn.y, Mn.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Mn.fromBufferAttribute(this, t),
        Mn.applyMatrix4(e),
        this.setXYZ(t, Mn.x, Mn.y, Mn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Mn.fromBufferAttribute(this, t),
        Mn.applyNormalMatrix(e),
        this.setXYZ(t, Mn.x, Mn.y, Mn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Mn.fromBufferAttribute(this, t),
        Mn.transformDirection(e),
        this.setXYZ(t, Mn.x, Mn.y, Mn.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = gt(t, this.array)), (i = gt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gt(t, this.array)),
        (i = gt(i, this.array)),
        (r = gt(r, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gt(t, this.array)),
        (i = gt(i, this.array)),
        (r = gt(r, this.array)),
        (s = gt(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = r),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== $f && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
  copyColorsArray() {
    console.error(
      "THREE.BufferAttribute: copyColorsArray() was removed in r144."
    );
  }
  copyVector2sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
    );
  }
  copyVector3sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
    );
  }
  copyVector4sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
    );
  }
}
class QO extends Dt {
  constructor(e, t, i) {
    super(new Int8Array(e), t, i);
  }
}
class ZO extends Dt {
  constructor(e, t, i) {
    super(new Uint8Array(e), t, i);
  }
}
class qO extends Dt {
  constructor(e, t, i) {
    super(new Uint8ClampedArray(e), t, i);
  }
}
class $O extends Dt {
  constructor(e, t, i) {
    super(new Int16Array(e), t, i);
  }
}
class nA extends Dt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class ek extends Dt {
  constructor(e, t, i) {
    super(new Int32Array(e), t, i);
  }
}
class iA extends Dt {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class tk extends Dt {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = lf(this.array[e * this.itemSize]);
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize] = wi(t)),
      this
    );
  }
  getY(e) {
    let t = lf(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize + 1] = wi(t)),
      this
    );
  }
  getZ(e) {
    let t = lf(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize + 2] = wi(t)),
      this
    );
  }
  getW(e) {
    let t = lf(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.array[e * this.itemSize + 3] = wi(t)),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = gt(t, this.array)), (i = gt(i, this.array))),
      (this.array[e + 0] = wi(t)),
      (this.array[e + 1] = wi(i)),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gt(t, this.array)),
        (i = gt(i, this.array)),
        (r = gt(r, this.array))),
      (this.array[e + 0] = wi(t)),
      (this.array[e + 1] = wi(i)),
      (this.array[e + 2] = wi(r)),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = gt(t, this.array)),
        (i = gt(i, this.array)),
        (r = gt(r, this.array)),
        (s = gt(s, this.array))),
      (this.array[e + 0] = wi(t)),
      (this.array[e + 1] = wi(i)),
      (this.array[e + 2] = wi(r)),
      (this.array[e + 3] = wi(s)),
      this
    );
  }
}
class Ve extends Dt {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
class nk extends Dt {
  constructor(e, t, i) {
    super(new Float64Array(e), t, i);
  }
}
let ik = 0;
const ar = new st(),
  qy = new Pt(),
  Gl = new F(),
  Ui = new Hr(),
  zc = new Hr(),
  Nn = new F();
class ct extends ds {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: ik++ }),
      (this.uuid = ji()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (WB(e) ? iA : nA)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (i !== void 0) {
      const s = new wt().getNormalMatrix(e);
      i.applyNormalMatrix(s), (i.needsUpdate = !0);
    }
    const r = this.attributes.tangent;
    return (
      r !== void 0 && (r.transformDirection(e), (r.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return ar.makeRotationFromQuaternion(e), this.applyMatrix4(ar), this;
  }
  rotateX(e) {
    return ar.makeRotationX(e), this.applyMatrix4(ar), this;
  }
  rotateY(e) {
    return ar.makeRotationY(e), this.applyMatrix4(ar), this;
  }
  rotateZ(e) {
    return ar.makeRotationZ(e), this.applyMatrix4(ar), this;
  }
  translate(e, t, i) {
    return ar.makeTranslation(e, t, i), this.applyMatrix4(ar), this;
  }
  scale(e, t, i) {
    return ar.makeScale(e, t, i), this.applyMatrix4(ar), this;
  }
  lookAt(e) {
    return qy.lookAt(e), qy.updateMatrix(), this.applyMatrix4(qy.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Gl).negate(),
      this.translate(Gl.x, Gl.y, Gl.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, r = e.length; i < r; i++) {
      const s = e[i];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new Ve(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new Hr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new F(-1 / 0, -1 / 0, -1 / 0),
          new F(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, r = t.length; i < r; i++) {
          const s = t[i];
          Ui.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Nn.addVectors(this.boundingBox.min, Ui.min),
                this.boundingBox.expandByPoint(Nn),
                Nn.addVectors(this.boundingBox.max, Ui.max),
                this.boundingBox.expandByPoint(Nn))
              : (this.boundingBox.expandByPoint(Ui.min),
                this.boundingBox.expandByPoint(Ui.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new Vr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new F(), 1 / 0);
      return;
    }
    if (e) {
      const i = this.boundingSphere.center;
      if ((Ui.setFromBufferAttribute(e), t))
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s];
          zc.setFromBufferAttribute(a),
            this.morphTargetsRelative
              ? (Nn.addVectors(Ui.min, zc.min),
                Ui.expandByPoint(Nn),
                Nn.addVectors(Ui.max, zc.max),
                Ui.expandByPoint(Nn))
              : (Ui.expandByPoint(zc.min), Ui.expandByPoint(zc.max));
        }
      Ui.getCenter(i);
      let r = 0;
      for (let s = 0, o = e.count; s < o; s++)
        Nn.fromBufferAttribute(e, s),
          (r = Math.max(r, i.distanceToSquared(Nn)));
      if (t)
        for (let s = 0, o = t.length; s < o; s++) {
          const a = t[s],
            l = this.morphTargetsRelative;
          for (let c = 0, h = a.count; c < h; c++)
            Nn.fromBufferAttribute(a, c),
              l && (Gl.fromBufferAttribute(e, c), Nn.add(Gl)),
              (r = Math.max(r, i.distanceToSquared(Nn)));
        }
      (this.boundingSphere.radius = Math.sqrt(r)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const i = e.array,
      r = t.position.array,
      s = t.normal.array,
      o = t.uv.array,
      a = r.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new Dt(new Float32Array(4 * a), 4));
    const l = this.getAttribute("tangent").array,
      c = [],
      h = [];
    for (let R = 0; R < a; R++) (c[R] = new F()), (h[R] = new F());
    const d = new F(),
      p = new F(),
      m = new F(),
      v = new ge(),
      A = new ge(),
      x = new ge(),
      g = new F(),
      _ = new F();
    function S(R, U, j) {
      d.fromArray(r, R * 3),
        p.fromArray(r, U * 3),
        m.fromArray(r, j * 3),
        v.fromArray(o, R * 2),
        A.fromArray(o, U * 2),
        x.fromArray(o, j * 2),
        p.sub(d),
        m.sub(d),
        A.sub(v),
        x.sub(v);
      const V = 1 / (A.x * x.y - x.x * A.y);
      isFinite(V) &&
        (g
          .copy(p)
          .multiplyScalar(x.y)
          .addScaledVector(m, -A.y)
          .multiplyScalar(V),
        _.copy(m)
          .multiplyScalar(A.x)
          .addScaledVector(p, -x.x)
          .multiplyScalar(V),
        c[R].add(g),
        c[U].add(g),
        c[j].add(g),
        h[R].add(_),
        h[U].add(_),
        h[j].add(_));
    }
    let w = this.groups;
    w.length === 0 && (w = [{ start: 0, count: i.length }]);
    for (let R = 0, U = w.length; R < U; ++R) {
      const j = w[R],
        V = j.start,
        J = j.count;
      for (let X = V, oe = V + J; X < oe; X += 3)
        S(i[X + 0], i[X + 1], i[X + 2]);
    }
    const E = new F(),
      P = new F(),
      L = new F(),
      B = new F();
    function b(R) {
      L.fromArray(s, R * 3), B.copy(L);
      const U = c[R];
      E.copy(U),
        E.sub(L.multiplyScalar(L.dot(U))).normalize(),
        P.crossVectors(B, U);
      const V = P.dot(h[R]) < 0 ? -1 : 1;
      (l[R * 4] = E.x),
        (l[R * 4 + 1] = E.y),
        (l[R * 4 + 2] = E.z),
        (l[R * 4 + 3] = V);
    }
    for (let R = 0, U = w.length; R < U; ++R) {
      const j = w[R],
        V = j.start,
        J = j.count;
      for (let X = V, oe = V + J; X < oe; X += 3)
        b(i[X + 0]), b(i[X + 1]), b(i[X + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let i = this.getAttribute("normal");
      if (i === void 0)
        (i = new Dt(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", i);
      else for (let p = 0, m = i.count; p < m; p++) i.setXYZ(p, 0, 0, 0);
      const r = new F(),
        s = new F(),
        o = new F(),
        a = new F(),
        l = new F(),
        c = new F(),
        h = new F(),
        d = new F();
      if (e)
        for (let p = 0, m = e.count; p < m; p += 3) {
          const v = e.getX(p + 0),
            A = e.getX(p + 1),
            x = e.getX(p + 2);
          r.fromBufferAttribute(t, v),
            s.fromBufferAttribute(t, A),
            o.fromBufferAttribute(t, x),
            h.subVectors(o, s),
            d.subVectors(r, s),
            h.cross(d),
            a.fromBufferAttribute(i, v),
            l.fromBufferAttribute(i, A),
            c.fromBufferAttribute(i, x),
            a.add(h),
            l.add(h),
            c.add(h),
            i.setXYZ(v, a.x, a.y, a.z),
            i.setXYZ(A, l.x, l.y, l.z),
            i.setXYZ(x, c.x, c.y, c.z);
        }
      else
        for (let p = 0, m = t.count; p < m; p += 3)
          r.fromBufferAttribute(t, p + 0),
            s.fromBufferAttribute(t, p + 1),
            o.fromBufferAttribute(t, p + 2),
            h.subVectors(o, s),
            d.subVectors(r, s),
            h.cross(d),
            i.setXYZ(p + 0, h.x, h.y, h.z),
            i.setXYZ(p + 1, h.x, h.y, h.z),
            i.setXYZ(p + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  merge() {
    return (
      console.error(
        "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."
      ),
      this
    );
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      Nn.fromBufferAttribute(e, t),
        Nn.normalize(),
        e.setXYZ(t, Nn.x, Nn.y, Nn.z);
  }
  toNonIndexed() {
    function e(a, l) {
      const c = a.array,
        h = a.itemSize,
        d = a.normalized,
        p = new c.constructor(l.length * h);
      let m = 0,
        v = 0;
      for (let A = 0, x = l.length; A < x; A++) {
        a.isInterleavedBufferAttribute
          ? (m = l[A] * a.data.stride + a.offset)
          : (m = l[A] * h);
        for (let g = 0; g < h; g++) p[v++] = c[m++];
      }
      return new Dt(p, h, d);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new ct(),
      i = this.index.array,
      r = this.attributes;
    for (const a in r) {
      const l = r[a],
        c = e(l, i);
      t.setAttribute(a, c);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const l = [],
        c = s[a];
      for (let h = 0, d = c.length; h < d; h++) {
        const p = c[h],
          m = e(p, i);
        l.push(m);
      }
      t.morphAttributes[a] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const o = this.groups;
    for (let a = 0, l = o.length; a < l; a++) {
      const c = o[a];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const l in i) {
      const c = i[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const r = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        h = [];
      for (let d = 0, p = c.length; d < p; d++) {
        const m = c[d];
        h.push(m.toJSON(e.data));
      }
      h.length > 0 && ((r[l] = h), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = r),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const o = this.groups;
    o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
    const a = this.boundingSphere;
    return (
      a !== null &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const i = e.index;
    i !== null && this.setIndex(i.clone(t));
    const r = e.attributes;
    for (const c in r) {
      const h = r[c];
      this.setAttribute(c, h.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const h = [],
        d = s[c];
      for (let p = 0, m = d.length; p < m; p++) h.push(d[p].clone(t));
      this.morphAttributes[c] = h;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const o = e.groups;
    for (let c = 0, h = o.length; c < h; c++) {
      const d = o[c];
      this.addGroup(d.start, d.count, d.materialIndex);
    }
    const a = e.boundingBox;
    a !== null && (this.boundingBox = a.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const _C = new st(),
  ts = new Ah(),
  pp = new Vr(),
  AC = new F(),
  Hl = new F(),
  Vl = new F(),
  Wl = new F(),
  $y = new F(),
  mp = new F(),
  gp = new ge(),
  yp = new ge(),
  vp = new ge(),
  MC = new F(),
  SC = new F(),
  wC = new F(),
  xp = new F(),
  _p = new F();
class Pn extends Pt {
  constructor(e = new ct(), t = new Wi()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      r = i.attributes.position,
      s = i.morphAttributes.position,
      o = i.morphTargetsRelative;
    t.fromBufferAttribute(r, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      mp.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const h = a[l],
          d = s[l];
        h !== 0 &&
          ($y.fromBufferAttribute(d, e),
          o ? mp.addScaledVector($y, h) : mp.addScaledVector($y.sub(t), h));
      }
      t.add(mp);
    }
    return this.isSkinnedMesh && this.applyBoneTransform(e, t), t;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.material,
      s = this.matrixWorld;
    if (
      r === void 0 ||
      (i.boundingSphere === null && i.computeBoundingSphere(),
      pp.copy(i.boundingSphere),
      pp.applyMatrix4(s),
      ts.copy(e.ray).recast(e.near),
      pp.containsPoint(ts.origin) === !1 &&
        (ts.intersectSphere(pp, AC) === null ||
          ts.origin.distanceToSquared(AC) > (e.far - e.near) ** 2)) ||
      (_C.copy(s).invert(),
      ts.copy(e.ray).applyMatrix4(_C),
      i.boundingBox !== null && ts.intersectsBox(i.boundingBox) === !1)
    )
      return;
    let o;
    const a = i.index,
      l = i.attributes.position,
      c = i.attributes.uv,
      h = i.attributes.uv2,
      d = i.attributes.normal,
      p = i.groups,
      m = i.drawRange;
    if (a !== null)
      if (Array.isArray(r))
        for (let v = 0, A = p.length; v < A; v++) {
          const x = p[v],
            g = r[x.materialIndex],
            _ = Math.max(x.start, m.start),
            S = Math.min(
              a.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let w = _, E = S; w < E; w += 3) {
            const P = a.getX(w),
              L = a.getX(w + 1),
              B = a.getX(w + 2);
            (o = Ap(this, g, e, ts, c, h, d, P, L, B)),
              o &&
                ((o.faceIndex = Math.floor(w / 3)),
                (o.face.materialIndex = x.materialIndex),
                t.push(o));
          }
        }
      else {
        const v = Math.max(0, m.start),
          A = Math.min(a.count, m.start + m.count);
        for (let x = v, g = A; x < g; x += 3) {
          const _ = a.getX(x),
            S = a.getX(x + 1),
            w = a.getX(x + 2);
          (o = Ap(this, r, e, ts, c, h, d, _, S, w)),
            o && ((o.faceIndex = Math.floor(x / 3)), t.push(o));
        }
      }
    else if (l !== void 0)
      if (Array.isArray(r))
        for (let v = 0, A = p.length; v < A; v++) {
          const x = p[v],
            g = r[x.materialIndex],
            _ = Math.max(x.start, m.start),
            S = Math.min(
              l.count,
              Math.min(x.start + x.count, m.start + m.count)
            );
          for (let w = _, E = S; w < E; w += 3) {
            const P = w,
              L = w + 1,
              B = w + 2;
            (o = Ap(this, g, e, ts, c, h, d, P, L, B)),
              o &&
                ((o.faceIndex = Math.floor(w / 3)),
                (o.face.materialIndex = x.materialIndex),
                t.push(o));
          }
        }
      else {
        const v = Math.max(0, m.start),
          A = Math.min(l.count, m.start + m.count);
        for (let x = v, g = A; x < g; x += 3) {
          const _ = x,
            S = x + 1,
            w = x + 2;
          (o = Ap(this, r, e, ts, c, h, d, _, S, w)),
            o && ((o.faceIndex = Math.floor(x / 3)), t.push(o));
        }
      }
  }
}
function rk(n, e, t, i, r, s, o, a) {
  let l;
  if (
    (e.side === mi
      ? (l = i.intersectTriangle(o, s, r, !0, a))
      : (l = i.intersectTriangle(r, s, o, e.side === cs, a)),
    l === null)
  )
    return null;
  _p.copy(a), _p.applyMatrix4(n.matrixWorld);
  const c = t.ray.origin.distanceTo(_p);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: _p.clone(), object: n };
}
function Ap(n, e, t, i, r, s, o, a, l, c) {
  n.getVertexPosition(a, Hl),
    n.getVertexPosition(l, Vl),
    n.getVertexPosition(c, Wl);
  const h = rk(n, e, t, i, Hl, Vl, Wl, xp);
  if (h) {
    r &&
      (gp.fromBufferAttribute(r, a),
      yp.fromBufferAttribute(r, l),
      vp.fromBufferAttribute(r, c),
      (h.uv = Ei.getInterpolation(xp, Hl, Vl, Wl, gp, yp, vp, new ge()))),
      s &&
        (gp.fromBufferAttribute(s, a),
        yp.fromBufferAttribute(s, l),
        vp.fromBufferAttribute(s, c),
        (h.uv2 = Ei.getInterpolation(xp, Hl, Vl, Wl, gp, yp, vp, new ge()))),
      o &&
        (MC.fromBufferAttribute(o, a),
        SC.fromBufferAttribute(o, l),
        wC.fromBufferAttribute(o, c),
        (h.normal = Ei.getInterpolation(xp, Hl, Vl, Wl, MC, SC, wC, new F())),
        h.normal.dot(i.direction) > 0 && h.normal.multiplyScalar(-1));
    const d = { a, b: l, c, normal: new F(), materialIndex: 0 };
    Ei.getNormal(Hl, Vl, Wl, d.normal), (h.face = d);
  }
  return h;
}
class ta extends ct {
  constructor(e = 1, t = 1, i = 1, r = 1, s = 1, o = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: r,
        heightSegments: s,
        depthSegments: o,
      });
    const a = this;
    (r = Math.floor(r)), (s = Math.floor(s)), (o = Math.floor(o));
    const l = [],
      c = [],
      h = [],
      d = [];
    let p = 0,
      m = 0;
    v("z", "y", "x", -1, -1, i, t, e, o, s, 0),
      v("z", "y", "x", 1, -1, i, t, -e, o, s, 1),
      v("x", "z", "y", 1, 1, e, i, t, r, o, 2),
      v("x", "z", "y", 1, -1, e, i, -t, r, o, 3),
      v("x", "y", "z", 1, -1, e, t, i, r, s, 4),
      v("x", "y", "z", -1, -1, e, t, -i, r, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new Ve(c, 3)),
      this.setAttribute("normal", new Ve(h, 3)),
      this.setAttribute("uv", new Ve(d, 2));
    function v(A, x, g, _, S, w, E, P, L, B, b) {
      const R = w / L,
        U = E / B,
        j = w / 2,
        V = E / 2,
        J = P / 2,
        X = L + 1,
        oe = B + 1;
      let ae = 0,
        I = 0;
      const G = new F();
      for (let z = 0; z < oe; z++) {
        const q = z * U - V;
        for (let Q = 0; Q < X; Q++) {
          const ee = Q * R - j;
          (G[A] = ee * _),
            (G[x] = q * S),
            (G[g] = J),
            c.push(G.x, G.y, G.z),
            (G[A] = 0),
            (G[x] = 0),
            (G[g] = P > 0 ? 1 : -1),
            h.push(G.x, G.y, G.z),
            d.push(Q / L),
            d.push(1 - z / B),
            (ae += 1);
        }
      }
      for (let z = 0; z < B; z++)
        for (let q = 0; q < L; q++) {
          const Q = p + q + X * z,
            ee = p + q + X * (z + 1),
            ne = p + (q + 1) + X * (z + 1),
            Ce = p + (q + 1) + X * z;
          l.push(Q, ee, Ce), l.push(ee, ne, Ce), (I += 6);
        }
      a.addGroup(m, I, b), (m += I), (p += ae);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ta(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function Wu(n) {
  const e = {};
  for (const t in n) {
    e[t] = {};
    for (const i in n[t]) {
      const r = n[t][i];
      r &&
      (r.isColor ||
        r.isMatrix3 ||
        r.isMatrix4 ||
        r.isVector2 ||
        r.isVector3 ||
        r.isVector4 ||
        r.isTexture ||
        r.isQuaternion)
        ? r.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][i] = null))
          : (e[t][i] = r.clone())
        : Array.isArray(r)
        ? (e[t][i] = r.slice())
        : (e[t][i] = r);
    }
  }
  return e;
}
function fi(n) {
  const e = {};
  for (let t = 0; t < n.length; t++) {
    const i = Wu(n[t]);
    for (const r in i) e[r] = i[r];
  }
  return e;
}
function sk(n) {
  const e = [];
  for (let t = 0; t < n.length; t++) e.push(n[t].clone());
  return e;
}
function jB(n) {
  return n.getRenderTarget() === null && n.outputEncoding === Tt ? Lr : Hu;
}
const XB = { clone: Wu, merge: fi };
var ok = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  ak = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class hs extends Cn {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = ok),
      (this.fragmentShader = ak),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = Wu(e.uniforms)),
      (this.uniformsGroups = sk(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const r in this.uniforms) {
      const o = this.uniforms[r].value;
      o && o.isTexture
        ? (t.uniforms[r] = { type: "t", value: o.toJSON(e).uuid })
        : o && o.isColor
        ? (t.uniforms[r] = { type: "c", value: o.getHex() })
        : o && o.isVector2
        ? (t.uniforms[r] = { type: "v2", value: o.toArray() })
        : o && o.isVector3
        ? (t.uniforms[r] = { type: "v3", value: o.toArray() })
        : o && o.isVector4
        ? (t.uniforms[r] = { type: "v4", value: o.toArray() })
        : o && o.isMatrix3
        ? (t.uniforms[r] = { type: "m3", value: o.toArray() })
        : o && o.isMatrix4
        ? (t.uniforms[r] = { type: "m4", value: o.toArray() })
        : (t.uniforms[r] = { value: o });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader);
    const i = {};
    for (const r in this.extensions) this.extensions[r] === !0 && (i[r] = !0);
    return Object.keys(i).length > 0 && (t.extensions = i), t;
  }
}
class Mh extends Pt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new st()),
      (this.projectionMatrix = new st()),
      (this.projectionMatrixInverse = new st());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Vt extends Mh {
  constructor(e = 50, t = 1, i = 0.1, r = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = r),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Vu * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(Qa * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Vu * 2 * Math.atan(Math.tan(Qa * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, i, r, s, o) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(Qa * 0.5 * this.fov)) / this.zoom,
      i = 2 * t,
      r = this.aspect * i,
      s = -0.5 * r;
    const o = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = o.fullWidth,
        c = o.fullHeight;
      (s += (o.offsetX * r) / l),
        (t -= (o.offsetY * i) / c),
        (r *= o.width / l),
        (i *= o.height / c);
    }
    const a = this.filmOffset;
    a !== 0 && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(s, s + r, t, t - i, e, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Jl = -90,
  jl = 1;
class rA extends Pt {
  constructor(e, t, i) {
    super(), (this.type = "CubeCamera"), (this.renderTarget = i);
    const r = new Vt(Jl, jl, e, t);
    (r.layers = this.layers), r.up.set(0, 1, 0), r.lookAt(1, 0, 0), this.add(r);
    const s = new Vt(Jl, jl, e, t);
    (s.layers = this.layers),
      s.up.set(0, 1, 0),
      s.lookAt(-1, 0, 0),
      this.add(s);
    const o = new Vt(Jl, jl, e, t);
    (o.layers = this.layers),
      o.up.set(0, 0, -1),
      o.lookAt(0, 1, 0),
      this.add(o);
    const a = new Vt(Jl, jl, e, t);
    (a.layers = this.layers),
      a.up.set(0, 0, 1),
      a.lookAt(0, -1, 0),
      this.add(a);
    const l = new Vt(Jl, jl, e, t);
    (l.layers = this.layers), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l);
    const c = new Vt(Jl, jl, e, t);
    (c.layers = this.layers),
      c.up.set(0, 1, 0),
      c.lookAt(0, 0, -1),
      this.add(c);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const i = this.renderTarget,
      [r, s, o, a, l, c] = this.children,
      h = e.getRenderTarget(),
      d = e.toneMapping,
      p = e.xr.enabled;
    (e.toneMapping = Or), (e.xr.enabled = !1);
    const m = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0),
      e.render(t, r),
      e.setRenderTarget(i, 1),
      e.render(t, s),
      e.setRenderTarget(i, 2),
      e.render(t, o),
      e.setRenderTarget(i, 3),
      e.render(t, a),
      e.setRenderTarget(i, 4),
      e.render(t, l),
      (i.texture.generateMipmaps = m),
      e.setRenderTarget(i, 5),
      e.render(t, c),
      e.setRenderTarget(h),
      (e.toneMapping = d),
      (e.xr.enabled = p),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class Sh extends en {
  constructor(e, t, i, r, s, o, a, l, c, h) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Wo),
      super(e, t, i, r, s, o, a, l, c, h),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class sA extends Gr {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      r = [i, i, i, i, i, i];
    (this.texture = new Sh(
      r,
      t.mapping,
      t.wrapS,
      t.wrapT,
      t.magFilter,
      t.minFilter,
      t.format,
      t.type,
      t.anisotropy,
      t.encoding
    )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : rn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.encoding = t.encoding),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      r = new ta(5, 5, 5),
      s = new hs({
        name: "CubemapFromEquirect",
        uniforms: Wu(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: mi,
        blending: zs,
      });
    s.uniforms.tEquirect.value = t;
    const o = new Pn(r, s),
      a = t.minFilter;
    return (
      t.minFilter === fs && (t.minFilter = rn),
      new rA(1, 10, this).update(e, o),
      (t.minFilter = a),
      o.geometry.dispose(),
      o.material.dispose(),
      this
    );
  }
  clear(e, t, i, r) {
    const s = e.getRenderTarget();
    for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, i, r);
    e.setRenderTarget(s);
  }
}
const ev = new F(),
  lk = new F(),
  uk = new wt();
class Mo {
  constructor(e = new F(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, r) {
    return this.normal.set(e, t, i), (this.constant = r), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const r = ev.subVectors(i, t).cross(lk.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(r, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(ev),
      r = this.normal.dot(i);
    if (r === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / r;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || uk.getNormalMatrix(e),
      r = this.coplanarPoint(ev).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -r.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const ya = new Vr(),
  Mp = new F();
class Fg {
  constructor(
    e = new Mo(),
    t = new Mo(),
    i = new Mo(),
    r = new Mo(),
    s = new Mo(),
    o = new Mo()
  ) {
    this.planes = [e, t, i, r, s, o];
  }
  set(e, t, i, r, s, o) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(r),
      a[4].copy(s),
      a[5].copy(o),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes,
      i = e.elements,
      r = i[0],
      s = i[1],
      o = i[2],
      a = i[3],
      l = i[4],
      c = i[5],
      h = i[6],
      d = i[7],
      p = i[8],
      m = i[9],
      v = i[10],
      A = i[11],
      x = i[12],
      g = i[13],
      _ = i[14],
      S = i[15];
    return (
      t[0].setComponents(a - r, d - l, A - p, S - x).normalize(),
      t[1].setComponents(a + r, d + l, A + p, S + x).normalize(),
      t[2].setComponents(a + s, d + c, A + m, S + g).normalize(),
      t[3].setComponents(a - s, d - c, A - m, S - g).normalize(),
      t[4].setComponents(a - o, d - h, A - v, S - _).normalize(),
      t[5].setComponents(a + o, d + h, A + v, S + _).normalize(),
      this
    );
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        ya.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        ya.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(ya);
  }
  intersectsSprite(e) {
    return (
      ya.center.set(0, 0, 0),
      (ya.radius = 0.7071067811865476),
      ya.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(ya)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      r = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(i) < r) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const r = t[i];
      if (
        ((Mp.x = r.normal.x > 0 ? e.max.x : e.min.x),
        (Mp.y = r.normal.y > 0 ? e.max.y : e.min.y),
        (Mp.z = r.normal.z > 0 ? e.max.z : e.min.z),
        r.distanceToPoint(Mp) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function KB() {
  let n = null,
    e = !1,
    t = null,
    i = null;
  function r(s, o) {
    t(s, o), (i = n.requestAnimationFrame(r));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((i = n.requestAnimationFrame(r)), (e = !0));
    },
    stop: function () {
      n.cancelAnimationFrame(i), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      n = s;
    },
  };
}
function ck(n, e) {
  const t = e.isWebGL2,
    i = new WeakMap();
  function r(c, h) {
    const d = c.array,
      p = c.usage,
      m = n.createBuffer();
    n.bindBuffer(h, m), n.bufferData(h, d, p), c.onUploadCallback();
    let v;
    if (d instanceof Float32Array) v = 5126;
    else if (d instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t) v = 5131;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else v = 5123;
    else if (d instanceof Int16Array) v = 5122;
    else if (d instanceof Uint32Array) v = 5125;
    else if (d instanceof Int32Array) v = 5124;
    else if (d instanceof Int8Array) v = 5120;
    else if (d instanceof Uint8Array) v = 5121;
    else if (d instanceof Uint8ClampedArray) v = 5121;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + d
      );
    return {
      buffer: m,
      type: v,
      bytesPerElement: d.BYTES_PER_ELEMENT,
      version: c.version,
    };
  }
  function s(c, h, d) {
    const p = h.array,
      m = h.updateRange;
    n.bindBuffer(d, c),
      m.count === -1
        ? n.bufferSubData(d, 0, p)
        : (t
            ? n.bufferSubData(
                d,
                m.offset * p.BYTES_PER_ELEMENT,
                p,
                m.offset,
                m.count
              )
            : n.bufferSubData(
                d,
                m.offset * p.BYTES_PER_ELEMENT,
                p.subarray(m.offset, m.offset + m.count)
              ),
          (m.count = -1)),
      h.onUploadCallback();
  }
  function o(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), i.get(c);
  }
  function a(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = i.get(c);
    h && (n.deleteBuffer(h.buffer), i.delete(c));
  }
  function l(c, h) {
    if (c.isGLBufferAttribute) {
      const p = i.get(c);
      (!p || p.version < c.version) &&
        i.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const d = i.get(c);
    d === void 0
      ? i.set(c, r(c, h))
      : d.version < c.version && (s(d.buffer, c, h), (d.version = c.version));
  }
  return { get: o, remove: a, update: l };
}
class tc extends ct {
  constructor(e = 1, t = 1, i = 1, r = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: r,
      });
    const s = e / 2,
      o = t / 2,
      a = Math.floor(i),
      l = Math.floor(r),
      c = a + 1,
      h = l + 1,
      d = e / a,
      p = t / l,
      m = [],
      v = [],
      A = [],
      x = [];
    for (let g = 0; g < h; g++) {
      const _ = g * p - o;
      for (let S = 0; S < c; S++) {
        const w = S * d - s;
        v.push(w, -_, 0), A.push(0, 0, 1), x.push(S / a), x.push(1 - g / l);
      }
    }
    for (let g = 0; g < l; g++)
      for (let _ = 0; _ < a; _++) {
        const S = _ + c * g,
          w = _ + c * (g + 1),
          E = _ + 1 + c * (g + 1),
          P = _ + 1 + c * g;
        m.push(S, w, P), m.push(w, E, P);
      }
    this.setIndex(m),
      this.setAttribute("position", new Ve(v, 3)),
      this.setAttribute("normal", new Ve(A, 3)),
      this.setAttribute("uv", new Ve(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new tc(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var fk = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  hk = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  dk = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  pk = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  mk = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  gk = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  yk = "vec3 transformed = vec3( position );",
  vk = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  xk = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  _k = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  Ak = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  Mk = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  Sk = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  wk = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Ck = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  Ek = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  Tk = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  bk = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  Pk = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  Bk = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  Rk = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  Lk = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  Ik = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  Dk = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  Fk = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  Nk = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  Ok = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  kk = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  Uk = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  zk = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  Gk = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  Hk = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  Vk = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  Wk = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  Jk = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  jk = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  Xk = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  Kk = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  Yk = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  Qk = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  Zk = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  qk = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  $k = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  eU = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  tU = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  nU = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  iU = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  rU = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  sU = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif`,
  oU = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  aU = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  lU = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  uU = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  cU = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  fU = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  hU = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  dU = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  pU = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
  mU = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  gU = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  yU = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  vU = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  xU = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  _U = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  AU = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  MU = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  SU = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  wU = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#ifdef USE_NORMALMAP_TANGENTSPACE
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  CU = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  EU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  TU = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  bU = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  PU = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  BU = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  RU = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  LU = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  IU = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  DU = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  FU = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  NU = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  OU = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  kU = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  UU = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  zU = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  GU = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  HU = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  VU = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  WU = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  JU = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  jU = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  XU = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  KU = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  YU = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  QU = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  ZU = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  qU = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  $U = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  ez = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
  tz = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, vec2 fullSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		
		vec2 lodFudge = pow( 1.95, lod ) / fullSize;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec2 fullSize = vec2( textureSize( sampler, 0 ) );
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), fullSize, floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), fullSize, ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  nz = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  iz = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_UV2
	attribute vec2 uv2;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  rz = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  sz = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const oz = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  az = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  lz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  uz = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  cz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  fz = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  hz = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  dz = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  pz = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  mz = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  gz = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  yz = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  vz = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  xz = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  _z = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  Az = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Mz = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Sz = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  wz = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  Cz = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Ez = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  Tz = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  bz = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Pz = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Bz = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  Rz = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Lz = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Iz = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  Dz = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  Fz = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  Nz = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  Oz = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  kz = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  Uz = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  mt = {
    alphamap_fragment: fk,
    alphamap_pars_fragment: hk,
    alphatest_fragment: dk,
    alphatest_pars_fragment: pk,
    aomap_fragment: mk,
    aomap_pars_fragment: gk,
    begin_vertex: yk,
    beginnormal_vertex: vk,
    bsdfs: xk,
    iridescence_fragment: _k,
    bumpmap_pars_fragment: Ak,
    clipping_planes_fragment: Mk,
    clipping_planes_pars_fragment: Sk,
    clipping_planes_pars_vertex: wk,
    clipping_planes_vertex: Ck,
    color_fragment: Ek,
    color_pars_fragment: Tk,
    color_pars_vertex: bk,
    color_vertex: Pk,
    common: Bk,
    cube_uv_reflection_fragment: Rk,
    defaultnormal_vertex: Lk,
    displacementmap_pars_vertex: Ik,
    displacementmap_vertex: Dk,
    emissivemap_fragment: Fk,
    emissivemap_pars_fragment: Nk,
    encodings_fragment: Ok,
    encodings_pars_fragment: kk,
    envmap_fragment: Uk,
    envmap_common_pars_fragment: zk,
    envmap_pars_fragment: Gk,
    envmap_pars_vertex: Hk,
    envmap_physical_pars_fragment: eU,
    envmap_vertex: Vk,
    fog_vertex: Wk,
    fog_pars_vertex: Jk,
    fog_fragment: jk,
    fog_pars_fragment: Xk,
    gradientmap_pars_fragment: Kk,
    lightmap_fragment: Yk,
    lightmap_pars_fragment: Qk,
    lights_lambert_fragment: Zk,
    lights_lambert_pars_fragment: qk,
    lights_pars_begin: $k,
    lights_toon_fragment: tU,
    lights_toon_pars_fragment: nU,
    lights_phong_fragment: iU,
    lights_phong_pars_fragment: rU,
    lights_physical_fragment: sU,
    lights_physical_pars_fragment: oU,
    lights_fragment_begin: aU,
    lights_fragment_maps: lU,
    lights_fragment_end: uU,
    logdepthbuf_fragment: cU,
    logdepthbuf_pars_fragment: fU,
    logdepthbuf_pars_vertex: hU,
    logdepthbuf_vertex: dU,
    map_fragment: pU,
    map_pars_fragment: mU,
    map_particle_fragment: gU,
    map_particle_pars_fragment: yU,
    metalnessmap_fragment: vU,
    metalnessmap_pars_fragment: xU,
    morphcolor_vertex: _U,
    morphnormal_vertex: AU,
    morphtarget_pars_vertex: MU,
    morphtarget_vertex: SU,
    normal_fragment_begin: wU,
    normal_fragment_maps: CU,
    normal_pars_fragment: EU,
    normal_pars_vertex: TU,
    normal_vertex: bU,
    normalmap_pars_fragment: PU,
    clearcoat_normal_fragment_begin: BU,
    clearcoat_normal_fragment_maps: RU,
    clearcoat_pars_fragment: LU,
    iridescence_pars_fragment: IU,
    output_fragment: DU,
    packing: FU,
    premultiplied_alpha_fragment: NU,
    project_vertex: OU,
    dithering_fragment: kU,
    dithering_pars_fragment: UU,
    roughnessmap_fragment: zU,
    roughnessmap_pars_fragment: GU,
    shadowmap_pars_fragment: HU,
    shadowmap_pars_vertex: VU,
    shadowmap_vertex: WU,
    shadowmask_pars_fragment: JU,
    skinbase_vertex: jU,
    skinning_pars_vertex: XU,
    skinning_vertex: KU,
    skinnormal_vertex: YU,
    specularmap_fragment: QU,
    specularmap_pars_fragment: ZU,
    tonemapping_fragment: qU,
    tonemapping_pars_fragment: $U,
    transmission_fragment: ez,
    transmission_pars_fragment: tz,
    uv_pars_fragment: nz,
    uv_pars_vertex: iz,
    uv_vertex: rz,
    worldpos_vertex: sz,
    background_vert: oz,
    background_frag: az,
    backgroundCube_vert: lz,
    backgroundCube_frag: uz,
    cube_vert: cz,
    cube_frag: fz,
    depth_vert: hz,
    depth_frag: dz,
    distanceRGBA_vert: pz,
    distanceRGBA_frag: mz,
    equirect_vert: gz,
    equirect_frag: yz,
    linedashed_vert: vz,
    linedashed_frag: xz,
    meshbasic_vert: _z,
    meshbasic_frag: Az,
    meshlambert_vert: Mz,
    meshlambert_frag: Sz,
    meshmatcap_vert: wz,
    meshmatcap_frag: Cz,
    meshnormal_vert: Ez,
    meshnormal_frag: Tz,
    meshphong_vert: bz,
    meshphong_frag: Pz,
    meshphysical_vert: Bz,
    meshphysical_frag: Rz,
    meshtoon_vert: Lz,
    meshtoon_frag: Iz,
    points_vert: Dz,
    points_frag: Fz,
    shadow_vert: Nz,
    shadow_frag: Oz,
    sprite_vert: kz,
    sprite_frag: Uz,
  },
  De = {
    common: {
      diffuse: { value: new Ie(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new wt() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new wt() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new wt() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new wt() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new wt() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new wt() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new wt() },
      normalScale: { value: new ge(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new wt() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new wt() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new wt() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new wt() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Ie(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Ie(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new wt() },
    },
    sprite: {
      diffuse: { value: new Ie(16777215) },
      opacity: { value: 1 },
      center: { value: new ge(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new wt() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
  },
  Dr = {
    basic: {
      uniforms: fi([
        De.common,
        De.specularmap,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.fog,
      ]),
      vertexShader: mt.meshbasic_vert,
      fragmentShader: mt.meshbasic_frag,
    },
    lambert: {
      uniforms: fi([
        De.common,
        De.specularmap,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.fog,
        De.lights,
        { emissive: { value: new Ie(0) } },
      ]),
      vertexShader: mt.meshlambert_vert,
      fragmentShader: mt.meshlambert_frag,
    },
    phong: {
      uniforms: fi([
        De.common,
        De.specularmap,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.fog,
        De.lights,
        {
          emissive: { value: new Ie(0) },
          specular: { value: new Ie(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: mt.meshphong_vert,
      fragmentShader: mt.meshphong_frag,
    },
    standard: {
      uniforms: fi([
        De.common,
        De.envmap,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.roughnessmap,
        De.metalnessmap,
        De.fog,
        De.lights,
        {
          emissive: { value: new Ie(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: mt.meshphysical_vert,
      fragmentShader: mt.meshphysical_frag,
    },
    toon: {
      uniforms: fi([
        De.common,
        De.aomap,
        De.lightmap,
        De.emissivemap,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.gradientmap,
        De.fog,
        De.lights,
        { emissive: { value: new Ie(0) } },
      ]),
      vertexShader: mt.meshtoon_vert,
      fragmentShader: mt.meshtoon_frag,
    },
    matcap: {
      uniforms: fi([
        De.common,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        De.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: mt.meshmatcap_vert,
      fragmentShader: mt.meshmatcap_frag,
    },
    points: {
      uniforms: fi([De.points, De.fog]),
      vertexShader: mt.points_vert,
      fragmentShader: mt.points_frag,
    },
    dashed: {
      uniforms: fi([
        De.common,
        De.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: mt.linedashed_vert,
      fragmentShader: mt.linedashed_frag,
    },
    depth: {
      uniforms: fi([De.common, De.displacementmap]),
      vertexShader: mt.depth_vert,
      fragmentShader: mt.depth_frag,
    },
    normal: {
      uniforms: fi([
        De.common,
        De.bumpmap,
        De.normalmap,
        De.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: mt.meshnormal_vert,
      fragmentShader: mt.meshnormal_frag,
    },
    sprite: {
      uniforms: fi([De.sprite, De.fog]),
      vertexShader: mt.sprite_vert,
      fragmentShader: mt.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new wt() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: mt.background_vert,
      fragmentShader: mt.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: mt.backgroundCube_vert,
      fragmentShader: mt.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: mt.cube_vert,
      fragmentShader: mt.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: mt.equirect_vert,
      fragmentShader: mt.equirect_frag,
    },
    distanceRGBA: {
      uniforms: fi([
        De.common,
        De.displacementmap,
        {
          referencePosition: { value: new F() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: mt.distanceRGBA_vert,
      fragmentShader: mt.distanceRGBA_frag,
    },
    shadow: {
      uniforms: fi([
        De.lights,
        De.fog,
        { color: { value: new Ie(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: mt.shadow_vert,
      fragmentShader: mt.shadow_frag,
    },
  };
Dr.physical = {
  uniforms: fi([
    Dr.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new wt() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new wt() },
      clearcoatNormalScale: { value: new ge(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new wt() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new wt() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new wt() },
      sheen: { value: 0 },
      sheenColor: { value: new Ie(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new wt() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new wt() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new wt() },
      transmissionSamplerSize: { value: new ge() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new wt() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Ie(0) },
      specularColor: { value: new Ie(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new wt() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new wt() },
    },
  ]),
  vertexShader: mt.meshphysical_vert,
  fragmentShader: mt.meshphysical_frag,
};
const Sp = { r: 0, b: 0, g: 0 };
function zz(n, e, t, i, r, s, o) {
  const a = new Ie(0);
  let l = s === !0 ? 0 : 1,
    c,
    h,
    d = null,
    p = 0,
    m = null;
  function v(x, g) {
    let _ = !1,
      S = g.isScene === !0 ? g.background : null;
    S && S.isTexture && (S = (g.backgroundBlurriness > 0 ? t : e).get(S));
    const w = n.xr,
      E = w.getSession && w.getSession();
    E && E.environmentBlendMode === "additive" && (S = null),
      S === null ? A(a, l) : S && S.isColor && (A(S, 1), (_ = !0)),
      (n.autoClear || _) &&
        n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil),
      S && (S.isCubeTexture || S.mapping === ec)
        ? (h === void 0 &&
            ((h = new Pn(
              new ta(1, 1, 1),
              new hs({
                name: "BackgroundCubeMaterial",
                uniforms: Wu(Dr.backgroundCube.uniforms),
                vertexShader: Dr.backgroundCube.vertexShader,
                fragmentShader: Dr.backgroundCube.fragmentShader,
                side: mi,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            h.geometry.deleteAttribute("normal"),
            h.geometry.deleteAttribute("uv"),
            (h.onBeforeRender = function (P, L, B) {
              this.matrixWorld.copyPosition(B.matrixWorld);
            }),
            Object.defineProperty(h.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            r.update(h)),
          (h.material.uniforms.envMap.value = S),
          (h.material.uniforms.flipEnvMap.value =
            S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1),
          (h.material.uniforms.backgroundBlurriness.value =
            g.backgroundBlurriness),
          (h.material.uniforms.backgroundIntensity.value =
            g.backgroundIntensity),
          (h.material.toneMapped = S.encoding !== Tt),
          (d !== S || p !== S.version || m !== n.toneMapping) &&
            ((h.material.needsUpdate = !0),
            (d = S),
            (p = S.version),
            (m = n.toneMapping)),
          h.layers.enableAll(),
          x.unshift(h, h.geometry, h.material, 0, 0, null))
        : S &&
          S.isTexture &&
          (c === void 0 &&
            ((c = new Pn(
              new tc(2, 2),
              new hs({
                name: "BackgroundMaterial",
                uniforms: Wu(Dr.background.uniforms),
                vertexShader: Dr.background.vertexShader,
                fragmentShader: Dr.background.fragmentShader,
                side: cs,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            Object.defineProperty(c.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            r.update(c)),
          (c.material.uniforms.t2D.value = S),
          (c.material.uniforms.backgroundIntensity.value =
            g.backgroundIntensity),
          (c.material.toneMapped = S.encoding !== Tt),
          S.matrixAutoUpdate === !0 && S.updateMatrix(),
          c.material.uniforms.uvTransform.value.copy(S.matrix),
          (d !== S || p !== S.version || m !== n.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (d = S),
            (p = S.version),
            (m = n.toneMapping)),
          c.layers.enableAll(),
          x.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function A(x, g) {
    x.getRGB(Sp, jB(n)), i.buffers.color.setClear(Sp.r, Sp.g, Sp.b, g, o);
  }
  return {
    getClearColor: function () {
      return a;
    },
    setClearColor: function (x, g = 1) {
      a.set(x), (l = g), A(a, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (x) {
      (l = x), A(a, l);
    },
    render: v,
  };
}
function Gz(n, e, t, i) {
  const r = n.getParameter(34921),
    s = i.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    o = i.isWebGL2 || s !== null,
    a = {},
    l = x(null);
  let c = l,
    h = !1;
  function d(J, X, oe, ae, I) {
    let G = !1;
    if (o) {
      const z = A(ae, oe, X);
      c !== z && ((c = z), m(c.object)),
        (G = g(J, ae, oe, I)),
        G && _(J, ae, oe, I);
    } else {
      const z = X.wireframe === !0;
      (c.geometry !== ae.id || c.program !== oe.id || c.wireframe !== z) &&
        ((c.geometry = ae.id),
        (c.program = oe.id),
        (c.wireframe = z),
        (G = !0));
    }
    I !== null && t.update(I, 34963),
      (G || h) &&
        ((h = !1),
        B(J, X, oe, ae),
        I !== null && n.bindBuffer(34963, t.get(I).buffer));
  }
  function p() {
    return i.isWebGL2 ? n.createVertexArray() : s.createVertexArrayOES();
  }
  function m(J) {
    return i.isWebGL2 ? n.bindVertexArray(J) : s.bindVertexArrayOES(J);
  }
  function v(J) {
    return i.isWebGL2 ? n.deleteVertexArray(J) : s.deleteVertexArrayOES(J);
  }
  function A(J, X, oe) {
    const ae = oe.wireframe === !0;
    let I = a[J.id];
    I === void 0 && ((I = {}), (a[J.id] = I));
    let G = I[X.id];
    G === void 0 && ((G = {}), (I[X.id] = G));
    let z = G[ae];
    return z === void 0 && ((z = x(p())), (G[ae] = z)), z;
  }
  function x(J) {
    const X = [],
      oe = [],
      ae = [];
    for (let I = 0; I < r; I++) (X[I] = 0), (oe[I] = 0), (ae[I] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: X,
      enabledAttributes: oe,
      attributeDivisors: ae,
      object: J,
      attributes: {},
      index: null,
    };
  }
  function g(J, X, oe, ae) {
    const I = c.attributes,
      G = X.attributes;
    let z = 0;
    const q = oe.getAttributes();
    for (const Q in q)
      if (q[Q].location >= 0) {
        const ne = I[Q];
        let Ce = G[Q];
        if (
          (Ce === void 0 &&
            (Q === "instanceMatrix" &&
              J.instanceMatrix &&
              (Ce = J.instanceMatrix),
            Q === "instanceColor" && J.instanceColor && (Ce = J.instanceColor)),
          ne === void 0 || ne.attribute !== Ce || (Ce && ne.data !== Ce.data))
        )
          return !0;
        z++;
      }
    return c.attributesNum !== z || c.index !== ae;
  }
  function _(J, X, oe, ae) {
    const I = {},
      G = X.attributes;
    let z = 0;
    const q = oe.getAttributes();
    for (const Q in q)
      if (q[Q].location >= 0) {
        let ne = G[Q];
        ne === void 0 &&
          (Q === "instanceMatrix" &&
            J.instanceMatrix &&
            (ne = J.instanceMatrix),
          Q === "instanceColor" && J.instanceColor && (ne = J.instanceColor));
        const Ce = {};
        (Ce.attribute = ne),
          ne && ne.data && (Ce.data = ne.data),
          (I[Q] = Ce),
          z++;
      }
    (c.attributes = I), (c.attributesNum = z), (c.index = ae);
  }
  function S() {
    const J = c.newAttributes;
    for (let X = 0, oe = J.length; X < oe; X++) J[X] = 0;
  }
  function w(J) {
    E(J, 0);
  }
  function E(J, X) {
    const oe = c.newAttributes,
      ae = c.enabledAttributes,
      I = c.attributeDivisors;
    (oe[J] = 1),
      ae[J] === 0 && (n.enableVertexAttribArray(J), (ae[J] = 1)),
      I[J] !== X &&
        ((i.isWebGL2 ? n : e.get("ANGLE_instanced_arrays"))[
          i.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](J, X),
        (I[J] = X));
  }
  function P() {
    const J = c.newAttributes,
      X = c.enabledAttributes;
    for (let oe = 0, ae = X.length; oe < ae; oe++)
      X[oe] !== J[oe] && (n.disableVertexAttribArray(oe), (X[oe] = 0));
  }
  function L(J, X, oe, ae, I, G) {
    i.isWebGL2 === !0 && (oe === 5124 || oe === 5125)
      ? n.vertexAttribIPointer(J, X, oe, I, G)
      : n.vertexAttribPointer(J, X, oe, ae, I, G);
  }
  function B(J, X, oe, ae) {
    if (
      i.isWebGL2 === !1 &&
      (J.isInstancedMesh || ae.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    S();
    const I = ae.attributes,
      G = oe.getAttributes(),
      z = X.defaultAttributeValues;
    for (const q in G) {
      const Q = G[q];
      if (Q.location >= 0) {
        let ee = I[q];
        if (
          (ee === void 0 &&
            (q === "instanceMatrix" &&
              J.instanceMatrix &&
              (ee = J.instanceMatrix),
            q === "instanceColor" && J.instanceColor && (ee = J.instanceColor)),
          ee !== void 0)
        ) {
          const ne = ee.normalized,
            Ce = ee.itemSize,
            _e = t.get(ee);
          if (_e === void 0) continue;
          const $ = _e.buffer,
            je = _e.type,
            Xe = _e.bytesPerElement;
          if (ee.isInterleavedBufferAttribute) {
            const ve = ee.data,
              Me = ve.stride,
              me = ee.offset;
            if (ve.isInstancedInterleavedBuffer) {
              for (let se = 0; se < Q.locationSize; se++)
                E(Q.location + se, ve.meshPerAttribute);
              J.isInstancedMesh !== !0 &&
                ae._maxInstanceCount === void 0 &&
                (ae._maxInstanceCount = ve.meshPerAttribute * ve.count);
            } else
              for (let se = 0; se < Q.locationSize; se++) w(Q.location + se);
            n.bindBuffer(34962, $);
            for (let se = 0; se < Q.locationSize; se++)
              L(
                Q.location + se,
                Ce / Q.locationSize,
                je,
                ne,
                Me * Xe,
                (me + (Ce / Q.locationSize) * se) * Xe
              );
          } else {
            if (ee.isInstancedBufferAttribute) {
              for (let ve = 0; ve < Q.locationSize; ve++)
                E(Q.location + ve, ee.meshPerAttribute);
              J.isInstancedMesh !== !0 &&
                ae._maxInstanceCount === void 0 &&
                (ae._maxInstanceCount = ee.meshPerAttribute * ee.count);
            } else
              for (let ve = 0; ve < Q.locationSize; ve++) w(Q.location + ve);
            n.bindBuffer(34962, $);
            for (let ve = 0; ve < Q.locationSize; ve++)
              L(
                Q.location + ve,
                Ce / Q.locationSize,
                je,
                ne,
                Ce * Xe,
                (Ce / Q.locationSize) * ve * Xe
              );
          }
        } else if (z !== void 0) {
          const ne = z[q];
          if (ne !== void 0)
            switch (ne.length) {
              case 2:
                n.vertexAttrib2fv(Q.location, ne);
                break;
              case 3:
                n.vertexAttrib3fv(Q.location, ne);
                break;
              case 4:
                n.vertexAttrib4fv(Q.location, ne);
                break;
              default:
                n.vertexAttrib1fv(Q.location, ne);
            }
        }
      }
    }
    P();
  }
  function b() {
    j();
    for (const J in a) {
      const X = a[J];
      for (const oe in X) {
        const ae = X[oe];
        for (const I in ae) v(ae[I].object), delete ae[I];
        delete X[oe];
      }
      delete a[J];
    }
  }
  function R(J) {
    if (a[J.id] === void 0) return;
    const X = a[J.id];
    for (const oe in X) {
      const ae = X[oe];
      for (const I in ae) v(ae[I].object), delete ae[I];
      delete X[oe];
    }
    delete a[J.id];
  }
  function U(J) {
    for (const X in a) {
      const oe = a[X];
      if (oe[J.id] === void 0) continue;
      const ae = oe[J.id];
      for (const I in ae) v(ae[I].object), delete ae[I];
      delete oe[J.id];
    }
  }
  function j() {
    V(), (h = !0), c !== l && ((c = l), m(c.object));
  }
  function V() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: d,
    reset: j,
    resetDefaultState: V,
    dispose: b,
    releaseStatesOfGeometry: R,
    releaseStatesOfProgram: U,
    initAttributes: S,
    enableAttribute: w,
    disableUnusedAttributes: P,
  };
}
function Hz(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(c) {
    s = c;
  }
  function a(c, h) {
    n.drawArrays(s, c, h), t.update(h, s, 1);
  }
  function l(c, h, d) {
    if (d === 0) return;
    let p, m;
    if (r) (p = n), (m = "drawArraysInstanced");
    else if (
      ((p = e.get("ANGLE_instanced_arrays")),
      (m = "drawArraysInstancedANGLE"),
      p === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    p[m](s, c, h, d), t.update(h, s, d);
  }
  (this.setMode = o), (this.render = a), (this.renderInstances = l);
}
function Vz(n, e, t) {
  let i;
  function r() {
    if (i !== void 0) return i;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const L = e.get("EXT_texture_filter_anisotropic");
      i = n.getParameter(L.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else i = 0;
    return i;
  }
  function s(L) {
    if (L === "highp") {
      if (
        n.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        n.getShaderPrecisionFormat(35632, 36338).precision > 0
      )
        return "highp";
      L = "mediump";
    }
    return L === "mediump" &&
      n.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
      n.getShaderPrecisionFormat(35632, 36337).precision > 0
      ? "mediump"
      : "lowp";
  }
  const o =
    typeof WebGL2RenderingContext < "u" &&
    n.constructor.name === "WebGL2RenderingContext";
  let a = t.precision !== void 0 ? t.precision : "highp";
  const l = s(a);
  l !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      l,
      "instead."
    ),
    (a = l));
  const c = o || e.has("WEBGL_draw_buffers"),
    h = t.logarithmicDepthBuffer === !0,
    d = n.getParameter(34930),
    p = n.getParameter(35660),
    m = n.getParameter(3379),
    v = n.getParameter(34076),
    A = n.getParameter(34921),
    x = n.getParameter(36347),
    g = n.getParameter(36348),
    _ = n.getParameter(36349),
    S = p > 0,
    w = o || e.has("OES_texture_float"),
    E = S && w,
    P = o ? n.getParameter(36183) : 0;
  return {
    isWebGL2: o,
    drawBuffers: c,
    getMaxAnisotropy: r,
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: h,
    maxTextures: d,
    maxVertexTextures: p,
    maxTextureSize: m,
    maxCubemapSize: v,
    maxAttributes: A,
    maxVertexUniforms: x,
    maxVaryings: g,
    maxFragmentUniforms: _,
    vertexTextures: S,
    floatFragmentTextures: w,
    floatVertexTextures: E,
    maxSamples: P,
  };
}
function Wz(n) {
  const e = this;
  let t = null,
    i = 0,
    r = !1,
    s = !1;
  const o = new Mo(),
    a = new wt(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (d, p) {
      const m = d.length !== 0 || p || i !== 0 || r;
      return (r = p), (i = d.length), m;
    }),
    (this.beginShadows = function () {
      (s = !0), h(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (d, p) {
      t = h(d, p, 0);
    }),
    (this.setState = function (d, p, m) {
      const v = d.clippingPlanes,
        A = d.clipIntersection,
        x = d.clipShadows,
        g = n.get(d);
      if (!r || v === null || v.length === 0 || (s && !x)) s ? h(null) : c();
      else {
        const _ = s ? 0 : i,
          S = _ * 4;
        let w = g.clippingState || null;
        (l.value = w), (w = h(v, p, S, m));
        for (let E = 0; E !== S; ++E) w[E] = t[E];
        (g.clippingState = w),
          (this.numIntersection = A ? this.numPlanes : 0),
          (this.numPlanes += _);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = i > 0)),
      (e.numPlanes = i),
      (e.numIntersection = 0);
  }
  function h(d, p, m, v) {
    const A = d !== null ? d.length : 0;
    let x = null;
    if (A !== 0) {
      if (((x = l.value), v !== !0 || x === null)) {
        const g = m + A * 4,
          _ = p.matrixWorldInverse;
        a.getNormalMatrix(_),
          (x === null || x.length < g) && (x = new Float32Array(g));
        for (let S = 0, w = m; S !== A; ++S, w += 4)
          o.copy(d[S]).applyMatrix4(_, a),
            o.normal.toArray(x, w),
            (x[w + 3] = o.constant);
      }
      (l.value = x), (l.needsUpdate = !0);
    }
    return (e.numPlanes = A), (e.numIntersection = 0), x;
  }
}
function Jz(n) {
  let e = new WeakMap();
  function t(o, a) {
    return a === Yf ? (o.mapping = Wo) : a === Qf && (o.mapping = Jo), o;
  }
  function i(o) {
    if (o && o.isTexture && o.isRenderTargetTexture === !1) {
      const a = o.mapping;
      if (a === Yf || a === Qf)
        if (e.has(o)) {
          const l = e.get(o).texture;
          return t(l, o.mapping);
        } else {
          const l = o.image;
          if (l && l.height > 0) {
            const c = new sA(l.height / 2);
            return (
              c.fromEquirectangularTexture(n, o),
              e.set(o, c),
              o.addEventListener("dispose", r),
              t(c.texture, o.mapping)
            );
          } else return null;
        }
    }
    return o;
  }
  function r(o) {
    const a = o.target;
    a.removeEventListener("dispose", r);
    const l = e.get(a);
    l !== void 0 && (e.delete(a), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: i, dispose: s };
}
class kr extends Mh {
  constructor(e = -1, t = 1, i = 1, r = -1, s = 0.1, o = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = r),
      (this.near = s),
      (this.far = o),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, r, s, o) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = r),
      (this.view.width = s),
      (this.view.height = o),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      r = (this.top + this.bottom) / 2;
    let s = i - e,
      o = i + e,
      a = r + t,
      l = r - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (o = s + c * this.view.width),
        (a -= h * this.view.offsetY),
        (l = a - h * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const gu = 4,
  CC = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  Da = 20,
  tv = new kr(),
  EC = new Ie();
let nv = null;
const Pa = (1 + Math.sqrt(5)) / 2,
  Xl = 1 / Pa,
  TC = [
    new F(1, 1, 1),
    new F(-1, 1, 1),
    new F(1, 1, -1),
    new F(-1, 1, -1),
    new F(0, Pa, Xl),
    new F(0, Pa, -Xl),
    new F(Xl, 0, Pa),
    new F(-Xl, 0, Pa),
    new F(Pa, Xl, 0),
    new F(-Pa, Xl, 0),
  ];
class p_ {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, r = 100) {
    (nv = this._renderer.getRenderTarget()), this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, i, r, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = BC()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = PC()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(nv),
      (e.scissorTest = !1),
      wp(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Wo || e.mapping === Jo
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (nv = this._renderer.getRenderTarget());
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: rn,
        minFilter: rn,
        generateMipmaps: !1,
        type: zu,
        format: Ti,
        encoding: Ks,
        depthBuffer: !1,
      },
      r = bC(e, t, i);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = bC(e, t, i));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = jz(s)),
        (this._blurMaterial = Xz(s, e, t));
    }
    return r;
  }
  _compileMaterial(e) {
    const t = new Pn(this._lodPlanes[0], e);
    this._renderer.compile(t, tv);
  }
  _sceneToCubeUV(e, t, i, r) {
    const a = new Vt(90, 1, t, i),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      h = this._renderer,
      d = h.autoClear,
      p = h.toneMapping;
    h.getClearColor(EC), (h.toneMapping = Or), (h.autoClear = !1);
    const m = new Wi({
        name: "PMREM.Background",
        side: mi,
        depthWrite: !1,
        depthTest: !1,
      }),
      v = new Pn(new ta(), m);
    let A = !1;
    const x = e.background;
    x
      ? x.isColor && (m.color.copy(x), (e.background = null), (A = !0))
      : (m.color.copy(EC), (A = !0));
    for (let g = 0; g < 6; g++) {
      const _ = g % 3;
      _ === 0
        ? (a.up.set(0, l[g], 0), a.lookAt(c[g], 0, 0))
        : _ === 1
        ? (a.up.set(0, 0, l[g]), a.lookAt(0, c[g], 0))
        : (a.up.set(0, l[g], 0), a.lookAt(0, 0, c[g]));
      const S = this._cubeSize;
      wp(r, _ * S, g > 2 ? S : 0, S, S),
        h.setRenderTarget(r),
        A && h.render(v, a),
        h.render(e, a);
    }
    v.geometry.dispose(),
      v.material.dispose(),
      (h.toneMapping = p),
      (h.autoClear = d),
      (e.background = x);
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      r = e.mapping === Wo || e.mapping === Jo;
    r
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = BC()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = PC());
    const s = r ? this._cubemapMaterial : this._equirectMaterial,
      o = new Pn(this._lodPlanes[0], s),
      a = s.uniforms;
    a.envMap.value = e;
    const l = this._cubeSize;
    wp(t, 0, 0, 3 * l, 2 * l), i.setRenderTarget(t), i.render(o, tv);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    for (let r = 1; r < this._lodPlanes.length; r++) {
      const s = Math.sqrt(
          this._sigmas[r] * this._sigmas[r] -
            this._sigmas[r - 1] * this._sigmas[r - 1]
        ),
        o = TC[(r - 1) % TC.length];
      this._blur(e, r - 1, r, s, o);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, r, s) {
    const o = this._pingPongRenderTarget;
    this._halfBlur(e, o, t, i, r, "latitudinal", s),
      this._halfBlur(o, e, i, i, r, "longitudinal", s);
  }
  _halfBlur(e, t, i, r, s, o, a) {
    const l = this._renderer,
      c = this._blurMaterial;
    o !== "latitudinal" &&
      o !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = 3,
      d = new Pn(this._lodPlanes[r], c),
      p = c.uniforms,
      m = this._sizeLods[i] - 1,
      v = isFinite(s) ? Math.PI / (2 * m) : (2 * Math.PI) / (2 * Da - 1),
      A = s / v,
      x = isFinite(s) ? 1 + Math.floor(h * A) : Da;
    x > Da &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${x} samples when the maximum is set to ${Da}`
      );
    const g = [];
    let _ = 0;
    for (let L = 0; L < Da; ++L) {
      const B = L / A,
        b = Math.exp((-B * B) / 2);
      g.push(b), L === 0 ? (_ += b) : L < x && (_ += 2 * b);
    }
    for (let L = 0; L < g.length; L++) g[L] = g[L] / _;
    (p.envMap.value = e.texture),
      (p.samples.value = x),
      (p.weights.value = g),
      (p.latitudinal.value = o === "latitudinal"),
      a && (p.poleAxis.value = a);
    const { _lodMax: S } = this;
    (p.dTheta.value = v), (p.mipInt.value = S - i);
    const w = this._sizeLods[r],
      E = 3 * w * (r > S - gu ? r - S + gu : 0),
      P = 4 * (this._cubeSize - w);
    wp(t, E, P, 3 * w, 2 * w), l.setRenderTarget(t), l.render(d, tv);
  }
}
function jz(n) {
  const e = [],
    t = [],
    i = [];
  let r = n;
  const s = n - gu + 1 + CC.length;
  for (let o = 0; o < s; o++) {
    const a = Math.pow(2, r);
    t.push(a);
    let l = 1 / a;
    o > n - gu ? (l = CC[o - n + gu - 1]) : o === 0 && (l = 0), i.push(l);
    const c = 1 / (a - 2),
      h = -c,
      d = 1 + c,
      p = [h, h, d, h, d, d, h, h, d, d, h, d],
      m = 6,
      v = 6,
      A = 3,
      x = 2,
      g = 1,
      _ = new Float32Array(A * v * m),
      S = new Float32Array(x * v * m),
      w = new Float32Array(g * v * m);
    for (let P = 0; P < m; P++) {
      const L = ((P % 3) * 2) / 3 - 1,
        B = P > 2 ? 0 : -1,
        b = [
          L,
          B,
          0,
          L + 2 / 3,
          B,
          0,
          L + 2 / 3,
          B + 1,
          0,
          L,
          B,
          0,
          L + 2 / 3,
          B + 1,
          0,
          L,
          B + 1,
          0,
        ];
      _.set(b, A * v * P), S.set(p, x * v * P);
      const R = [P, P, P, P, P, P];
      w.set(R, g * v * P);
    }
    const E = new ct();
    E.setAttribute("position", new Dt(_, A)),
      E.setAttribute("uv", new Dt(S, x)),
      E.setAttribute("faceIndex", new Dt(w, g)),
      e.push(E),
      r > gu && r--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: i };
}
function bC(n, e, t) {
  const i = new Gr(n, e, t);
  return (
    (i.texture.mapping = ec),
    (i.texture.name = "PMREM.cubeUv"),
    (i.scissorTest = !0),
    i
  );
}
function wp(n, e, t, i, r) {
  n.viewport.set(e, t, i, r), n.scissor.set(e, t, i, r);
}
function Xz(n, e, t) {
  const i = new Float32Array(Da),
    r = new F(0, 1, 0);
  return new hs({
    name: "SphericalGaussianBlur",
    defines: {
      n: Da,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${n}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: i },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: r },
    },
    vertexShader: oA(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: zs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function PC() {
  return new hs({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: oA(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: zs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function BC() {
  return new hs({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: oA(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: zs,
    depthTest: !1,
    depthWrite: !1,
  });
}
function oA() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function Kz(n) {
  let e = new WeakMap(),
    t = null;
  function i(a) {
    if (a && a.isTexture) {
      const l = a.mapping,
        c = l === Yf || l === Qf,
        h = l === Wo || l === Jo;
      if (c || h)
        if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) {
          a.needsPMREMUpdate = !1;
          let d = e.get(a);
          return (
            t === null && (t = new p_(n)),
            (d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d)),
            e.set(a, d),
            d.texture
          );
        } else {
          if (e.has(a)) return e.get(a).texture;
          {
            const d = a.image;
            if ((c && d && d.height > 0) || (h && d && r(d))) {
              t === null && (t = new p_(n));
              const p = c ? t.fromEquirectangular(a) : t.fromCubemap(a);
              return e.set(a, p), a.addEventListener("dispose", s), p.texture;
            } else return null;
          }
        }
    }
    return a;
  }
  function r(a) {
    let l = 0;
    const c = 6;
    for (let h = 0; h < c; h++) a[h] !== void 0 && l++;
    return l === c;
  }
  function s(a) {
    const l = a.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function o() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: i, dispose: o };
}
function Yz(n) {
  const e = {};
  function t(i) {
    if (e[i] !== void 0) return e[i];
    let r;
    switch (i) {
      case "WEBGL_depth_texture":
        r =
          n.getExtension("WEBGL_depth_texture") ||
          n.getExtension("MOZ_WEBGL_depth_texture") ||
          n.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        r =
          n.getExtension("EXT_texture_filter_anisotropic") ||
          n.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        r =
          n.getExtension("WEBGL_compressed_texture_s3tc") ||
          n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        r =
          n.getExtension("WEBGL_compressed_texture_pvrtc") ||
          n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        r = n.getExtension(i);
    }
    return (e[i] = r), r;
  }
  return {
    has: function (i) {
      return t(i) !== null;
    },
    init: function (i) {
      i.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (i) {
      const r = t(i);
      return (
        r === null &&
          console.warn(
            "THREE.WebGLRenderer: " + i + " extension not supported."
          ),
        r
      );
    },
  };
}
function Qz(n, e, t, i) {
  const r = {},
    s = new WeakMap();
  function o(d) {
    const p = d.target;
    p.index !== null && e.remove(p.index);
    for (const v in p.attributes) e.remove(p.attributes[v]);
    p.removeEventListener("dispose", o), delete r[p.id];
    const m = s.get(p);
    m && (e.remove(m), s.delete(p)),
      i.releaseStatesOfGeometry(p),
      p.isInstancedBufferGeometry === !0 && delete p._maxInstanceCount,
      t.memory.geometries--;
  }
  function a(d, p) {
    return (
      r[p.id] === !0 ||
        (p.addEventListener("dispose", o),
        (r[p.id] = !0),
        t.memory.geometries++),
      p
    );
  }
  function l(d) {
    const p = d.attributes;
    for (const v in p) e.update(p[v], 34962);
    const m = d.morphAttributes;
    for (const v in m) {
      const A = m[v];
      for (let x = 0, g = A.length; x < g; x++) e.update(A[x], 34962);
    }
  }
  function c(d) {
    const p = [],
      m = d.index,
      v = d.attributes.position;
    let A = 0;
    if (m !== null) {
      const _ = m.array;
      A = m.version;
      for (let S = 0, w = _.length; S < w; S += 3) {
        const E = _[S + 0],
          P = _[S + 1],
          L = _[S + 2];
        p.push(E, P, P, L, L, E);
      }
    } else {
      const _ = v.array;
      A = v.version;
      for (let S = 0, w = _.length / 3 - 1; S < w; S += 3) {
        const E = S + 0,
          P = S + 1,
          L = S + 2;
        p.push(E, P, P, L, L, E);
      }
    }
    const x = new (WB(p) ? iA : nA)(p, 1);
    x.version = A;
    const g = s.get(d);
    g && e.remove(g), s.set(d, x);
  }
  function h(d) {
    const p = s.get(d);
    if (p) {
      const m = d.index;
      m !== null && p.version < m.version && c(d);
    } else c(d);
    return s.get(d);
  }
  return { get: a, update: l, getWireframeAttribute: h };
}
function Zz(n, e, t, i) {
  const r = i.isWebGL2;
  let s;
  function o(p) {
    s = p;
  }
  let a, l;
  function c(p) {
    (a = p.type), (l = p.bytesPerElement);
  }
  function h(p, m) {
    n.drawElements(s, m, a, p * l), t.update(m, s, 1);
  }
  function d(p, m, v) {
    if (v === 0) return;
    let A, x;
    if (r) (A = n), (x = "drawElementsInstanced");
    else if (
      ((A = e.get("ANGLE_instanced_arrays")),
      (x = "drawElementsInstancedANGLE"),
      A === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    A[x](s, m, a, p * l, v), t.update(m, s, v);
  }
  (this.setMode = o),
    (this.setIndex = c),
    (this.render = h),
    (this.renderInstances = d);
}
function qz(n) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function i(s, o, a) {
    switch ((t.calls++, o)) {
      case 4:
        t.triangles += a * (s / 3);
        break;
      case 1:
        t.lines += a * (s / 2);
        break;
      case 3:
        t.lines += a * (s - 1);
        break;
      case 2:
        t.lines += a * s;
        break;
      case 0:
        t.points += a * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", o);
        break;
    }
  }
  function r() {
    t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: r,
    update: i,
  };
}
function $z(n, e) {
  return n[0] - e[0];
}
function e4(n, e) {
  return Math.abs(e[1]) - Math.abs(n[1]);
}
function t4(n, e, t) {
  const i = {},
    r = new Float32Array(8),
    s = new WeakMap(),
    o = new Ot(),
    a = [];
  for (let c = 0; c < 8; c++) a[c] = [c, 0];
  function l(c, h, d) {
    const p = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const v =
          h.morphAttributes.position ||
          h.morphAttributes.normal ||
          h.morphAttributes.color,
        A = v !== void 0 ? v.length : 0;
      let x = s.get(h);
      if (x === void 0 || x.count !== A) {
        let X = function () {
          V.dispose(), s.delete(h), h.removeEventListener("dispose", X);
        };
        var m = X;
        x !== void 0 && x.texture.dispose();
        const S = h.morphAttributes.position !== void 0,
          w = h.morphAttributes.normal !== void 0,
          E = h.morphAttributes.color !== void 0,
          P = h.morphAttributes.position || [],
          L = h.morphAttributes.normal || [],
          B = h.morphAttributes.color || [];
        let b = 0;
        S === !0 && (b = 1), w === !0 && (b = 2), E === !0 && (b = 3);
        let R = h.attributes.position.count * b,
          U = 1;
        R > e.maxTextureSize &&
          ((U = Math.ceil(R / e.maxTextureSize)), (R = e.maxTextureSize));
        const j = new Float32Array(R * U * 4 * A),
          V = new Dg(j, R, U, A);
        (V.type = Ns), (V.needsUpdate = !0);
        const J = b * 4;
        for (let oe = 0; oe < A; oe++) {
          const ae = P[oe],
            I = L[oe],
            G = B[oe],
            z = R * U * 4 * oe;
          for (let q = 0; q < ae.count; q++) {
            const Q = q * J;
            S === !0 &&
              (o.fromBufferAttribute(ae, q),
              (j[z + Q + 0] = o.x),
              (j[z + Q + 1] = o.y),
              (j[z + Q + 2] = o.z),
              (j[z + Q + 3] = 0)),
              w === !0 &&
                (o.fromBufferAttribute(I, q),
                (j[z + Q + 4] = o.x),
                (j[z + Q + 5] = o.y),
                (j[z + Q + 6] = o.z),
                (j[z + Q + 7] = 0)),
              E === !0 &&
                (o.fromBufferAttribute(G, q),
                (j[z + Q + 8] = o.x),
                (j[z + Q + 9] = o.y),
                (j[z + Q + 10] = o.z),
                (j[z + Q + 11] = G.itemSize === 4 ? o.w : 1));
          }
        }
        (x = { count: A, texture: V, size: new ge(R, U) }),
          s.set(h, x),
          h.addEventListener("dispose", X);
      }
      let g = 0;
      for (let S = 0; S < p.length; S++) g += p[S];
      const _ = h.morphTargetsRelative ? 1 : 1 - g;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", _),
        d.getUniforms().setValue(n, "morphTargetInfluences", p),
        d.getUniforms().setValue(n, "morphTargetsTexture", x.texture, t),
        d.getUniforms().setValue(n, "morphTargetsTextureSize", x.size);
    } else {
      const v = p === void 0 ? 0 : p.length;
      let A = i[h.id];
      if (A === void 0 || A.length !== v) {
        A = [];
        for (let w = 0; w < v; w++) A[w] = [w, 0];
        i[h.id] = A;
      }
      for (let w = 0; w < v; w++) {
        const E = A[w];
        (E[0] = w), (E[1] = p[w]);
      }
      A.sort(e4);
      for (let w = 0; w < 8; w++)
        w < v && A[w][1]
          ? ((a[w][0] = A[w][0]), (a[w][1] = A[w][1]))
          : ((a[w][0] = Number.MAX_SAFE_INTEGER), (a[w][1] = 0));
      a.sort($z);
      const x = h.morphAttributes.position,
        g = h.morphAttributes.normal;
      let _ = 0;
      for (let w = 0; w < 8; w++) {
        const E = a[w],
          P = E[0],
          L = E[1];
        P !== Number.MAX_SAFE_INTEGER && L
          ? (x &&
              h.getAttribute("morphTarget" + w) !== x[P] &&
              h.setAttribute("morphTarget" + w, x[P]),
            g &&
              h.getAttribute("morphNormal" + w) !== g[P] &&
              h.setAttribute("morphNormal" + w, g[P]),
            (r[w] = L),
            (_ += L))
          : (x &&
              h.hasAttribute("morphTarget" + w) === !0 &&
              h.deleteAttribute("morphTarget" + w),
            g &&
              h.hasAttribute("morphNormal" + w) === !0 &&
              h.deleteAttribute("morphNormal" + w),
            (r[w] = 0));
      }
      const S = h.morphTargetsRelative ? 1 : 1 - _;
      d.getUniforms().setValue(n, "morphTargetBaseInfluence", S),
        d.getUniforms().setValue(n, "morphTargetInfluences", r);
    }
  }
  return { update: l };
}
function n4(n, e, t, i) {
  let r = new WeakMap();
  function s(l) {
    const c = i.render.frame,
      h = l.geometry,
      d = e.get(l, h);
    return (
      r.get(d) !== c && (e.update(d), r.set(d, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", a) === !1 &&
          l.addEventListener("dispose", a),
        t.update(l.instanceMatrix, 34962),
        l.instanceColor !== null && t.update(l.instanceColor, 34962)),
      d
    );
  }
  function o() {
    r = new WeakMap();
  }
  function a(l) {
    const c = l.target;
    c.removeEventListener("dispose", a),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: s, dispose: o };
}
const YB = new en(),
  QB = new Dg(),
  ZB = new tA(),
  qB = new Sh(),
  RC = [],
  LC = [],
  IC = new Float32Array(16),
  DC = new Float32Array(9),
  FC = new Float32Array(4);
function nc(n, e, t) {
  const i = n[0];
  if (i <= 0 || i > 0) return n;
  const r = e * t;
  let s = RC[r];
  if ((s === void 0 && ((s = new Float32Array(r)), (RC[r] = s)), e !== 0)) {
    i.toArray(s, 0);
    for (let o = 1, a = 0; o !== e; ++o) (a += t), n[o].toArray(s, a);
  }
  return s;
}
function Bn(n, e) {
  if (n.length !== e.length) return !1;
  for (let t = 0, i = n.length; t < i; t++) if (n[t] !== e[t]) return !1;
  return !0;
}
function Rn(n, e) {
  for (let t = 0, i = e.length; t < i; t++) n[t] = e[t];
}
function Ng(n, e) {
  let t = LC[e];
  t === void 0 && ((t = new Int32Array(e)), (LC[e] = t));
  for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
  return t;
}
function i4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1f(this.addr, e), (t[0] = e));
}
function r4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Bn(t, e)) return;
    n.uniform2fv(this.addr, e), Rn(t, e);
  }
}
function s4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (n.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Bn(t, e)) return;
    n.uniform3fv(this.addr, e), Rn(t, e);
  }
}
function o4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Bn(t, e)) return;
    n.uniform4fv(this.addr, e), Rn(t, e);
  }
}
function a4(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Bn(t, e)) return;
    n.uniformMatrix2fv(this.addr, !1, e), Rn(t, e);
  } else {
    if (Bn(t, i)) return;
    FC.set(i), n.uniformMatrix2fv(this.addr, !1, FC), Rn(t, i);
  }
}
function l4(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Bn(t, e)) return;
    n.uniformMatrix3fv(this.addr, !1, e), Rn(t, e);
  } else {
    if (Bn(t, i)) return;
    DC.set(i), n.uniformMatrix3fv(this.addr, !1, DC), Rn(t, i);
  }
}
function u4(n, e) {
  const t = this.cache,
    i = e.elements;
  if (i === void 0) {
    if (Bn(t, e)) return;
    n.uniformMatrix4fv(this.addr, !1, e), Rn(t, e);
  } else {
    if (Bn(t, i)) return;
    IC.set(i), n.uniformMatrix4fv(this.addr, !1, IC), Rn(t, i);
  }
}
function c4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1i(this.addr, e), (t[0] = e));
}
function f4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Bn(t, e)) return;
    n.uniform2iv(this.addr, e), Rn(t, e);
  }
}
function h4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Bn(t, e)) return;
    n.uniform3iv(this.addr, e), Rn(t, e);
  }
}
function d4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Bn(t, e)) return;
    n.uniform4iv(this.addr, e), Rn(t, e);
  }
}
function p4(n, e) {
  const t = this.cache;
  t[0] !== e && (n.uniform1ui(this.addr, e), (t[0] = e));
}
function m4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (n.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Bn(t, e)) return;
    n.uniform2uiv(this.addr, e), Rn(t, e);
  }
}
function g4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (n.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Bn(t, e)) return;
    n.uniform3uiv(this.addr, e), Rn(t, e);
  }
}
function y4(n, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Bn(t, e)) return;
    n.uniform4uiv(this.addr, e), Rn(t, e);
  }
}
function v4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2D(e || YB, r);
}
function x4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture3D(e || ZB, r);
}
function _4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTextureCube(e || qB, r);
}
function A4(n, e, t) {
  const i = this.cache,
    r = t.allocateTextureUnit();
  i[0] !== r && (n.uniform1i(this.addr, r), (i[0] = r)),
    t.setTexture2DArray(e || QB, r);
}
function M4(n) {
  switch (n) {
    case 5126:
      return i4;
    case 35664:
      return r4;
    case 35665:
      return s4;
    case 35666:
      return o4;
    case 35674:
      return a4;
    case 35675:
      return l4;
    case 35676:
      return u4;
    case 5124:
    case 35670:
      return c4;
    case 35667:
    case 35671:
      return f4;
    case 35668:
    case 35672:
      return h4;
    case 35669:
    case 35673:
      return d4;
    case 5125:
      return p4;
    case 36294:
      return m4;
    case 36295:
      return g4;
    case 36296:
      return y4;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return v4;
    case 35679:
    case 36299:
    case 36307:
      return x4;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return _4;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return A4;
  }
}
function S4(n, e) {
  n.uniform1fv(this.addr, e);
}
function w4(n, e) {
  const t = nc(e, this.size, 2);
  n.uniform2fv(this.addr, t);
}
function C4(n, e) {
  const t = nc(e, this.size, 3);
  n.uniform3fv(this.addr, t);
}
function E4(n, e) {
  const t = nc(e, this.size, 4);
  n.uniform4fv(this.addr, t);
}
function T4(n, e) {
  const t = nc(e, this.size, 4);
  n.uniformMatrix2fv(this.addr, !1, t);
}
function b4(n, e) {
  const t = nc(e, this.size, 9);
  n.uniformMatrix3fv(this.addr, !1, t);
}
function P4(n, e) {
  const t = nc(e, this.size, 16);
  n.uniformMatrix4fv(this.addr, !1, t);
}
function B4(n, e) {
  n.uniform1iv(this.addr, e);
}
function R4(n, e) {
  n.uniform2iv(this.addr, e);
}
function L4(n, e) {
  n.uniform3iv(this.addr, e);
}
function I4(n, e) {
  n.uniform4iv(this.addr, e);
}
function D4(n, e) {
  n.uniform1uiv(this.addr, e);
}
function F4(n, e) {
  n.uniform2uiv(this.addr, e);
}
function N4(n, e) {
  n.uniform3uiv(this.addr, e);
}
function O4(n, e) {
  n.uniform4uiv(this.addr, e);
}
function k4(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Ng(t, r);
  Bn(i, s) || (n.uniform1iv(this.addr, s), Rn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2D(e[o] || YB, s[o]);
}
function U4(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Ng(t, r);
  Bn(i, s) || (n.uniform1iv(this.addr, s), Rn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture3D(e[o] || ZB, s[o]);
}
function z4(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Ng(t, r);
  Bn(i, s) || (n.uniform1iv(this.addr, s), Rn(i, s));
  for (let o = 0; o !== r; ++o) t.setTextureCube(e[o] || qB, s[o]);
}
function G4(n, e, t) {
  const i = this.cache,
    r = e.length,
    s = Ng(t, r);
  Bn(i, s) || (n.uniform1iv(this.addr, s), Rn(i, s));
  for (let o = 0; o !== r; ++o) t.setTexture2DArray(e[o] || QB, s[o]);
}
function H4(n) {
  switch (n) {
    case 5126:
      return S4;
    case 35664:
      return w4;
    case 35665:
      return C4;
    case 35666:
      return E4;
    case 35674:
      return T4;
    case 35675:
      return b4;
    case 35676:
      return P4;
    case 5124:
    case 35670:
      return B4;
    case 35667:
    case 35671:
      return R4;
    case 35668:
    case 35672:
      return L4;
    case 35669:
    case 35673:
      return I4;
    case 5125:
      return D4;
    case 36294:
      return F4;
    case 36295:
      return N4;
    case 36296:
      return O4;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return k4;
    case 35679:
    case 36299:
    case 36307:
      return U4;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return z4;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return G4;
  }
}
class V4 {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = M4(t.type));
  }
}
class W4 {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = H4(t.type));
  }
}
class J4 {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    const r = this.seq;
    for (let s = 0, o = r.length; s !== o; ++s) {
      const a = r[s];
      a.setValue(e, t[a.id], i);
    }
  }
}
const iv = /(\w+)(\])?(\[|\.)?/g;
function NC(n, e) {
  n.seq.push(e), (n.map[e.id] = e);
}
function j4(n, e, t) {
  const i = n.name,
    r = i.length;
  for (iv.lastIndex = 0; ; ) {
    const s = iv.exec(i),
      o = iv.lastIndex;
    let a = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (a = a | 0), c === void 0 || (c === "[" && o + 2 === r))) {
      NC(t, c === void 0 ? new V4(a, n, e) : new W4(a, n, e));
      break;
    } else {
      let d = t.map[a];
      d === void 0 && ((d = new J4(a)), NC(t, d)), (t = d);
    }
  }
}
class _m {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(t, 35718);
    for (let r = 0; r < i; ++r) {
      const s = e.getActiveUniform(t, r),
        o = e.getUniformLocation(t, s.name);
      j4(s, o, this);
    }
  }
  setValue(e, t, i, r) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, i, r);
  }
  setOptional(e, t, i) {
    const r = t[i];
    r !== void 0 && this.setValue(e, i, r);
  }
  static upload(e, t, i, r) {
    for (let s = 0, o = t.length; s !== o; ++s) {
      const a = t[s],
        l = i[a.id];
      l.needsUpdate !== !1 && a.setValue(e, l.value, r);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let r = 0, s = e.length; r !== s; ++r) {
      const o = e[r];
      o.id in t && i.push(o);
    }
    return i;
  }
}
function OC(n, e, t) {
  const i = n.createShader(e);
  return n.shaderSource(i, t), n.compileShader(i), i;
}
let X4 = 0;
function K4(n, e) {
  const t = n.split(`
`),
    i = [],
    r = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let o = r; o < s; o++) {
    const a = o + 1;
    i.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`);
  }
  return i.join(`
`);
}
function Y4(n) {
  switch (n) {
    case Ks:
      return ["Linear", "( value )"];
    case Tt:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported encoding:", n),
        ["Linear", "( value )"]
      );
  }
}
function kC(n, e, t) {
  const i = n.getShaderParameter(e, 35713),
    r = n.getShaderInfoLog(e).trim();
  if (i && r === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(r);
  if (s) {
    const o = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      r +
      `

` +
      K4(n.getShaderSource(e), o)
    );
  } else return r;
}
function Q4(n, e) {
  const t = Y4(e);
  return "vec4 " + n + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function Z4(n, e) {
  let t;
  switch (e) {
    case mB:
      t = "Linear";
      break;
    case gB:
      t = "Reinhard";
      break;
    case yB:
      t = "OptimizedCineon";
      break;
    case X1:
      t = "ACESFilmic";
      break;
    case vB:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function q4(n) {
  return [
    n.extensionDerivatives ||
    n.envMapCubeUVHeight ||
    n.bumpMap ||
    n.normalMapTangentSpace ||
    n.clearcoatNormalMap ||
    n.flatShading ||
    n.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (n.extensionFragDepth || n.logarithmicDepthBuffer) &&
    n.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    n.extensionDrawBuffers && n.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (n.extensionShaderTextureLOD || n.envMap || n.transmission) &&
    n.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(uf).join(`
`);
}
function $4(n) {
  const e = [];
  for (const t in n) {
    const i = n[t];
    i !== !1 && e.push("#define " + t + " " + i);
  }
  return e.join(`
`);
}
function eG(n, e) {
  const t = {},
    i = n.getProgramParameter(e, 35721);
  for (let r = 0; r < i; r++) {
    const s = n.getActiveAttrib(e, r),
      o = s.name;
    let a = 1;
    s.type === 35674 && (a = 2),
      s.type === 35675 && (a = 3),
      s.type === 35676 && (a = 4),
      (t[o] = {
        type: s.type,
        location: n.getAttribLocation(e, o),
        locationSize: a,
      });
  }
  return t;
}
function uf(n) {
  return n !== "";
}
function UC(n, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return n
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function zC(n, e) {
  return n
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const tG = /^[ \t]*#include +<([\w\d./]+)>/gm;
function m_(n) {
  return n.replace(tG, nG);
}
function nG(n, e) {
  const t = mt[e];
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return m_(t);
}
const iG =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function GC(n) {
  return n.replace(iG, rG);
}
function rG(n, e, t, i) {
  let r = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    r += i
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return r;
}
function HC(n) {
  let e =
    "precision " +
    n.precision +
    ` float;
precision ` +
    n.precision +
    " int;";
  return (
    n.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : n.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : n.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function sG(n) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    n.shadowMapType === Bg
      ? (e = "SHADOWMAP_TYPE_PCF")
      : n.shadowMapType === _f
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : n.shadowMapType === Ua && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function oG(n) {
  let e = "ENVMAP_TYPE_CUBE";
  if (n.envMap)
    switch (n.envMapMode) {
      case Wo:
      case Jo:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case ec:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function aG(n) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (n.envMap)
    switch (n.envMapMode) {
      case Jo:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function lG(n) {
  let e = "ENVMAP_BLENDING_NONE";
  if (n.envMap)
    switch (n.combine) {
      case _h:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case dB:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case pB:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function uG(n) {
  const e = n.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    i = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: i,
    maxMip: t,
  };
}
function cG(n, e, t, i) {
  const r = n.getContext(),
    s = t.defines;
  let o = t.vertexShader,
    a = t.fragmentShader;
  const l = sG(t),
    c = oG(t),
    h = aG(t),
    d = lG(t),
    p = uG(t),
    m = t.isWebGL2 ? "" : q4(t),
    v = $4(s),
    A = r.createProgram();
  let x,
    g,
    _ = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((x = [v].filter(uf).join(`
`)),
      x.length > 0 &&
        (x += `
`),
      (g = [m, v].filter(uf).join(`
`)),
      g.length > 0 &&
        (g += `
`))
    : ((x = [
        HC(t),
        "#define SHADER_NAME " + t.shaderName,
        v,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + h : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs2 ? "#define USE_UV2" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(uf).join(`
`)),
      (g = [
        m,
        HC(t),
        "#define SHADER_NAME " + t.shaderName,
        v,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + h : "",
        t.envMap ? "#define " + d : "",
        p ? "#define CUBEUV_TEXEL_WIDTH " + p.texelWidth : "",
        p ? "#define CUBEUV_TEXEL_HEIGHT " + p.texelHeight : "",
        p ? "#define CUBEUV_MAX_MIP " + p.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUvs2 ? "#define USE_UV2" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== Or ? "#define TONE_MAPPING" : "",
        t.toneMapping !== Or ? mt.tonemapping_pars_fragment : "",
        t.toneMapping !== Or ? Z4("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        mt.encodings_pars_fragment,
        Q4("linearToOutputTexel", t.outputEncoding),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(uf).join(`
`))),
    (o = m_(o)),
    (o = UC(o, t)),
    (o = zC(o, t)),
    (a = m_(a)),
    (a = UC(a, t)),
    (a = zC(a, t)),
    (o = GC(o)),
    (a = GC(a)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((_ = `#version 300 es
`),
      (x =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        x),
      (g =
        [
          "#define varying in",
          t.glslVersion === h_
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === h_ ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        g));
  const S = _ + x + o,
    w = _ + g + a,
    E = OC(r, 35633, S),
    P = OC(r, 35632, w);
  if (
    (r.attachShader(A, E),
    r.attachShader(A, P),
    t.index0AttributeName !== void 0
      ? r.bindAttribLocation(A, 0, t.index0AttributeName)
      : t.morphTargets === !0 && r.bindAttribLocation(A, 0, "position"),
    r.linkProgram(A),
    n.debug.checkShaderErrors)
  ) {
    const b = r.getProgramInfoLog(A).trim(),
      R = r.getShaderInfoLog(E).trim(),
      U = r.getShaderInfoLog(P).trim();
    let j = !0,
      V = !0;
    if (r.getProgramParameter(A, 35714) === !1)
      if (((j = !1), typeof n.debug.onShaderError == "function"))
        n.debug.onShaderError(r, A, E, P);
      else {
        const J = kC(r, E, "vertex"),
          X = kC(r, P, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            r.getError() +
            " - VALIDATE_STATUS " +
            r.getProgramParameter(A, 35715) +
            `

Program Info Log: ` +
            b +
            `
` +
            J +
            `
` +
            X
        );
      }
    else
      b !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", b)
        : (R === "" || U === "") && (V = !1);
    V &&
      (this.diagnostics = {
        runnable: j,
        programLog: b,
        vertexShader: { log: R, prefix: x },
        fragmentShader: { log: U, prefix: g },
      });
  }
  r.deleteShader(E), r.deleteShader(P);
  let L;
  this.getUniforms = function () {
    return L === void 0 && (L = new _m(r, A)), L;
  };
  let B;
  return (
    (this.getAttributes = function () {
      return B === void 0 && (B = eG(r, A)), B;
    }),
    (this.destroy = function () {
      i.releaseStatesOfProgram(this),
        r.deleteProgram(A),
        (this.program = void 0);
    }),
    (this.name = t.shaderName),
    (this.id = X4++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = A),
    (this.vertexShader = E),
    (this.fragmentShader = P),
    this
  );
}
let fG = 0;
class hG {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      r = this._getShaderStage(t),
      s = this._getShaderStage(i),
      o = this._getShaderCacheForMaterial(e);
    return (
      o.has(r) === !1 && (o.add(r), r.usedTimes++),
      o.has(s) === !1 && (o.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return i === void 0 && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return i === void 0 && ((i = new dG(e)), t.set(e, i)), i;
  }
}
class dG {
  constructor(e) {
    (this.id = fG++), (this.code = e), (this.usedTimes = 0);
  }
}
function pG(n, e, t, i, r, s, o) {
  const a = new Za(),
    l = new hG(),
    c = [],
    h = r.isWebGL2,
    d = r.logarithmicDepthBuffer,
    p = r.vertexTextures;
  let m = r.precision;
  const v = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function A(b) {
    return b === 1 ? "uv2" : "uv";
  }
  function x(b, R, U, j, V) {
    const J = j.fog,
      X = V.geometry,
      oe = b.isMeshStandardMaterial ? j.environment : null,
      ae = (b.isMeshStandardMaterial ? t : e).get(b.envMap || oe),
      I = ae && ae.mapping === ec ? ae.image.height : null,
      G = v[b.type];
    b.precision !== null &&
      ((m = r.getMaxPrecision(b.precision)),
      m !== b.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          b.precision,
          "not supported, using",
          m,
          "instead."
        ));
    const z =
        X.morphAttributes.position ||
        X.morphAttributes.normal ||
        X.morphAttributes.color,
      q = z !== void 0 ? z.length : 0;
    let Q = 0;
    X.morphAttributes.position !== void 0 && (Q = 1),
      X.morphAttributes.normal !== void 0 && (Q = 2),
      X.morphAttributes.color !== void 0 && (Q = 3);
    let ee, ne, Ce, _e;
    if (G) {
      const ke = Dr[G];
      (ee = ke.vertexShader), (ne = ke.fragmentShader);
    } else
      (ee = b.vertexShader),
        (ne = b.fragmentShader),
        l.update(b),
        (Ce = l.getVertexShaderID(b)),
        (_e = l.getFragmentShaderID(b));
    const $ = n.getRenderTarget(),
      je = V.isInstancedMesh === !0,
      Xe = !!b.map,
      ve = !!b.matcap,
      Me = !!ae,
      me = !!b.aoMap,
      se = !!b.lightMap,
      xe = !!b.bumpMap,
      Ne = !!b.normalMap,
      Le = !!b.displacementMap,
      We = !!b.emissiveMap,
      Ke = !!b.metalnessMap,
      Je = !!b.roughnessMap,
      nt = b.clearcoat > 0,
      _t = b.iridescence > 0,
      k = b.sheen > 0,
      D = b.transmission > 0,
      le = nt && !!b.clearcoatMap,
      Ee = nt && !!b.clearcoatNormalMap,
      Te = nt && !!b.clearcoatRoughnessMap,
      Re = _t && !!b.iridescenceMap,
      et = _t && !!b.iridescenceThicknessMap,
      Ue = k && !!b.sheenColorMap,
      de = k && !!b.sheenRoughnessMap,
      He = !!b.specularMap,
      W = !!b.specularColorMap,
      he = !!b.specularIntensityMap,
      Ae = D && !!b.transmissionMap,
      Pe = D && !!b.thicknessMap,
      qe = !!b.gradientMap,
      ft = !!b.alphaMap,
      Ut = b.alphaTest > 0,
      K = !!b.extensions,
      ce = !!X.attributes.uv2;
    return {
      isWebGL2: h,
      shaderID: G,
      shaderName: b.type,
      vertexShader: ee,
      fragmentShader: ne,
      defines: b.defines,
      customVertexShaderID: Ce,
      customFragmentShaderID: _e,
      isRawShaderMaterial: b.isRawShaderMaterial === !0,
      glslVersion: b.glslVersion,
      precision: m,
      instancing: je,
      instancingColor: je && V.instanceColor !== null,
      supportsVertexTextures: p,
      outputEncoding:
        $ === null
          ? n.outputEncoding
          : $.isXRRenderTarget === !0
          ? $.texture.encoding
          : Ks,
      map: Xe,
      matcap: ve,
      envMap: Me,
      envMapMode: Me && ae.mapping,
      envMapCubeUVHeight: I,
      aoMap: me,
      lightMap: se,
      bumpMap: xe,
      normalMap: Ne,
      displacementMap: p && Le,
      emissiveMap: We,
      normalMapObjectSpace: Ne && b.normalMapType === zB,
      normalMapTangentSpace: Ne && b.normalMapType === Zs,
      decodeVideoTexture:
        Xe && b.map.isVideoTexture === !0 && b.map.encoding === Tt,
      metalnessMap: Ke,
      roughnessMap: Je,
      clearcoat: nt,
      clearcoatMap: le,
      clearcoatNormalMap: Ee,
      clearcoatRoughnessMap: Te,
      iridescence: _t,
      iridescenceMap: Re,
      iridescenceThicknessMap: et,
      sheen: k,
      sheenColorMap: Ue,
      sheenRoughnessMap: de,
      specularMap: He,
      specularColorMap: W,
      specularIntensityMap: he,
      transmission: D,
      transmissionMap: Ae,
      thicknessMap: Pe,
      gradientMap: qe,
      opaque: b.transparent === !1 && b.blending === Xa,
      alphaMap: ft,
      alphaTest: Ut,
      combine: b.combine,
      mapUv: Xe && A(b.map.channel),
      aoMapUv: me && A(b.aoMap.channel),
      lightMapUv: se && A(b.lightMap.channel),
      bumpMapUv: xe && A(b.bumpMap.channel),
      normalMapUv: Ne && A(b.normalMap.channel),
      displacementMapUv: Le && A(b.displacementMap.channel),
      emissiveMapUv: We && A(b.emissiveMap.channel),
      metalnessMapUv: Ke && A(b.metalnessMap.channel),
      roughnessMapUv: Je && A(b.roughnessMap.channel),
      clearcoatMapUv: le && A(b.clearcoatMap.channel),
      clearcoatNormalMapUv: Ee && A(b.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: Te && A(b.clearcoatRoughnessMap.channel),
      iridescenceMapUv: Re && A(b.iridescenceMap.channel),
      iridescenceThicknessMapUv: et && A(b.iridescenceThicknessMap.channel),
      sheenColorMapUv: Ue && A(b.sheenColorMap.channel),
      sheenRoughnessMapUv: de && A(b.sheenRoughnessMap.channel),
      specularMapUv: He && A(b.specularMap.channel),
      specularColorMapUv: W && A(b.specularColorMap.channel),
      specularIntensityMapUv: he && A(b.specularIntensityMap.channel),
      transmissionMapUv: Ae && A(b.transmissionMap.channel),
      thicknessMapUv: Pe && A(b.thicknessMap.channel),
      alphaMapUv: ft && A(b.alphaMap.channel),
      vertexTangents: Ne && !!X.attributes.tangent,
      vertexColors: b.vertexColors,
      vertexAlphas:
        b.vertexColors === !0 &&
        !!X.attributes.color &&
        X.attributes.color.itemSize === 4,
      vertexUvs2: ce,
      pointsUvs: V.isPoints === !0 && !!X.attributes.uv && (Xe || ft),
      fog: !!J,
      useFog: b.fog === !0,
      fogExp2: J && J.isFogExp2,
      flatShading: b.flatShading === !0,
      sizeAttenuation: b.sizeAttenuation === !0,
      logarithmicDepthBuffer: d,
      skinning: V.isSkinnedMesh === !0,
      morphTargets: X.morphAttributes.position !== void 0,
      morphNormals: X.morphAttributes.normal !== void 0,
      morphColors: X.morphAttributes.color !== void 0,
      morphTargetsCount: q,
      morphTextureStride: Q,
      numDirLights: R.directional.length,
      numPointLights: R.point.length,
      numSpotLights: R.spot.length,
      numSpotLightMaps: R.spotLightMap.length,
      numRectAreaLights: R.rectArea.length,
      numHemiLights: R.hemi.length,
      numDirLightShadows: R.directionalShadowMap.length,
      numPointLightShadows: R.pointShadowMap.length,
      numSpotLightShadows: R.spotShadowMap.length,
      numSpotLightShadowsWithMaps: R.numSpotLightShadowsWithMaps,
      numClippingPlanes: o.numPlanes,
      numClipIntersection: o.numIntersection,
      dithering: b.dithering,
      shadowMapEnabled: n.shadowMap.enabled && U.length > 0,
      shadowMapType: n.shadowMap.type,
      toneMapping: b.toneMapped ? n.toneMapping : Or,
      useLegacyLights: n.useLegacyLights,
      premultipliedAlpha: b.premultipliedAlpha,
      doubleSided: b.side === dr,
      flipSided: b.side === mi,
      useDepthPacking: b.depthPacking >= 0,
      depthPacking: b.depthPacking || 0,
      index0AttributeName: b.index0AttributeName,
      extensionDerivatives: K && b.extensions.derivatives === !0,
      extensionFragDepth: K && b.extensions.fragDepth === !0,
      extensionDrawBuffers: K && b.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: K && b.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: h || i.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: h || i.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: h || i.has("EXT_shader_texture_lod"),
      customProgramCacheKey: b.customProgramCacheKey(),
    };
  }
  function g(b) {
    const R = [];
    if (
      (b.shaderID
        ? R.push(b.shaderID)
        : (R.push(b.customVertexShaderID), R.push(b.customFragmentShaderID)),
      b.defines !== void 0)
    )
      for (const U in b.defines) R.push(U), R.push(b.defines[U]);
    return (
      b.isRawShaderMaterial === !1 &&
        (_(R, b), S(R, b), R.push(n.outputEncoding)),
      R.push(b.customProgramCacheKey),
      R.join()
    );
  }
  function _(b, R) {
    b.push(R.precision),
      b.push(R.outputEncoding),
      b.push(R.envMapMode),
      b.push(R.envMapCubeUVHeight),
      b.push(R.mapUv),
      b.push(R.alphaMapUv),
      b.push(R.lightMapUv),
      b.push(R.aoMapUv),
      b.push(R.bumpMapUv),
      b.push(R.normalMapUv),
      b.push(R.displacementMapUv),
      b.push(R.emissiveMapUv),
      b.push(R.metalnessMapUv),
      b.push(R.roughnessMapUv),
      b.push(R.clearcoatMapUv),
      b.push(R.clearcoatNormalMapUv),
      b.push(R.clearcoatRoughnessMapUv),
      b.push(R.iridescenceMapUv),
      b.push(R.iridescenceThicknessMapUv),
      b.push(R.sheenColorMapUv),
      b.push(R.sheenRoughnessMapUv),
      b.push(R.specularMapUv),
      b.push(R.specularColorMapUv),
      b.push(R.specularIntensityMapUv),
      b.push(R.transmissionMapUv),
      b.push(R.thicknessMapUv),
      b.push(R.combine),
      b.push(R.fogExp2),
      b.push(R.sizeAttenuation),
      b.push(R.morphTargetsCount),
      b.push(R.morphAttributeCount),
      b.push(R.numDirLights),
      b.push(R.numPointLights),
      b.push(R.numSpotLights),
      b.push(R.numSpotLightMaps),
      b.push(R.numHemiLights),
      b.push(R.numRectAreaLights),
      b.push(R.numDirLightShadows),
      b.push(R.numPointLightShadows),
      b.push(R.numSpotLightShadows),
      b.push(R.numSpotLightShadowsWithMaps),
      b.push(R.shadowMapType),
      b.push(R.toneMapping),
      b.push(R.numClippingPlanes),
      b.push(R.numClipIntersection),
      b.push(R.depthPacking);
  }
  function S(b, R) {
    a.disableAll(),
      R.isWebGL2 && a.enable(0),
      R.supportsVertexTextures && a.enable(1),
      R.instancing && a.enable(2),
      R.instancingColor && a.enable(3),
      R.matcap && a.enable(4),
      R.envMap && a.enable(5),
      R.normalMapObjectSpace && a.enable(6),
      R.normalMapTangentSpace && a.enable(7),
      R.clearcoat && a.enable(8),
      R.iridescence && a.enable(9),
      R.alphaTest && a.enable(10),
      R.vertexColors && a.enable(11),
      R.vertexAlphas && a.enable(12),
      R.vertexUvs2 && a.enable(13),
      R.vertexTangents && a.enable(14),
      b.push(a.mask),
      a.disableAll(),
      R.fog && a.enable(0),
      R.useFog && a.enable(1),
      R.flatShading && a.enable(2),
      R.logarithmicDepthBuffer && a.enable(3),
      R.skinning && a.enable(4),
      R.morphTargets && a.enable(5),
      R.morphNormals && a.enable(6),
      R.morphColors && a.enable(7),
      R.premultipliedAlpha && a.enable(8),
      R.shadowMapEnabled && a.enable(9),
      R.useLegacyLights && a.enable(10),
      R.doubleSided && a.enable(11),
      R.flipSided && a.enable(12),
      R.useDepthPacking && a.enable(13),
      R.dithering && a.enable(14),
      R.transmission && a.enable(15),
      R.sheen && a.enable(16),
      R.decodeVideoTexture && a.enable(17),
      R.opaque && a.enable(18),
      R.pointsUvs && a.enable(19),
      b.push(a.mask);
  }
  function w(b) {
    const R = v[b.type];
    let U;
    if (R) {
      const j = Dr[R];
      U = XB.clone(j.uniforms);
    } else U = b.uniforms;
    return U;
  }
  function E(b, R) {
    let U;
    for (let j = 0, V = c.length; j < V; j++) {
      const J = c[j];
      if (J.cacheKey === R) {
        (U = J), ++U.usedTimes;
        break;
      }
    }
    return U === void 0 && ((U = new cG(n, R, b, s)), c.push(U)), U;
  }
  function P(b) {
    if (--b.usedTimes === 0) {
      const R = c.indexOf(b);
      (c[R] = c[c.length - 1]), c.pop(), b.destroy();
    }
  }
  function L(b) {
    l.remove(b);
  }
  function B() {
    l.dispose();
  }
  return {
    getParameters: x,
    getProgramCacheKey: g,
    getUniforms: w,
    acquireProgram: E,
    releaseProgram: P,
    releaseShaderCache: L,
    programs: c,
    dispose: B,
  };
}
function mG() {
  let n = new WeakMap();
  function e(s) {
    let o = n.get(s);
    return o === void 0 && ((o = {}), n.set(s, o)), o;
  }
  function t(s) {
    n.delete(s);
  }
  function i(s, o, a) {
    n.get(s)[o] = a;
  }
  function r() {
    n = new WeakMap();
  }
  return { get: e, remove: t, update: i, dispose: r };
}
function gG(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.material.id !== e.material.id
    ? n.material.id - e.material.id
    : n.z !== e.z
    ? n.z - e.z
    : n.id - e.id;
}
function VC(n, e) {
  return n.groupOrder !== e.groupOrder
    ? n.groupOrder - e.groupOrder
    : n.renderOrder !== e.renderOrder
    ? n.renderOrder - e.renderOrder
    : n.z !== e.z
    ? e.z - n.z
    : n.id - e.id;
}
function WC() {
  const n = [];
  let e = 0;
  const t = [],
    i = [],
    r = [];
  function s() {
    (e = 0), (t.length = 0), (i.length = 0), (r.length = 0);
  }
  function o(d, p, m, v, A, x) {
    let g = n[e];
    return (
      g === void 0
        ? ((g = {
            id: d.id,
            object: d,
            geometry: p,
            material: m,
            groupOrder: v,
            renderOrder: d.renderOrder,
            z: A,
            group: x,
          }),
          (n[e] = g))
        : ((g.id = d.id),
          (g.object = d),
          (g.geometry = p),
          (g.material = m),
          (g.groupOrder = v),
          (g.renderOrder = d.renderOrder),
          (g.z = A),
          (g.group = x)),
      e++,
      g
    );
  }
  function a(d, p, m, v, A, x) {
    const g = o(d, p, m, v, A, x);
    m.transmission > 0
      ? i.push(g)
      : m.transparent === !0
      ? r.push(g)
      : t.push(g);
  }
  function l(d, p, m, v, A, x) {
    const g = o(d, p, m, v, A, x);
    m.transmission > 0
      ? i.unshift(g)
      : m.transparent === !0
      ? r.unshift(g)
      : t.unshift(g);
  }
  function c(d, p) {
    t.length > 1 && t.sort(d || gG),
      i.length > 1 && i.sort(p || VC),
      r.length > 1 && r.sort(p || VC);
  }
  function h() {
    for (let d = e, p = n.length; d < p; d++) {
      const m = n[d];
      if (m.id === null) break;
      (m.id = null),
        (m.object = null),
        (m.geometry = null),
        (m.material = null),
        (m.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: i,
    transparent: r,
    init: s,
    push: a,
    unshift: l,
    finish: h,
    sort: c,
  };
}
function yG() {
  let n = new WeakMap();
  function e(i, r) {
    const s = n.get(i);
    let o;
    return (
      s === void 0
        ? ((o = new WC()), n.set(i, [o]))
        : r >= s.length
        ? ((o = new WC()), s.push(o))
        : (o = s[r]),
      o
    );
  }
  function t() {
    n = new WeakMap();
  }
  return { get: e, dispose: t };
}
function vG() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new F(), color: new Ie() };
          break;
        case "SpotLight":
          t = {
            position: new F(),
            direction: new F(),
            color: new Ie(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new F(), color: new Ie(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new F(), skyColor: new Ie(), groundColor: new Ie() };
          break;
        case "RectAreaLight":
          t = {
            color: new Ie(),
            position: new F(),
            halfWidth: new F(),
            halfHeight: new F(),
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
function xG() {
  const n = {};
  return {
    get: function (e) {
      if (n[e.id] !== void 0) return n[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ge(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ge(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new ge(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (n[e.id] = t), t;
    },
  };
}
let _G = 0;
function AG(n, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (n.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (n.map ? 1 : 0)
  );
}
function MG(n, e) {
  const t = new vG(),
    i = xG(),
    r = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let h = 0; h < 9; h++) r.probe.push(new F());
  const s = new F(),
    o = new st(),
    a = new st();
  function l(h, d) {
    let p = 0,
      m = 0,
      v = 0;
    for (let U = 0; U < 9; U++) r.probe[U].set(0, 0, 0);
    let A = 0,
      x = 0,
      g = 0,
      _ = 0,
      S = 0,
      w = 0,
      E = 0,
      P = 0,
      L = 0,
      B = 0;
    h.sort(AG);
    const b = d === !0 ? Math.PI : 1;
    for (let U = 0, j = h.length; U < j; U++) {
      const V = h[U],
        J = V.color,
        X = V.intensity,
        oe = V.distance,
        ae = V.shadow && V.shadow.map ? V.shadow.map.texture : null;
      if (V.isAmbientLight)
        (p += J.r * X * b), (m += J.g * X * b), (v += J.b * X * b);
      else if (V.isLightProbe)
        for (let I = 0; I < 9; I++)
          r.probe[I].addScaledVector(V.sh.coefficients[I], X);
      else if (V.isDirectionalLight) {
        const I = t.get(V);
        if (
          (I.color.copy(V.color).multiplyScalar(V.intensity * b), V.castShadow)
        ) {
          const G = V.shadow,
            z = i.get(V);
          (z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (r.directionalShadow[A] = z),
            (r.directionalShadowMap[A] = ae),
            (r.directionalShadowMatrix[A] = V.shadow.matrix),
            w++;
        }
        (r.directional[A] = I), A++;
      } else if (V.isSpotLight) {
        const I = t.get(V);
        I.position.setFromMatrixPosition(V.matrixWorld),
          I.color.copy(J).multiplyScalar(X * b),
          (I.distance = oe),
          (I.coneCos = Math.cos(V.angle)),
          (I.penumbraCos = Math.cos(V.angle * (1 - V.penumbra))),
          (I.decay = V.decay),
          (r.spot[g] = I);
        const G = V.shadow;
        if (
          (V.map &&
            ((r.spotLightMap[L] = V.map),
            L++,
            G.updateMatrices(V),
            V.castShadow && B++),
          (r.spotLightMatrix[g] = G.matrix),
          V.castShadow)
        ) {
          const z = i.get(V);
          (z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (r.spotShadow[g] = z),
            (r.spotShadowMap[g] = ae),
            P++;
        }
        g++;
      } else if (V.isRectAreaLight) {
        const I = t.get(V);
        I.color.copy(J).multiplyScalar(X),
          I.halfWidth.set(V.width * 0.5, 0, 0),
          I.halfHeight.set(0, V.height * 0.5, 0),
          (r.rectArea[_] = I),
          _++;
      } else if (V.isPointLight) {
        const I = t.get(V);
        if (
          (I.color.copy(V.color).multiplyScalar(V.intensity * b),
          (I.distance = V.distance),
          (I.decay = V.decay),
          V.castShadow)
        ) {
          const G = V.shadow,
            z = i.get(V);
          (z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (z.shadowCameraNear = G.camera.near),
            (z.shadowCameraFar = G.camera.far),
            (r.pointShadow[x] = z),
            (r.pointShadowMap[x] = ae),
            (r.pointShadowMatrix[x] = V.shadow.matrix),
            E++;
        }
        (r.point[x] = I), x++;
      } else if (V.isHemisphereLight) {
        const I = t.get(V);
        I.skyColor.copy(V.color).multiplyScalar(X * b),
          I.groundColor.copy(V.groundColor).multiplyScalar(X * b),
          (r.hemi[S] = I),
          S++;
      }
    }
    _ > 0 &&
      (e.isWebGL2 || n.has("OES_texture_float_linear") === !0
        ? ((r.rectAreaLTC1 = De.LTC_FLOAT_1), (r.rectAreaLTC2 = De.LTC_FLOAT_2))
        : n.has("OES_texture_half_float_linear") === !0
        ? ((r.rectAreaLTC1 = De.LTC_HALF_1), (r.rectAreaLTC2 = De.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (r.ambient[0] = p),
      (r.ambient[1] = m),
      (r.ambient[2] = v);
    const R = r.hash;
    (R.directionalLength !== A ||
      R.pointLength !== x ||
      R.spotLength !== g ||
      R.rectAreaLength !== _ ||
      R.hemiLength !== S ||
      R.numDirectionalShadows !== w ||
      R.numPointShadows !== E ||
      R.numSpotShadows !== P ||
      R.numSpotMaps !== L) &&
      ((r.directional.length = A),
      (r.spot.length = g),
      (r.rectArea.length = _),
      (r.point.length = x),
      (r.hemi.length = S),
      (r.directionalShadow.length = w),
      (r.directionalShadowMap.length = w),
      (r.pointShadow.length = E),
      (r.pointShadowMap.length = E),
      (r.spotShadow.length = P),
      (r.spotShadowMap.length = P),
      (r.directionalShadowMatrix.length = w),
      (r.pointShadowMatrix.length = E),
      (r.spotLightMatrix.length = P + L - B),
      (r.spotLightMap.length = L),
      (r.numSpotLightShadowsWithMaps = B),
      (R.directionalLength = A),
      (R.pointLength = x),
      (R.spotLength = g),
      (R.rectAreaLength = _),
      (R.hemiLength = S),
      (R.numDirectionalShadows = w),
      (R.numPointShadows = E),
      (R.numSpotShadows = P),
      (R.numSpotMaps = L),
      (r.version = _G++));
  }
  function c(h, d) {
    let p = 0,
      m = 0,
      v = 0,
      A = 0,
      x = 0;
    const g = d.matrixWorldInverse;
    for (let _ = 0, S = h.length; _ < S; _++) {
      const w = h[_];
      if (w.isDirectionalLight) {
        const E = r.directional[p];
        E.direction.setFromMatrixPosition(w.matrixWorld),
          s.setFromMatrixPosition(w.target.matrixWorld),
          E.direction.sub(s),
          E.direction.transformDirection(g),
          p++;
      } else if (w.isSpotLight) {
        const E = r.spot[v];
        E.position.setFromMatrixPosition(w.matrixWorld),
          E.position.applyMatrix4(g),
          E.direction.setFromMatrixPosition(w.matrixWorld),
          s.setFromMatrixPosition(w.target.matrixWorld),
          E.direction.sub(s),
          E.direction.transformDirection(g),
          v++;
      } else if (w.isRectAreaLight) {
        const E = r.rectArea[A];
        E.position.setFromMatrixPosition(w.matrixWorld),
          E.position.applyMatrix4(g),
          a.identity(),
          o.copy(w.matrixWorld),
          o.premultiply(g),
          a.extractRotation(o),
          E.halfWidth.set(w.width * 0.5, 0, 0),
          E.halfHeight.set(0, w.height * 0.5, 0),
          E.halfWidth.applyMatrix4(a),
          E.halfHeight.applyMatrix4(a),
          A++;
      } else if (w.isPointLight) {
        const E = r.point[m];
        E.position.setFromMatrixPosition(w.matrixWorld),
          E.position.applyMatrix4(g),
          m++;
      } else if (w.isHemisphereLight) {
        const E = r.hemi[x];
        E.direction.setFromMatrixPosition(w.matrixWorld),
          E.direction.transformDirection(g),
          x++;
      }
    }
  }
  return { setup: l, setupView: c, state: r };
}
function JC(n, e) {
  const t = new MG(n, e),
    i = [],
    r = [];
  function s() {
    (i.length = 0), (r.length = 0);
  }
  function o(d) {
    i.push(d);
  }
  function a(d) {
    r.push(d);
  }
  function l(d) {
    t.setup(i, d);
  }
  function c(d) {
    t.setupView(i, d);
  }
  return {
    init: s,
    state: { lightsArray: i, shadowsArray: r, lights: t },
    setupLights: l,
    setupLightsView: c,
    pushLight: o,
    pushShadow: a,
  };
}
function SG(n, e) {
  let t = new WeakMap();
  function i(s, o = 0) {
    const a = t.get(s);
    let l;
    return (
      a === void 0
        ? ((l = new JC(n, e)), t.set(s, [l]))
        : o >= a.length
        ? ((l = new JC(n, e)), a.push(l))
        : (l = a[o]),
      l
    );
  }
  function r() {
    t = new WeakMap();
  }
  return { get: i, dispose: r };
}
class aA extends Cn {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = kB),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class lA extends Cn {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const wG = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  CG = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function EG(n, e, t) {
  let i = new Fg();
  const r = new ge(),
    s = new ge(),
    o = new Ot(),
    a = new aA({ depthPacking: UB }),
    l = new lA(),
    c = {},
    h = t.maxTextureSize,
    d = { [cs]: mi, [mi]: cs, [dr]: dr },
    p = new hs({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new ge() },
        radius: { value: 4 },
      },
      vertexShader: wG,
      fragmentShader: CG,
    }),
    m = p.clone();
  m.defines.HORIZONTAL_PASS = 1;
  const v = new ct();
  v.setAttribute(
    "position",
    new Dt(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const A = new Pn(v, p),
    x = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = Bg),
    (this.render = function (w, E, P) {
      if (
        x.enabled === !1 ||
        (x.autoUpdate === !1 && x.needsUpdate === !1) ||
        w.length === 0
      )
        return;
      const L = n.getRenderTarget(),
        B = n.getActiveCubeFace(),
        b = n.getActiveMipmapLevel(),
        R = n.state;
      R.setBlending(zs),
        R.buffers.color.setClear(1, 1, 1, 1),
        R.buffers.depth.setTest(!0),
        R.setScissorTest(!1);
      for (let U = 0, j = w.length; U < j; U++) {
        const V = w[U],
          J = V.shadow;
        if (J === void 0) {
          console.warn("THREE.WebGLShadowMap:", V, "has no shadow.");
          continue;
        }
        if (J.autoUpdate === !1 && J.needsUpdate === !1) continue;
        r.copy(J.mapSize);
        const X = J.getFrameExtents();
        if (
          (r.multiply(X),
          s.copy(J.mapSize),
          (r.x > h || r.y > h) &&
            (r.x > h &&
              ((s.x = Math.floor(h / X.x)),
              (r.x = s.x * X.x),
              (J.mapSize.x = s.x)),
            r.y > h &&
              ((s.y = Math.floor(h / X.y)),
              (r.y = s.y * X.y),
              (J.mapSize.y = s.y))),
          J.map === null)
        ) {
          const ae = this.type !== Ua ? { minFilter: dn, magFilter: dn } : {};
          (J.map = new Gr(r.x, r.y, ae)),
            (J.map.texture.name = V.name + ".shadowMap"),
            J.camera.updateProjectionMatrix();
        }
        n.setRenderTarget(J.map), n.clear();
        const oe = J.getViewportCount();
        for (let ae = 0; ae < oe; ae++) {
          const I = J.getViewport(ae);
          o.set(s.x * I.x, s.y * I.y, s.x * I.z, s.y * I.w),
            R.viewport(o),
            J.updateMatrices(V, ae),
            (i = J.getFrustum()),
            S(E, P, J.camera, V, this.type);
        }
        J.isPointLightShadow !== !0 && this.type === Ua && g(J, P),
          (J.needsUpdate = !1);
      }
      (x.needsUpdate = !1), n.setRenderTarget(L, B, b);
    });
  function g(w, E) {
    const P = e.update(A);
    p.defines.VSM_SAMPLES !== w.blurSamples &&
      ((p.defines.VSM_SAMPLES = w.blurSamples),
      (m.defines.VSM_SAMPLES = w.blurSamples),
      (p.needsUpdate = !0),
      (m.needsUpdate = !0)),
      w.mapPass === null && (w.mapPass = new Gr(r.x, r.y)),
      (p.uniforms.shadow_pass.value = w.map.texture),
      (p.uniforms.resolution.value = w.mapSize),
      (p.uniforms.radius.value = w.radius),
      n.setRenderTarget(w.mapPass),
      n.clear(),
      n.renderBufferDirect(E, null, P, p, A, null),
      (m.uniforms.shadow_pass.value = w.mapPass.texture),
      (m.uniforms.resolution.value = w.mapSize),
      (m.uniforms.radius.value = w.radius),
      n.setRenderTarget(w.map),
      n.clear(),
      n.renderBufferDirect(E, null, P, m, A, null);
  }
  function _(w, E, P, L) {
    let B = null;
    const b =
      P.isPointLight === !0 ? w.customDistanceMaterial : w.customDepthMaterial;
    if (b !== void 0) B = b;
    else if (
      ((B = P.isPointLight === !0 ? l : a),
      (n.localClippingEnabled &&
        E.clipShadows === !0 &&
        Array.isArray(E.clippingPlanes) &&
        E.clippingPlanes.length !== 0) ||
        (E.displacementMap && E.displacementScale !== 0) ||
        (E.alphaMap && E.alphaTest > 0) ||
        (E.map && E.alphaTest > 0))
    ) {
      const R = B.uuid,
        U = E.uuid;
      let j = c[R];
      j === void 0 && ((j = {}), (c[R] = j));
      let V = j[U];
      V === void 0 && ((V = B.clone()), (j[U] = V)), (B = V);
    }
    if (
      ((B.visible = E.visible),
      (B.wireframe = E.wireframe),
      L === Ua
        ? (B.side = E.shadowSide !== null ? E.shadowSide : E.side)
        : (B.side = E.shadowSide !== null ? E.shadowSide : d[E.side]),
      (B.alphaMap = E.alphaMap),
      (B.alphaTest = E.alphaTest),
      (B.map = E.map),
      (B.clipShadows = E.clipShadows),
      (B.clippingPlanes = E.clippingPlanes),
      (B.clipIntersection = E.clipIntersection),
      (B.displacementMap = E.displacementMap),
      (B.displacementScale = E.displacementScale),
      (B.displacementBias = E.displacementBias),
      (B.wireframeLinewidth = E.wireframeLinewidth),
      (B.linewidth = E.linewidth),
      P.isPointLight === !0 && B.isMeshDistanceMaterial === !0)
    ) {
      const R = n.properties.get(B);
      R.light = P;
    }
    return B;
  }
  function S(w, E, P, L, B) {
    if (w.visible === !1) return;
    if (
      w.layers.test(E.layers) &&
      (w.isMesh || w.isLine || w.isPoints) &&
      (w.castShadow || (w.receiveShadow && B === Ua)) &&
      (!w.frustumCulled || i.intersectsObject(w))
    ) {
      w.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, w.matrixWorld);
      const U = e.update(w),
        j = w.material;
      if (Array.isArray(j)) {
        const V = U.groups;
        for (let J = 0, X = V.length; J < X; J++) {
          const oe = V[J],
            ae = j[oe.materialIndex];
          if (ae && ae.visible) {
            const I = _(w, ae, L, B);
            n.renderBufferDirect(P, null, U, I, w, oe);
          }
        }
      } else if (j.visible) {
        const V = _(w, j, L, B);
        n.renderBufferDirect(P, null, U, V, w, null);
      }
    }
    const R = w.children;
    for (let U = 0, j = R.length; U < j; U++) S(R[U], E, P, L, B);
  }
}
function TG(n, e, t) {
  const i = t.isWebGL2;
  function r() {
    let K = !1;
    const ce = new Ot();
    let Se = null;
    const ke = new Ot(0, 0, 0, 0);
    return {
      setMask: function (Qe) {
        Se !== Qe && !K && (n.colorMask(Qe, Qe, Qe, Qe), (Se = Qe));
      },
      setLocked: function (Qe) {
        K = Qe;
      },
      setClear: function (Qe, zt, Wt, Ln, xr) {
        xr === !0 && ((Qe *= Ln), (zt *= Ln), (Wt *= Ln)),
          ce.set(Qe, zt, Wt, Ln),
          ke.equals(ce) === !1 && (n.clearColor(Qe, zt, Wt, Ln), ke.copy(ce));
      },
      reset: function () {
        (K = !1), (Se = null), ke.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let K = !1,
      ce = null,
      Se = null,
      ke = null;
    return {
      setTest: function (Qe) {
        Qe ? $(2929) : je(2929);
      },
      setMask: function (Qe) {
        ce !== Qe && !K && (n.depthMask(Qe), (ce = Qe));
      },
      setFunc: function (Qe) {
        if (Se !== Qe) {
          switch (Qe) {
            case oB:
              n.depthFunc(512);
              break;
            case aB:
              n.depthFunc(519);
              break;
            case lB:
              n.depthFunc(513);
              break;
            case Xm:
              n.depthFunc(515);
              break;
            case uB:
              n.depthFunc(514);
              break;
            case cB:
              n.depthFunc(518);
              break;
            case fB:
              n.depthFunc(516);
              break;
            case hB:
              n.depthFunc(517);
              break;
            default:
              n.depthFunc(515);
          }
          Se = Qe;
        }
      },
      setLocked: function (Qe) {
        K = Qe;
      },
      setClear: function (Qe) {
        ke !== Qe && (n.clearDepth(Qe), (ke = Qe));
      },
      reset: function () {
        (K = !1), (ce = null), (Se = null), (ke = null);
      },
    };
  }
  function o() {
    let K = !1,
      ce = null,
      Se = null,
      ke = null,
      Qe = null,
      zt = null,
      Wt = null,
      Ln = null,
      xr = null;
    return {
      setTest: function (Qt) {
        K || (Qt ? $(2960) : je(2960));
      },
      setMask: function (Qt) {
        ce !== Qt && !K && (n.stencilMask(Qt), (ce = Qt));
      },
      setFunc: function (Qt, ai, qi) {
        (Se !== Qt || ke !== ai || Qe !== qi) &&
          (n.stencilFunc(Qt, ai, qi), (Se = Qt), (ke = ai), (Qe = qi));
      },
      setOp: function (Qt, ai, qi) {
        (zt !== Qt || Wt !== ai || Ln !== qi) &&
          (n.stencilOp(Qt, ai, qi), (zt = Qt), (Wt = ai), (Ln = qi));
      },
      setLocked: function (Qt) {
        K = Qt;
      },
      setClear: function (Qt) {
        xr !== Qt && (n.clearStencil(Qt), (xr = Qt));
      },
      reset: function () {
        (K = !1),
          (ce = null),
          (Se = null),
          (ke = null),
          (Qe = null),
          (zt = null),
          (Wt = null),
          (Ln = null),
          (xr = null);
      },
    };
  }
  const a = new r(),
    l = new s(),
    c = new o(),
    h = new WeakMap(),
    d = new WeakMap();
  let p = {},
    m = {},
    v = new WeakMap(),
    A = [],
    x = null,
    g = !1,
    _ = null,
    S = null,
    w = null,
    E = null,
    P = null,
    L = null,
    B = null,
    b = !1,
    R = null,
    U = null,
    j = null,
    V = null,
    J = null;
  const X = n.getParameter(35661);
  let oe = !1,
    ae = 0;
  const I = n.getParameter(7938);
  I.indexOf("WebGL") !== -1
    ? ((ae = parseFloat(/^WebGL (\d)/.exec(I)[1])), (oe = ae >= 1))
    : I.indexOf("OpenGL ES") !== -1 &&
      ((ae = parseFloat(/^OpenGL ES (\d)/.exec(I)[1])), (oe = ae >= 2));
  let G = null,
    z = {};
  const q = n.getParameter(3088),
    Q = n.getParameter(2978),
    ee = new Ot().fromArray(q),
    ne = new Ot().fromArray(Q);
  function Ce(K, ce, Se) {
    const ke = new Uint8Array(4),
      Qe = n.createTexture();
    n.bindTexture(K, Qe),
      n.texParameteri(K, 10241, 9728),
      n.texParameteri(K, 10240, 9728);
    for (let zt = 0; zt < Se; zt++)
      n.texImage2D(ce + zt, 0, 6408, 1, 1, 0, 6408, 5121, ke);
    return Qe;
  }
  const _e = {};
  (_e[3553] = Ce(3553, 3553, 1)),
    (_e[34067] = Ce(34067, 34069, 6)),
    a.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    $(2929),
    l.setFunc(Xm),
    Le(!1),
    We(Ox),
    $(2884),
    xe(zs);
  function $(K) {
    p[K] !== !0 && (n.enable(K), (p[K] = !0));
  }
  function je(K) {
    p[K] !== !1 && (n.disable(K), (p[K] = !1));
  }
  function Xe(K, ce) {
    return m[K] !== ce
      ? (n.bindFramebuffer(K, ce),
        (m[K] = ce),
        i && (K === 36009 && (m[36160] = ce), K === 36160 && (m[36009] = ce)),
        !0)
      : !1;
  }
  function ve(K, ce) {
    let Se = A,
      ke = !1;
    if (K)
      if (
        ((Se = v.get(ce)),
        Se === void 0 && ((Se = []), v.set(ce, Se)),
        K.isWebGLMultipleRenderTargets)
      ) {
        const Qe = K.texture;
        if (Se.length !== Qe.length || Se[0] !== 36064) {
          for (let zt = 0, Wt = Qe.length; zt < Wt; zt++) Se[zt] = 36064 + zt;
          (Se.length = Qe.length), (ke = !0);
        }
      } else Se[0] !== 36064 && ((Se[0] = 36064), (ke = !0));
    else Se[0] !== 1029 && ((Se[0] = 1029), (ke = !0));
    ke &&
      (t.isWebGL2
        ? n.drawBuffers(Se)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Se));
  }
  function Me(K) {
    return x !== K ? (n.useProgram(K), (x = K), !0) : !1;
  }
  const me = { [Ia]: 32774, [Y2]: 32778, [Q2]: 32779 };
  if (i) (me[Gx] = 32775), (me[Hx] = 32776);
  else {
    const K = e.get("EXT_blend_minmax");
    K !== null && ((me[Gx] = K.MIN_EXT), (me[Hx] = K.MAX_EXT));
  }
  const se = {
    [Z2]: 0,
    [q2]: 1,
    [$2]: 768,
    [J1]: 770,
    [sB]: 776,
    [iB]: 774,
    [tB]: 772,
    [eB]: 769,
    [j1]: 771,
    [rB]: 775,
    [nB]: 773,
  };
  function xe(K, ce, Se, ke, Qe, zt, Wt, Ln) {
    if (K === zs) {
      g === !0 && (je(3042), (g = !1));
      return;
    }
    if ((g === !1 && ($(3042), (g = !0)), K !== K2)) {
      if (K !== _ || Ln !== b) {
        if (
          ((S !== Ia || P !== Ia) &&
            (n.blendEquation(32774), (S = Ia), (P = Ia)),
          Ln)
        )
          switch (K) {
            case Xa:
              n.blendFuncSeparate(1, 771, 1, 771);
              break;
            case kx:
              n.blendFunc(1, 1);
              break;
            case Ux:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case zx:
              n.blendFuncSeparate(0, 768, 0, 770);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", K);
              break;
          }
        else
          switch (K) {
            case Xa:
              n.blendFuncSeparate(770, 771, 1, 771);
              break;
            case kx:
              n.blendFunc(770, 1);
              break;
            case Ux:
              n.blendFuncSeparate(0, 769, 0, 1);
              break;
            case zx:
              n.blendFunc(0, 768);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", K);
              break;
          }
        (w = null), (E = null), (L = null), (B = null), (_ = K), (b = Ln);
      }
      return;
    }
    (Qe = Qe || ce),
      (zt = zt || Se),
      (Wt = Wt || ke),
      (ce !== S || Qe !== P) &&
        (n.blendEquationSeparate(me[ce], me[Qe]), (S = ce), (P = Qe)),
      (Se !== w || ke !== E || zt !== L || Wt !== B) &&
        (n.blendFuncSeparate(se[Se], se[ke], se[zt], se[Wt]),
        (w = Se),
        (E = ke),
        (L = zt),
        (B = Wt)),
      (_ = K),
      (b = !1);
  }
  function Ne(K, ce) {
    K.side === dr ? je(2884) : $(2884);
    let Se = K.side === mi;
    ce && (Se = !Se),
      Le(Se),
      K.blending === Xa && K.transparent === !1
        ? xe(zs)
        : xe(
            K.blending,
            K.blendEquation,
            K.blendSrc,
            K.blendDst,
            K.blendEquationAlpha,
            K.blendSrcAlpha,
            K.blendDstAlpha,
            K.premultipliedAlpha
          ),
      l.setFunc(K.depthFunc),
      l.setTest(K.depthTest),
      l.setMask(K.depthWrite),
      a.setMask(K.colorWrite);
    const ke = K.stencilWrite;
    c.setTest(ke),
      ke &&
        (c.setMask(K.stencilWriteMask),
        c.setFunc(K.stencilFunc, K.stencilRef, K.stencilFuncMask),
        c.setOp(K.stencilFail, K.stencilZFail, K.stencilZPass)),
      Je(K.polygonOffset, K.polygonOffsetFactor, K.polygonOffsetUnits),
      K.alphaToCoverage === !0 ? $(32926) : je(32926);
  }
  function Le(K) {
    R !== K && (K ? n.frontFace(2304) : n.frontFace(2305), (R = K));
  }
  function We(K) {
    K !== J2
      ? ($(2884),
        K !== U &&
          (K === Ox
            ? n.cullFace(1029)
            : K === j2
            ? n.cullFace(1028)
            : n.cullFace(1032)))
      : je(2884),
      (U = K);
  }
  function Ke(K) {
    K !== j && (oe && n.lineWidth(K), (j = K));
  }
  function Je(K, ce, Se) {
    K
      ? ($(32823),
        (V !== ce || J !== Se) && (n.polygonOffset(ce, Se), (V = ce), (J = Se)))
      : je(32823);
  }
  function nt(K) {
    K ? $(3089) : je(3089);
  }
  function _t(K) {
    K === void 0 && (K = 33984 + X - 1),
      G !== K && (n.activeTexture(K), (G = K));
  }
  function k(K, ce, Se) {
    Se === void 0 && (G === null ? (Se = 33984 + X - 1) : (Se = G));
    let ke = z[Se];
    ke === void 0 && ((ke = { type: void 0, texture: void 0 }), (z[Se] = ke)),
      (ke.type !== K || ke.texture !== ce) &&
        (G !== Se && (n.activeTexture(Se), (G = Se)),
        n.bindTexture(K, ce || _e[K]),
        (ke.type = K),
        (ke.texture = ce));
  }
  function D() {
    const K = z[G];
    K !== void 0 &&
      K.type !== void 0 &&
      (n.bindTexture(K.type, null), (K.type = void 0), (K.texture = void 0));
  }
  function le() {
    try {
      n.compressedTexImage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ee() {
    try {
      n.compressedTexImage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Te() {
    try {
      n.texSubImage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Re() {
    try {
      n.texSubImage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function et() {
    try {
      n.compressedTexSubImage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ue() {
    try {
      n.compressedTexSubImage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function de() {
    try {
      n.texStorage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function He() {
    try {
      n.texStorage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function W() {
    try {
      n.texImage2D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function he() {
    try {
      n.texImage3D.apply(n, arguments);
    } catch (K) {
      console.error("THREE.WebGLState:", K);
    }
  }
  function Ae(K) {
    ee.equals(K) === !1 && (n.scissor(K.x, K.y, K.z, K.w), ee.copy(K));
  }
  function Pe(K) {
    ne.equals(K) === !1 && (n.viewport(K.x, K.y, K.z, K.w), ne.copy(K));
  }
  function qe(K, ce) {
    let Se = d.get(ce);
    Se === void 0 && ((Se = new WeakMap()), d.set(ce, Se));
    let ke = Se.get(K);
    ke === void 0 && ((ke = n.getUniformBlockIndex(ce, K.name)), Se.set(K, ke));
  }
  function ft(K, ce) {
    const ke = d.get(ce).get(K);
    h.get(ce) !== ke &&
      (n.uniformBlockBinding(ce, ke, K.__bindingPointIndex), h.set(ce, ke));
  }
  function Ut() {
    n.disable(3042),
      n.disable(2884),
      n.disable(2929),
      n.disable(32823),
      n.disable(3089),
      n.disable(2960),
      n.disable(32926),
      n.blendEquation(32774),
      n.blendFunc(1, 0),
      n.blendFuncSeparate(1, 0, 1, 0),
      n.colorMask(!0, !0, !0, !0),
      n.clearColor(0, 0, 0, 0),
      n.depthMask(!0),
      n.depthFunc(513),
      n.clearDepth(1),
      n.stencilMask(4294967295),
      n.stencilFunc(519, 0, 4294967295),
      n.stencilOp(7680, 7680, 7680),
      n.clearStencil(0),
      n.cullFace(1029),
      n.frontFace(2305),
      n.polygonOffset(0, 0),
      n.activeTexture(33984),
      n.bindFramebuffer(36160, null),
      i === !0 &&
        (n.bindFramebuffer(36009, null), n.bindFramebuffer(36008, null)),
      n.useProgram(null),
      n.lineWidth(1),
      n.scissor(0, 0, n.canvas.width, n.canvas.height),
      n.viewport(0, 0, n.canvas.width, n.canvas.height),
      (p = {}),
      (G = null),
      (z = {}),
      (m = {}),
      (v = new WeakMap()),
      (A = []),
      (x = null),
      (g = !1),
      (_ = null),
      (S = null),
      (w = null),
      (E = null),
      (P = null),
      (L = null),
      (B = null),
      (b = !1),
      (R = null),
      (U = null),
      (j = null),
      (V = null),
      (J = null),
      ee.set(0, 0, n.canvas.width, n.canvas.height),
      ne.set(0, 0, n.canvas.width, n.canvas.height),
      a.reset(),
      l.reset(),
      c.reset();
  }
  return {
    buffers: { color: a, depth: l, stencil: c },
    enable: $,
    disable: je,
    bindFramebuffer: Xe,
    drawBuffers: ve,
    useProgram: Me,
    setBlending: xe,
    setMaterial: Ne,
    setFlipSided: Le,
    setCullFace: We,
    setLineWidth: Ke,
    setPolygonOffset: Je,
    setScissorTest: nt,
    activeTexture: _t,
    bindTexture: k,
    unbindTexture: D,
    compressedTexImage2D: le,
    compressedTexImage3D: Ee,
    texImage2D: W,
    texImage3D: he,
    updateUBOMapping: qe,
    uniformBlockBinding: ft,
    texStorage2D: de,
    texStorage3D: He,
    texSubImage2D: Te,
    texSubImage3D: Re,
    compressedTexSubImage2D: et,
    compressedTexSubImage3D: Ue,
    scissor: Ae,
    viewport: Pe,
    reset: Ut,
  };
}
function bG(n, e, t, i, r, s, o) {
  const a = r.isWebGL2,
    l = r.maxTextures,
    c = r.maxCubemapSize,
    h = r.maxTextureSize,
    d = r.maxSamples,
    p = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    m =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    v = new WeakMap();
  let A;
  const x = new WeakMap();
  let g = !1;
  try {
    g =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function _(k, D) {
    return g ? new OffscreenCanvas(k, D) : eh("canvas");
  }
  function S(k, D, le, Ee) {
    let Te = 1;
    if (
      ((k.width > Ee || k.height > Ee) &&
        (Te = Ee / Math.max(k.width, k.height)),
      Te < 1 || D === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && k instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && k instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && k instanceof ImageBitmap)
      ) {
        const Re = D ? VB : Math.floor,
          et = Re(Te * k.width),
          Ue = Re(Te * k.height);
        A === void 0 && (A = _(et, Ue));
        const de = le ? _(et, Ue) : A;
        return (
          (de.width = et),
          (de.height = Ue),
          de.getContext("2d").drawImage(k, 0, 0, et, Ue),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              k.width +
              "x" +
              k.height +
              ") to (" +
              et +
              "x" +
              Ue +
              ")."
          ),
          de
        );
      } else
        return (
          "data" in k &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                k.width +
                "x" +
                k.height +
                ")."
            ),
          k
        );
    return k;
  }
  function w(k) {
    return d_(k.width) && d_(k.height);
  }
  function E(k) {
    return a
      ? !1
      : k.wrapS !== Wn ||
          k.wrapT !== Wn ||
          (k.minFilter !== dn && k.minFilter !== rn);
  }
  function P(k, D) {
    return k.generateMipmaps && D && k.minFilter !== dn && k.minFilter !== rn;
  }
  function L(k) {
    n.generateMipmap(k);
  }
  function B(k, D, le, Ee, Te = !1) {
    if (a === !1) return D;
    if (k !== null) {
      if (n[k] !== void 0) return n[k];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          k +
          "'"
      );
    }
    let Re = D;
    return (
      D === 6403 &&
        (le === 5126 && (Re = 33326),
        le === 5131 && (Re = 33325),
        le === 5121 && (Re = 33321)),
      D === 33319 &&
        (le === 5126 && (Re = 33328),
        le === 5131 && (Re = 33327),
        le === 5121 && (Re = 33323)),
      D === 6408 &&
        (le === 5126 && (Re = 34836),
        le === 5131 && (Re = 34842),
        le === 5121 && (Re = Ee === Tt && Te === !1 ? 35907 : 32856),
        le === 32819 && (Re = 32854),
        le === 32820 && (Re = 32855)),
      (Re === 33325 ||
        Re === 33326 ||
        Re === 33327 ||
        Re === 33328 ||
        Re === 34842 ||
        Re === 34836) &&
        e.get("EXT_color_buffer_float"),
      Re
    );
  }
  function b(k, D, le) {
    return P(k, le) === !0 ||
      (k.isFramebufferTexture && k.minFilter !== dn && k.minFilter !== rn)
      ? Math.log2(Math.max(D.width, D.height)) + 1
      : k.mipmaps !== void 0 && k.mipmaps.length > 0
      ? k.mipmaps.length
      : k.isCompressedTexture && Array.isArray(k.image)
      ? D.mipmaps.length
      : 1;
  }
  function R(k) {
    return k === dn || k === Zf || k === bu ? 9728 : 9729;
  }
  function U(k) {
    const D = k.target;
    D.removeEventListener("dispose", U), V(D), D.isVideoTexture && v.delete(D);
  }
  function j(k) {
    const D = k.target;
    D.removeEventListener("dispose", j), X(D);
  }
  function V(k) {
    const D = i.get(k);
    if (D.__webglInit === void 0) return;
    const le = k.source,
      Ee = x.get(le);
    if (Ee) {
      const Te = Ee[D.__cacheKey];
      Te.usedTimes--,
        Te.usedTimes === 0 && J(k),
        Object.keys(Ee).length === 0 && x.delete(le);
    }
    i.remove(k);
  }
  function J(k) {
    const D = i.get(k);
    n.deleteTexture(D.__webglTexture);
    const le = k.source,
      Ee = x.get(le);
    delete Ee[D.__cacheKey], o.memory.textures--;
  }
  function X(k) {
    const D = k.texture,
      le = i.get(k),
      Ee = i.get(D);
    if (
      (Ee.__webglTexture !== void 0 &&
        (n.deleteTexture(Ee.__webglTexture), o.memory.textures--),
      k.depthTexture && k.depthTexture.dispose(),
      k.isWebGLCubeRenderTarget)
    )
      for (let Te = 0; Te < 6; Te++)
        n.deleteFramebuffer(le.__webglFramebuffer[Te]),
          le.__webglDepthbuffer &&
            n.deleteRenderbuffer(le.__webglDepthbuffer[Te]);
    else {
      if (
        (n.deleteFramebuffer(le.__webglFramebuffer),
        le.__webglDepthbuffer && n.deleteRenderbuffer(le.__webglDepthbuffer),
        le.__webglMultisampledFramebuffer &&
          n.deleteFramebuffer(le.__webglMultisampledFramebuffer),
        le.__webglColorRenderbuffer)
      )
        for (let Te = 0; Te < le.__webglColorRenderbuffer.length; Te++)
          le.__webglColorRenderbuffer[Te] &&
            n.deleteRenderbuffer(le.__webglColorRenderbuffer[Te]);
      le.__webglDepthRenderbuffer &&
        n.deleteRenderbuffer(le.__webglDepthRenderbuffer);
    }
    if (k.isWebGLMultipleRenderTargets)
      for (let Te = 0, Re = D.length; Te < Re; Te++) {
        const et = i.get(D[Te]);
        et.__webglTexture &&
          (n.deleteTexture(et.__webglTexture), o.memory.textures--),
          i.remove(D[Te]);
      }
    i.remove(D), i.remove(k);
  }
  let oe = 0;
  function ae() {
    oe = 0;
  }
  function I() {
    const k = oe;
    return (
      k >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            k +
            " texture units while this GPU supports only " +
            l
        ),
      (oe += 1),
      k
    );
  }
  function G(k) {
    const D = [];
    return (
      D.push(k.wrapS),
      D.push(k.wrapT),
      D.push(k.wrapR || 0),
      D.push(k.magFilter),
      D.push(k.minFilter),
      D.push(k.anisotropy),
      D.push(k.internalFormat),
      D.push(k.format),
      D.push(k.type),
      D.push(k.generateMipmaps),
      D.push(k.premultiplyAlpha),
      D.push(k.flipY),
      D.push(k.unpackAlignment),
      D.push(k.encoding),
      D.join()
    );
  }
  function z(k, D) {
    const le = i.get(k);
    if (
      (k.isVideoTexture && nt(k),
      k.isRenderTargetTexture === !1 &&
        k.version > 0 &&
        le.__version !== k.version)
    ) {
      const Ee = k.image;
      if (Ee === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (Ee.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        je(le, k, D);
        return;
      }
    }
    t.bindTexture(3553, le.__webglTexture, 33984 + D);
  }
  function q(k, D) {
    const le = i.get(k);
    if (k.version > 0 && le.__version !== k.version) {
      je(le, k, D);
      return;
    }
    t.bindTexture(35866, le.__webglTexture, 33984 + D);
  }
  function Q(k, D) {
    const le = i.get(k);
    if (k.version > 0 && le.__version !== k.version) {
      je(le, k, D);
      return;
    }
    t.bindTexture(32879, le.__webglTexture, 33984 + D);
  }
  function ee(k, D) {
    const le = i.get(k);
    if (k.version > 0 && le.__version !== k.version) {
      Xe(le, k, D);
      return;
    }
    t.bindTexture(34067, le.__webglTexture, 33984 + D);
  }
  const ne = { [jo]: 10497, [Wn]: 33071, [Uu]: 33648 },
    Ce = {
      [dn]: 9728,
      [Zf]: 9984,
      [bu]: 9986,
      [rn]: 9729,
      [Lg]: 9985,
      [fs]: 9987,
    };
  function _e(k, D, le) {
    if (
      (le
        ? (n.texParameteri(k, 10242, ne[D.wrapS]),
          n.texParameteri(k, 10243, ne[D.wrapT]),
          (k === 32879 || k === 35866) &&
            n.texParameteri(k, 32882, ne[D.wrapR]),
          n.texParameteri(k, 10240, Ce[D.magFilter]),
          n.texParameteri(k, 10241, Ce[D.minFilter]))
        : (n.texParameteri(k, 10242, 33071),
          n.texParameteri(k, 10243, 33071),
          (k === 32879 || k === 35866) && n.texParameteri(k, 32882, 33071),
          (D.wrapS !== Wn || D.wrapT !== Wn) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          n.texParameteri(k, 10240, R(D.magFilter)),
          n.texParameteri(k, 10241, R(D.minFilter)),
          D.minFilter !== dn &&
            D.minFilter !== rn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const Ee = e.get("EXT_texture_filter_anisotropic");
      if (
        D.magFilter === dn ||
        (D.minFilter !== bu && D.minFilter !== fs) ||
        (D.type === Ns && e.has("OES_texture_float_linear") === !1) ||
        (a === !1 &&
          D.type === zu &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (D.anisotropy > 1 || i.get(D).__currentAnisotropy) &&
        (n.texParameterf(
          k,
          Ee.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(D.anisotropy, r.getMaxAnisotropy())
        ),
        (i.get(D).__currentAnisotropy = D.anisotropy));
    }
  }
  function $(k, D) {
    let le = !1;
    k.__webglInit === void 0 &&
      ((k.__webglInit = !0), D.addEventListener("dispose", U));
    const Ee = D.source;
    let Te = x.get(Ee);
    Te === void 0 && ((Te = {}), x.set(Ee, Te));
    const Re = G(D);
    if (Re !== k.__cacheKey) {
      Te[Re] === void 0 &&
        ((Te[Re] = { texture: n.createTexture(), usedTimes: 0 }),
        o.memory.textures++,
        (le = !0)),
        Te[Re].usedTimes++;
      const et = Te[k.__cacheKey];
      et !== void 0 &&
        (Te[k.__cacheKey].usedTimes--, et.usedTimes === 0 && J(D)),
        (k.__cacheKey = Re),
        (k.__webglTexture = Te[Re].texture);
    }
    return le;
  }
  function je(k, D, le) {
    let Ee = 3553;
    (D.isDataArrayTexture || D.isCompressedArrayTexture) && (Ee = 35866),
      D.isData3DTexture && (Ee = 32879);
    const Te = $(k, D),
      Re = D.source;
    t.bindTexture(Ee, k.__webglTexture, 33984 + le);
    const et = i.get(Re);
    if (Re.version !== et.__version || Te === !0) {
      t.activeTexture(33984 + le),
        n.pixelStorei(37440, D.flipY),
        n.pixelStorei(37441, D.premultiplyAlpha),
        n.pixelStorei(3317, D.unpackAlignment),
        n.pixelStorei(37443, 0);
      const Ue = E(D) && w(D.image) === !1;
      let de = S(D.image, Ue, !1, h);
      de = _t(D, de);
      const He = w(de) || a,
        W = s.convert(D.format, D.encoding);
      let he = s.convert(D.type),
        Ae = B(D.internalFormat, W, he, D.encoding, D.isVideoTexture);
      _e(Ee, D, He);
      let Pe;
      const qe = D.mipmaps,
        ft = a && D.isVideoTexture !== !0,
        Ut = et.__version === void 0 || Te === !0,
        K = b(D, de, He);
      if (D.isDepthTexture)
        (Ae = 6402),
          a
            ? D.type === Ns
              ? (Ae = 36012)
              : D.type === bo
              ? (Ae = 33190)
              : D.type === Ka
              ? (Ae = 35056)
              : (Ae = 33189)
            : D.type === Ns &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          D.format === Uo &&
            Ae === 6402 &&
            D.type !== K1 &&
            D.type !== bo &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (D.type = bo),
            (he = s.convert(D.type))),
          D.format === rl &&
            Ae === 6402 &&
            ((Ae = 34041),
            D.type !== Ka &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (D.type = Ka),
              (he = s.convert(D.type)))),
          Ut &&
            (ft
              ? t.texStorage2D(3553, 1, Ae, de.width, de.height)
              : t.texImage2D(3553, 0, Ae, de.width, de.height, 0, W, he, null));
      else if (D.isDataTexture)
        if (qe.length > 0 && He) {
          ft && Ut && t.texStorage2D(3553, K, Ae, qe[0].width, qe[0].height);
          for (let ce = 0, Se = qe.length; ce < Se; ce++)
            (Pe = qe[ce]),
              ft
                ? t.texSubImage2D(
                    3553,
                    ce,
                    0,
                    0,
                    Pe.width,
                    Pe.height,
                    W,
                    he,
                    Pe.data
                  )
                : t.texImage2D(
                    3553,
                    ce,
                    Ae,
                    Pe.width,
                    Pe.height,
                    0,
                    W,
                    he,
                    Pe.data
                  );
          D.generateMipmaps = !1;
        } else
          ft
            ? (Ut && t.texStorage2D(3553, K, Ae, de.width, de.height),
              t.texSubImage2D(
                3553,
                0,
                0,
                0,
                de.width,
                de.height,
                W,
                he,
                de.data
              ))
            : t.texImage2D(3553, 0, Ae, de.width, de.height, 0, W, he, de.data);
      else if (D.isCompressedTexture)
        if (D.isCompressedArrayTexture) {
          ft &&
            Ut &&
            t.texStorage3D(35866, K, Ae, qe[0].width, qe[0].height, de.depth);
          for (let ce = 0, Se = qe.length; ce < Se; ce++)
            (Pe = qe[ce]),
              D.format !== Ti
                ? W !== null
                  ? ft
                    ? t.compressedTexSubImage3D(
                        35866,
                        ce,
                        0,
                        0,
                        0,
                        Pe.width,
                        Pe.height,
                        de.depth,
                        W,
                        Pe.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        35866,
                        ce,
                        Ae,
                        Pe.width,
                        Pe.height,
                        de.depth,
                        0,
                        Pe.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ft
                ? t.texSubImage3D(
                    35866,
                    ce,
                    0,
                    0,
                    0,
                    Pe.width,
                    Pe.height,
                    de.depth,
                    W,
                    he,
                    Pe.data
                  )
                : t.texImage3D(
                    35866,
                    ce,
                    Ae,
                    Pe.width,
                    Pe.height,
                    de.depth,
                    0,
                    W,
                    he,
                    Pe.data
                  );
        } else {
          ft && Ut && t.texStorage2D(3553, K, Ae, qe[0].width, qe[0].height);
          for (let ce = 0, Se = qe.length; ce < Se; ce++)
            (Pe = qe[ce]),
              D.format !== Ti
                ? W !== null
                  ? ft
                    ? t.compressedTexSubImage2D(
                        3553,
                        ce,
                        0,
                        0,
                        Pe.width,
                        Pe.height,
                        W,
                        Pe.data
                      )
                    : t.compressedTexImage2D(
                        3553,
                        ce,
                        Ae,
                        Pe.width,
                        Pe.height,
                        0,
                        Pe.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ft
                ? t.texSubImage2D(
                    3553,
                    ce,
                    0,
                    0,
                    Pe.width,
                    Pe.height,
                    W,
                    he,
                    Pe.data
                  )
                : t.texImage2D(
                    3553,
                    ce,
                    Ae,
                    Pe.width,
                    Pe.height,
                    0,
                    W,
                    he,
                    Pe.data
                  );
        }
      else if (D.isDataArrayTexture)
        ft
          ? (Ut && t.texStorage3D(35866, K, Ae, de.width, de.height, de.depth),
            t.texSubImage3D(
              35866,
              0,
              0,
              0,
              0,
              de.width,
              de.height,
              de.depth,
              W,
              he,
              de.data
            ))
          : t.texImage3D(
              35866,
              0,
              Ae,
              de.width,
              de.height,
              de.depth,
              0,
              W,
              he,
              de.data
            );
      else if (D.isData3DTexture)
        ft
          ? (Ut && t.texStorage3D(32879, K, Ae, de.width, de.height, de.depth),
            t.texSubImage3D(
              32879,
              0,
              0,
              0,
              0,
              de.width,
              de.height,
              de.depth,
              W,
              he,
              de.data
            ))
          : t.texImage3D(
              32879,
              0,
              Ae,
              de.width,
              de.height,
              de.depth,
              0,
              W,
              he,
              de.data
            );
      else if (D.isFramebufferTexture) {
        if (Ut)
          if (ft) t.texStorage2D(3553, K, Ae, de.width, de.height);
          else {
            let ce = de.width,
              Se = de.height;
            for (let ke = 0; ke < K; ke++)
              t.texImage2D(3553, ke, Ae, ce, Se, 0, W, he, null),
                (ce >>= 1),
                (Se >>= 1);
          }
      } else if (qe.length > 0 && He) {
        ft && Ut && t.texStorage2D(3553, K, Ae, qe[0].width, qe[0].height);
        for (let ce = 0, Se = qe.length; ce < Se; ce++)
          (Pe = qe[ce]),
            ft
              ? t.texSubImage2D(3553, ce, 0, 0, W, he, Pe)
              : t.texImage2D(3553, ce, Ae, W, he, Pe);
        D.generateMipmaps = !1;
      } else
        ft
          ? (Ut && t.texStorage2D(3553, K, Ae, de.width, de.height),
            t.texSubImage2D(3553, 0, 0, 0, W, he, de))
          : t.texImage2D(3553, 0, Ae, W, he, de);
      P(D, He) && L(Ee),
        (et.__version = Re.version),
        D.onUpdate && D.onUpdate(D);
    }
    k.__version = D.version;
  }
  function Xe(k, D, le) {
    if (D.image.length !== 6) return;
    const Ee = $(k, D),
      Te = D.source;
    t.bindTexture(34067, k.__webglTexture, 33984 + le);
    const Re = i.get(Te);
    if (Te.version !== Re.__version || Ee === !0) {
      t.activeTexture(33984 + le),
        n.pixelStorei(37440, D.flipY),
        n.pixelStorei(37441, D.premultiplyAlpha),
        n.pixelStorei(3317, D.unpackAlignment),
        n.pixelStorei(37443, 0);
      const et = D.isCompressedTexture || D.image[0].isCompressedTexture,
        Ue = D.image[0] && D.image[0].isDataTexture,
        de = [];
      for (let ce = 0; ce < 6; ce++)
        !et && !Ue
          ? (de[ce] = S(D.image[ce], !1, !0, c))
          : (de[ce] = Ue ? D.image[ce].image : D.image[ce]),
          (de[ce] = _t(D, de[ce]));
      const He = de[0],
        W = w(He) || a,
        he = s.convert(D.format, D.encoding),
        Ae = s.convert(D.type),
        Pe = B(D.internalFormat, he, Ae, D.encoding),
        qe = a && D.isVideoTexture !== !0,
        ft = Re.__version === void 0 || Ee === !0;
      let Ut = b(D, He, W);
      _e(34067, D, W);
      let K;
      if (et) {
        qe && ft && t.texStorage2D(34067, Ut, Pe, He.width, He.height);
        for (let ce = 0; ce < 6; ce++) {
          K = de[ce].mipmaps;
          for (let Se = 0; Se < K.length; Se++) {
            const ke = K[Se];
            D.format !== Ti
              ? he !== null
                ? qe
                  ? t.compressedTexSubImage2D(
                      34069 + ce,
                      Se,
                      0,
                      0,
                      ke.width,
                      ke.height,
                      he,
                      ke.data
                    )
                  : t.compressedTexImage2D(
                      34069 + ce,
                      Se,
                      Pe,
                      ke.width,
                      ke.height,
                      0,
                      ke.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : qe
              ? t.texSubImage2D(
                  34069 + ce,
                  Se,
                  0,
                  0,
                  ke.width,
                  ke.height,
                  he,
                  Ae,
                  ke.data
                )
              : t.texImage2D(
                  34069 + ce,
                  Se,
                  Pe,
                  ke.width,
                  ke.height,
                  0,
                  he,
                  Ae,
                  ke.data
                );
          }
        }
      } else {
        (K = D.mipmaps),
          qe &&
            ft &&
            (K.length > 0 && Ut++,
            t.texStorage2D(34067, Ut, Pe, de[0].width, de[0].height));
        for (let ce = 0; ce < 6; ce++)
          if (Ue) {
            qe
              ? t.texSubImage2D(
                  34069 + ce,
                  0,
                  0,
                  0,
                  de[ce].width,
                  de[ce].height,
                  he,
                  Ae,
                  de[ce].data
                )
              : t.texImage2D(
                  34069 + ce,
                  0,
                  Pe,
                  de[ce].width,
                  de[ce].height,
                  0,
                  he,
                  Ae,
                  de[ce].data
                );
            for (let Se = 0; Se < K.length; Se++) {
              const Qe = K[Se].image[ce].image;
              qe
                ? t.texSubImage2D(
                    34069 + ce,
                    Se + 1,
                    0,
                    0,
                    Qe.width,
                    Qe.height,
                    he,
                    Ae,
                    Qe.data
                  )
                : t.texImage2D(
                    34069 + ce,
                    Se + 1,
                    Pe,
                    Qe.width,
                    Qe.height,
                    0,
                    he,
                    Ae,
                    Qe.data
                  );
            }
          } else {
            qe
              ? t.texSubImage2D(34069 + ce, 0, 0, 0, he, Ae, de[ce])
              : t.texImage2D(34069 + ce, 0, Pe, he, Ae, de[ce]);
            for (let Se = 0; Se < K.length; Se++) {
              const ke = K[Se];
              qe
                ? t.texSubImage2D(
                    34069 + ce,
                    Se + 1,
                    0,
                    0,
                    he,
                    Ae,
                    ke.image[ce]
                  )
                : t.texImage2D(34069 + ce, Se + 1, Pe, he, Ae, ke.image[ce]);
            }
          }
      }
      P(D, W) && L(34067),
        (Re.__version = Te.version),
        D.onUpdate && D.onUpdate(D);
    }
    k.__version = D.version;
  }
  function ve(k, D, le, Ee, Te) {
    const Re = s.convert(le.format, le.encoding),
      et = s.convert(le.type),
      Ue = B(le.internalFormat, Re, et, le.encoding);
    i.get(D).__hasExternalTextures ||
      (Te === 32879 || Te === 35866
        ? t.texImage3D(Te, 0, Ue, D.width, D.height, D.depth, 0, Re, et, null)
        : t.texImage2D(Te, 0, Ue, D.width, D.height, 0, Re, et, null)),
      t.bindFramebuffer(36160, k),
      Je(D)
        ? p.framebufferTexture2DMultisampleEXT(
            36160,
            Ee,
            Te,
            i.get(le).__webglTexture,
            0,
            Ke(D)
          )
        : (Te === 3553 || (Te >= 34069 && Te <= 34074)) &&
          n.framebufferTexture2D(36160, Ee, Te, i.get(le).__webglTexture, 0),
      t.bindFramebuffer(36160, null);
  }
  function Me(k, D, le) {
    if ((n.bindRenderbuffer(36161, k), D.depthBuffer && !D.stencilBuffer)) {
      let Ee = 33189;
      if (le || Je(D)) {
        const Te = D.depthTexture;
        Te &&
          Te.isDepthTexture &&
          (Te.type === Ns ? (Ee = 36012) : Te.type === bo && (Ee = 33190));
        const Re = Ke(D);
        Je(D)
          ? p.renderbufferStorageMultisampleEXT(
              36161,
              Re,
              Ee,
              D.width,
              D.height
            )
          : n.renderbufferStorageMultisample(36161, Re, Ee, D.width, D.height);
      } else n.renderbufferStorage(36161, Ee, D.width, D.height);
      n.framebufferRenderbuffer(36160, 36096, 36161, k);
    } else if (D.depthBuffer && D.stencilBuffer) {
      const Ee = Ke(D);
      le && Je(D) === !1
        ? n.renderbufferStorageMultisample(36161, Ee, 35056, D.width, D.height)
        : Je(D)
        ? p.renderbufferStorageMultisampleEXT(
            36161,
            Ee,
            35056,
            D.width,
            D.height
          )
        : n.renderbufferStorage(36161, 34041, D.width, D.height),
        n.framebufferRenderbuffer(36160, 33306, 36161, k);
    } else {
      const Ee =
        D.isWebGLMultipleRenderTargets === !0 ? D.texture : [D.texture];
      for (let Te = 0; Te < Ee.length; Te++) {
        const Re = Ee[Te],
          et = s.convert(Re.format, Re.encoding),
          Ue = s.convert(Re.type),
          de = B(Re.internalFormat, et, Ue, Re.encoding),
          He = Ke(D);
        le && Je(D) === !1
          ? n.renderbufferStorageMultisample(36161, He, de, D.width, D.height)
          : Je(D)
          ? p.renderbufferStorageMultisampleEXT(
              36161,
              He,
              de,
              D.width,
              D.height
            )
          : n.renderbufferStorage(36161, de, D.width, D.height);
      }
    }
    n.bindRenderbuffer(36161, null);
  }
  function me(k, D) {
    if (D && D.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(36160, k),
      !(D.depthTexture && D.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!i.get(D.depthTexture).__webglTexture ||
      D.depthTexture.image.width !== D.width ||
      D.depthTexture.image.height !== D.height) &&
      ((D.depthTexture.image.width = D.width),
      (D.depthTexture.image.height = D.height),
      (D.depthTexture.needsUpdate = !0)),
      z(D.depthTexture, 0);
    const Ee = i.get(D.depthTexture).__webglTexture,
      Te = Ke(D);
    if (D.depthTexture.format === Uo)
      Je(D)
        ? p.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, Ee, 0, Te)
        : n.framebufferTexture2D(36160, 36096, 3553, Ee, 0);
    else if (D.depthTexture.format === rl)
      Je(D)
        ? p.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, Ee, 0, Te)
        : n.framebufferTexture2D(36160, 33306, 3553, Ee, 0);
    else throw new Error("Unknown depthTexture format");
  }
  function se(k) {
    const D = i.get(k),
      le = k.isWebGLCubeRenderTarget === !0;
    if (k.depthTexture && !D.__autoAllocateDepthBuffer) {
      if (le)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      me(D.__webglFramebuffer, k);
    } else if (le) {
      D.__webglDepthbuffer = [];
      for (let Ee = 0; Ee < 6; Ee++)
        t.bindFramebuffer(36160, D.__webglFramebuffer[Ee]),
          (D.__webglDepthbuffer[Ee] = n.createRenderbuffer()),
          Me(D.__webglDepthbuffer[Ee], k, !1);
    } else
      t.bindFramebuffer(36160, D.__webglFramebuffer),
        (D.__webglDepthbuffer = n.createRenderbuffer()),
        Me(D.__webglDepthbuffer, k, !1);
    t.bindFramebuffer(36160, null);
  }
  function xe(k, D, le) {
    const Ee = i.get(k);
    D !== void 0 && ve(Ee.__webglFramebuffer, k, k.texture, 36064, 3553),
      le !== void 0 && se(k);
  }
  function Ne(k) {
    const D = k.texture,
      le = i.get(k),
      Ee = i.get(D);
    k.addEventListener("dispose", j),
      k.isWebGLMultipleRenderTargets !== !0 &&
        (Ee.__webglTexture === void 0 &&
          (Ee.__webglTexture = n.createTexture()),
        (Ee.__version = D.version),
        o.memory.textures++);
    const Te = k.isWebGLCubeRenderTarget === !0,
      Re = k.isWebGLMultipleRenderTargets === !0,
      et = w(k) || a;
    if (Te) {
      le.__webglFramebuffer = [];
      for (let Ue = 0; Ue < 6; Ue++)
        le.__webglFramebuffer[Ue] = n.createFramebuffer();
    } else {
      if (((le.__webglFramebuffer = n.createFramebuffer()), Re))
        if (r.drawBuffers) {
          const Ue = k.texture;
          for (let de = 0, He = Ue.length; de < He; de++) {
            const W = i.get(Ue[de]);
            W.__webglTexture === void 0 &&
              ((W.__webglTexture = n.createTexture()), o.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (a && k.samples > 0 && Je(k) === !1) {
        const Ue = Re ? D : [D];
        (le.__webglMultisampledFramebuffer = n.createFramebuffer()),
          (le.__webglColorRenderbuffer = []),
          t.bindFramebuffer(36160, le.__webglMultisampledFramebuffer);
        for (let de = 0; de < Ue.length; de++) {
          const He = Ue[de];
          (le.__webglColorRenderbuffer[de] = n.createRenderbuffer()),
            n.bindRenderbuffer(36161, le.__webglColorRenderbuffer[de]);
          const W = s.convert(He.format, He.encoding),
            he = s.convert(He.type),
            Ae = B(
              He.internalFormat,
              W,
              he,
              He.encoding,
              k.isXRRenderTarget === !0
            ),
            Pe = Ke(k);
          n.renderbufferStorageMultisample(36161, Pe, Ae, k.width, k.height),
            n.framebufferRenderbuffer(
              36160,
              36064 + de,
              36161,
              le.__webglColorRenderbuffer[de]
            );
        }
        n.bindRenderbuffer(36161, null),
          k.depthBuffer &&
            ((le.__webglDepthRenderbuffer = n.createRenderbuffer()),
            Me(le.__webglDepthRenderbuffer, k, !0)),
          t.bindFramebuffer(36160, null);
      }
    }
    if (Te) {
      t.bindTexture(34067, Ee.__webglTexture), _e(34067, D, et);
      for (let Ue = 0; Ue < 6; Ue++)
        ve(le.__webglFramebuffer[Ue], k, D, 36064, 34069 + Ue);
      P(D, et) && L(34067), t.unbindTexture();
    } else if (Re) {
      const Ue = k.texture;
      for (let de = 0, He = Ue.length; de < He; de++) {
        const W = Ue[de],
          he = i.get(W);
        t.bindTexture(3553, he.__webglTexture),
          _e(3553, W, et),
          ve(le.__webglFramebuffer, k, W, 36064 + de, 3553),
          P(W, et) && L(3553);
      }
      t.unbindTexture();
    } else {
      let Ue = 3553;
      (k.isWebGL3DRenderTarget || k.isWebGLArrayRenderTarget) &&
        (a
          ? (Ue = k.isWebGL3DRenderTarget ? 32879 : 35866)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(Ue, Ee.__webglTexture),
        _e(Ue, D, et),
        ve(le.__webglFramebuffer, k, D, 36064, Ue),
        P(D, et) && L(Ue),
        t.unbindTexture();
    }
    k.depthBuffer && se(k);
  }
  function Le(k) {
    const D = w(k) || a,
      le = k.isWebGLMultipleRenderTargets === !0 ? k.texture : [k.texture];
    for (let Ee = 0, Te = le.length; Ee < Te; Ee++) {
      const Re = le[Ee];
      if (P(Re, D)) {
        const et = k.isWebGLCubeRenderTarget ? 34067 : 3553,
          Ue = i.get(Re).__webglTexture;
        t.bindTexture(et, Ue), L(et), t.unbindTexture();
      }
    }
  }
  function We(k) {
    if (a && k.samples > 0 && Je(k) === !1) {
      const D = k.isWebGLMultipleRenderTargets ? k.texture : [k.texture],
        le = k.width,
        Ee = k.height;
      let Te = 16384;
      const Re = [],
        et = k.stencilBuffer ? 33306 : 36096,
        Ue = i.get(k),
        de = k.isWebGLMultipleRenderTargets === !0;
      if (de)
        for (let He = 0; He < D.length; He++)
          t.bindFramebuffer(36160, Ue.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(36160, 36064 + He, 36161, null),
            t.bindFramebuffer(36160, Ue.__webglFramebuffer),
            n.framebufferTexture2D(36009, 36064 + He, 3553, null, 0);
      t.bindFramebuffer(36008, Ue.__webglMultisampledFramebuffer),
        t.bindFramebuffer(36009, Ue.__webglFramebuffer);
      for (let He = 0; He < D.length; He++) {
        Re.push(36064 + He), k.depthBuffer && Re.push(et);
        const W =
          Ue.__ignoreDepthValues !== void 0 ? Ue.__ignoreDepthValues : !1;
        if (
          (W === !1 &&
            (k.depthBuffer && (Te |= 256), k.stencilBuffer && (Te |= 1024)),
          de &&
            n.framebufferRenderbuffer(
              36008,
              36064,
              36161,
              Ue.__webglColorRenderbuffer[He]
            ),
          W === !0 &&
            (n.invalidateFramebuffer(36008, [et]),
            n.invalidateFramebuffer(36009, [et])),
          de)
        ) {
          const he = i.get(D[He]).__webglTexture;
          n.framebufferTexture2D(36009, 36064, 3553, he, 0);
        }
        n.blitFramebuffer(0, 0, le, Ee, 0, 0, le, Ee, Te, 9728),
          m && n.invalidateFramebuffer(36008, Re);
      }
      if ((t.bindFramebuffer(36008, null), t.bindFramebuffer(36009, null), de))
        for (let He = 0; He < D.length; He++) {
          t.bindFramebuffer(36160, Ue.__webglMultisampledFramebuffer),
            n.framebufferRenderbuffer(
              36160,
              36064 + He,
              36161,
              Ue.__webglColorRenderbuffer[He]
            );
          const W = i.get(D[He]).__webglTexture;
          t.bindFramebuffer(36160, Ue.__webglFramebuffer),
            n.framebufferTexture2D(36009, 36064 + He, 3553, W, 0);
        }
      t.bindFramebuffer(36009, Ue.__webglMultisampledFramebuffer);
    }
  }
  function Ke(k) {
    return Math.min(d, k.samples);
  }
  function Je(k) {
    const D = i.get(k);
    return (
      a &&
      k.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      D.__useRenderToTexture !== !1
    );
  }
  function nt(k) {
    const D = o.render.frame;
    v.get(k) !== D && (v.set(k, D), k.update());
  }
  function _t(k, D) {
    const le = k.encoding,
      Ee = k.format,
      Te = k.type;
    return (
      k.isCompressedTexture === !0 ||
        k.isVideoTexture === !0 ||
        k.format === Km ||
        (le !== Ks &&
          (le === Tt
            ? a === !1
              ? e.has("EXT_sRGB") === !0 && Ee === Ti
                ? ((k.format = Km),
                  (k.minFilter = rn),
                  (k.generateMipmaps = !1))
                : (D = eA.sRGBToLinear(D))
              : (Ee !== Ti || Te !== Xs) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture encoding:",
                le
              ))),
      D
    );
  }
  (this.allocateTextureUnit = I),
    (this.resetTextureUnits = ae),
    (this.setTexture2D = z),
    (this.setTexture2DArray = q),
    (this.setTexture3D = Q),
    (this.setTextureCube = ee),
    (this.rebindTextures = xe),
    (this.setupRenderTarget = Ne),
    (this.updateRenderTargetMipmap = Le),
    (this.updateMultisampleRenderTarget = We),
    (this.setupDepthRenderbuffer = se),
    (this.setupFrameBufferTexture = ve),
    (this.useMultisampledRTT = Je);
}
function $B(n, e, t) {
  const i = t.isWebGL2;
  function r(s, o = null) {
    let a;
    if (s === Xs) return 5121;
    if (s === MB) return 32819;
    if (s === SB) return 32820;
    if (s === xB) return 5120;
    if (s === _B) return 5122;
    if (s === K1) return 5123;
    if (s === AB) return 5124;
    if (s === bo) return 5125;
    if (s === Ns) return 5126;
    if (s === zu)
      return i
        ? 5131
        : ((a = e.get("OES_texture_half_float")),
          a !== null ? a.HALF_FLOAT_OES : null);
    if (s === wB) return 6406;
    if (s === Ti) return 6408;
    if (s === CB) return 6409;
    if (s === EB) return 6410;
    if (s === Uo) return 6402;
    if (s === rl) return 34041;
    if (s === Km)
      return (a = e.get("EXT_sRGB")), a !== null ? a.SRGB_ALPHA_EXT : null;
    if (s === TB) return 6403;
    if (s === bB) return 36244;
    if (s === PB) return 33319;
    if (s === BB) return 33320;
    if (s === RB) return 36249;
    if (s === dm || s === pm || s === mm || s === gm)
      if (o === Tt)
        if (((a = e.get("WEBGL_compressed_texture_s3tc_srgb")), a !== null)) {
          if (s === dm) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === pm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === mm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === gm) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((a = e.get("WEBGL_compressed_texture_s3tc")), a !== null)) {
        if (s === dm) return a.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === pm) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === mm) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === gm) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === Vx || s === Wx || s === Jx || s === jx)
      if (((a = e.get("WEBGL_compressed_texture_pvrtc")), a !== null)) {
        if (s === Vx) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === Wx) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Jx) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === jx) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === LB)
      return (
        (a = e.get("WEBGL_compressed_texture_etc1")),
        a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === Xx || s === Kx)
      if (((a = e.get("WEBGL_compressed_texture_etc")), a !== null)) {
        if (s === Xx)
          return o === Tt ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2;
        if (s === Kx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : a.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === Yx ||
      s === Qx ||
      s === Zx ||
      s === qx ||
      s === $x ||
      s === e_ ||
      s === t_ ||
      s === n_ ||
      s === i_ ||
      s === r_ ||
      s === s_ ||
      s === o_ ||
      s === a_ ||
      s === l_
    )
      if (((a = e.get("WEBGL_compressed_texture_astc")), a !== null)) {
        if (s === Yx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : a.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === Qx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : a.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === Zx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : a.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === qx)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : a.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === $x)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : a.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === e_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : a.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === t_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : a.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === n_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : a.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === i_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : a.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === r_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : a.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === s_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : a.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === o_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : a.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === a_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : a.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === l_)
          return o === Tt
            ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : a.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === ym)
      if (((a = e.get("EXT_texture_compression_bptc")), a !== null)) {
        if (s === ym)
          return o === Tt
            ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : a.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (s === IB || s === u_ || s === c_ || s === f_)
      if (((a = e.get("EXT_texture_compression_rgtc")), a !== null)) {
        if (s === ym) return a.COMPRESSED_RED_RGTC1_EXT;
        if (s === u_) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === c_) return a.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === f_) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === Ka
      ? i
        ? 34042
        : ((a = e.get("WEBGL_depth_texture")),
          a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null)
      : n[s] !== void 0
      ? n[s]
      : null;
  }
  return { convert: r };
}
class eR extends Vt {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class Os extends Pt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const PG = { type: "move" };
class rv {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new Os()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new Os()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new F()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new F())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new Os()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new F()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new F())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let r = null,
      s = null,
      o = null;
    const a = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        o = !0;
        for (const A of e.hand.values()) {
          const x = t.getJointPose(A, i),
            g = this._getHandJoint(c, A);
          x !== null &&
            (g.matrix.fromArray(x.transform.matrix),
            g.matrix.decompose(g.position, g.rotation, g.scale),
            (g.jointRadius = x.radius)),
            (g.visible = x !== null);
        }
        const h = c.joints["index-finger-tip"],
          d = c.joints["thumb-tip"],
          p = h.position.distanceTo(d.position),
          m = 0.02,
          v = 0.005;
        c.inputState.pinching && p > m + v
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            p <= m - v &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      a !== null &&
        ((r = t.getPose(e.targetRaySpace, i)),
        r === null && s !== null && (r = s),
        r !== null &&
          (a.matrix.fromArray(r.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          r.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(r.linearVelocity))
            : (a.hasLinearVelocity = !1),
          r.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(r.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(PG)));
    }
    return (
      a !== null && (a.visible = r !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = o !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const i = new Os();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class tR extends en {
  constructor(e, t, i, r, s, o, a, l, c, h) {
    if (((h = h !== void 0 ? h : Uo), h !== Uo && h !== rl))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    i === void 0 && h === Uo && (i = bo),
      i === void 0 && h === rl && (i = Ka),
      super(null, r, s, o, a, l, h, i, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = a !== void 0 ? a : dn),
      (this.minFilter = l !== void 0 ? l : dn),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class BG extends ds {
  constructor(e, t) {
    super();
    const i = this;
    let r = null,
      s = 1,
      o = null,
      a = "local-floor",
      l = 1,
      c = null,
      h = null,
      d = null,
      p = null,
      m = null,
      v = null;
    const A = t.getContextAttributes();
    let x = null,
      g = null;
    const _ = [],
      S = [],
      w = new Set(),
      E = new Map(),
      P = new Vt();
    P.layers.enable(1), (P.viewport = new Ot());
    const L = new Vt();
    L.layers.enable(2), (L.viewport = new Ot());
    const B = [P, L],
      b = new eR();
    b.layers.enable(1), b.layers.enable(2);
    let R = null,
      U = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (ee) {
        let ne = _[ee];
        return (
          ne === void 0 && ((ne = new rv()), (_[ee] = ne)),
          ne.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (ee) {
        let ne = _[ee];
        return (
          ne === void 0 && ((ne = new rv()), (_[ee] = ne)), ne.getGripSpace()
        );
      }),
      (this.getHand = function (ee) {
        let ne = _[ee];
        return (
          ne === void 0 && ((ne = new rv()), (_[ee] = ne)), ne.getHandSpace()
        );
      });
    function j(ee) {
      const ne = S.indexOf(ee.inputSource);
      if (ne === -1) return;
      const Ce = _[ne];
      Ce !== void 0 &&
        Ce.dispatchEvent({ type: ee.type, data: ee.inputSource });
    }
    function V() {
      r.removeEventListener("select", j),
        r.removeEventListener("selectstart", j),
        r.removeEventListener("selectend", j),
        r.removeEventListener("squeeze", j),
        r.removeEventListener("squeezestart", j),
        r.removeEventListener("squeezeend", j),
        r.removeEventListener("end", V),
        r.removeEventListener("inputsourceschange", J);
      for (let ee = 0; ee < _.length; ee++) {
        const ne = S[ee];
        ne !== null && ((S[ee] = null), _[ee].disconnect(ne));
      }
      (R = null),
        (U = null),
        e.setRenderTarget(x),
        (m = null),
        (p = null),
        (d = null),
        (r = null),
        (g = null),
        Q.stop(),
        (i.isPresenting = !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (ee) {
      (s = ee),
        i.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (ee) {
        (a = ee),
          i.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || o;
      }),
      (this.setReferenceSpace = function (ee) {
        c = ee;
      }),
      (this.getBaseLayer = function () {
        return p !== null ? p : m;
      }),
      (this.getBinding = function () {
        return d;
      }),
      (this.getFrame = function () {
        return v;
      }),
      (this.getSession = function () {
        return r;
      }),
      (this.setSession = async function (ee) {
        if (((r = ee), r !== null)) {
          if (
            ((x = e.getRenderTarget()),
            r.addEventListener("select", j),
            r.addEventListener("selectstart", j),
            r.addEventListener("selectend", j),
            r.addEventListener("squeeze", j),
            r.addEventListener("squeezestart", j),
            r.addEventListener("squeezeend", j),
            r.addEventListener("end", V),
            r.addEventListener("inputsourceschange", J),
            A.xrCompatible !== !0 && (await t.makeXRCompatible()),
            r.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const ne = {
              antialias: r.renderState.layers === void 0 ? A.antialias : !0,
              alpha: A.alpha,
              depth: A.depth,
              stencil: A.stencil,
              framebufferScaleFactor: s,
            };
            (m = new XRWebGLLayer(r, t, ne)),
              r.updateRenderState({ baseLayer: m }),
              (g = new Gr(m.framebufferWidth, m.framebufferHeight, {
                format: Ti,
                type: Xs,
                encoding: e.outputEncoding,
                stencilBuffer: A.stencil,
              }));
          } else {
            let ne = null,
              Ce = null,
              _e = null;
            A.depth &&
              ((_e = A.stencil ? 35056 : 33190),
              (ne = A.stencil ? rl : Uo),
              (Ce = A.stencil ? Ka : bo));
            const $ = { colorFormat: 32856, depthFormat: _e, scaleFactor: s };
            (d = new XRWebGLBinding(r, t)),
              (p = d.createProjectionLayer($)),
              r.updateRenderState({ layers: [p] }),
              (g = new Gr(p.textureWidth, p.textureHeight, {
                format: Ti,
                type: Xs,
                depthTexture: new tR(
                  p.textureWidth,
                  p.textureHeight,
                  Ce,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  ne
                ),
                stencilBuffer: A.stencil,
                encoding: e.outputEncoding,
                samples: A.antialias ? 4 : 0,
              }));
            const je = e.properties.get(g);
            je.__ignoreDepthValues = p.ignoreDepthValues;
          }
          (g.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (o = await r.requestReferenceSpace(a)),
            Q.setContext(r),
            Q.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      });
    function J(ee) {
      for (let ne = 0; ne < ee.removed.length; ne++) {
        const Ce = ee.removed[ne],
          _e = S.indexOf(Ce);
        _e >= 0 && ((S[_e] = null), _[_e].disconnect(Ce));
      }
      for (let ne = 0; ne < ee.added.length; ne++) {
        const Ce = ee.added[ne];
        let _e = S.indexOf(Ce);
        if (_e === -1) {
          for (let je = 0; je < _.length; je++)
            if (je >= S.length) {
              S.push(Ce), (_e = je);
              break;
            } else if (S[je] === null) {
              (S[je] = Ce), (_e = je);
              break;
            }
          if (_e === -1) break;
        }
        const $ = _[_e];
        $ && $.connect(Ce);
      }
    }
    const X = new F(),
      oe = new F();
    function ae(ee, ne, Ce) {
      X.setFromMatrixPosition(ne.matrixWorld),
        oe.setFromMatrixPosition(Ce.matrixWorld);
      const _e = X.distanceTo(oe),
        $ = ne.projectionMatrix.elements,
        je = Ce.projectionMatrix.elements,
        Xe = $[14] / ($[10] - 1),
        ve = $[14] / ($[10] + 1),
        Me = ($[9] + 1) / $[5],
        me = ($[9] - 1) / $[5],
        se = ($[8] - 1) / $[0],
        xe = (je[8] + 1) / je[0],
        Ne = Xe * se,
        Le = Xe * xe,
        We = _e / (-se + xe),
        Ke = We * -se;
      ne.matrixWorld.decompose(ee.position, ee.quaternion, ee.scale),
        ee.translateX(Ke),
        ee.translateZ(We),
        ee.matrixWorld.compose(ee.position, ee.quaternion, ee.scale),
        ee.matrixWorldInverse.copy(ee.matrixWorld).invert();
      const Je = Xe + We,
        nt = ve + We,
        _t = Ne - Ke,
        k = Le + (_e - Ke),
        D = ((Me * ve) / nt) * Je,
        le = ((me * ve) / nt) * Je;
      ee.projectionMatrix.makePerspective(_t, k, D, le, Je, nt),
        ee.projectionMatrixInverse.copy(ee.projectionMatrix).invert();
    }
    function I(ee, ne) {
      ne === null
        ? ee.matrixWorld.copy(ee.matrix)
        : ee.matrixWorld.multiplyMatrices(ne.matrixWorld, ee.matrix),
        ee.matrixWorldInverse.copy(ee.matrixWorld).invert();
    }
    this.updateCamera = function (ee) {
      if (r === null) return;
      (b.near = L.near = P.near = ee.near),
        (b.far = L.far = P.far = ee.far),
        (R !== b.near || U !== b.far) &&
          (r.updateRenderState({ depthNear: b.near, depthFar: b.far }),
          (R = b.near),
          (U = b.far));
      const ne = ee.parent,
        Ce = b.cameras;
      I(b, ne);
      for (let _e = 0; _e < Ce.length; _e++) I(Ce[_e], ne);
      Ce.length === 2
        ? ae(b, P, L)
        : b.projectionMatrix.copy(P.projectionMatrix),
        G(ee, b, ne);
    };
    function G(ee, ne, Ce) {
      Ce === null
        ? ee.matrix.copy(ne.matrixWorld)
        : (ee.matrix.copy(Ce.matrixWorld),
          ee.matrix.invert(),
          ee.matrix.multiply(ne.matrixWorld)),
        ee.matrix.decompose(ee.position, ee.quaternion, ee.scale),
        ee.updateMatrixWorld(!0);
      const _e = ee.children;
      for (let $ = 0, je = _e.length; $ < je; $++) _e[$].updateMatrixWorld(!0);
      ee.projectionMatrix.copy(ne.projectionMatrix),
        ee.projectionMatrixInverse.copy(ne.projectionMatrixInverse),
        ee.isPerspectiveCamera &&
          ((ee.fov = Vu * 2 * Math.atan(1 / ee.projectionMatrix.elements[5])),
          (ee.zoom = 1));
    }
    (this.getCamera = function () {
      return b;
    }),
      (this.getFoveation = function () {
        if (!(p === null && m === null)) return l;
      }),
      (this.setFoveation = function (ee) {
        (l = ee),
          p !== null && (p.fixedFoveation = ee),
          m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = ee);
      }),
      (this.getPlanes = function () {
        return w;
      });
    let z = null;
    function q(ee, ne) {
      if (((h = ne.getViewerPose(c || o)), (v = ne), h !== null)) {
        const Ce = h.views;
        m !== null &&
          (e.setRenderTargetFramebuffer(g, m.framebuffer),
          e.setRenderTarget(g));
        let _e = !1;
        Ce.length !== b.cameras.length && ((b.cameras.length = 0), (_e = !0));
        for (let $ = 0; $ < Ce.length; $++) {
          const je = Ce[$];
          let Xe = null;
          if (m !== null) Xe = m.getViewport(je);
          else {
            const Me = d.getViewSubImage(p, je);
            (Xe = Me.viewport),
              $ === 0 &&
                (e.setRenderTargetTextures(
                  g,
                  Me.colorTexture,
                  p.ignoreDepthValues ? void 0 : Me.depthStencilTexture
                ),
                e.setRenderTarget(g));
          }
          let ve = B[$];
          ve === void 0 &&
            ((ve = new Vt()),
            ve.layers.enable($),
            (ve.viewport = new Ot()),
            (B[$] = ve)),
            ve.matrix.fromArray(je.transform.matrix),
            ve.matrix.decompose(ve.position, ve.quaternion, ve.scale),
            ve.projectionMatrix.fromArray(je.projectionMatrix),
            ve.projectionMatrixInverse.copy(ve.projectionMatrix).invert(),
            ve.viewport.set(Xe.x, Xe.y, Xe.width, Xe.height),
            $ === 0 &&
              (b.matrix.copy(ve.matrix),
              b.matrix.decompose(b.position, b.quaternion, b.scale)),
            _e === !0 && b.cameras.push(ve);
        }
      }
      for (let Ce = 0; Ce < _.length; Ce++) {
        const _e = S[Ce],
          $ = _[Ce];
        _e !== null && $ !== void 0 && $.update(_e, ne, c || o);
      }
      if ((z && z(ee, ne), ne.detectedPlanes)) {
        i.dispatchEvent({ type: "planesdetected", data: ne.detectedPlanes });
        let Ce = null;
        for (const _e of w)
          ne.detectedPlanes.has(_e) || (Ce === null && (Ce = []), Ce.push(_e));
        if (Ce !== null)
          for (const _e of Ce)
            w.delete(_e),
              E.delete(_e),
              i.dispatchEvent({ type: "planeremoved", data: _e });
        for (const _e of ne.detectedPlanes)
          if (!w.has(_e))
            w.add(_e),
              E.set(_e, ne.lastChangedTime),
              i.dispatchEvent({ type: "planeadded", data: _e });
          else {
            const $ = E.get(_e);
            _e.lastChangedTime > $ &&
              (E.set(_e, _e.lastChangedTime),
              i.dispatchEvent({ type: "planechanged", data: _e }));
          }
      }
      v = null;
    }
    const Q = new KB();
    Q.setAnimationLoop(q),
      (this.setAnimationLoop = function (ee) {
        z = ee;
      }),
      (this.dispose = function () {});
  }
}
function RG(n, e) {
  function t(x, g) {
    x.matrixAutoUpdate === !0 && x.updateMatrix(), g.value.copy(x.matrix);
  }
  function i(x, g) {
    g.color.getRGB(x.fogColor.value, jB(n)),
      g.isFog
        ? ((x.fogNear.value = g.near), (x.fogFar.value = g.far))
        : g.isFogExp2 && (x.fogDensity.value = g.density);
  }
  function r(x, g, _, S, w) {
    g.isMeshBasicMaterial || g.isMeshLambertMaterial
      ? s(x, g)
      : g.isMeshToonMaterial
      ? (s(x, g), d(x, g))
      : g.isMeshPhongMaterial
      ? (s(x, g), h(x, g))
      : g.isMeshStandardMaterial
      ? (s(x, g), p(x, g), g.isMeshPhysicalMaterial && m(x, g, w))
      : g.isMeshMatcapMaterial
      ? (s(x, g), v(x, g))
      : g.isMeshDepthMaterial
      ? s(x, g)
      : g.isMeshDistanceMaterial
      ? (s(x, g), A(x, g))
      : g.isMeshNormalMaterial
      ? s(x, g)
      : g.isLineBasicMaterial
      ? (o(x, g), g.isLineDashedMaterial && a(x, g))
      : g.isPointsMaterial
      ? l(x, g, _, S)
      : g.isSpriteMaterial
      ? c(x, g)
      : g.isShadowMaterial
      ? (x.color.value.copy(g.color), (x.opacity.value = g.opacity))
      : g.isShaderMaterial && (g.uniformsNeedUpdate = !1);
  }
  function s(x, g) {
    (x.opacity.value = g.opacity),
      g.color && x.diffuse.value.copy(g.color),
      g.emissive &&
        x.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
      g.alphaMap &&
        ((x.alphaMap.value = g.alphaMap), t(g.alphaMap, x.alphaMapTransform)),
      g.bumpMap &&
        ((x.bumpMap.value = g.bumpMap),
        t(g.bumpMap, x.bumpMapTransform),
        (x.bumpScale.value = g.bumpScale),
        g.side === mi && (x.bumpScale.value *= -1)),
      g.normalMap &&
        ((x.normalMap.value = g.normalMap),
        t(g.normalMap, x.normalMapTransform),
        x.normalScale.value.copy(g.normalScale),
        g.side === mi && x.normalScale.value.negate()),
      g.displacementMap &&
        ((x.displacementMap.value = g.displacementMap),
        t(g.displacementMap, x.displacementMapTransform),
        (x.displacementScale.value = g.displacementScale),
        (x.displacementBias.value = g.displacementBias)),
      g.emissiveMap &&
        ((x.emissiveMap.value = g.emissiveMap),
        t(g.emissiveMap, x.emissiveMapTransform)),
      g.specularMap &&
        ((x.specularMap.value = g.specularMap),
        t(g.specularMap, x.specularMapTransform)),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
    const _ = e.get(g).envMap;
    if (
      (_ &&
        ((x.envMap.value = _),
        (x.flipEnvMap.value =
          _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1),
        (x.reflectivity.value = g.reflectivity),
        (x.ior.value = g.ior),
        (x.refractionRatio.value = g.refractionRatio)),
      g.lightMap)
    ) {
      x.lightMap.value = g.lightMap;
      const S = n.useLegacyLights === !0 ? Math.PI : 1;
      (x.lightMapIntensity.value = g.lightMapIntensity * S),
        t(g.lightMap, x.lightMapTransform);
    }
    g.aoMap &&
      ((x.aoMap.value = g.aoMap),
      (x.aoMapIntensity.value = g.aoMapIntensity),
      t(g.aoMap, x.aoMapTransform));
  }
  function o(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform));
  }
  function a(x, g) {
    (x.dashSize.value = g.dashSize),
      (x.totalSize.value = g.dashSize + g.gapSize),
      (x.scale.value = g.scale);
  }
  function l(x, g, _, S) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.size.value = g.size * _),
      (x.scale.value = S * 0.5),
      g.map && ((x.map.value = g.map), t(g.map, x.uvTransform)),
      g.alphaMap && (x.alphaMap.value = g.alphaMap),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function c(x, g) {
    x.diffuse.value.copy(g.color),
      (x.opacity.value = g.opacity),
      (x.rotation.value = g.rotation),
      g.map && ((x.map.value = g.map), t(g.map, x.mapTransform)),
      g.alphaMap && (x.alphaMap.value = g.alphaMap),
      g.alphaTest > 0 && (x.alphaTest.value = g.alphaTest);
  }
  function h(x, g) {
    x.specular.value.copy(g.specular),
      (x.shininess.value = Math.max(g.shininess, 1e-4));
  }
  function d(x, g) {
    g.gradientMap && (x.gradientMap.value = g.gradientMap);
  }
  function p(x, g) {
    (x.metalness.value = g.metalness),
      g.metalnessMap &&
        ((x.metalnessMap.value = g.metalnessMap),
        t(g.metalnessMap, x.metalnessMapTransform)),
      (x.roughness.value = g.roughness),
      g.roughnessMap &&
        ((x.roughnessMap.value = g.roughnessMap),
        t(g.roughnessMap, x.roughnessMapTransform)),
      e.get(g).envMap && (x.envMapIntensity.value = g.envMapIntensity);
  }
  function m(x, g, _) {
    (x.ior.value = g.ior),
      g.sheen > 0 &&
        (x.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),
        (x.sheenRoughness.value = g.sheenRoughness),
        g.sheenColorMap &&
          ((x.sheenColorMap.value = g.sheenColorMap),
          t(g.sheenColorMap, x.sheenColorMapTransform)),
        g.sheenRoughnessMap &&
          ((x.sheenRoughnessMap.value = g.sheenRoughnessMap),
          t(g.sheenRoughnessMap, x.sheenRoughnessMapTransform))),
      g.clearcoat > 0 &&
        ((x.clearcoat.value = g.clearcoat),
        (x.clearcoatRoughness.value = g.clearcoatRoughness),
        g.clearcoatMap &&
          ((x.clearcoatMap.value = g.clearcoatMap),
          t(g.clearcoatMap, x.clearcoatMapTransform)),
        g.clearcoatRoughnessMap &&
          ((x.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap),
          t(g.clearcoatRoughnessMap, x.clearcoatRoughnessMapTransform)),
        g.clearcoatNormalMap &&
          ((x.clearcoatNormalMap.value = g.clearcoatNormalMap),
          t(g.clearcoatNormalMap, x.clearcoatNormalMapTransform),
          x.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),
          g.side === mi && x.clearcoatNormalScale.value.negate())),
      g.iridescence > 0 &&
        ((x.iridescence.value = g.iridescence),
        (x.iridescenceIOR.value = g.iridescenceIOR),
        (x.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0]),
        (x.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1]),
        g.iridescenceMap &&
          ((x.iridescenceMap.value = g.iridescenceMap),
          t(g.iridescenceMap, x.iridescenceMapTransform)),
        g.iridescenceThicknessMap &&
          ((x.iridescenceThicknessMap.value = g.iridescenceThicknessMap),
          t(g.iridescenceThicknessMap, x.iridescenceThicknessMapTransform))),
      g.transmission > 0 &&
        ((x.transmission.value = g.transmission),
        (x.transmissionSamplerMap.value = _.texture),
        x.transmissionSamplerSize.value.set(_.width, _.height),
        g.transmissionMap &&
          ((x.transmissionMap.value = g.transmissionMap),
          t(g.transmissionMap, x.transmissionMapTransform)),
        (x.thickness.value = g.thickness),
        g.thicknessMap &&
          ((x.thicknessMap.value = g.thicknessMap),
          t(g.thicknessMap, x.thicknessMapTransform)),
        (x.attenuationDistance.value = g.attenuationDistance),
        x.attenuationColor.value.copy(g.attenuationColor)),
      (x.specularIntensity.value = g.specularIntensity),
      x.specularColor.value.copy(g.specularColor),
      g.specularColorMap &&
        ((x.specularColorMap.value = g.specularColorMap),
        t(g.specularColorMap, x.specularColorMapTransform)),
      g.specularIntensityMap &&
        ((x.specularIntensityMap.value = g.specularIntensityMap),
        t(g.specularIntensityMap, x.specularIntensityMapTransform));
  }
  function v(x, g) {
    g.matcap && (x.matcap.value = g.matcap);
  }
  function A(x, g) {
    const _ = e.get(g).light;
    x.referencePosition.value.setFromMatrixPosition(_.matrixWorld),
      (x.nearDistance.value = _.shadow.camera.near),
      (x.farDistance.value = _.shadow.camera.far);
  }
  return { refreshFogUniforms: i, refreshMaterialUniforms: r };
}
function LG(n, e, t, i) {
  let r = {},
    s = {},
    o = [];
  const a = t.isWebGL2 ? n.getParameter(35375) : 0;
  function l(_, S) {
    const w = S.program;
    i.uniformBlockBinding(_, w);
  }
  function c(_, S) {
    let w = r[_.id];
    w === void 0 &&
      (v(_), (w = h(_)), (r[_.id] = w), _.addEventListener("dispose", x));
    const E = S.program;
    i.updateUBOMapping(_, E);
    const P = e.render.frame;
    s[_.id] !== P && (p(_), (s[_.id] = P));
  }
  function h(_) {
    const S = d();
    _.__bindingPointIndex = S;
    const w = n.createBuffer(),
      E = _.__size,
      P = _.usage;
    return (
      n.bindBuffer(35345, w),
      n.bufferData(35345, E, P),
      n.bindBuffer(35345, null),
      n.bindBufferBase(35345, S, w),
      w
    );
  }
  function d() {
    for (let _ = 0; _ < a; _++) if (o.indexOf(_) === -1) return o.push(_), _;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function p(_) {
    const S = r[_.id],
      w = _.uniforms,
      E = _.__cache;
    n.bindBuffer(35345, S);
    for (let P = 0, L = w.length; P < L; P++) {
      const B = w[P];
      if (m(B, P, E) === !0) {
        const b = B.__offset,
          R = Array.isArray(B.value) ? B.value : [B.value];
        let U = 0;
        for (let j = 0; j < R.length; j++) {
          const V = R[j],
            J = A(V);
          typeof V == "number"
            ? ((B.__data[0] = V), n.bufferSubData(35345, b + U, B.__data))
            : V.isMatrix3
            ? ((B.__data[0] = V.elements[0]),
              (B.__data[1] = V.elements[1]),
              (B.__data[2] = V.elements[2]),
              (B.__data[3] = V.elements[0]),
              (B.__data[4] = V.elements[3]),
              (B.__data[5] = V.elements[4]),
              (B.__data[6] = V.elements[5]),
              (B.__data[7] = V.elements[0]),
              (B.__data[8] = V.elements[6]),
              (B.__data[9] = V.elements[7]),
              (B.__data[10] = V.elements[8]),
              (B.__data[11] = V.elements[0]))
            : (V.toArray(B.__data, U),
              (U += J.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        n.bufferSubData(35345, b, B.__data);
      }
    }
    n.bindBuffer(35345, null);
  }
  function m(_, S, w) {
    const E = _.value;
    if (w[S] === void 0) {
      if (typeof E == "number") w[S] = E;
      else {
        const P = Array.isArray(E) ? E : [E],
          L = [];
        for (let B = 0; B < P.length; B++) L.push(P[B].clone());
        w[S] = L;
      }
      return !0;
    } else if (typeof E == "number") {
      if (w[S] !== E) return (w[S] = E), !0;
    } else {
      const P = Array.isArray(w[S]) ? w[S] : [w[S]],
        L = Array.isArray(E) ? E : [E];
      for (let B = 0; B < P.length; B++) {
        const b = P[B];
        if (b.equals(L[B]) === !1) return b.copy(L[B]), !0;
      }
    }
    return !1;
  }
  function v(_) {
    const S = _.uniforms;
    let w = 0;
    const E = 16;
    let P = 0;
    for (let L = 0, B = S.length; L < B; L++) {
      const b = S[L],
        R = { boundary: 0, storage: 0 },
        U = Array.isArray(b.value) ? b.value : [b.value];
      for (let j = 0, V = U.length; j < V; j++) {
        const J = U[j],
          X = A(J);
        (R.boundary += X.boundary), (R.storage += X.storage);
      }
      if (
        ((b.__data = new Float32Array(
          R.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (b.__offset = w),
        L > 0)
      ) {
        P = w % E;
        const j = E - P;
        P !== 0 && j - R.boundary < 0 && ((w += E - P), (b.__offset = w));
      }
      w += R.storage;
    }
    return (
      (P = w % E), P > 0 && (w += E - P), (_.__size = w), (_.__cache = {}), this
    );
  }
  function A(_) {
    const S = { boundary: 0, storage: 0 };
    return (
      typeof _ == "number"
        ? ((S.boundary = 4), (S.storage = 4))
        : _.isVector2
        ? ((S.boundary = 8), (S.storage = 8))
        : _.isVector3 || _.isColor
        ? ((S.boundary = 16), (S.storage = 12))
        : _.isVector4
        ? ((S.boundary = 16), (S.storage = 16))
        : _.isMatrix3
        ? ((S.boundary = 48), (S.storage = 48))
        : _.isMatrix4
        ? ((S.boundary = 64), (S.storage = 64))
        : _.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            _
          ),
      S
    );
  }
  function x(_) {
    const S = _.target;
    S.removeEventListener("dispose", x);
    const w = o.indexOf(S.__bindingPointIndex);
    o.splice(w, 1), n.deleteBuffer(r[S.id]), delete r[S.id], delete s[S.id];
  }
  function g() {
    for (const _ in r) n.deleteBuffer(r[_]);
    (o = []), (r = {}), (s = {});
  }
  return { bind: l, update: c, dispose: g };
}
function IG() {
  const n = eh("canvas");
  return (n.style.display = "block"), n;
}
class uA {
  constructor(e = {}) {
    const {
      canvas: t = IG(),
      context: i = null,
      depth: r = !0,
      stencil: s = !0,
      alpha: o = !1,
      antialias: a = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: h = "default",
      failIfMajorPerformanceCaveat: d = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let p;
    i !== null ? (p = i.getContextAttributes().alpha) : (p = o);
    let m = null,
      v = null;
    const A = [],
      x = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputEncoding = Ks),
      (this.useLegacyLights = !0),
      (this.toneMapping = Or),
      (this.toneMappingExposure = 1);
    const g = this;
    let _ = !1,
      S = 0,
      w = 0,
      E = null,
      P = -1,
      L = null;
    const B = new Ot(),
      b = new Ot();
    let R = null,
      U = t.width,
      j = t.height,
      V = 1,
      J = null,
      X = null;
    const oe = new Ot(0, 0, U, j),
      ae = new Ot(0, 0, U, j);
    let I = !1;
    const G = new Fg();
    let z = !1,
      q = !1,
      Q = null;
    const ee = new st(),
      ne = new F(),
      Ce = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function _e() {
      return E === null ? V : 1;
    }
    let $ = i;
    function je(N, re) {
      for (let pe = 0; pe < N.length; pe++) {
        const te = N[pe],
          ye = t.getContext(te, re);
        if (ye !== null) return ye;
      }
      return null;
    }
    try {
      const N = {
        alpha: !0,
        depth: r,
        stencil: s,
        antialias: a,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: h,
        failIfMajorPerformanceCaveat: d,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Pg}`),
        t.addEventListener("webglcontextlost", Pe, !1),
        t.addEventListener("webglcontextrestored", qe, !1),
        t.addEventListener("webglcontextcreationerror", ft, !1),
        $ === null)
      ) {
        const re = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (g.isWebGL1Renderer === !0 && re.shift(), ($ = je(re, N)), $ === null)
        )
          throw je(re)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      $.getShaderPrecisionFormat === void 0 &&
        ($.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (N) {
      throw (console.error("THREE.WebGLRenderer: " + N.message), N);
    }
    let Xe,
      ve,
      Me,
      me,
      se,
      xe,
      Ne,
      Le,
      We,
      Ke,
      Je,
      nt,
      _t,
      k,
      D,
      le,
      Ee,
      Te,
      Re,
      et,
      Ue,
      de,
      He,
      W;
    function he() {
      (Xe = new Yz($)),
        (ve = new Vz($, Xe, e)),
        Xe.init(ve),
        (de = new $B($, Xe, ve)),
        (Me = new TG($, Xe, ve)),
        (me = new qz()),
        (se = new mG()),
        (xe = new bG($, Xe, Me, se, ve, de, me)),
        (Ne = new Jz(g)),
        (Le = new Kz(g)),
        (We = new ck($, ve)),
        (He = new Gz($, Xe, We, ve)),
        (Ke = new Qz($, We, me, He)),
        (Je = new n4($, Ke, We, me)),
        (Re = new t4($, ve, xe)),
        (le = new Wz(se)),
        (nt = new pG(g, Ne, Le, Xe, ve, He, le)),
        (_t = new RG(g, se)),
        (k = new yG()),
        (D = new SG(Xe, ve)),
        (Te = new zz(g, Ne, Le, Me, Je, p, l)),
        (Ee = new EG(g, Je, ve)),
        (W = new LG($, me, ve, Me)),
        (et = new Hz($, Xe, me, ve)),
        (Ue = new Zz($, Xe, me, ve)),
        (me.programs = nt.programs),
        (g.capabilities = ve),
        (g.extensions = Xe),
        (g.properties = se),
        (g.renderLists = k),
        (g.shadowMap = Ee),
        (g.state = Me),
        (g.info = me);
    }
    he();
    const Ae = new BG(g, $);
    (this.xr = Ae),
      (this.getContext = function () {
        return $;
      }),
      (this.getContextAttributes = function () {
        return $.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const N = Xe.get("WEBGL_lose_context");
        N && N.loseContext();
      }),
      (this.forceContextRestore = function () {
        const N = Xe.get("WEBGL_lose_context");
        N && N.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return V;
      }),
      (this.setPixelRatio = function (N) {
        N !== void 0 && ((V = N), this.setSize(U, j, !1));
      }),
      (this.getSize = function (N) {
        return N.set(U, j);
      }),
      (this.setSize = function (N, re, pe = !0) {
        if (Ae.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (U = N),
          (j = re),
          (t.width = Math.floor(N * V)),
          (t.height = Math.floor(re * V)),
          pe === !0 &&
            ((t.style.width = N + "px"), (t.style.height = re + "px")),
          this.setViewport(0, 0, N, re);
      }),
      (this.getDrawingBufferSize = function (N) {
        return N.set(U * V, j * V).floor();
      }),
      (this.setDrawingBufferSize = function (N, re, pe) {
        (U = N),
          (j = re),
          (V = pe),
          (t.width = Math.floor(N * pe)),
          (t.height = Math.floor(re * pe)),
          this.setViewport(0, 0, N, re);
      }),
      (this.getCurrentViewport = function (N) {
        return N.copy(B);
      }),
      (this.getViewport = function (N) {
        return N.copy(oe);
      }),
      (this.setViewport = function (N, re, pe, te) {
        N.isVector4 ? oe.set(N.x, N.y, N.z, N.w) : oe.set(N, re, pe, te),
          Me.viewport(B.copy(oe).multiplyScalar(V).floor());
      }),
      (this.getScissor = function (N) {
        return N.copy(ae);
      }),
      (this.setScissor = function (N, re, pe, te) {
        N.isVector4 ? ae.set(N.x, N.y, N.z, N.w) : ae.set(N, re, pe, te),
          Me.scissor(b.copy(ae).multiplyScalar(V).floor());
      }),
      (this.getScissorTest = function () {
        return I;
      }),
      (this.setScissorTest = function (N) {
        Me.setScissorTest((I = N));
      }),
      (this.setOpaqueSort = function (N) {
        J = N;
      }),
      (this.setTransparentSort = function (N) {
        X = N;
      }),
      (this.getClearColor = function (N) {
        return N.copy(Te.getClearColor());
      }),
      (this.setClearColor = function () {
        Te.setClearColor.apply(Te, arguments);
      }),
      (this.getClearAlpha = function () {
        return Te.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Te.setClearAlpha.apply(Te, arguments);
      }),
      (this.clear = function (N = !0, re = !0, pe = !0) {
        let te = 0;
        N && (te |= 16384), re && (te |= 256), pe && (te |= 1024), $.clear(te);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Pe, !1),
          t.removeEventListener("webglcontextrestored", qe, !1),
          t.removeEventListener("webglcontextcreationerror", ft, !1),
          k.dispose(),
          D.dispose(),
          se.dispose(),
          Ne.dispose(),
          Le.dispose(),
          Je.dispose(),
          He.dispose(),
          W.dispose(),
          nt.dispose(),
          Ae.dispose(),
          Ae.removeEventListener("sessionstart", Qe),
          Ae.removeEventListener("sessionend", zt),
          Q && (Q.dispose(), (Q = null)),
          Wt.stop();
      });
    function Pe(N) {
      N.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (_ = !0);
    }
    function qe() {
      console.log("THREE.WebGLRenderer: Context Restored."), (_ = !1);
      const N = me.autoReset,
        re = Ee.enabled,
        pe = Ee.autoUpdate,
        te = Ee.needsUpdate,
        ye = Ee.type;
      he(),
        (me.autoReset = N),
        (Ee.enabled = re),
        (Ee.autoUpdate = pe),
        (Ee.needsUpdate = te),
        (Ee.type = ye);
    }
    function ft(N) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        N.statusMessage
      );
    }
    function Ut(N) {
      const re = N.target;
      re.removeEventListener("dispose", Ut), K(re);
    }
    function K(N) {
      ce(N), se.remove(N);
    }
    function ce(N) {
      const re = se.get(N).programs;
      re !== void 0 &&
        (re.forEach(function (pe) {
          nt.releaseProgram(pe);
        }),
        N.isShaderMaterial && nt.releaseShaderCache(N));
    }
    (this.renderBufferDirect = function (N, re, pe, te, ye, $e) {
      re === null && (re = Ce);
      const rt = ye.isMesh && ye.matrixWorld.determinant() < 0,
        ot = Xh(N, re, pe, te, ye);
      Me.setMaterial(te, rt);
      let ht = pe.index,
        yt = 1;
      te.wireframe === !0 && ((ht = Ke.getWireframeAttribute(pe)), (yt = 2));
      const vt = pe.drawRange,
        At = pe.attributes.position;
      let Ft = vt.start * yt,
        zn = (vt.start + vt.count) * yt;
      $e !== null &&
        ((Ft = Math.max(Ft, $e.start * yt)),
        (zn = Math.min(zn, ($e.start + $e.count) * yt))),
        ht !== null
          ? ((Ft = Math.max(Ft, 0)), (zn = Math.min(zn, ht.count)))
          : At != null &&
            ((Ft = Math.max(Ft, 0)), (zn = Math.min(zn, At.count)));
      const Ii = zn - Ft;
      if (Ii < 0 || Ii === 1 / 0) return;
      He.setup(ye, te, ot, pe, ht);
      let _r,
        Jt = et;
      if (
        (ht !== null && ((_r = We.get(ht)), (Jt = Ue), Jt.setIndex(_r)),
        ye.isMesh)
      )
        te.wireframe === !0
          ? (Me.setLineWidth(te.wireframeLinewidth * _e()), Jt.setMode(1))
          : Jt.setMode(4);
      else if (ye.isLine) {
        let Mt = te.linewidth;
        Mt === void 0 && (Mt = 1),
          Me.setLineWidth(Mt * _e()),
          ye.isLineSegments
            ? Jt.setMode(1)
            : ye.isLineLoop
            ? Jt.setMode(2)
            : Jt.setMode(3);
      } else ye.isPoints ? Jt.setMode(0) : ye.isSprite && Jt.setMode(4);
      if (ye.isInstancedMesh) Jt.renderInstances(Ft, Ii, ye.count);
      else if (pe.isInstancedBufferGeometry) {
        const Mt =
            pe._maxInstanceCount !== void 0 ? pe._maxInstanceCount : 1 / 0,
          sa = Math.min(pe.instanceCount, Mt);
        Jt.renderInstances(Ft, Ii, sa);
      } else Jt.render(Ft, Ii);
    }),
      (this.compile = function (N, re) {
        function pe(te, ye, $e) {
          te.transparent === !0 && te.side === dr && te.forceSinglePass === !1
            ? ((te.side = mi),
              (te.needsUpdate = !0),
              vl(te, ye, $e),
              (te.side = cs),
              (te.needsUpdate = !0),
              vl(te, ye, $e),
              (te.side = dr))
            : vl(te, ye, $e);
        }
        (v = D.get(N)),
          v.init(),
          x.push(v),
          N.traverseVisible(function (te) {
            te.isLight &&
              te.layers.test(re.layers) &&
              (v.pushLight(te), te.castShadow && v.pushShadow(te));
          }),
          v.setupLights(g.useLegacyLights),
          N.traverse(function (te) {
            const ye = te.material;
            if (ye)
              if (Array.isArray(ye))
                for (let $e = 0; $e < ye.length; $e++) {
                  const rt = ye[$e];
                  pe(rt, N, te);
                }
              else pe(ye, N, te);
          }),
          x.pop(),
          (v = null);
      });
    let Se = null;
    function ke(N) {
      Se && Se(N);
    }
    function Qe() {
      Wt.stop();
    }
    function zt() {
      Wt.start();
    }
    const Wt = new KB();
    Wt.setAnimationLoop(ke),
      typeof self < "u" && Wt.setContext(self),
      (this.setAnimationLoop = function (N) {
        (Se = N), Ae.setAnimationLoop(N), N === null ? Wt.stop() : Wt.start();
      }),
      Ae.addEventListener("sessionstart", Qe),
      Ae.addEventListener("sessionend", zt),
      (this.render = function (N, re) {
        if (re !== void 0 && re.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (_ === !0) return;
        N.matrixWorldAutoUpdate === !0 && N.updateMatrixWorld(),
          re.parent === null &&
            re.matrixWorldAutoUpdate === !0 &&
            re.updateMatrixWorld(),
          Ae.enabled === !0 &&
            Ae.isPresenting === !0 &&
            (Ae.cameraAutoUpdate === !0 && Ae.updateCamera(re),
            (re = Ae.getCamera())),
          N.isScene === !0 && N.onBeforeRender(g, N, re, E),
          (v = D.get(N, x.length)),
          v.init(),
          x.push(v),
          ee.multiplyMatrices(re.projectionMatrix, re.matrixWorldInverse),
          G.setFromProjectionMatrix(ee),
          (q = this.localClippingEnabled),
          (z = le.init(this.clippingPlanes, q)),
          (m = k.get(N, A.length)),
          m.init(),
          A.push(m),
          Ln(N, re, 0, g.sortObjects),
          m.finish(),
          g.sortObjects === !0 && m.sort(J, X),
          z === !0 && le.beginShadows();
        const pe = v.state.shadowsArray;
        if (
          (Ee.render(pe, N, re),
          z === !0 && le.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          Te.render(m, N),
          v.setupLights(g.useLegacyLights),
          re.isArrayCamera)
        ) {
          const te = re.cameras;
          for (let ye = 0, $e = te.length; ye < $e; ye++) {
            const rt = te[ye];
            xr(m, N, rt, rt.viewport);
          }
        } else xr(m, N, re);
        E !== null &&
          (xe.updateMultisampleRenderTarget(E), xe.updateRenderTargetMipmap(E)),
          N.isScene === !0 && N.onAfterRender(g, N, re),
          He.resetDefaultState(),
          (P = -1),
          (L = null),
          x.pop(),
          x.length > 0 ? (v = x[x.length - 1]) : (v = null),
          A.pop(),
          A.length > 0 ? (m = A[A.length - 1]) : (m = null);
      });
    function Ln(N, re, pe, te) {
      if (N.visible === !1) return;
      if (N.layers.test(re.layers)) {
        if (N.isGroup) pe = N.renderOrder;
        else if (N.isLOD) N.autoUpdate === !0 && N.update(re);
        else if (N.isLight) v.pushLight(N), N.castShadow && v.pushShadow(N);
        else if (N.isSprite) {
          if (!N.frustumCulled || G.intersectsSprite(N)) {
            te && ne.setFromMatrixPosition(N.matrixWorld).applyMatrix4(ee);
            const rt = Je.update(N),
              ot = N.material;
            ot.visible && m.push(N, rt, ot, pe, ne.z, null);
          }
        } else if (
          (N.isMesh || N.isLine || N.isPoints) &&
          (N.isSkinnedMesh &&
            N.skeleton.frame !== me.render.frame &&
            (N.skeleton.update(), (N.skeleton.frame = me.render.frame)),
          !N.frustumCulled || G.intersectsObject(N))
        ) {
          te && ne.setFromMatrixPosition(N.matrixWorld).applyMatrix4(ee);
          const rt = Je.update(N),
            ot = N.material;
          if (Array.isArray(ot)) {
            const ht = rt.groups;
            for (let yt = 0, vt = ht.length; yt < vt; yt++) {
              const At = ht[yt],
                Ft = ot[At.materialIndex];
              Ft && Ft.visible && m.push(N, rt, Ft, pe, ne.z, At);
            }
          } else ot.visible && m.push(N, rt, ot, pe, ne.z, null);
        }
      }
      const $e = N.children;
      for (let rt = 0, ot = $e.length; rt < ot; rt++) Ln($e[rt], re, pe, te);
    }
    function xr(N, re, pe, te) {
      const ye = N.opaque,
        $e = N.transmissive,
        rt = N.transparent;
      v.setupLightsView(pe),
        z === !0 && le.setGlobalState(g.clippingPlanes, pe),
        $e.length > 0 && Qt(ye, $e, re, pe),
        te && Me.viewport(B.copy(te)),
        ye.length > 0 && ai(ye, re, pe),
        $e.length > 0 && ai($e, re, pe),
        rt.length > 0 && ai(rt, re, pe),
        Me.buffers.depth.setTest(!0),
        Me.buffers.depth.setMask(!0),
        Me.buffers.color.setMask(!0),
        Me.setPolygonOffset(!1);
    }
    function Qt(N, re, pe, te) {
      if (Q === null) {
        const ot = ve.isWebGL2;
        Q = new Gr(1024, 1024, {
          generateMipmaps: !0,
          type: Xe.has("EXT_color_buffer_half_float") ? zu : Xs,
          minFilter: fs,
          samples: ot && a === !0 ? 4 : 0,
        });
      }
      const ye = g.getRenderTarget();
      g.setRenderTarget(Q), g.clear();
      const $e = g.toneMapping;
      (g.toneMapping = Or),
        ai(N, pe, te),
        xe.updateMultisampleRenderTarget(Q),
        xe.updateRenderTargetMipmap(Q);
      let rt = !1;
      for (let ot = 0, ht = re.length; ot < ht; ot++) {
        const yt = re[ot],
          vt = yt.object,
          At = yt.geometry,
          Ft = yt.material,
          zn = yt.group;
        if (Ft.side === dr && vt.layers.test(te.layers)) {
          const Ii = Ft.side;
          (Ft.side = mi),
            (Ft.needsUpdate = !0),
            qi(vt, pe, te, At, Ft, zn),
            (Ft.side = Ii),
            (Ft.needsUpdate = !0),
            (rt = !0);
        }
      }
      rt === !0 &&
        (xe.updateMultisampleRenderTarget(Q), xe.updateRenderTargetMipmap(Q)),
        g.setRenderTarget(ye),
        (g.toneMapping = $e);
    }
    function ai(N, re, pe) {
      const te = re.isScene === !0 ? re.overrideMaterial : null;
      for (let ye = 0, $e = N.length; ye < $e; ye++) {
        const rt = N[ye],
          ot = rt.object,
          ht = rt.geometry,
          yt = te === null ? rt.material : te,
          vt = rt.group;
        ot.layers.test(pe.layers) && qi(ot, re, pe, ht, yt, vt);
      }
    }
    function qi(N, re, pe, te, ye, $e) {
      N.onBeforeRender(g, re, pe, te, ye, $e),
        N.modelViewMatrix.multiplyMatrices(
          pe.matrixWorldInverse,
          N.matrixWorld
        ),
        N.normalMatrix.getNormalMatrix(N.modelViewMatrix),
        ye.onBeforeRender(g, re, pe, te, N, $e),
        ye.transparent === !0 && ye.side === dr && ye.forceSinglePass === !1
          ? ((ye.side = mi),
            (ye.needsUpdate = !0),
            g.renderBufferDirect(pe, re, te, ye, N, $e),
            (ye.side = cs),
            (ye.needsUpdate = !0),
            g.renderBufferDirect(pe, re, te, ye, N, $e),
            (ye.side = dr))
          : g.renderBufferDirect(pe, re, te, ye, N, $e),
        N.onAfterRender(g, re, pe, te, ye, $e);
    }
    function vl(N, re, pe) {
      re.isScene !== !0 && (re = Ce);
      const te = se.get(N),
        ye = v.state.lights,
        $e = v.state.shadowsArray,
        rt = ye.state.version,
        ot = nt.getParameters(N, ye.state, $e, re, pe),
        ht = nt.getProgramCacheKey(ot);
      let yt = te.programs;
      (te.environment = N.isMeshStandardMaterial ? re.environment : null),
        (te.fog = re.fog),
        (te.envMap = (N.isMeshStandardMaterial ? Le : Ne).get(
          N.envMap || te.environment
        )),
        yt === void 0 &&
          (N.addEventListener("dispose", Ut),
          (yt = new Map()),
          (te.programs = yt));
      let vt = yt.get(ht);
      if (vt !== void 0) {
        if (te.currentProgram === vt && te.lightsStateVersion === rt)
          return jh(N, ot), vt;
      } else
        (ot.uniforms = nt.getUniforms(N)),
          N.onBuild(pe, ot, g),
          N.onBeforeCompile(ot, g),
          (vt = nt.acquireProgram(ot, ht)),
          yt.set(ht, vt),
          (te.uniforms = ot.uniforms);
      const At = te.uniforms;
      ((!N.isShaderMaterial && !N.isRawShaderMaterial) || N.clipping === !0) &&
        (At.clippingPlanes = le.uniform),
        jh(N, ot),
        (te.needsLights = s0(N)),
        (te.lightsStateVersion = rt),
        te.needsLights &&
          ((At.ambientLightColor.value = ye.state.ambient),
          (At.lightProbe.value = ye.state.probe),
          (At.directionalLights.value = ye.state.directional),
          (At.directionalLightShadows.value = ye.state.directionalShadow),
          (At.spotLights.value = ye.state.spot),
          (At.spotLightShadows.value = ye.state.spotShadow),
          (At.rectAreaLights.value = ye.state.rectArea),
          (At.ltc_1.value = ye.state.rectAreaLTC1),
          (At.ltc_2.value = ye.state.rectAreaLTC2),
          (At.pointLights.value = ye.state.point),
          (At.pointLightShadows.value = ye.state.pointShadow),
          (At.hemisphereLights.value = ye.state.hemi),
          (At.directionalShadowMap.value = ye.state.directionalShadowMap),
          (At.directionalShadowMatrix.value = ye.state.directionalShadowMatrix),
          (At.spotShadowMap.value = ye.state.spotShadowMap),
          (At.spotLightMatrix.value = ye.state.spotLightMatrix),
          (At.spotLightMap.value = ye.state.spotLightMap),
          (At.pointShadowMap.value = ye.state.pointShadowMap),
          (At.pointShadowMatrix.value = ye.state.pointShadowMatrix));
      const Ft = vt.getUniforms(),
        zn = _m.seqWithValue(Ft.seq, At);
      return (te.currentProgram = vt), (te.uniformsList = zn), vt;
    }
    function jh(N, re) {
      const pe = se.get(N);
      (pe.outputEncoding = re.outputEncoding),
        (pe.instancing = re.instancing),
        (pe.skinning = re.skinning),
        (pe.morphTargets = re.morphTargets),
        (pe.morphNormals = re.morphNormals),
        (pe.morphColors = re.morphColors),
        (pe.morphTargetsCount = re.morphTargetsCount),
        (pe.numClippingPlanes = re.numClippingPlanes),
        (pe.numIntersection = re.numClipIntersection),
        (pe.vertexAlphas = re.vertexAlphas),
        (pe.vertexTangents = re.vertexTangents),
        (pe.toneMapping = re.toneMapping);
    }
    function Xh(N, re, pe, te, ye) {
      re.isScene !== !0 && (re = Ce), xe.resetTextureUnits();
      const $e = re.fog,
        rt = te.isMeshStandardMaterial ? re.environment : null,
        ot =
          E === null
            ? g.outputEncoding
            : E.isXRRenderTarget === !0
            ? E.texture.encoding
            : Ks,
        ht = (te.isMeshStandardMaterial ? Le : Ne).get(te.envMap || rt),
        yt =
          te.vertexColors === !0 &&
          !!pe.attributes.color &&
          pe.attributes.color.itemSize === 4,
        vt = !!te.normalMap && !!pe.attributes.tangent,
        At = !!pe.morphAttributes.position,
        Ft = !!pe.morphAttributes.normal,
        zn = !!pe.morphAttributes.color,
        Ii = te.toneMapped ? g.toneMapping : Or,
        _r =
          pe.morphAttributes.position ||
          pe.morphAttributes.normal ||
          pe.morphAttributes.color,
        Jt = _r !== void 0 ? _r.length : 0,
        Mt = se.get(te),
        sa = v.state.lights;
      if (z === !0 && (q === !0 || N !== L)) {
        const Gt = N === L && te.id === P;
        le.setState(te, N, Gt);
      }
      let vn = !1;
      te.version === Mt.__version
        ? ((Mt.needsLights && Mt.lightsStateVersion !== sa.state.version) ||
            Mt.outputEncoding !== ot ||
            (ye.isInstancedMesh && Mt.instancing === !1) ||
            (!ye.isInstancedMesh && Mt.instancing === !0) ||
            (ye.isSkinnedMesh && Mt.skinning === !1) ||
            (!ye.isSkinnedMesh && Mt.skinning === !0) ||
            Mt.envMap !== ht ||
            (te.fog === !0 && Mt.fog !== $e) ||
            (Mt.numClippingPlanes !== void 0 &&
              (Mt.numClippingPlanes !== le.numPlanes ||
                Mt.numIntersection !== le.numIntersection)) ||
            Mt.vertexAlphas !== yt ||
            Mt.vertexTangents !== vt ||
            Mt.morphTargets !== At ||
            Mt.morphNormals !== Ft ||
            Mt.morphColors !== zn ||
            Mt.toneMapping !== Ii ||
            (ve.isWebGL2 === !0 && Mt.morphTargetsCount !== Jt)) &&
          (vn = !0)
        : ((vn = !0), (Mt.__version = te.version));
      let Ar = Mt.currentProgram;
      vn === !0 && (Ar = vl(te, re, ye));
      let ps = !1,
        xi = !1,
        Nt = !1;
      const dt = Ar.getUniforms(),
        Kn = Mt.uniforms;
      if (
        (Me.useProgram(Ar.program) && ((ps = !0), (xi = !0), (Nt = !0)),
        te.id !== P && ((P = te.id), (xi = !0)),
        ps || L !== N)
      ) {
        if (
          (dt.setValue($, "projectionMatrix", N.projectionMatrix),
          ve.logarithmicDepthBuffer &&
            dt.setValue(
              $,
              "logDepthBufFC",
              2 / (Math.log(N.far + 1) / Math.LN2)
            ),
          L !== N && ((L = N), (xi = !0), (Nt = !0)),
          te.isShaderMaterial ||
            te.isMeshPhongMaterial ||
            te.isMeshToonMaterial ||
            te.isMeshStandardMaterial ||
            te.envMap)
        ) {
          const Gt = dt.map.cameraPosition;
          Gt !== void 0 &&
            Gt.setValue($, ne.setFromMatrixPosition(N.matrixWorld));
        }
        (te.isMeshPhongMaterial ||
          te.isMeshToonMaterial ||
          te.isMeshLambertMaterial ||
          te.isMeshBasicMaterial ||
          te.isMeshStandardMaterial ||
          te.isShaderMaterial) &&
          dt.setValue($, "isOrthographic", N.isOrthographicCamera === !0),
          (te.isMeshPhongMaterial ||
            te.isMeshToonMaterial ||
            te.isMeshLambertMaterial ||
            te.isMeshBasicMaterial ||
            te.isMeshStandardMaterial ||
            te.isShaderMaterial ||
            te.isShadowMaterial ||
            ye.isSkinnedMesh) &&
            dt.setValue($, "viewMatrix", N.matrixWorldInverse);
      }
      if (ye.isSkinnedMesh) {
        dt.setOptional($, ye, "bindMatrix"),
          dt.setOptional($, ye, "bindMatrixInverse");
        const Gt = ye.skeleton;
        Gt &&
          (ve.floatVertexTextures
            ? (Gt.boneTexture === null && Gt.computeBoneTexture(),
              dt.setValue($, "boneTexture", Gt.boneTexture, xe),
              dt.setValue($, "boneTextureSize", Gt.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const xn = pe.morphAttributes;
      if (
        ((xn.position !== void 0 ||
          xn.normal !== void 0 ||
          (xn.color !== void 0 && ve.isWebGL2 === !0)) &&
          Re.update(ye, pe, Ar),
        (xi || Mt.receiveShadow !== ye.receiveShadow) &&
          ((Mt.receiveShadow = ye.receiveShadow),
          dt.setValue($, "receiveShadow", ye.receiveShadow)),
        te.isMeshGouraudMaterial &&
          te.envMap !== null &&
          ((Kn.envMap.value = ht),
          (Kn.flipEnvMap.value =
            ht.isCubeTexture && ht.isRenderTargetTexture === !1 ? -1 : 1)),
        xi &&
          (dt.setValue($, "toneMappingExposure", g.toneMappingExposure),
          Mt.needsLights && uc(Kn, Nt),
          $e && te.fog === !0 && _t.refreshFogUniforms(Kn, $e),
          _t.refreshMaterialUniforms(Kn, te, V, j, Q),
          _m.upload($, Mt.uniformsList, Kn, xe)),
        te.isShaderMaterial &&
          te.uniformsNeedUpdate === !0 &&
          (_m.upload($, Mt.uniformsList, Kn, xe), (te.uniformsNeedUpdate = !1)),
        te.isSpriteMaterial && dt.setValue($, "center", ye.center),
        dt.setValue($, "modelViewMatrix", ye.modelViewMatrix),
        dt.setValue($, "normalMatrix", ye.normalMatrix),
        dt.setValue($, "modelMatrix", ye.matrixWorld),
        te.isShaderMaterial || te.isRawShaderMaterial)
      ) {
        const Gt = te.uniformsGroups;
        for (let Mr = 0, eo = Gt.length; Mr < eo; Mr++)
          if (ve.isWebGL2) {
            const Gn = Gt[Mr];
            W.update(Gn, Ar), W.bind(Gn, Ar);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return Ar;
    }
    function uc(N, re) {
      (N.ambientLightColor.needsUpdate = re),
        (N.lightProbe.needsUpdate = re),
        (N.directionalLights.needsUpdate = re),
        (N.directionalLightShadows.needsUpdate = re),
        (N.pointLights.needsUpdate = re),
        (N.pointLightShadows.needsUpdate = re),
        (N.spotLights.needsUpdate = re),
        (N.spotLightShadows.needsUpdate = re),
        (N.rectAreaLights.needsUpdate = re),
        (N.hemisphereLights.needsUpdate = re);
    }
    function s0(N) {
      return (
        N.isMeshLambertMaterial ||
        N.isMeshToonMaterial ||
        N.isMeshPhongMaterial ||
        N.isMeshStandardMaterial ||
        N.isShadowMaterial ||
        (N.isShaderMaterial && N.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return S;
    }),
      (this.getActiveMipmapLevel = function () {
        return w;
      }),
      (this.getRenderTarget = function () {
        return E;
      }),
      (this.setRenderTargetTextures = function (N, re, pe) {
        (se.get(N.texture).__webglTexture = re),
          (se.get(N.depthTexture).__webglTexture = pe);
        const te = se.get(N);
        (te.__hasExternalTextures = !0),
          te.__hasExternalTextures &&
            ((te.__autoAllocateDepthBuffer = pe === void 0),
            te.__autoAllocateDepthBuffer ||
              (Xe.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (te.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (N, re) {
        const pe = se.get(N);
        (pe.__webglFramebuffer = re),
          (pe.__useDefaultFramebuffer = re === void 0);
      }),
      (this.setRenderTarget = function (N, re = 0, pe = 0) {
        (E = N), (S = re), (w = pe);
        let te = !0,
          ye = null,
          $e = !1,
          rt = !1;
        if (N) {
          const ht = se.get(N);
          ht.__useDefaultFramebuffer !== void 0
            ? (Me.bindFramebuffer(36160, null), (te = !1))
            : ht.__webglFramebuffer === void 0
            ? xe.setupRenderTarget(N)
            : ht.__hasExternalTextures &&
              xe.rebindTextures(
                N,
                se.get(N.texture).__webglTexture,
                se.get(N.depthTexture).__webglTexture
              );
          const yt = N.texture;
          (yt.isData3DTexture ||
            yt.isDataArrayTexture ||
            yt.isCompressedArrayTexture) &&
            (rt = !0);
          const vt = se.get(N).__webglFramebuffer;
          N.isWebGLCubeRenderTarget
            ? ((ye = vt[re]), ($e = !0))
            : ve.isWebGL2 && N.samples > 0 && xe.useMultisampledRTT(N) === !1
            ? (ye = se.get(N).__webglMultisampledFramebuffer)
            : (ye = vt),
            B.copy(N.viewport),
            b.copy(N.scissor),
            (R = N.scissorTest);
        } else
          B.copy(oe).multiplyScalar(V).floor(),
            b.copy(ae).multiplyScalar(V).floor(),
            (R = I);
        if (
          (Me.bindFramebuffer(36160, ye) &&
            ve.drawBuffers &&
            te &&
            Me.drawBuffers(N, ye),
          Me.viewport(B),
          Me.scissor(b),
          Me.setScissorTest(R),
          $e)
        ) {
          const ht = se.get(N.texture);
          $.framebufferTexture2D(
            36160,
            36064,
            34069 + re,
            ht.__webglTexture,
            pe
          );
        } else if (rt) {
          const ht = se.get(N.texture),
            yt = re || 0;
          $.framebufferTextureLayer(
            36160,
            36064,
            ht.__webglTexture,
            pe || 0,
            yt
          );
        }
        P = -1;
      }),
      (this.readRenderTargetPixels = function (N, re, pe, te, ye, $e, rt) {
        if (!(N && N.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let ot = se.get(N).__webglFramebuffer;
        if ((N.isWebGLCubeRenderTarget && rt !== void 0 && (ot = ot[rt]), ot)) {
          Me.bindFramebuffer(36160, ot);
          try {
            const ht = N.texture,
              yt = ht.format,
              vt = ht.type;
            if (yt !== Ti && de.convert(yt) !== $.getParameter(35739)) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const At =
              vt === zu &&
              (Xe.has("EXT_color_buffer_half_float") ||
                (ve.isWebGL2 && Xe.has("EXT_color_buffer_float")));
            if (
              vt !== Xs &&
              de.convert(vt) !== $.getParameter(35738) &&
              !(
                vt === Ns &&
                (ve.isWebGL2 ||
                  Xe.has("OES_texture_float") ||
                  Xe.has("WEBGL_color_buffer_float"))
              ) &&
              !At
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            re >= 0 &&
              re <= N.width - te &&
              pe >= 0 &&
              pe <= N.height - ye &&
              $.readPixels(re, pe, te, ye, de.convert(yt), de.convert(vt), $e);
          } finally {
            const ht = E !== null ? se.get(E).__webglFramebuffer : null;
            Me.bindFramebuffer(36160, ht);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (N, re, pe = 0) {
        const te = Math.pow(2, -pe),
          ye = Math.floor(re.image.width * te),
          $e = Math.floor(re.image.height * te);
        xe.setTexture2D(re, 0),
          $.copyTexSubImage2D(3553, pe, 0, 0, N.x, N.y, ye, $e),
          Me.unbindTexture();
      }),
      (this.copyTextureToTexture = function (N, re, pe, te = 0) {
        const ye = re.image.width,
          $e = re.image.height,
          rt = de.convert(pe.format),
          ot = de.convert(pe.type);
        xe.setTexture2D(pe, 0),
          $.pixelStorei(37440, pe.flipY),
          $.pixelStorei(37441, pe.premultiplyAlpha),
          $.pixelStorei(3317, pe.unpackAlignment),
          re.isDataTexture
            ? $.texSubImage2D(3553, te, N.x, N.y, ye, $e, rt, ot, re.image.data)
            : re.isCompressedTexture
            ? $.compressedTexSubImage2D(
                3553,
                te,
                N.x,
                N.y,
                re.mipmaps[0].width,
                re.mipmaps[0].height,
                rt,
                re.mipmaps[0].data
              )
            : $.texSubImage2D(3553, te, N.x, N.y, rt, ot, re.image),
          te === 0 && pe.generateMipmaps && $.generateMipmap(3553),
          Me.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (N, re, pe, te, ye = 0) {
        if (g.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const $e = N.max.x - N.min.x + 1,
          rt = N.max.y - N.min.y + 1,
          ot = N.max.z - N.min.z + 1,
          ht = de.convert(te.format),
          yt = de.convert(te.type);
        let vt;
        if (te.isData3DTexture) xe.setTexture3D(te, 0), (vt = 32879);
        else if (te.isDataArrayTexture)
          xe.setTexture2DArray(te, 0), (vt = 35866);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        $.pixelStorei(37440, te.flipY),
          $.pixelStorei(37441, te.premultiplyAlpha),
          $.pixelStorei(3317, te.unpackAlignment);
        const At = $.getParameter(3314),
          Ft = $.getParameter(32878),
          zn = $.getParameter(3316),
          Ii = $.getParameter(3315),
          _r = $.getParameter(32877),
          Jt = pe.isCompressedTexture ? pe.mipmaps[0] : pe.image;
        $.pixelStorei(3314, Jt.width),
          $.pixelStorei(32878, Jt.height),
          $.pixelStorei(3316, N.min.x),
          $.pixelStorei(3315, N.min.y),
          $.pixelStorei(32877, N.min.z),
          pe.isDataTexture || pe.isData3DTexture
            ? $.texSubImage3D(
                vt,
                ye,
                re.x,
                re.y,
                re.z,
                $e,
                rt,
                ot,
                ht,
                yt,
                Jt.data
              )
            : pe.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              $.compressedTexSubImage3D(
                vt,
                ye,
                re.x,
                re.y,
                re.z,
                $e,
                rt,
                ot,
                ht,
                Jt.data
              ))
            : $.texSubImage3D(vt, ye, re.x, re.y, re.z, $e, rt, ot, ht, yt, Jt),
          $.pixelStorei(3314, At),
          $.pixelStorei(32878, Ft),
          $.pixelStorei(3316, zn),
          $.pixelStorei(3315, Ii),
          $.pixelStorei(32877, _r),
          ye === 0 && te.generateMipmaps && $.generateMipmap(vt),
          Me.unbindTexture();
      }),
      (this.initTexture = function (N) {
        N.isCubeTexture
          ? xe.setTextureCube(N, 0)
          : N.isData3DTexture
          ? xe.setTexture3D(N, 0)
          : N.isDataArrayTexture || N.isCompressedArrayTexture
          ? xe.setTexture2DArray(N, 0)
          : xe.setTexture2D(N, 0),
          Me.unbindTexture();
      }),
      (this.resetState = function () {
        (S = 0), (w = 0), (E = null), Me.reset(), He.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
}
class nR extends uA {}
nR.prototype.isWebGL1Renderer = !0;
class Og {
  constructor(e, t = 25e-5) {
    (this.isFogExp2 = !0),
      (this.name = ""),
      (this.color = new Ie(e)),
      (this.density = t);
  }
  clone() {
    return new Og(this.color, this.density);
  }
  toJSON() {
    return {
      type: "FogExp2",
      color: this.color.getHex(),
      density: this.density,
    };
  }
}
class kg {
  constructor(e, t = 1, i = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Ie(e)),
      (this.near = t),
      (this.far = i);
  }
  clone() {
    return new kg(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class Ym extends Pt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
  get autoUpdate() {
    return (
      console.warn(
        "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
      ),
      this.matrixWorldAutoUpdate
    );
  }
  set autoUpdate(e) {
    console.warn(
      "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
    ),
      (this.matrixWorldAutoUpdate = e);
  }
}
class wh {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = $f),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = ji());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let r = 0, s = this.stride; r < s; r++)
      this.array[e + r] = t.array[i + r];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ji()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ji()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const ci = new F();
class Xo {
  constructor(e, t, i, r = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = r);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      ci.fromBufferAttribute(this, t),
        ci.applyMatrix4(e),
        this.setXYZ(t, ci.x, ci.y, ci.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      ci.fromBufferAttribute(this, t),
        ci.applyNormalMatrix(e),
        this.setXYZ(t, ci.x, ci.y, ci.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      ci.fromBufferAttribute(this, t),
        ci.transformDirection(e),
        this.setXYZ(t, ci.x, ci.y, ci.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = gt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Vi(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = gt(t, this.array)), (i = gt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, r) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = gt(t, this.array)),
        (i = gt(i, this.array)),
        (r = gt(r, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      this
    );
  }
  setXYZW(e, t, i, r, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = gt(t, this.array)),
        (i = gt(i, this.array)),
        (r = gt(r, this.array)),
        (s = gt(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = r),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return new Dt(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Xo(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let i = 0; i < this.count; i++) {
        const r = i * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[r + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
class cA extends Cn {
  constructor(e) {
    super(),
      (this.isSpriteMaterial = !0),
      (this.type = "SpriteMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.rotation = e.rotation),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
let Kl;
const Gc = new F(),
  Yl = new F(),
  Ql = new F(),
  Zl = new ge(),
  Hc = new ge(),
  iR = new st(),
  Cp = new F(),
  Vc = new F(),
  Ep = new F(),
  jC = new ge(),
  sv = new ge(),
  XC = new ge();
class rR extends Pt {
  constructor(e) {
    if (
      (super(), (this.isSprite = !0), (this.type = "Sprite"), Kl === void 0)
    ) {
      Kl = new ct();
      const t = new Float32Array([
          -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
          0, 0, 1,
        ]),
        i = new wh(t, 5);
      Kl.setIndex([0, 1, 2, 0, 2, 3]),
        Kl.setAttribute("position", new Xo(i, 3, 0, !1)),
        Kl.setAttribute("uv", new Xo(i, 2, 3, !1));
    }
    (this.geometry = Kl),
      (this.material = e !== void 0 ? e : new cA()),
      (this.center = new ge(0.5, 0.5));
  }
  raycast(e, t) {
    e.camera === null &&
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'
      ),
      Yl.setFromMatrixScale(this.matrixWorld),
      iR.copy(e.camera.matrixWorld),
      this.modelViewMatrix.multiplyMatrices(
        e.camera.matrixWorldInverse,
        this.matrixWorld
      ),
      Ql.setFromMatrixPosition(this.modelViewMatrix),
      e.camera.isPerspectiveCamera &&
        this.material.sizeAttenuation === !1 &&
        Yl.multiplyScalar(-Ql.z);
    const i = this.material.rotation;
    let r, s;
    i !== 0 && ((s = Math.cos(i)), (r = Math.sin(i)));
    const o = this.center;
    Tp(Cp.set(-0.5, -0.5, 0), Ql, o, Yl, r, s),
      Tp(Vc.set(0.5, -0.5, 0), Ql, o, Yl, r, s),
      Tp(Ep.set(0.5, 0.5, 0), Ql, o, Yl, r, s),
      jC.set(0, 0),
      sv.set(1, 0),
      XC.set(1, 1);
    let a = e.ray.intersectTriangle(Cp, Vc, Ep, !1, Gc);
    if (
      a === null &&
      (Tp(Vc.set(-0.5, 0.5, 0), Ql, o, Yl, r, s),
      sv.set(0, 1),
      (a = e.ray.intersectTriangle(Cp, Ep, Vc, !1, Gc)),
      a === null)
    )
      return;
    const l = e.ray.origin.distanceTo(Gc);
    l < e.near ||
      l > e.far ||
      t.push({
        distance: l,
        point: Gc.clone(),
        uv: Ei.getInterpolation(Gc, Cp, Vc, Ep, jC, sv, XC, new ge()),
        face: null,
        object: this,
      });
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.center !== void 0 && this.center.copy(e.center),
      (this.material = e.material),
      this
    );
  }
}
function Tp(n, e, t, i, r, s) {
  Zl.subVectors(n, t).addScalar(0.5).multiply(i),
    r !== void 0
      ? ((Hc.x = s * Zl.x - r * Zl.y), (Hc.y = r * Zl.x + s * Zl.y))
      : Hc.copy(Zl),
    n.copy(e),
    (n.x += Hc.x),
    (n.y += Hc.y),
    n.applyMatrix4(iR);
}
const bp = new F(),
  KC = new F();
class sR extends Pt {
  constructor() {
    super(),
      (this._currentLevel = 0),
      (this.type = "LOD"),
      Object.defineProperties(this, {
        levels: { enumerable: !0, value: [] },
        isLOD: { value: !0 },
      }),
      (this.autoUpdate = !0);
  }
  copy(e) {
    super.copy(e, !1);
    const t = e.levels;
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      this.addLevel(s.object.clone(), s.distance, s.hysteresis);
    }
    return (this.autoUpdate = e.autoUpdate), this;
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const r = this.levels;
    let s;
    for (s = 0; s < r.length && !(t < r[s].distance); s++);
    return (
      r.splice(s, 0, { distance: t, hysteresis: i, object: e }),
      this.add(e),
      this
    );
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getObjectForDistance(e) {
    const t = this.levels;
    if (t.length > 0) {
      let i, r;
      for (i = 1, r = t.length; i < r; i++) {
        let s = t[i].distance;
        if ((t[i].object.visible && (s -= s * t[i].hysteresis), e < s)) break;
      }
      return t[i - 1].object;
    }
    return null;
  }
  raycast(e, t) {
    if (this.levels.length > 0) {
      bp.setFromMatrixPosition(this.matrixWorld);
      const r = e.ray.origin.distanceTo(bp);
      this.getObjectForDistance(r).raycast(e, t);
    }
  }
  update(e) {
    const t = this.levels;
    if (t.length > 1) {
      bp.setFromMatrixPosition(e.matrixWorld),
        KC.setFromMatrixPosition(this.matrixWorld);
      const i = bp.distanceTo(KC) / e.zoom;
      t[0].object.visible = !0;
      let r, s;
      for (r = 1, s = t.length; r < s; r++) {
        let o = t[r].distance;
        if ((t[r].object.visible && (o -= o * t[r].hysteresis), i >= o))
          (t[r - 1].object.visible = !1), (t[r].object.visible = !0);
        else break;
      }
      for (this._currentLevel = r - 1; r < s; r++) t[r].object.visible = !1;
    }
  }
  toJSON(e) {
    const t = super.toJSON(e);
    this.autoUpdate === !1 && (t.object.autoUpdate = !1),
      (t.object.levels = []);
    const i = this.levels;
    for (let r = 0, s = i.length; r < s; r++) {
      const o = i[r];
      t.object.levels.push({
        object: o.object.uuid,
        distance: o.distance,
        hysteresis: o.hysteresis,
      });
    }
    return t;
  }
}
const YC = new F(),
  QC = new Ot(),
  ZC = new Ot(),
  DG = new F(),
  qC = new st(),
  ql = new F();
class fA extends Pn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new st()),
      (this.bindMatrixInverse = new st()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new Hr()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      ql.fromBufferAttribute(t, i),
        this.applyBoneTransform(i, ql),
        this.boundingBox.expandByPoint(ql);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new Vr()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      ql.fromBufferAttribute(t, i),
        this.applyBoneTransform(i, ql),
        this.boundingSphere.expandByPoint(ql);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      this
    );
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Ot(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, r = t.count; i < r; i++) {
      e.fromBufferAttribute(t, i);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      r = this.geometry;
    QC.fromBufferAttribute(r.attributes.skinIndex, e),
      ZC.fromBufferAttribute(r.attributes.skinWeight, e),
      YC.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const o = ZC.getComponent(s);
      if (o !== 0) {
        const a = QC.getComponent(s);
        qC.multiplyMatrices(i.bones[a].matrixWorld, i.boneInverses[a]),
          t.addScaledVector(DG.copy(YC).applyMatrix4(qC), o);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class Ug extends Pt {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Bu extends en {
  constructor(e = null, t = 1, i = 1, r, s, o, a, l, c = dn, h = dn, d, p) {
    super(null, o, a, l, c, h, r, s, d, p),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const $C = new st(),
  FG = new st();
class Ch {
  constructor(e = [], t = []) {
    (this.uuid = ji()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let i = 0, r = this.bones.length; i < r; i++)
        this.boneInverses.push(new st());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = new st();
      this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(i);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i && i.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const i = this.bones[e];
      i &&
        (i.parent && i.parent.isBone
          ? (i.matrix.copy(i.parent.matrixWorld).invert(),
            i.matrix.multiply(i.matrixWorld))
          : i.matrix.copy(i.matrixWorld),
        i.matrix.decompose(i.position, i.quaternion, i.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      r = this.boneTexture;
    for (let s = 0, o = e.length; s < o; s++) {
      const a = e[s] ? e[s].matrixWorld : FG;
      $C.multiplyMatrices(a, t[s]), $C.toArray(i, s * 16);
    }
    r !== null && (r.needsUpdate = !0);
  }
  clone() {
    return new Ch(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = HB(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Bu(t, e, e, Ti, Ns);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const r = this.bones[t];
      if (r.name === e) return r;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, r = e.bones.length; i < r; i++) {
      const s = e.bones[i];
      let o = t[s];
      o === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (o = new Ug())),
        this.bones.push(o),
        this.boneInverses.push(new st().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r];
      e.bones.push(o.uuid);
      const a = i[r];
      e.boneInverses.push(a.toArray());
    }
    return e;
  }
}
class Ju extends Dt {
  constructor(e, t, i, r = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = r);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const $l = new st(),
  eE = new st(),
  Pp = [],
  tE = new Hr(),
  NG = new st(),
  Wc = new Pn(),
  Jc = new Vr();
class oR extends Pn {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Ju(new Float32Array(i * 16), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let r = 0; r < i; r++) this.setMatrixAt(r, NG);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new Hr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, $l),
        tE.copy(e.boundingBox).applyMatrix4($l),
        this.boundingBox.union(tE);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new Vr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, $l),
        Jc.copy(e.boundingSphere).applyMatrix4($l),
        this.boundingSphere.union(Jc);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      r = this.count;
    if (
      ((Wc.geometry = this.geometry),
      (Wc.material = this.material),
      Wc.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        Jc.copy(this.boundingSphere),
        Jc.applyMatrix4(i),
        e.ray.intersectsSphere(Jc) !== !1))
    )
      for (let s = 0; s < r; s++) {
        this.getMatrixAt(s, $l),
          eE.multiplyMatrices(i, $l),
          (Wc.matrixWorld = eE),
          Wc.raycast(e, Pp);
        for (let o = 0, a = Pp.length; o < a; o++) {
          const l = Pp[o];
          (l.instanceId = s), (l.object = this), t.push(l);
        }
        Pp.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new Ju(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class oi extends Cn {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const nE = new F(),
  iE = new F(),
  rE = new st(),
  ov = new Ah(),
  Bp = new Vr();
class Ys extends Pt {
  constructor(e = new ct(), t = new oi()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [0];
      for (let r = 1, s = t.count; r < s; r++)
        nE.fromBufferAttribute(t, r - 1),
          iE.fromBufferAttribute(t, r),
          (i[r] = i[r - 1]),
          (i[r] += nE.distanceTo(iE));
      e.setAttribute("lineDistance", new Ve(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Line.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Bp.copy(i.boundingSphere),
      Bp.applyMatrix4(r),
      (Bp.radius += s),
      e.ray.intersectsSphere(Bp) === !1)
    )
      return;
    rE.copy(r).invert(), ov.copy(e.ray).applyMatrix4(rE);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = new F(),
      h = new F(),
      d = new F(),
      p = new F(),
      m = this.isLineSegments ? 2 : 1,
      v = i.index,
      x = i.attributes.position;
    if (v !== null) {
      const g = Math.max(0, o.start),
        _ = Math.min(v.count, o.start + o.count);
      for (let S = g, w = _ - 1; S < w; S += m) {
        const E = v.getX(S),
          P = v.getX(S + 1);
        if (
          (c.fromBufferAttribute(x, E),
          h.fromBufferAttribute(x, P),
          ov.distanceSqToSegment(c, h, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const B = e.ray.origin.distanceTo(p);
        B < e.near ||
          B > e.far ||
          t.push({
            distance: B,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: S,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const g = Math.max(0, o.start),
        _ = Math.min(x.count, o.start + o.count);
      for (let S = g, w = _ - 1; S < w; S += m) {
        if (
          (c.fromBufferAttribute(x, S),
          h.fromBufferAttribute(x, S + 1),
          ov.distanceSqToSegment(c, h, p, d) > l)
        )
          continue;
        p.applyMatrix4(this.matrixWorld);
        const P = e.ray.origin.distanceTo(p);
        P < e.near ||
          P > e.far ||
          t.push({
            distance: P,
            point: d.clone().applyMatrix4(this.matrixWorld),
            index: S,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
}
const sE = new F(),
  oE = new F();
class Wr extends Ys {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        i = [];
      for (let r = 0, s = t.count; r < s; r += 2)
        sE.fromBufferAttribute(t, r),
          oE.fromBufferAttribute(t, r + 1),
          (i[r] = r === 0 ? 0 : i[r - 1]),
          (i[r + 1] = i[r] + sE.distanceTo(oE));
      e.setAttribute("lineDistance", new Ve(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class hA extends Ys {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class Eh extends Cn {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const aE = new st(),
  g_ = new Ah(),
  Rp = new Vr(),
  Lp = new F();
let dA = class extends Pt {
  constructor(e = new ct(), t = new Eh()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      r = this.matrixWorld,
      s = e.params.Points.threshold,
      o = i.drawRange;
    if (
      (i.boundingSphere === null && i.computeBoundingSphere(),
      Rp.copy(i.boundingSphere),
      Rp.applyMatrix4(r),
      (Rp.radius += s),
      e.ray.intersectsSphere(Rp) === !1)
    )
      return;
    aE.copy(r).invert(), g_.copy(e.ray).applyMatrix4(aE);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = a * a,
      c = i.index,
      d = i.attributes.position;
    if (c !== null) {
      const p = Math.max(0, o.start),
        m = Math.min(c.count, o.start + o.count);
      for (let v = p, A = m; v < A; v++) {
        const x = c.getX(v);
        Lp.fromBufferAttribute(d, x), lE(Lp, x, l, r, e, t, this);
      }
    } else {
      const p = Math.max(0, o.start),
        m = Math.min(d.count, o.start + o.count);
      for (let v = p, A = m; v < A; v++)
        Lp.fromBufferAttribute(d, v), lE(Lp, v, l, r, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      i = Object.keys(t);
    if (i.length > 0) {
      const r = t[i[0]];
      if (r !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, o = r.length; s < o; s++) {
          const a = r[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[a] = s);
        }
      }
    }
  }
};
function lE(n, e, t, i, r, s, o) {
  const a = g_.distanceSqToPoint(n);
  if (a < t) {
    const l = new F();
    g_.closestPointToPoint(n, l), l.applyMatrix4(i);
    const c = r.ray.origin.distanceTo(l);
    if (c < r.near || c > r.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(a),
      point: l,
      index: e,
      face: null,
      object: o,
    });
  }
}
class OG extends en {
  constructor(e, t, i, r, s, o, a, l, c) {
    super(e, t, i, r, s, o, a, l, c),
      (this.isVideoTexture = !0),
      (this.minFilter = o !== void 0 ? o : rn),
      (this.magFilter = s !== void 0 ? s : rn),
      (this.generateMipmaps = !1);
    const h = this;
    function d() {
      (h.needsUpdate = !0), e.requestVideoFrameCallback(d);
    }
    "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(d);
  }
  clone() {
    return new this.constructor(this.image).copy(this);
  }
  update() {
    const e = this.image;
    "requestVideoFrameCallback" in e === !1 &&
      e.readyState >= e.HAVE_CURRENT_DATA &&
      (this.needsUpdate = !0);
  }
}
class kG extends en {
  constructor(e, t, i) {
    super({ width: e, height: t }),
      (this.isFramebufferTexture = !0),
      (this.format = i),
      (this.magFilter = dn),
      (this.minFilter = dn),
      (this.generateMipmaps = !1),
      (this.needsUpdate = !0);
  }
}
class pA extends en {
  constructor(e, t, i, r, s, o, a, l, c, h, d, p) {
    super(null, o, a, l, c, h, r, s, d, p),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class UG extends pA {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, s, o),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = r),
      (this.wrapR = Wn);
  }
}
class zG extends en {
  constructor(e, t, i, r, s, o, a, l, c) {
    super(e, t, i, r, s, o, a, l, c),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class Jr {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i,
      r = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let o = 1; o <= e; o++)
      (i = this.getPoint(o / e)), (s += i.distanceTo(r)), t.push(s), (r = i);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let r = 0;
    const s = i.length;
    let o;
    t ? (o = t) : (o = e * i[s - 1]);
    let a = 0,
      l = s - 1,
      c;
    for (; a <= l; )
      if (((r = Math.floor(a + (l - a) / 2)), (c = i[r] - o), c < 0)) a = r + 1;
      else if (c > 0) l = r - 1;
      else {
        l = r;
        break;
      }
    if (((r = l), i[r] === o)) return r / (s - 1);
    const h = i[r],
      p = i[r + 1] - h,
      m = (o - h) / p;
    return (r + m) / (s - 1);
  }
  getTangent(e, t) {
    let r = e - 1e-4,
      s = e + 1e-4;
    r < 0 && (r = 0), s > 1 && (s = 1);
    const o = this.getPoint(r),
      a = this.getPoint(s),
      l = t || (o.isVector2 ? new ge() : new F());
    return l.copy(a).sub(o).normalize(), l;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new F(),
      r = [],
      s = [],
      o = [],
      a = new F(),
      l = new st();
    for (let m = 0; m <= e; m++) {
      const v = m / e;
      r[m] = this.getTangentAt(v, new F());
    }
    (s[0] = new F()), (o[0] = new F());
    let c = Number.MAX_VALUE;
    const h = Math.abs(r[0].x),
      d = Math.abs(r[0].y),
      p = Math.abs(r[0].z);
    h <= c && ((c = h), i.set(1, 0, 0)),
      d <= c && ((c = d), i.set(0, 1, 0)),
      p <= c && i.set(0, 0, 1),
      a.crossVectors(r[0], i).normalize(),
      s[0].crossVectors(r[0], a),
      o[0].crossVectors(r[0], s[0]);
    for (let m = 1; m <= e; m++) {
      if (
        ((s[m] = s[m - 1].clone()),
        (o[m] = o[m - 1].clone()),
        a.crossVectors(r[m - 1], r[m]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const v = Math.acos(pn(r[m - 1].dot(r[m]), -1, 1));
        s[m].applyMatrix4(l.makeRotationAxis(a, v));
      }
      o[m].crossVectors(r[m], s[m]);
    }
    if (t === !0) {
      let m = Math.acos(pn(s[0].dot(s[e]), -1, 1));
      (m /= e), r[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
      for (let v = 1; v <= e; v++)
        s[v].applyMatrix4(l.makeRotationAxis(r[v], m * v)),
          o[v].crossVectors(r[v], s[v]);
    }
    return { tangents: r, normals: s, binormals: o };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
class zg extends Jr {
  constructor(
    e = 0,
    t = 0,
    i = 1,
    r = 1,
    s = 0,
    o = Math.PI * 2,
    a = !1,
    l = 0
  ) {
    super(),
      (this.isEllipseCurve = !0),
      (this.type = "EllipseCurve"),
      (this.aX = e),
      (this.aY = t),
      (this.xRadius = i),
      (this.yRadius = r),
      (this.aStartAngle = s),
      (this.aEndAngle = o),
      (this.aClockwise = a),
      (this.aRotation = l);
  }
  getPoint(e, t) {
    const i = t || new ge(),
      r = Math.PI * 2;
    let s = this.aEndAngle - this.aStartAngle;
    const o = Math.abs(s) < Number.EPSILON;
    for (; s < 0; ) s += r;
    for (; s > r; ) s -= r;
    s < Number.EPSILON && (o ? (s = 0) : (s = r)),
      this.aClockwise === !0 && !o && (s === r ? (s = -r) : (s = s - r));
    const a = this.aStartAngle + e * s;
    let l = this.aX + this.xRadius * Math.cos(a),
      c = this.aY + this.yRadius * Math.sin(a);
    if (this.aRotation !== 0) {
      const h = Math.cos(this.aRotation),
        d = Math.sin(this.aRotation),
        p = l - this.aX,
        m = c - this.aY;
      (l = p * h - m * d + this.aX), (c = p * d + m * h + this.aY);
    }
    return i.set(l, c);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.aX = this.aX),
      (e.aY = this.aY),
      (e.xRadius = this.xRadius),
      (e.yRadius = this.yRadius),
      (e.aStartAngle = this.aStartAngle),
      (e.aEndAngle = this.aEndAngle),
      (e.aClockwise = this.aClockwise),
      (e.aRotation = this.aRotation),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      (this.aX = e.aX),
      (this.aY = e.aY),
      (this.xRadius = e.xRadius),
      (this.yRadius = e.yRadius),
      (this.aStartAngle = e.aStartAngle),
      (this.aEndAngle = e.aEndAngle),
      (this.aClockwise = e.aClockwise),
      (this.aRotation = e.aRotation),
      this
    );
  }
}
class aR extends zg {
  constructor(e, t, i, r, s, o) {
    super(e, t, i, i, r, s, o),
      (this.isArcCurve = !0),
      (this.type = "ArcCurve");
  }
}
function mA() {
  let n = 0,
    e = 0,
    t = 0,
    i = 0;
  function r(s, o, a, l) {
    (n = s),
      (e = a),
      (t = -3 * s + 3 * o - 2 * a - l),
      (i = 2 * s - 2 * o + a + l);
  }
  return {
    initCatmullRom: function (s, o, a, l, c) {
      r(o, a, c * (a - s), c * (l - o));
    },
    initNonuniformCatmullRom: function (s, o, a, l, c, h, d) {
      let p = (o - s) / c - (a - s) / (c + h) + (a - o) / h,
        m = (a - o) / h - (l - o) / (h + d) + (l - a) / d;
      (p *= h), (m *= h), r(o, a, p, m);
    },
    calc: function (s) {
      const o = s * s,
        a = o * s;
      return n + e * s + t * o + i * a;
    },
  };
}
const Ip = new F(),
  av = new mA(),
  lv = new mA(),
  uv = new mA();
class lR extends Jr {
  constructor(e = [], t = !1, i = "centripetal", r = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = r);
  }
  getPoint(e, t = new F()) {
    const i = t,
      r = this.points,
      s = r.length,
      o = (s - (this.closed ? 0 : 1)) * e;
    let a = Math.floor(o),
      l = o - a;
    this.closed
      ? (a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s)
      : l === 0 && a === s - 1 && ((a = s - 2), (l = 1));
    let c, h;
    this.closed || a > 0
      ? (c = r[(a - 1) % s])
      : (Ip.subVectors(r[0], r[1]).add(r[0]), (c = Ip));
    const d = r[a % s],
      p = r[(a + 1) % s];
    if (
      (this.closed || a + 2 < s
        ? (h = r[(a + 2) % s])
        : (Ip.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), (h = Ip)),
      this.curveType === "centripetal" || this.curveType === "chordal")
    ) {
      const m = this.curveType === "chordal" ? 0.5 : 0.25;
      let v = Math.pow(c.distanceToSquared(d), m),
        A = Math.pow(d.distanceToSquared(p), m),
        x = Math.pow(p.distanceToSquared(h), m);
      A < 1e-4 && (A = 1),
        v < 1e-4 && (v = A),
        x < 1e-4 && (x = A),
        av.initNonuniformCatmullRom(c.x, d.x, p.x, h.x, v, A, x),
        lv.initNonuniformCatmullRom(c.y, d.y, p.y, h.y, v, A, x),
        uv.initNonuniformCatmullRom(c.z, d.z, p.z, h.z, v, A, x);
    } else
      this.curveType === "catmullrom" &&
        (av.initCatmullRom(c.x, d.x, p.x, h.x, this.tension),
        lv.initCatmullRom(c.y, d.y, p.y, h.y, this.tension),
        uv.initCatmullRom(c.z, d.z, p.z, h.z, this.tension));
    return i.set(av.calc(l), lv.calc(l), uv.calc(l)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new F().fromArray(r));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
function uE(n, e, t, i, r) {
  const s = (i - e) * 0.5,
    o = (r - t) * 0.5,
    a = n * n,
    l = n * a;
  return (
    (2 * t - 2 * i + s + o) * l + (-3 * t + 3 * i - 2 * s - o) * a + s * n + t
  );
}
function GG(n, e) {
  const t = 1 - n;
  return t * t * e;
}
function HG(n, e) {
  return 2 * (1 - n) * n * e;
}
function VG(n, e) {
  return n * n * e;
}
function Mf(n, e, t, i) {
  return GG(n, e) + HG(n, t) + VG(n, i);
}
function WG(n, e) {
  const t = 1 - n;
  return t * t * t * e;
}
function JG(n, e) {
  const t = 1 - n;
  return 3 * t * t * n * e;
}
function jG(n, e) {
  return 3 * (1 - n) * n * n * e;
}
function XG(n, e) {
  return n * n * n * e;
}
function Sf(n, e, t, i, r) {
  return WG(n, e) + JG(n, t) + jG(n, i) + XG(n, r);
}
class gA extends Jr {
  constructor(e = new ge(), t = new ge(), i = new ge(), r = new ge()) {
    super(),
      (this.isCubicBezierCurve = !0),
      (this.type = "CubicBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new ge()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return i.set(Sf(e, r.x, s.x, o.x, a.x), Sf(e, r.y, s.y, o.y, a.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class uR extends Jr {
  constructor(e = new F(), t = new F(), i = new F(), r = new F()) {
    super(),
      (this.isCubicBezierCurve3 = !0),
      (this.type = "CubicBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i),
      (this.v3 = r);
  }
  getPoint(e, t = new F()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2,
      a = this.v3;
    return (
      i.set(
        Sf(e, r.x, s.x, o.x, a.x),
        Sf(e, r.y, s.y, o.y, a.y),
        Sf(e, r.z, s.z, o.z, a.z)
      ),
      i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this.v3.copy(e.v3),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      (e.v3 = this.v3.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this.v3.fromArray(e.v3),
      this
    );
  }
}
class Gg extends Jr {
  constructor(e = new ge(), t = new ge()) {
    super(),
      (this.isLineCurve = !0),
      (this.type = "LineCurve"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new ge()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new ge()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class cR extends Jr {
  constructor(e = new F(), t = new F()) {
    super(),
      (this.isLineCurve3 = !0),
      (this.type = "LineCurve3"),
      (this.v1 = e),
      (this.v2 = t);
  }
  getPoint(e, t = new F()) {
    const i = t;
    return (
      e === 1
        ? i.copy(this.v2)
        : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)),
      i
    );
  }
  getPointAt(e, t) {
    return this.getPoint(e, t);
  }
  getTangent(e, t = new F()) {
    return t.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(e, t) {
    return this.getTangent(e, t);
  }
  copy(e) {
    return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.v1 = this.v1.toArray()), (e.v2 = this.v2.toArray()), e;
  }
  fromJSON(e) {
    return (
      super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    );
  }
}
class yA extends Jr {
  constructor(e = new ge(), t = new ge(), i = new ge()) {
    super(),
      (this.isQuadraticBezierCurve = !0),
      (this.type = "QuadraticBezierCurve"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new ge()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return i.set(Mf(e, r.x, s.x, o.x), Mf(e, r.y, s.y, o.y)), i;
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class vA extends Jr {
  constructor(e = new F(), t = new F(), i = new F()) {
    super(),
      (this.isQuadraticBezierCurve3 = !0),
      (this.type = "QuadraticBezierCurve3"),
      (this.v0 = e),
      (this.v1 = t),
      (this.v2 = i);
  }
  getPoint(e, t = new F()) {
    const i = t,
      r = this.v0,
      s = this.v1,
      o = this.v2;
    return (
      i.set(Mf(e, r.x, s.x, o.x), Mf(e, r.y, s.y, o.y), Mf(e, r.z, s.z, o.z)), i
    );
  }
  copy(e) {
    return (
      super.copy(e),
      this.v0.copy(e.v0),
      this.v1.copy(e.v1),
      this.v2.copy(e.v2),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.v0 = this.v0.toArray()),
      (e.v1 = this.v1.toArray()),
      (e.v2 = this.v2.toArray()),
      e
    );
  }
  fromJSON(e) {
    return (
      super.fromJSON(e),
      this.v0.fromArray(e.v0),
      this.v1.fromArray(e.v1),
      this.v2.fromArray(e.v2),
      this
    );
  }
}
class xA extends Jr {
  constructor(e = []) {
    super(),
      (this.isSplineCurve = !0),
      (this.type = "SplineCurve"),
      (this.points = e);
  }
  getPoint(e, t = new ge()) {
    const i = t,
      r = this.points,
      s = (r.length - 1) * e,
      o = Math.floor(s),
      a = s - o,
      l = r[o === 0 ? o : o - 1],
      c = r[o],
      h = r[o > r.length - 2 ? r.length - 1 : o + 1],
      d = r[o > r.length - 3 ? r.length - 1 : o + 2];
    return i.set(uE(a, l.x, c.x, h.x, d.x), uE(a, l.y, c.y, h.y, d.y)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const r = this.points[t];
      e.points.push(r.toArray());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const r = e.points[t];
      this.points.push(new ge().fromArray(r));
    }
    return this;
  }
}
var _A = Object.freeze({
  __proto__: null,
  ArcCurve: aR,
  CatmullRomCurve3: lR,
  CubicBezierCurve: gA,
  CubicBezierCurve3: uR,
  EllipseCurve: zg,
  LineCurve: Gg,
  LineCurve3: cR,
  QuadraticBezierCurve: yA,
  QuadraticBezierCurve3: vA,
  SplineCurve: xA,
});
class fR extends Jr {
  constructor() {
    super(),
      (this.type = "CurvePath"),
      (this.curves = []),
      (this.autoClose = !1);
  }
  add(e) {
    this.curves.push(e);
  }
  closePath() {
    const e = this.curves[0].getPoint(0),
      t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new Gg(t, e));
  }
  getPoint(e, t) {
    const i = e * this.getLength(),
      r = this.getCurveLengths();
    let s = 0;
    for (; s < r.length; ) {
      if (r[s] >= i) {
        const o = r[s] - i,
          a = this.curves[s],
          l = a.getLength(),
          c = l === 0 ? 0 : 1 - o / l;
        return a.getPointAt(c, t);
      }
      s++;
    }
    return null;
  }
  getLength() {
    const e = this.getCurveLengths();
    return e[e.length - 1];
  }
  updateArcLengths() {
    (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
      return this.cacheLengths;
    const e = [];
    let t = 0;
    for (let i = 0, r = this.curves.length; i < r; i++)
      (t += this.curves[i].getLength()), e.push(t);
    return (this.cacheLengths = e), e;
  }
  getSpacedPoints(e = 40) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return this.autoClose && t.push(t[0]), t;
  }
  getPoints(e = 12) {
    const t = [];
    let i;
    for (let r = 0, s = this.curves; r < s.length; r++) {
      const o = s[r],
        a = o.isEllipseCurve
          ? e * 2
          : o.isLineCurve || o.isLineCurve3
          ? 1
          : o.isSplineCurve
          ? e * o.points.length
          : e,
        l = o.getPoints(a);
      for (let c = 0; c < l.length; c++) {
        const h = l[c];
        (i && i.equals(h)) || (t.push(h), (i = h));
      }
    }
    return (
      this.autoClose &&
        t.length > 1 &&
        !t[t.length - 1].equals(t[0]) &&
        t.push(t[0]),
      t
    );
  }
  copy(e) {
    super.copy(e), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(r.clone());
    }
    return (this.autoClose = e.autoClose), this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.autoClose = this.autoClose), (e.curves = []);
    for (let t = 0, i = this.curves.length; t < i; t++) {
      const r = this.curves[t];
      e.curves.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.autoClose = e.autoClose), (this.curves = []);
    for (let t = 0, i = e.curves.length; t < i; t++) {
      const r = e.curves[t];
      this.curves.push(new _A[r.type]().fromJSON(r));
    }
    return this;
  }
}
class th extends fR {
  constructor(e) {
    super(),
      (this.type = "Path"),
      (this.currentPoint = new ge()),
      e && this.setFromPoints(e);
  }
  setFromPoints(e) {
    this.moveTo(e[0].x, e[0].y);
    for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
    return this;
  }
  moveTo(e, t) {
    return this.currentPoint.set(e, t), this;
  }
  lineTo(e, t) {
    const i = new Gg(this.currentPoint.clone(), new ge(e, t));
    return this.curves.push(i), this.currentPoint.set(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    const s = new yA(this.currentPoint.clone(), new ge(e, t), new ge(i, r));
    return this.curves.push(s), this.currentPoint.set(i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    const a = new gA(
      this.currentPoint.clone(),
      new ge(e, t),
      new ge(i, r),
      new ge(s, o)
    );
    return this.curves.push(a), this.currentPoint.set(s, o), this;
  }
  splineThru(e) {
    const t = [this.currentPoint.clone()].concat(e),
      i = new xA(t);
    return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this;
  }
  arc(e, t, i, r, s, o) {
    const a = this.currentPoint.x,
      l = this.currentPoint.y;
    return this.absarc(e + a, t + l, i, r, s, o), this;
  }
  absarc(e, t, i, r, s, o) {
    return this.absellipse(e, t, i, i, r, s, o), this;
  }
  ellipse(e, t, i, r, s, o, a, l) {
    const c = this.currentPoint.x,
      h = this.currentPoint.y;
    return this.absellipse(e + c, t + h, i, r, s, o, a, l), this;
  }
  absellipse(e, t, i, r, s, o, a, l) {
    const c = new zg(e, t, i, r, s, o, a, l);
    if (this.curves.length > 0) {
      const d = c.getPoint(0);
      d.equals(this.currentPoint) || this.lineTo(d.x, d.y);
    }
    this.curves.push(c);
    const h = c.getPoint(1);
    return this.currentPoint.copy(h), this;
  }
  copy(e) {
    return super.copy(e), this.currentPoint.copy(e.currentPoint), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (e.currentPoint = this.currentPoint.toArray()), e;
  }
  fromJSON(e) {
    return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this;
  }
}
class ic extends ct {
  constructor(
    e = [new ge(0, -0.5), new ge(0.5, 0), new ge(0, 0.5)],
    t = 12,
    i = 0,
    r = Math.PI * 2
  ) {
    super(),
      (this.type = "LatheGeometry"),
      (this.parameters = { points: e, segments: t, phiStart: i, phiLength: r }),
      (t = Math.floor(t)),
      (r = pn(r, 0, Math.PI * 2));
    const s = [],
      o = [],
      a = [],
      l = [],
      c = [],
      h = 1 / t,
      d = new F(),
      p = new ge(),
      m = new F(),
      v = new F(),
      A = new F();
    let x = 0,
      g = 0;
    for (let _ = 0; _ <= e.length - 1; _++)
      switch (_) {
        case 0:
          (x = e[_ + 1].x - e[_].x),
            (g = e[_ + 1].y - e[_].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            A.copy(m),
            m.normalize(),
            l.push(m.x, m.y, m.z);
          break;
        case e.length - 1:
          l.push(A.x, A.y, A.z);
          break;
        default:
          (x = e[_ + 1].x - e[_].x),
            (g = e[_ + 1].y - e[_].y),
            (m.x = g * 1),
            (m.y = -x),
            (m.z = g * 0),
            v.copy(m),
            (m.x += A.x),
            (m.y += A.y),
            (m.z += A.z),
            m.normalize(),
            l.push(m.x, m.y, m.z),
            A.copy(v);
      }
    for (let _ = 0; _ <= t; _++) {
      const S = i + _ * h * r,
        w = Math.sin(S),
        E = Math.cos(S);
      for (let P = 0; P <= e.length - 1; P++) {
        (d.x = e[P].x * w),
          (d.y = e[P].y),
          (d.z = e[P].x * E),
          o.push(d.x, d.y, d.z),
          (p.x = _ / t),
          (p.y = P / (e.length - 1)),
          a.push(p.x, p.y);
        const L = l[3 * P + 0] * w,
          B = l[3 * P + 1],
          b = l[3 * P + 0] * E;
        c.push(L, B, b);
      }
    }
    for (let _ = 0; _ < t; _++)
      for (let S = 0; S < e.length - 1; S++) {
        const w = S + _ * e.length,
          E = w,
          P = w + e.length,
          L = w + e.length + 1,
          B = w + 1;
        s.push(E, P, B), s.push(L, B, P);
      }
    this.setIndex(s),
      this.setAttribute("position", new Ve(o, 3)),
      this.setAttribute("uv", new Ve(a, 2)),
      this.setAttribute("normal", new Ve(c, 3));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new ic(e.points, e.segments, e.phiStart, e.phiLength);
  }
}
class Th extends ic {
  constructor(e = 1, t = 1, i = 4, r = 8) {
    const s = new th();
    s.absarc(0, -t / 2, e, Math.PI * 1.5, 0),
      s.absarc(0, t / 2, e, 0, Math.PI * 0.5),
      super(s.getPoints(i), r),
      (this.type = "CapsuleGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        capSegments: i,
        radialSegments: r,
      });
  }
  static fromJSON(e) {
    return new Th(e.radius, e.length, e.capSegments, e.radialSegments);
  }
}
class bh extends ct {
  constructor(e = 1, t = 32, i = 0, r = Math.PI * 2) {
    super(),
      (this.type = "CircleGeometry"),
      (this.parameters = {
        radius: e,
        segments: t,
        thetaStart: i,
        thetaLength: r,
      }),
      (t = Math.max(3, t));
    const s = [],
      o = [],
      a = [],
      l = [],
      c = new F(),
      h = new ge();
    o.push(0, 0, 0), a.push(0, 0, 1), l.push(0.5, 0.5);
    for (let d = 0, p = 3; d <= t; d++, p += 3) {
      const m = i + (d / t) * r;
      (c.x = e * Math.cos(m)),
        (c.y = e * Math.sin(m)),
        o.push(c.x, c.y, c.z),
        a.push(0, 0, 1),
        (h.x = (o[p] / e + 1) / 2),
        (h.y = (o[p + 1] / e + 1) / 2),
        l.push(h.x, h.y);
    }
    for (let d = 1; d <= t; d++) s.push(d, d + 1, 0);
    this.setIndex(s),
      this.setAttribute("position", new Ve(o, 3)),
      this.setAttribute("normal", new Ve(a, 3)),
      this.setAttribute("uv", new Ve(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new bh(e.radius, e.segments, e.thetaStart, e.thetaLength);
  }
}
class hl extends ct {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    r = 32,
    s = 1,
    o = !1,
    a = 0,
    l = Math.PI * 2
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: r,
        heightSegments: s,
        openEnded: o,
        thetaStart: a,
        thetaLength: l,
      });
    const c = this;
    (r = Math.floor(r)), (s = Math.floor(s));
    const h = [],
      d = [],
      p = [],
      m = [];
    let v = 0;
    const A = [],
      x = i / 2;
    let g = 0;
    _(),
      o === !1 && (e > 0 && S(!0), t > 0 && S(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Ve(d, 3)),
      this.setAttribute("normal", new Ve(p, 3)),
      this.setAttribute("uv", new Ve(m, 2));
    function _() {
      const w = new F(),
        E = new F();
      let P = 0;
      const L = (t - e) / i;
      for (let B = 0; B <= s; B++) {
        const b = [],
          R = B / s,
          U = R * (t - e) + e;
        for (let j = 0; j <= r; j++) {
          const V = j / r,
            J = V * l + a,
            X = Math.sin(J),
            oe = Math.cos(J);
          (E.x = U * X),
            (E.y = -R * i + x),
            (E.z = U * oe),
            d.push(E.x, E.y, E.z),
            w.set(X, L, oe).normalize(),
            p.push(w.x, w.y, w.z),
            m.push(V, 1 - R),
            b.push(v++);
        }
        A.push(b);
      }
      for (let B = 0; B < r; B++)
        for (let b = 0; b < s; b++) {
          const R = A[b][B],
            U = A[b + 1][B],
            j = A[b + 1][B + 1],
            V = A[b][B + 1];
          h.push(R, U, V), h.push(U, j, V), (P += 6);
        }
      c.addGroup(g, P, 0), (g += P);
    }
    function S(w) {
      const E = v,
        P = new ge(),
        L = new F();
      let B = 0;
      const b = w === !0 ? e : t,
        R = w === !0 ? 1 : -1;
      for (let j = 1; j <= r; j++)
        d.push(0, x * R, 0), p.push(0, R, 0), m.push(0.5, 0.5), v++;
      const U = v;
      for (let j = 0; j <= r; j++) {
        const J = (j / r) * l + a,
          X = Math.cos(J),
          oe = Math.sin(J);
        (L.x = b * oe),
          (L.y = x * R),
          (L.z = b * X),
          d.push(L.x, L.y, L.z),
          p.push(0, R, 0),
          (P.x = X * 0.5 + 0.5),
          (P.y = oe * 0.5 * R + 0.5),
          m.push(P.x, P.y),
          v++;
      }
      for (let j = 0; j < r; j++) {
        const V = E + j,
          J = U + j;
        w === !0 ? h.push(J, J + 1, V) : h.push(J + 1, J, V), (B += 3);
      }
      c.addGroup(g, B, w === !0 ? 1 : 2), (g += B);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new hl(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Ph extends hl {
  constructor(e = 1, t = 1, i = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) {
    super(0, e, t, i, r, s, o, a),
      (this.type = "ConeGeometry"),
      (this.parameters = {
        radius: e,
        height: t,
        radialSegments: i,
        heightSegments: r,
        openEnded: s,
        thetaStart: o,
        thetaLength: a,
      });
  }
  static fromJSON(e) {
    return new Ph(
      e.radius,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class qs extends ct {
  constructor(e = [], t = [], i = 1, r = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: r });
    const s = [],
      o = [];
    a(r),
      c(i),
      h(),
      this.setAttribute("position", new Ve(s, 3)),
      this.setAttribute("normal", new Ve(s.slice(), 3)),
      this.setAttribute("uv", new Ve(o, 2)),
      r === 0 ? this.computeVertexNormals() : this.normalizeNormals();
    function a(_) {
      const S = new F(),
        w = new F(),
        E = new F();
      for (let P = 0; P < t.length; P += 3)
        m(t[P + 0], S), m(t[P + 1], w), m(t[P + 2], E), l(S, w, E, _);
    }
    function l(_, S, w, E) {
      const P = E + 1,
        L = [];
      for (let B = 0; B <= P; B++) {
        L[B] = [];
        const b = _.clone().lerp(w, B / P),
          R = S.clone().lerp(w, B / P),
          U = P - B;
        for (let j = 0; j <= U; j++)
          j === 0 && B === P
            ? (L[B][j] = b)
            : (L[B][j] = b.clone().lerp(R, j / U));
      }
      for (let B = 0; B < P; B++)
        for (let b = 0; b < 2 * (P - B) - 1; b++) {
          const R = Math.floor(b / 2);
          b % 2 === 0
            ? (p(L[B][R + 1]), p(L[B + 1][R]), p(L[B][R]))
            : (p(L[B][R + 1]), p(L[B + 1][R + 1]), p(L[B + 1][R]));
        }
    }
    function c(_) {
      const S = new F();
      for (let w = 0; w < s.length; w += 3)
        (S.x = s[w + 0]),
          (S.y = s[w + 1]),
          (S.z = s[w + 2]),
          S.normalize().multiplyScalar(_),
          (s[w + 0] = S.x),
          (s[w + 1] = S.y),
          (s[w + 2] = S.z);
    }
    function h() {
      const _ = new F();
      for (let S = 0; S < s.length; S += 3) {
        (_.x = s[S + 0]), (_.y = s[S + 1]), (_.z = s[S + 2]);
        const w = x(_) / 2 / Math.PI + 0.5,
          E = g(_) / Math.PI + 0.5;
        o.push(w, 1 - E);
      }
      v(), d();
    }
    function d() {
      for (let _ = 0; _ < o.length; _ += 6) {
        const S = o[_ + 0],
          w = o[_ + 2],
          E = o[_ + 4],
          P = Math.max(S, w, E),
          L = Math.min(S, w, E);
        P > 0.9 &&
          L < 0.1 &&
          (S < 0.2 && (o[_ + 0] += 1),
          w < 0.2 && (o[_ + 2] += 1),
          E < 0.2 && (o[_ + 4] += 1));
      }
    }
    function p(_) {
      s.push(_.x, _.y, _.z);
    }
    function m(_, S) {
      const w = _ * 3;
      (S.x = e[w + 0]), (S.y = e[w + 1]), (S.z = e[w + 2]);
    }
    function v() {
      const _ = new F(),
        S = new F(),
        w = new F(),
        E = new F(),
        P = new ge(),
        L = new ge(),
        B = new ge();
      for (let b = 0, R = 0; b < s.length; b += 9, R += 6) {
        _.set(s[b + 0], s[b + 1], s[b + 2]),
          S.set(s[b + 3], s[b + 4], s[b + 5]),
          w.set(s[b + 6], s[b + 7], s[b + 8]),
          P.set(o[R + 0], o[R + 1]),
          L.set(o[R + 2], o[R + 3]),
          B.set(o[R + 4], o[R + 5]),
          E.copy(_).add(S).add(w).divideScalar(3);
        const U = x(E);
        A(P, R + 0, _, U), A(L, R + 2, S, U), A(B, R + 4, w, U);
      }
    }
    function A(_, S, w, E) {
      E < 0 && _.x === 1 && (o[S] = _.x - 1),
        w.x === 0 && w.z === 0 && (o[S] = E / 2 / Math.PI + 0.5);
    }
    function x(_) {
      return Math.atan2(_.z, -_.x);
    }
    function g(_) {
      return Math.atan2(-_.y, Math.sqrt(_.x * _.x + _.z * _.z));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new qs(e.vertices, e.indices, e.radius, e.details);
  }
}
class Bh extends qs {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = 1 / i,
      s = [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        -r,
        -i,
        0,
        -r,
        i,
        0,
        r,
        -i,
        0,
        r,
        i,
        0,
        -i,
        0,
        -r,
        i,
        0,
        -r,
        -i,
        0,
        r,
        i,
        0,
        r,
      ],
      o = [
        3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
        17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18,
        0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
        18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5,
        11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14,
        5, 1, 5, 9,
      ];
    super(s, o, e, t),
      (this.type = "DodecahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Bh(e.radius, e.detail);
  }
}
const Dp = new F(),
  Fp = new F(),
  cv = new F(),
  Np = new Ei();
class hR extends ct {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      e !== null)
    ) {
      const r = Math.pow(10, 4),
        s = Math.cos(Qa * t),
        o = e.getIndex(),
        a = e.getAttribute("position"),
        l = o ? o.count : a.count,
        c = [0, 0, 0],
        h = ["a", "b", "c"],
        d = new Array(3),
        p = {},
        m = [];
      for (let v = 0; v < l; v += 3) {
        o
          ? ((c[0] = o.getX(v)), (c[1] = o.getX(v + 1)), (c[2] = o.getX(v + 2)))
          : ((c[0] = v), (c[1] = v + 1), (c[2] = v + 2));
        const { a: A, b: x, c: g } = Np;
        if (
          (A.fromBufferAttribute(a, c[0]),
          x.fromBufferAttribute(a, c[1]),
          g.fromBufferAttribute(a, c[2]),
          Np.getNormal(cv),
          (d[0] = `${Math.round(A.x * r)},${Math.round(A.y * r)},${Math.round(
            A.z * r
          )}`),
          (d[1] = `${Math.round(x.x * r)},${Math.round(x.y * r)},${Math.round(
            x.z * r
          )}`),
          (d[2] = `${Math.round(g.x * r)},${Math.round(g.y * r)},${Math.round(
            g.z * r
          )}`),
          !(d[0] === d[1] || d[1] === d[2] || d[2] === d[0]))
        )
          for (let _ = 0; _ < 3; _++) {
            const S = (_ + 1) % 3,
              w = d[_],
              E = d[S],
              P = Np[h[_]],
              L = Np[h[S]],
              B = `${w}_${E}`,
              b = `${E}_${w}`;
            b in p && p[b]
              ? (cv.dot(p[b].normal) <= s &&
                  (m.push(P.x, P.y, P.z), m.push(L.x, L.y, L.z)),
                (p[b] = null))
              : B in p ||
                (p[B] = { index0: c[_], index1: c[S], normal: cv.clone() });
          }
      }
      for (const v in p)
        if (p[v]) {
          const { index0: A, index1: x } = p[v];
          Dp.fromBufferAttribute(a, A),
            Fp.fromBufferAttribute(a, x),
            m.push(Dp.x, Dp.y, Dp.z),
            m.push(Fp.x, Fp.y, Fp.z);
        }
      this.setAttribute("position", new Ve(m, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class qa extends th {
  constructor(e) {
    super(e), (this.uuid = ji()), (this.type = "Shape"), (this.holes = []);
  }
  getPointsHoles(e) {
    const t = [];
    for (let i = 0, r = this.holes.length; i < r; i++)
      t[i] = this.holes[i].getPoints(e);
    return t;
  }
  extractPoints(e) {
    return { shape: this.getPoints(e), holes: this.getPointsHoles(e) };
  }
  copy(e) {
    super.copy(e), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(r.clone());
    }
    return this;
  }
  toJSON() {
    const e = super.toJSON();
    (e.uuid = this.uuid), (e.holes = []);
    for (let t = 0, i = this.holes.length; t < i; t++) {
      const r = this.holes[t];
      e.holes.push(r.toJSON());
    }
    return e;
  }
  fromJSON(e) {
    super.fromJSON(e), (this.uuid = e.uuid), (this.holes = []);
    for (let t = 0, i = e.holes.length; t < i; t++) {
      const r = e.holes[t];
      this.holes.push(new th().fromJSON(r));
    }
    return this;
  }
}
const KG = {
  triangulate: function (n, e, t = 2) {
    const i = e && e.length,
      r = i ? e[0] * t : n.length;
    let s = dR(n, 0, r, t, !0);
    const o = [];
    if (!s || s.next === s.prev) return o;
    let a, l, c, h, d, p, m;
    if ((i && (s = $G(n, e, s, t)), n.length > 80 * t)) {
      (a = c = n[0]), (l = h = n[1]);
      for (let v = t; v < r; v += t)
        (d = n[v]),
          (p = n[v + 1]),
          d < a && (a = d),
          p < l && (l = p),
          d > c && (c = d),
          p > h && (h = p);
      (m = Math.max(c - a, h - l)), (m = m !== 0 ? 32767 / m : 0);
    }
    return nh(s, o, t, a, l, m, 0), o;
  },
};
function dR(n, e, t, i, r) {
  let s, o;
  if (r === cH(n, e, t, i) > 0)
    for (s = e; s < t; s += i) o = cE(s, n[s], n[s + 1], o);
  else for (s = t - i; s >= e; s -= i) o = cE(s, n[s], n[s + 1], o);
  return o && Hg(o, o.next) && (rh(o), (o = o.next)), o;
}
function ol(n, e) {
  if (!n) return n;
  e || (e = n);
  let t = n,
    i;
  do
    if (
      ((i = !1), !t.steiner && (Hg(t, t.next) || sn(t.prev, t, t.next) === 0))
    ) {
      if ((rh(t), (t = e = t.prev), t === t.next)) break;
      i = !0;
    } else t = t.next;
  while (i || t !== e);
  return e;
}
function nh(n, e, t, i, r, s, o) {
  if (!n) return;
  !o && s && rH(n, i, r, s);
  let a = n,
    l,
    c;
  for (; n.prev !== n.next; ) {
    if (((l = n.prev), (c = n.next), s ? QG(n, i, r, s) : YG(n))) {
      e.push((l.i / t) | 0),
        e.push((n.i / t) | 0),
        e.push((c.i / t) | 0),
        rh(n),
        (n = c.next),
        (a = c.next);
      continue;
    }
    if (((n = c), n === a)) {
      o
        ? o === 1
          ? ((n = ZG(ol(n), e, t)), nh(n, e, t, i, r, s, 2))
          : o === 2 && qG(n, e, t, i, r, s)
        : nh(ol(n), e, t, i, r, s, 1);
      break;
    }
  }
}
function YG(n) {
  const e = n.prev,
    t = n,
    i = n.next;
  if (sn(e, t, i) >= 0) return !1;
  const r = e.x,
    s = t.x,
    o = i.x,
    a = e.y,
    l = t.y,
    c = i.y,
    h = r < s ? (r < o ? r : o) : s < o ? s : o,
    d = a < l ? (a < c ? a : c) : l < c ? l : c,
    p = r > s ? (r > o ? r : o) : s > o ? s : o,
    m = a > l ? (a > c ? a : c) : l > c ? l : c;
  let v = i.next;
  for (; v !== e; ) {
    if (
      v.x >= h &&
      v.x <= p &&
      v.y >= d &&
      v.y <= m &&
      yu(r, a, s, l, o, c, v.x, v.y) &&
      sn(v.prev, v, v.next) >= 0
    )
      return !1;
    v = v.next;
  }
  return !0;
}
function QG(n, e, t, i) {
  const r = n.prev,
    s = n,
    o = n.next;
  if (sn(r, s, o) >= 0) return !1;
  const a = r.x,
    l = s.x,
    c = o.x,
    h = r.y,
    d = s.y,
    p = o.y,
    m = a < l ? (a < c ? a : c) : l < c ? l : c,
    v = h < d ? (h < p ? h : p) : d < p ? d : p,
    A = a > l ? (a > c ? a : c) : l > c ? l : c,
    x = h > d ? (h > p ? h : p) : d > p ? d : p,
    g = y_(m, v, e, t, i),
    _ = y_(A, x, e, t, i);
  let S = n.prevZ,
    w = n.nextZ;
  for (; S && S.z >= g && w && w.z <= _; ) {
    if (
      (S.x >= m &&
        S.x <= A &&
        S.y >= v &&
        S.y <= x &&
        S !== r &&
        S !== o &&
        yu(a, h, l, d, c, p, S.x, S.y) &&
        sn(S.prev, S, S.next) >= 0) ||
      ((S = S.prevZ),
      w.x >= m &&
        w.x <= A &&
        w.y >= v &&
        w.y <= x &&
        w !== r &&
        w !== o &&
        yu(a, h, l, d, c, p, w.x, w.y) &&
        sn(w.prev, w, w.next) >= 0)
    )
      return !1;
    w = w.nextZ;
  }
  for (; S && S.z >= g; ) {
    if (
      S.x >= m &&
      S.x <= A &&
      S.y >= v &&
      S.y <= x &&
      S !== r &&
      S !== o &&
      yu(a, h, l, d, c, p, S.x, S.y) &&
      sn(S.prev, S, S.next) >= 0
    )
      return !1;
    S = S.prevZ;
  }
  for (; w && w.z <= _; ) {
    if (
      w.x >= m &&
      w.x <= A &&
      w.y >= v &&
      w.y <= x &&
      w !== r &&
      w !== o &&
      yu(a, h, l, d, c, p, w.x, w.y) &&
      sn(w.prev, w, w.next) >= 0
    )
      return !1;
    w = w.nextZ;
  }
  return !0;
}
function ZG(n, e, t) {
  let i = n;
  do {
    const r = i.prev,
      s = i.next.next;
    !Hg(r, s) &&
      pR(r, i, i.next, s) &&
      ih(r, s) &&
      ih(s, r) &&
      (e.push((r.i / t) | 0),
      e.push((i.i / t) | 0),
      e.push((s.i / t) | 0),
      rh(i),
      rh(i.next),
      (i = n = s)),
      (i = i.next);
  } while (i !== n);
  return ol(i);
}
function qG(n, e, t, i, r, s) {
  let o = n;
  do {
    let a = o.next.next;
    for (; a !== o.prev; ) {
      if (o.i !== a.i && aH(o, a)) {
        let l = mR(o, a);
        (o = ol(o, o.next)),
          (l = ol(l, l.next)),
          nh(o, e, t, i, r, s, 0),
          nh(l, e, t, i, r, s, 0);
        return;
      }
      a = a.next;
    }
    o = o.next;
  } while (o !== n);
}
function $G(n, e, t, i) {
  const r = [];
  let s, o, a, l, c;
  for (s = 0, o = e.length; s < o; s++)
    (a = e[s] * i),
      (l = s < o - 1 ? e[s + 1] * i : n.length),
      (c = dR(n, a, l, i, !1)),
      c === c.next && (c.steiner = !0),
      r.push(oH(c));
  for (r.sort(eH), s = 0; s < r.length; s++) t = tH(r[s], t);
  return t;
}
function eH(n, e) {
  return n.x - e.x;
}
function tH(n, e) {
  const t = nH(n, e);
  if (!t) return e;
  const i = mR(t, n);
  return ol(i, i.next), ol(t, t.next);
}
function nH(n, e) {
  let t = e,
    i = -1 / 0,
    r;
  const s = n.x,
    o = n.y;
  do {
    if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
      const p = t.x + ((o - t.y) * (t.next.x - t.x)) / (t.next.y - t.y);
      if (
        p <= s &&
        p > i &&
        ((i = p), (r = t.x < t.next.x ? t : t.next), p === s)
      )
        return r;
    }
    t = t.next;
  } while (t !== e);
  if (!r) return null;
  const a = r,
    l = r.x,
    c = r.y;
  let h = 1 / 0,
    d;
  t = r;
  do
    s >= t.x &&
      t.x >= l &&
      s !== t.x &&
      yu(o < c ? s : i, o, l, c, o < c ? i : s, o, t.x, t.y) &&
      ((d = Math.abs(o - t.y) / (s - t.x)),
      ih(t, n) &&
        (d < h || (d === h && (t.x > r.x || (t.x === r.x && iH(r, t))))) &&
        ((r = t), (h = d))),
      (t = t.next);
  while (t !== a);
  return r;
}
function iH(n, e) {
  return sn(n.prev, n, e.prev) < 0 && sn(e.next, n, n.next) < 0;
}
function rH(n, e, t, i) {
  let r = n;
  do
    r.z === 0 && (r.z = y_(r.x, r.y, e, t, i)),
      (r.prevZ = r.prev),
      (r.nextZ = r.next),
      (r = r.next);
  while (r !== n);
  (r.prevZ.nextZ = null), (r.prevZ = null), sH(r);
}
function sH(n) {
  let e,
    t,
    i,
    r,
    s,
    o,
    a,
    l,
    c = 1;
  do {
    for (t = n, n = null, s = null, o = 0; t; ) {
      for (o++, i = t, a = 0, e = 0; e < c && (a++, (i = i.nextZ), !!i); e++);
      for (l = c; a > 0 || (l > 0 && i); )
        a !== 0 && (l === 0 || !i || t.z <= i.z)
          ? ((r = t), (t = t.nextZ), a--)
          : ((r = i), (i = i.nextZ), l--),
          s ? (s.nextZ = r) : (n = r),
          (r.prevZ = s),
          (s = r);
      t = i;
    }
    (s.nextZ = null), (c *= 2);
  } while (o > 1);
  return n;
}
function y_(n, e, t, i, r) {
  return (
    (n = ((n - t) * r) | 0),
    (e = ((e - i) * r) | 0),
    (n = (n | (n << 8)) & 16711935),
    (n = (n | (n << 4)) & 252645135),
    (n = (n | (n << 2)) & 858993459),
    (n = (n | (n << 1)) & 1431655765),
    (e = (e | (e << 8)) & 16711935),
    (e = (e | (e << 4)) & 252645135),
    (e = (e | (e << 2)) & 858993459),
    (e = (e | (e << 1)) & 1431655765),
    n | (e << 1)
  );
}
function oH(n) {
  let e = n,
    t = n;
  do (e.x < t.x || (e.x === t.x && e.y < t.y)) && (t = e), (e = e.next);
  while (e !== n);
  return t;
}
function yu(n, e, t, i, r, s, o, a) {
  return (
    (r - o) * (e - a) >= (n - o) * (s - a) &&
    (n - o) * (i - a) >= (t - o) * (e - a) &&
    (t - o) * (s - a) >= (r - o) * (i - a)
  );
}
function aH(n, e) {
  return (
    n.next.i !== e.i &&
    n.prev.i !== e.i &&
    !lH(n, e) &&
    ((ih(n, e) &&
      ih(e, n) &&
      uH(n, e) &&
      (sn(n.prev, n, e.prev) || sn(n, e.prev, e))) ||
      (Hg(n, e) && sn(n.prev, n, n.next) > 0 && sn(e.prev, e, e.next) > 0))
  );
}
function sn(n, e, t) {
  return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y);
}
function Hg(n, e) {
  return n.x === e.x && n.y === e.y;
}
function pR(n, e, t, i) {
  const r = kp(sn(n, e, t)),
    s = kp(sn(n, e, i)),
    o = kp(sn(t, i, n)),
    a = kp(sn(t, i, e));
  return !!(
    (r !== s && o !== a) ||
    (r === 0 && Op(n, t, e)) ||
    (s === 0 && Op(n, i, e)) ||
    (o === 0 && Op(t, n, i)) ||
    (a === 0 && Op(t, e, i))
  );
}
function Op(n, e, t) {
  return (
    e.x <= Math.max(n.x, t.x) &&
    e.x >= Math.min(n.x, t.x) &&
    e.y <= Math.max(n.y, t.y) &&
    e.y >= Math.min(n.y, t.y)
  );
}
function kp(n) {
  return n > 0 ? 1 : n < 0 ? -1 : 0;
}
function lH(n, e) {
  let t = n;
  do {
    if (
      t.i !== n.i &&
      t.next.i !== n.i &&
      t.i !== e.i &&
      t.next.i !== e.i &&
      pR(t, t.next, n, e)
    )
      return !0;
    t = t.next;
  } while (t !== n);
  return !1;
}
function ih(n, e) {
  return sn(n.prev, n, n.next) < 0
    ? sn(n, e, n.next) >= 0 && sn(n, n.prev, e) >= 0
    : sn(n, e, n.prev) < 0 || sn(n, n.next, e) < 0;
}
function uH(n, e) {
  let t = n,
    i = !1;
  const r = (n.x + e.x) / 2,
    s = (n.y + e.y) / 2;
  do
    t.y > s != t.next.y > s &&
      t.next.y !== t.y &&
      r < ((t.next.x - t.x) * (s - t.y)) / (t.next.y - t.y) + t.x &&
      (i = !i),
      (t = t.next);
  while (t !== n);
  return i;
}
function mR(n, e) {
  const t = new v_(n.i, n.x, n.y),
    i = new v_(e.i, e.x, e.y),
    r = n.next,
    s = e.prev;
  return (
    (n.next = e),
    (e.prev = n),
    (t.next = r),
    (r.prev = t),
    (i.next = t),
    (t.prev = i),
    (s.next = i),
    (i.prev = s),
    i
  );
}
function cE(n, e, t, i) {
  const r = new v_(n, e, t);
  return (
    i
      ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
      : ((r.prev = r), (r.next = r)),
    r
  );
}
function rh(n) {
  (n.next.prev = n.prev),
    (n.prev.next = n.next),
    n.prevZ && (n.prevZ.nextZ = n.nextZ),
    n.nextZ && (n.nextZ.prevZ = n.prevZ);
}
function v_(n, e, t) {
  (this.i = n),
    (this.x = e),
    (this.y = t),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function cH(n, e, t, i) {
  let r = 0;
  for (let s = e, o = t - i; s < t; s += i)
    (r += (n[o] - n[s]) * (n[s + 1] + n[o + 1])), (o = s);
  return r;
}
class as {
  static area(e) {
    const t = e.length;
    let i = 0;
    for (let r = t - 1, s = 0; s < t; r = s++)
      i += e[r].x * e[s].y - e[s].x * e[r].y;
    return i * 0.5;
  }
  static isClockWise(e) {
    return as.area(e) < 0;
  }
  static triangulateShape(e, t) {
    const i = [],
      r = [],
      s = [];
    fE(e), hE(i, e);
    let o = e.length;
    t.forEach(fE);
    for (let l = 0; l < t.length; l++)
      r.push(o), (o += t[l].length), hE(i, t[l]);
    const a = KG.triangulate(i, r);
    for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
    return s;
  }
}
function fE(n) {
  const e = n.length;
  e > 2 && n[e - 1].equals(n[0]) && n.pop();
}
function hE(n, e) {
  for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y);
}
class Rh extends ct {
  constructor(
    e = new qa([
      new ge(0.5, 0.5),
      new ge(-0.5, 0.5),
      new ge(-0.5, -0.5),
      new ge(0.5, -0.5),
    ]),
    t = {}
  ) {
    super(),
      (this.type = "ExtrudeGeometry"),
      (this.parameters = { shapes: e, options: t }),
      (e = Array.isArray(e) ? e : [e]);
    const i = this,
      r = [],
      s = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a];
      o(c);
    }
    this.setAttribute("position", new Ve(r, 3)),
      this.setAttribute("uv", new Ve(s, 2)),
      this.computeVertexNormals();
    function o(a) {
      const l = [],
        c = t.curveSegments !== void 0 ? t.curveSegments : 12,
        h = t.steps !== void 0 ? t.steps : 1,
        d = t.depth !== void 0 ? t.depth : 1;
      let p = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
        m = t.bevelThickness !== void 0 ? t.bevelThickness : 0.2,
        v = t.bevelSize !== void 0 ? t.bevelSize : m - 0.1,
        A = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
        x = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
      const g = t.extrudePath,
        _ = t.UVGenerator !== void 0 ? t.UVGenerator : fH;
      let S,
        w = !1,
        E,
        P,
        L,
        B;
      g &&
        ((S = g.getSpacedPoints(h)),
        (w = !0),
        (p = !1),
        (E = g.computeFrenetFrames(h, !1)),
        (P = new F()),
        (L = new F()),
        (B = new F())),
        p || ((x = 0), (m = 0), (v = 0), (A = 0));
      const b = a.extractPoints(c);
      let R = b.shape;
      const U = b.holes;
      if (!as.isClockWise(R)) {
        R = R.reverse();
        for (let me = 0, se = U.length; me < se; me++) {
          const xe = U[me];
          as.isClockWise(xe) && (U[me] = xe.reverse());
        }
      }
      const V = as.triangulateShape(R, U),
        J = R;
      for (let me = 0, se = U.length; me < se; me++) {
        const xe = U[me];
        R = R.concat(xe);
      }
      function X(me, se, xe) {
        return (
          se || console.error("THREE.ExtrudeGeometry: vec does not exist"),
          me.clone().addScaledVector(se, xe)
        );
      }
      const oe = R.length,
        ae = V.length;
      function I(me, se, xe) {
        let Ne, Le, We;
        const Ke = me.x - se.x,
          Je = me.y - se.y,
          nt = xe.x - me.x,
          _t = xe.y - me.y,
          k = Ke * Ke + Je * Je,
          D = Ke * _t - Je * nt;
        if (Math.abs(D) > Number.EPSILON) {
          const le = Math.sqrt(k),
            Ee = Math.sqrt(nt * nt + _t * _t),
            Te = se.x - Je / le,
            Re = se.y + Ke / le,
            et = xe.x - _t / Ee,
            Ue = xe.y + nt / Ee,
            de = ((et - Te) * _t - (Ue - Re) * nt) / (Ke * _t - Je * nt);
          (Ne = Te + Ke * de - me.x), (Le = Re + Je * de - me.y);
          const He = Ne * Ne + Le * Le;
          if (He <= 2) return new ge(Ne, Le);
          We = Math.sqrt(He / 2);
        } else {
          let le = !1;
          Ke > Number.EPSILON
            ? nt > Number.EPSILON && (le = !0)
            : Ke < -Number.EPSILON
            ? nt < -Number.EPSILON && (le = !0)
            : Math.sign(Je) === Math.sign(_t) && (le = !0),
            le
              ? ((Ne = -Je), (Le = Ke), (We = Math.sqrt(k)))
              : ((Ne = Ke), (Le = Je), (We = Math.sqrt(k / 2)));
        }
        return new ge(Ne / We, Le / We);
      }
      const G = [];
      for (
        let me = 0, se = J.length, xe = se - 1, Ne = me + 1;
        me < se;
        me++, xe++, Ne++
      )
        xe === se && (xe = 0),
          Ne === se && (Ne = 0),
          (G[me] = I(J[me], J[xe], J[Ne]));
      const z = [];
      let q,
        Q = G.concat();
      for (let me = 0, se = U.length; me < se; me++) {
        const xe = U[me];
        q = [];
        for (
          let Ne = 0, Le = xe.length, We = Le - 1, Ke = Ne + 1;
          Ne < Le;
          Ne++, We++, Ke++
        )
          We === Le && (We = 0),
            Ke === Le && (Ke = 0),
            (q[Ne] = I(xe[Ne], xe[We], xe[Ke]));
        z.push(q), (Q = Q.concat(q));
      }
      for (let me = 0; me < x; me++) {
        const se = me / x,
          xe = m * Math.cos((se * Math.PI) / 2),
          Ne = v * Math.sin((se * Math.PI) / 2) + A;
        for (let Le = 0, We = J.length; Le < We; Le++) {
          const Ke = X(J[Le], G[Le], Ne);
          $(Ke.x, Ke.y, -xe);
        }
        for (let Le = 0, We = U.length; Le < We; Le++) {
          const Ke = U[Le];
          q = z[Le];
          for (let Je = 0, nt = Ke.length; Je < nt; Je++) {
            const _t = X(Ke[Je], q[Je], Ne);
            $(_t.x, _t.y, -xe);
          }
        }
      }
      const ee = v + A;
      for (let me = 0; me < oe; me++) {
        const se = p ? X(R[me], Q[me], ee) : R[me];
        w
          ? (L.copy(E.normals[0]).multiplyScalar(se.x),
            P.copy(E.binormals[0]).multiplyScalar(se.y),
            B.copy(S[0]).add(L).add(P),
            $(B.x, B.y, B.z))
          : $(se.x, se.y, 0);
      }
      for (let me = 1; me <= h; me++)
        for (let se = 0; se < oe; se++) {
          const xe = p ? X(R[se], Q[se], ee) : R[se];
          w
            ? (L.copy(E.normals[me]).multiplyScalar(xe.x),
              P.copy(E.binormals[me]).multiplyScalar(xe.y),
              B.copy(S[me]).add(L).add(P),
              $(B.x, B.y, B.z))
            : $(xe.x, xe.y, (d / h) * me);
        }
      for (let me = x - 1; me >= 0; me--) {
        const se = me / x,
          xe = m * Math.cos((se * Math.PI) / 2),
          Ne = v * Math.sin((se * Math.PI) / 2) + A;
        for (let Le = 0, We = J.length; Le < We; Le++) {
          const Ke = X(J[Le], G[Le], Ne);
          $(Ke.x, Ke.y, d + xe);
        }
        for (let Le = 0, We = U.length; Le < We; Le++) {
          const Ke = U[Le];
          q = z[Le];
          for (let Je = 0, nt = Ke.length; Je < nt; Je++) {
            const _t = X(Ke[Je], q[Je], Ne);
            w
              ? $(_t.x, _t.y + S[h - 1].y, S[h - 1].x + xe)
              : $(_t.x, _t.y, d + xe);
          }
        }
      }
      ne(), Ce();
      function ne() {
        const me = r.length / 3;
        if (p) {
          let se = 0,
            xe = oe * se;
          for (let Ne = 0; Ne < ae; Ne++) {
            const Le = V[Ne];
            je(Le[2] + xe, Le[1] + xe, Le[0] + xe);
          }
          (se = h + x * 2), (xe = oe * se);
          for (let Ne = 0; Ne < ae; Ne++) {
            const Le = V[Ne];
            je(Le[0] + xe, Le[1] + xe, Le[2] + xe);
          }
        } else {
          for (let se = 0; se < ae; se++) {
            const xe = V[se];
            je(xe[2], xe[1], xe[0]);
          }
          for (let se = 0; se < ae; se++) {
            const xe = V[se];
            je(xe[0] + oe * h, xe[1] + oe * h, xe[2] + oe * h);
          }
        }
        i.addGroup(me, r.length / 3 - me, 0);
      }
      function Ce() {
        const me = r.length / 3;
        let se = 0;
        _e(J, se), (se += J.length);
        for (let xe = 0, Ne = U.length; xe < Ne; xe++) {
          const Le = U[xe];
          _e(Le, se), (se += Le.length);
        }
        i.addGroup(me, r.length / 3 - me, 1);
      }
      function _e(me, se) {
        let xe = me.length;
        for (; --xe >= 0; ) {
          const Ne = xe;
          let Le = xe - 1;
          Le < 0 && (Le = me.length - 1);
          for (let We = 0, Ke = h + x * 2; We < Ke; We++) {
            const Je = oe * We,
              nt = oe * (We + 1),
              _t = se + Ne + Je,
              k = se + Le + Je,
              D = se + Le + nt,
              le = se + Ne + nt;
            Xe(_t, k, D, le);
          }
        }
      }
      function $(me, se, xe) {
        l.push(me), l.push(se), l.push(xe);
      }
      function je(me, se, xe) {
        ve(me), ve(se), ve(xe);
        const Ne = r.length / 3,
          Le = _.generateTopUV(i, r, Ne - 3, Ne - 2, Ne - 1);
        Me(Le[0]), Me(Le[1]), Me(Le[2]);
      }
      function Xe(me, se, xe, Ne) {
        ve(me), ve(se), ve(Ne), ve(se), ve(xe), ve(Ne);
        const Le = r.length / 3,
          We = _.generateSideWallUV(i, r, Le - 6, Le - 3, Le - 2, Le - 1);
        Me(We[0]), Me(We[1]), Me(We[3]), Me(We[1]), Me(We[2]), Me(We[3]);
      }
      function ve(me) {
        r.push(l[me * 3 + 0]), r.push(l[me * 3 + 1]), r.push(l[me * 3 + 2]);
      }
      function Me(me) {
        s.push(me.x), s.push(me.y);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes,
      i = this.parameters.options;
    return hH(t, i, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let s = 0, o = e.shapes.length; s < o; s++) {
      const a = t[e.shapes[s]];
      i.push(a);
    }
    const r = e.options.extrudePath;
    return (
      r !== void 0 && (e.options.extrudePath = new _A[r.type]().fromJSON(r)),
      new Rh(i, e.options)
    );
  }
}
const fH = {
  generateTopUV: function (n, e, t, i, r) {
    const s = e[t * 3],
      o = e[t * 3 + 1],
      a = e[i * 3],
      l = e[i * 3 + 1],
      c = e[r * 3],
      h = e[r * 3 + 1];
    return [new ge(s, o), new ge(a, l), new ge(c, h)];
  },
  generateSideWallUV: function (n, e, t, i, r, s) {
    const o = e[t * 3],
      a = e[t * 3 + 1],
      l = e[t * 3 + 2],
      c = e[i * 3],
      h = e[i * 3 + 1],
      d = e[i * 3 + 2],
      p = e[r * 3],
      m = e[r * 3 + 1],
      v = e[r * 3 + 2],
      A = e[s * 3],
      x = e[s * 3 + 1],
      g = e[s * 3 + 2];
    return Math.abs(a - h) < Math.abs(o - c)
      ? [new ge(o, 1 - l), new ge(c, 1 - d), new ge(p, 1 - v), new ge(A, 1 - g)]
      : [
          new ge(a, 1 - l),
          new ge(h, 1 - d),
          new ge(m, 1 - v),
          new ge(x, 1 - g),
        ];
  },
};
function hH(n, e, t) {
  if (((t.shapes = []), Array.isArray(n)))
    for (let i = 0, r = n.length; i < r; i++) {
      const s = n[i];
      t.shapes.push(s.uuid);
    }
  else t.shapes.push(n.uuid);
  return (
    (t.options = Object.assign({}, e)),
    e.extrudePath !== void 0 &&
      (t.options.extrudePath = e.extrudePath.toJSON()),
    t
  );
}
class Lh extends qs {
  constructor(e = 1, t = 0) {
    const i = (1 + Math.sqrt(5)) / 2,
      r = [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1,
      ],
      s = [
        0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
        10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9,
        4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
      ];
    super(r, s, e, t),
      (this.type = "IcosahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Lh(e.radius, e.detail);
  }
}
class rc extends qs {
  constructor(e = 1, t = 0) {
    const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      r = [
        0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
      ];
    super(i, r, e, t),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new rc(e.radius, e.detail);
  }
}
class Ih extends ct {
  constructor(e = 0.5, t = 1, i = 32, r = 1, s = 0, o = Math.PI * 2) {
    super(),
      (this.type = "RingGeometry"),
      (this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: i,
        phiSegments: r,
        thetaStart: s,
        thetaLength: o,
      }),
      (i = Math.max(3, i)),
      (r = Math.max(1, r));
    const a = [],
      l = [],
      c = [],
      h = [];
    let d = e;
    const p = (t - e) / r,
      m = new F(),
      v = new ge();
    for (let A = 0; A <= r; A++) {
      for (let x = 0; x <= i; x++) {
        const g = s + (x / i) * o;
        (m.x = d * Math.cos(g)),
          (m.y = d * Math.sin(g)),
          l.push(m.x, m.y, m.z),
          c.push(0, 0, 1),
          (v.x = (m.x / t + 1) / 2),
          (v.y = (m.y / t + 1) / 2),
          h.push(v.x, v.y);
      }
      d += p;
    }
    for (let A = 0; A < r; A++) {
      const x = A * (i + 1);
      for (let g = 0; g < i; g++) {
        const _ = g + x,
          S = _,
          w = _ + i + 1,
          E = _ + i + 2,
          P = _ + 1;
        a.push(S, w, P), a.push(w, E, P);
      }
    }
    this.setIndex(a),
      this.setAttribute("position", new Ve(l, 3)),
      this.setAttribute("normal", new Ve(c, 3)),
      this.setAttribute("uv", new Ve(h, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Ih(
      e.innerRadius,
      e.outerRadius,
      e.thetaSegments,
      e.phiSegments,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Dh extends ct {
  constructor(
    e = new qa([new ge(0, 0.5), new ge(-0.5, -0.5), new ge(0.5, -0.5)]),
    t = 12
  ) {
    super(),
      (this.type = "ShapeGeometry"),
      (this.parameters = { shapes: e, curveSegments: t });
    const i = [],
      r = [],
      s = [],
      o = [];
    let a = 0,
      l = 0;
    if (Array.isArray(e) === !1) c(e);
    else
      for (let h = 0; h < e.length; h++)
        c(e[h]), this.addGroup(a, l, h), (a += l), (l = 0);
    this.setIndex(i),
      this.setAttribute("position", new Ve(r, 3)),
      this.setAttribute("normal", new Ve(s, 3)),
      this.setAttribute("uv", new Ve(o, 2));
    function c(h) {
      const d = r.length / 3,
        p = h.extractPoints(t);
      let m = p.shape;
      const v = p.holes;
      as.isClockWise(m) === !1 && (m = m.reverse());
      for (let x = 0, g = v.length; x < g; x++) {
        const _ = v[x];
        as.isClockWise(_) === !0 && (v[x] = _.reverse());
      }
      const A = as.triangulateShape(m, v);
      for (let x = 0, g = v.length; x < g; x++) {
        const _ = v[x];
        m = m.concat(_);
      }
      for (let x = 0, g = m.length; x < g; x++) {
        const _ = m[x];
        r.push(_.x, _.y, 0), s.push(0, 0, 1), o.push(_.x, _.y);
      }
      for (let x = 0, g = A.length; x < g; x++) {
        const _ = A[x],
          S = _[0] + d,
          w = _[1] + d,
          E = _[2] + d;
        i.push(S, w, E), (l += 3);
      }
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON(),
      t = this.parameters.shapes;
    return dH(t, e);
  }
  static fromJSON(e, t) {
    const i = [];
    for (let r = 0, s = e.shapes.length; r < s; r++) {
      const o = t[e.shapes[r]];
      i.push(o);
    }
    return new Dh(i, e.curveSegments);
  }
}
function dH(n, e) {
  if (((e.shapes = []), Array.isArray(n)))
    for (let t = 0, i = n.length; t < i; t++) {
      const r = n[t];
      e.shapes.push(r.uuid);
    }
  else e.shapes.push(n.uuid);
  return e;
}
class sc extends ct {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    r = 0,
    s = Math.PI * 2,
    o = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: r,
        phiLength: s,
        thetaStart: o,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)));
    const l = Math.min(o + a, Math.PI);
    let c = 0;
    const h = [],
      d = new F(),
      p = new F(),
      m = [],
      v = [],
      A = [],
      x = [];
    for (let g = 0; g <= i; g++) {
      const _ = [],
        S = g / i;
      let w = 0;
      g === 0 && o === 0
        ? (w = 0.5 / t)
        : g === i && l === Math.PI && (w = -0.5 / t);
      for (let E = 0; E <= t; E++) {
        const P = E / t;
        (d.x = -e * Math.cos(r + P * s) * Math.sin(o + S * a)),
          (d.y = e * Math.cos(o + S * a)),
          (d.z = e * Math.sin(r + P * s) * Math.sin(o + S * a)),
          v.push(d.x, d.y, d.z),
          p.copy(d).normalize(),
          A.push(p.x, p.y, p.z),
          x.push(P + w, 1 - S),
          _.push(c++);
      }
      h.push(_);
    }
    for (let g = 0; g < i; g++)
      for (let _ = 0; _ < t; _++) {
        const S = h[g][_ + 1],
          w = h[g][_],
          E = h[g + 1][_],
          P = h[g + 1][_ + 1];
        (g !== 0 || o > 0) && m.push(S, w, P),
          (g !== i - 1 || l < Math.PI) && m.push(w, E, P);
      }
    this.setIndex(m),
      this.setAttribute("position", new Ve(v, 3)),
      this.setAttribute("normal", new Ve(A, 3)),
      this.setAttribute("uv", new Ve(x, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new sc(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Fh extends qs {
  constructor(e = 1, t = 0) {
    const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      r = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
    super(i, r, e, t),
      (this.type = "TetrahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Fh(e.radius, e.detail);
  }
}
class Nh extends ct {
  constructor(e = 1, t = 0.4, i = 12, r = 48, s = Math.PI * 2) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: r,
        arc: s,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const o = [],
      a = [],
      l = [],
      c = [],
      h = new F(),
      d = new F(),
      p = new F();
    for (let m = 0; m <= i; m++)
      for (let v = 0; v <= r; v++) {
        const A = (v / r) * s,
          x = (m / i) * Math.PI * 2;
        (d.x = (e + t * Math.cos(x)) * Math.cos(A)),
          (d.y = (e + t * Math.cos(x)) * Math.sin(A)),
          (d.z = t * Math.sin(x)),
          a.push(d.x, d.y, d.z),
          (h.x = e * Math.cos(A)),
          (h.y = e * Math.sin(A)),
          p.subVectors(d, h).normalize(),
          l.push(p.x, p.y, p.z),
          c.push(v / r),
          c.push(m / i);
      }
    for (let m = 1; m <= i; m++)
      for (let v = 1; v <= r; v++) {
        const A = (r + 1) * m + v - 1,
          x = (r + 1) * (m - 1) + v - 1,
          g = (r + 1) * (m - 1) + v,
          _ = (r + 1) * m + v;
        o.push(A, x, _), o.push(x, g, _);
      }
    this.setIndex(o),
      this.setAttribute("position", new Ve(a, 3)),
      this.setAttribute("normal", new Ve(l, 3)),
      this.setAttribute("uv", new Ve(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Nh(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Oh extends ct {
  constructor(e = 1, t = 0.4, i = 64, r = 8, s = 2, o = 3) {
    super(),
      (this.type = "TorusKnotGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: i,
        radialSegments: r,
        p: s,
        q: o,
      }),
      (i = Math.floor(i)),
      (r = Math.floor(r));
    const a = [],
      l = [],
      c = [],
      h = [],
      d = new F(),
      p = new F(),
      m = new F(),
      v = new F(),
      A = new F(),
      x = new F(),
      g = new F();
    for (let S = 0; S <= i; ++S) {
      const w = (S / i) * s * Math.PI * 2;
      _(w, s, o, e, m),
        _(w + 0.01, s, o, e, v),
        x.subVectors(v, m),
        g.addVectors(v, m),
        A.crossVectors(x, g),
        g.crossVectors(A, x),
        A.normalize(),
        g.normalize();
      for (let E = 0; E <= r; ++E) {
        const P = (E / r) * Math.PI * 2,
          L = -t * Math.cos(P),
          B = t * Math.sin(P);
        (d.x = m.x + (L * g.x + B * A.x)),
          (d.y = m.y + (L * g.y + B * A.y)),
          (d.z = m.z + (L * g.z + B * A.z)),
          l.push(d.x, d.y, d.z),
          p.subVectors(d, m).normalize(),
          c.push(p.x, p.y, p.z),
          h.push(S / i),
          h.push(E / r);
      }
    }
    for (let S = 1; S <= i; S++)
      for (let w = 1; w <= r; w++) {
        const E = (r + 1) * (S - 1) + (w - 1),
          P = (r + 1) * S + (w - 1),
          L = (r + 1) * S + w,
          B = (r + 1) * (S - 1) + w;
        a.push(E, P, B), a.push(P, L, B);
      }
    this.setIndex(a),
      this.setAttribute("position", new Ve(l, 3)),
      this.setAttribute("normal", new Ve(c, 3)),
      this.setAttribute("uv", new Ve(h, 2));
    function _(S, w, E, P, L) {
      const B = Math.cos(S),
        b = Math.sin(S),
        R = (E / w) * S,
        U = Math.cos(R);
      (L.x = P * (2 + U) * 0.5 * B),
        (L.y = P * (2 + U) * b * 0.5),
        (L.z = P * Math.sin(R) * 0.5);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Oh(
      e.radius,
      e.tube,
      e.tubularSegments,
      e.radialSegments,
      e.p,
      e.q
    );
  }
}
class kh extends ct {
  constructor(
    e = new vA(new F(-1, -1, 0), new F(-1, 1, 0), new F(1, 1, 0)),
    t = 64,
    i = 1,
    r = 8,
    s = !1
  ) {
    super(),
      (this.type = "TubeGeometry"),
      (this.parameters = {
        path: e,
        tubularSegments: t,
        radius: i,
        radialSegments: r,
        closed: s,
      });
    const o = e.computeFrenetFrames(t, s);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals);
    const a = new F(),
      l = new F(),
      c = new ge();
    let h = new F();
    const d = [],
      p = [],
      m = [],
      v = [];
    A(),
      this.setIndex(v),
      this.setAttribute("position", new Ve(d, 3)),
      this.setAttribute("normal", new Ve(p, 3)),
      this.setAttribute("uv", new Ve(m, 2));
    function A() {
      for (let S = 0; S < t; S++) x(S);
      x(s === !1 ? t : 0), _(), g();
    }
    function x(S) {
      h = e.getPointAt(S / t, h);
      const w = o.normals[S],
        E = o.binormals[S];
      for (let P = 0; P <= r; P++) {
        const L = (P / r) * Math.PI * 2,
          B = Math.sin(L),
          b = -Math.cos(L);
        (l.x = b * w.x + B * E.x),
          (l.y = b * w.y + B * E.y),
          (l.z = b * w.z + B * E.z),
          l.normalize(),
          p.push(l.x, l.y, l.z),
          (a.x = h.x + i * l.x),
          (a.y = h.y + i * l.y),
          (a.z = h.z + i * l.z),
          d.push(a.x, a.y, a.z);
      }
    }
    function g() {
      for (let S = 1; S <= t; S++)
        for (let w = 1; w <= r; w++) {
          const E = (r + 1) * (S - 1) + (w - 1),
            P = (r + 1) * S + (w - 1),
            L = (r + 1) * S + w,
            B = (r + 1) * (S - 1) + w;
          v.push(E, P, B), v.push(P, L, B);
        }
    }
    function _() {
      for (let S = 0; S <= t; S++)
        for (let w = 0; w <= r; w++)
          (c.x = S / t), (c.y = w / r), m.push(c.x, c.y);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  toJSON() {
    const e = super.toJSON();
    return (e.path = this.parameters.path.toJSON()), e;
  }
  static fromJSON(e) {
    return new kh(
      new _A[e.path.type]().fromJSON(e.path),
      e.tubularSegments,
      e.radius,
      e.radialSegments,
      e.closed
    );
  }
}
class gR extends ct {
  constructor(e = null) {
    if (
      (super(),
      (this.type = "WireframeGeometry"),
      (this.parameters = { geometry: e }),
      e !== null)
    ) {
      const t = [],
        i = new Set(),
        r = new F(),
        s = new F();
      if (e.index !== null) {
        const o = e.attributes.position,
          a = e.index;
        let l = e.groups;
        l.length === 0 &&
          (l = [{ start: 0, count: a.count, materialIndex: 0 }]);
        for (let c = 0, h = l.length; c < h; ++c) {
          const d = l[c],
            p = d.start,
            m = d.count;
          for (let v = p, A = p + m; v < A; v += 3)
            for (let x = 0; x < 3; x++) {
              const g = a.getX(v + x),
                _ = a.getX(v + ((x + 1) % 3));
              r.fromBufferAttribute(o, g),
                s.fromBufferAttribute(o, _),
                dE(r, s, i) === !0 &&
                  (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
            }
        }
      } else {
        const o = e.attributes.position;
        for (let a = 0, l = o.count / 3; a < l; a++)
          for (let c = 0; c < 3; c++) {
            const h = 3 * a + c,
              d = 3 * a + ((c + 1) % 3);
            r.fromBufferAttribute(o, h),
              s.fromBufferAttribute(o, d),
              dE(r, s, i) === !0 &&
                (t.push(r.x, r.y, r.z), t.push(s.x, s.y, s.z));
          }
      }
      this.setAttribute("position", new Ve(t, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
function dE(n, e, t) {
  const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
    r = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
  return t.has(i) === !0 || t.has(r) === !0 ? !1 : (t.add(i), t.add(r), !0);
}
var pE = Object.freeze({
  __proto__: null,
  BoxGeometry: ta,
  CapsuleGeometry: Th,
  CircleGeometry: bh,
  ConeGeometry: Ph,
  CylinderGeometry: hl,
  DodecahedronGeometry: Bh,
  EdgesGeometry: hR,
  ExtrudeGeometry: Rh,
  IcosahedronGeometry: Lh,
  LatheGeometry: ic,
  OctahedronGeometry: rc,
  PlaneGeometry: tc,
  PolyhedronGeometry: qs,
  RingGeometry: Ih,
  ShapeGeometry: Dh,
  SphereGeometry: sc,
  TetrahedronGeometry: Fh,
  TorusGeometry: Nh,
  TorusKnotGeometry: Oh,
  TubeGeometry: kh,
  WireframeGeometry: gR,
});
class yR extends Cn {
  constructor(e) {
    super(),
      (this.isShadowMaterial = !0),
      (this.type = "ShadowMaterial"),
      (this.color = new Ie(0)),
      (this.transparent = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), (this.fog = e.fog), this;
  }
}
class vR extends hs {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class oc extends Cn {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Ie(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ie(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zs),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class $s extends oc {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new ge(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return pn((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Ie(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Ie(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Ie(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
class xR extends Cn {
  constructor(e) {
    super(),
      (this.isMeshPhongMaterial = !0),
      (this.type = "MeshPhongMaterial"),
      (this.color = new Ie(16777215)),
      (this.specular = new Ie(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ie(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zs),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = _h),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      this.specular.copy(e.specular),
      (this.shininess = e.shininess),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class _R extends Cn {
  constructor(e) {
    super(),
      (this.isMeshToonMaterial = !0),
      (this.defines = { TOON: "" }),
      (this.type = "MeshToonMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.gradientMap = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ie(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zs),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.gradientMap = e.gradientMap),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
class AR extends Cn {
  constructor(e) {
    super(),
      (this.isMeshNormalMaterial = !0),
      (this.type = "MeshNormalMaterial"),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zs),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.flatShading = !1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.flatShading = e.flatShading),
      this
    );
  }
}
class MR extends Cn {
  constructor(e) {
    super(),
      (this.isMeshLambertMaterial = !0),
      (this.type = "MeshLambertMaterial"),
      (this.color = new Ie(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ie(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zs),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = _h),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class SR extends Cn {
  constructor(e) {
    super(),
      (this.isMeshMatcapMaterial = !0),
      (this.defines = { MATCAP: "" }),
      (this.type = "MeshMatcapMaterial"),
      (this.color = new Ie(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Zs),
      (this.normalScale = new ge(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { MATCAP: "" }),
      this.color.copy(e.color),
      (this.matcap = e.matcap),
      (this.map = e.map),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.alphaMap = e.alphaMap),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class wR extends oi {
  constructor(e) {
    super(),
      (this.isLineDashedMaterial = !0),
      (this.type = "LineDashedMaterial"),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.scale = e.scale),
      (this.dashSize = e.dashSize),
      (this.gapSize = e.gapSize),
      this
    );
  }
}
function cr(n, e, t) {
  return AA(n)
    ? new n.constructor(n.subarray(e, t !== void 0 ? t : n.length))
    : n.slice(e, t);
}
function Va(n, e, t) {
  return !n || (!t && n.constructor === e)
    ? n
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(n)
    : Array.prototype.slice.call(n);
}
function AA(n) {
  return ArrayBuffer.isView(n) && !(n instanceof DataView);
}
function CR(n) {
  function e(r, s) {
    return n[r] - n[s];
  }
  const t = n.length,
    i = new Array(t);
  for (let r = 0; r !== t; ++r) i[r] = r;
  return i.sort(e), i;
}
function x_(n, e, t) {
  const i = n.length,
    r = new n.constructor(i);
  for (let s = 0, o = 0; o !== i; ++s) {
    const a = t[s] * e;
    for (let l = 0; l !== e; ++l) r[o++] = n[a + l];
  }
  return r;
}
function MA(n, e, t, i) {
  let r = 1,
    s = n[0];
  for (; s !== void 0 && s[i] === void 0; ) s = n[r++];
  if (s === void 0) return;
  let o = s[i];
  if (o !== void 0)
    if (Array.isArray(o))
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), t.push.apply(t, o)),
          (s = n[r++]);
      while (s !== void 0);
    else if (o.toArray !== void 0)
      do
        (o = s[i]),
          o !== void 0 && (e.push(s.time), o.toArray(t, t.length)),
          (s = n[r++]);
      while (s !== void 0);
    else
      do (o = s[i]), o !== void 0 && (e.push(s.time), t.push(o)), (s = n[r++]);
      while (s !== void 0);
}
function pH(n, e, t, i, r = 30) {
  const s = n.clone();
  s.name = e;
  const o = [];
  for (let l = 0; l < s.tracks.length; ++l) {
    const c = s.tracks[l],
      h = c.getValueSize(),
      d = [],
      p = [];
    for (let m = 0; m < c.times.length; ++m) {
      const v = c.times[m] * r;
      if (!(v < t || v >= i)) {
        d.push(c.times[m]);
        for (let A = 0; A < h; ++A) p.push(c.values[m * h + A]);
      }
    }
    d.length !== 0 &&
      ((c.times = Va(d, c.times.constructor)),
      (c.values = Va(p, c.values.constructor)),
      o.push(c));
  }
  s.tracks = o;
  let a = 1 / 0;
  for (let l = 0; l < s.tracks.length; ++l)
    a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
  for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
  return s.resetDuration(), s;
}
function mH(n, e = 0, t = n, i = 30) {
  i <= 0 && (i = 30);
  const r = t.tracks.length,
    s = e / i;
  for (let o = 0; o < r; ++o) {
    const a = t.tracks[o],
      l = a.ValueTypeName;
    if (l === "bool" || l === "string") continue;
    const c = n.tracks.find(function (g) {
      return g.name === a.name && g.ValueTypeName === l;
    });
    if (c === void 0) continue;
    let h = 0;
    const d = a.getValueSize();
    a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (h = d / 3);
    let p = 0;
    const m = c.getValueSize();
    c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline &&
      (p = m / 3);
    const v = a.times.length - 1;
    let A;
    if (s <= a.times[0]) {
      const g = h,
        _ = d - h;
      A = cr(a.values, g, _);
    } else if (s >= a.times[v]) {
      const g = v * d + h,
        _ = g + d - h;
      A = cr(a.values, g, _);
    } else {
      const g = a.createInterpolant(),
        _ = h,
        S = d - h;
      g.evaluate(s), (A = cr(g.resultBuffer, _, S));
    }
    l === "quaternion" &&
      new jn().fromArray(A).normalize().conjugate().toArray(A);
    const x = c.times.length;
    for (let g = 0; g < x; ++g) {
      const _ = g * m + p;
      if (l === "quaternion")
        jn.multiplyQuaternionsFlat(c.values, _, A, 0, c.values, _);
      else {
        const S = m - p * 2;
        for (let w = 0; w < S; ++w) c.values[_ + w] -= A[w];
      }
    }
  }
  return (n.blendMode = Y1), n;
}
const gH = {
  arraySlice: cr,
  convertArray: Va,
  isTypedArray: AA,
  getKeyframeOrder: CR,
  sortedArray: x_,
  flattenJSON: MA,
  subclip: pH,
  makeClipAdditive: mH,
};
class ac {
  constructor(e, t, i, r) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = r !== void 0 ? r : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      r = t[i],
      s = t[i - 1];
    e: {
      t: {
        let o;
        n: {
          i: if (!(e < r)) {
            for (let a = i + 2; ; ) {
              if (r === void 0) {
                if (e < s) break i;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === a) break;
              if (((s = r), (r = t[++i]), e < r)) break t;
            }
            o = t.length;
            break n;
          }
          if (!(e >= s)) {
            const a = t[1];
            e < a && ((i = 2), (s = a));
            for (let l = i - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === l) break;
              if (((r = s), (s = t[--i - 1]), e >= s)) break t;
            }
            (o = i), (i = 0);
            break n;
          }
          break e;
        }
        for (; i < o; ) {
          const a = (i + o) >>> 1;
          e < t[a] ? (o = a) : (i = a + 1);
        }
        if (((r = t[i]), (s = t[i - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (r === void 0)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, s, r);
    }
    return this.interpolate_(i, s, e, r);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r;
    for (let o = 0; o !== r; ++o) t[o] = i[s + o];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class ER extends ac {
  constructor(e, t, i, r) {
    super(e, t, i, r),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: za, endingEnd: za });
  }
  intervalChanged_(e, t, i) {
    const r = this.parameterPositions;
    let s = e - 2,
      o = e + 1,
      a = r[s],
      l = r[o];
    if (a === void 0)
      switch (this.getSettings_().endingStart) {
        case Ga:
          (s = e), (a = 2 * t - i);
          break;
        case qf:
          (s = r.length - 2), (a = t + r[s] - r[s + 1]);
          break;
        default:
          (s = e), (a = i);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case Ga:
          (o = e), (l = 2 * i - t);
          break;
        case qf:
          (o = 1), (l = i + r[1] - r[0]);
          break;
        default:
          (o = e - 1), (l = t);
      }
    const c = (i - t) * 0.5,
      h = this.valueSize;
    (this._weightPrev = c / (t - a)),
      (this._weightNext = c / (l - i)),
      (this._offsetPrev = s * h),
      (this._offsetNext = o * h);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      h = this._offsetPrev,
      d = this._offsetNext,
      p = this._weightPrev,
      m = this._weightNext,
      v = (i - t) / (r - t),
      A = v * v,
      x = A * v,
      g = -p * x + 2 * p * A - p * v,
      _ = (1 + p) * x + (-1.5 - 2 * p) * A + (-0.5 + p) * v + 1,
      S = (-1 - m) * x + (1.5 + m) * A + 0.5 * v,
      w = m * x - m * A;
    for (let E = 0; E !== a; ++E)
      s[E] = g * o[h + E] + _ * o[c + E] + S * o[l + E] + w * o[d + E];
    return s;
  }
}
class SA extends ac {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = e * a,
      c = l - a,
      h = (i - t) / (r - t),
      d = 1 - h;
    for (let p = 0; p !== a; ++p) s[p] = o[c + p] * d + o[l + p] * h;
    return s;
  }
}
class TR extends ac {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class jr {
  constructor(e, t, i, r) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = Va(t, this.TimeBufferType)),
      (this.values = Va(i, this.ValueBufferType)),
      this.setInterpolation(r || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: Va(e.times, Array),
        values: Va(e.values, Array),
      };
      const r = e.getInterpolation();
      r !== e.DefaultInterpolation && (i.interpolation = r);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new TR(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new SA(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new ER(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Gu:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case sl:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case vm:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const i =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(i);
      return console.warn("THREE.KeyframeTrack:", i), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Gu;
      case this.InterpolantFactoryMethodLinear:
        return sl;
      case this.InterpolantFactoryMethodSmooth:
        return vm;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let i = 0, r = t.length; i !== r; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      r = i.length;
    let s = 0,
      o = r - 1;
    for (; s !== r && i[s] < e; ) ++s;
    for (; o !== -1 && i[o] > t; ) --o;
    if ((++o, s !== 0 || o !== r)) {
      s >= o && ((o = Math.max(o, 1)), (s = o - 1));
      const a = this.getValueSize();
      (this.times = cr(i, s, o)), (this.values = cr(this.values, s * a, o * a));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      r = this.values,
      s = i.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let o = null;
    for (let a = 0; a !== s; a++) {
      const l = i[a];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          l
        ),
          (e = !1);
        break;
      }
      if (o !== null && o > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
          (e = !1);
        break;
      }
      o = l;
    }
    if (r !== void 0 && AA(r))
      for (let a = 0, l = r.length; a !== l; ++a) {
        const c = r[a];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = cr(this.times),
      t = cr(this.values),
      i = this.getValueSize(),
      r = this.getInterpolation() === vm,
      s = e.length - 1;
    let o = 1;
    for (let a = 1; a < s; ++a) {
      let l = !1;
      const c = e[a],
        h = e[a + 1];
      if (c !== h && (a !== 1 || c !== e[0]))
        if (r) l = !0;
        else {
          const d = a * i,
            p = d - i,
            m = d + i;
          for (let v = 0; v !== i; ++v) {
            const A = t[d + v];
            if (A !== t[p + v] || A !== t[m + v]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (a !== o) {
          e[o] = e[a];
          const d = a * i,
            p = o * i;
          for (let m = 0; m !== i; ++m) t[p + m] = t[d + m];
        }
        ++o;
      }
    }
    if (s > 0) {
      e[o] = e[s];
      for (let a = s * i, l = o * i, c = 0; c !== i; ++c) t[l + c] = t[a + c];
      ++o;
    }
    return (
      o !== e.length
        ? ((this.times = cr(e, 0, o)), (this.values = cr(t, 0, o * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = cr(this.times, 0),
      t = cr(this.values, 0),
      i = this.constructor,
      r = new i(this.name, e, t);
    return (r.createInterpolant = this.createInterpolant), r;
  }
}
jr.prototype.TimeBufferType = Float32Array;
jr.prototype.ValueBufferType = Float32Array;
jr.prototype.DefaultInterpolation = sl;
class dl extends jr {}
dl.prototype.ValueTypeName = "bool";
dl.prototype.ValueBufferType = Array;
dl.prototype.DefaultInterpolation = Gu;
dl.prototype.InterpolantFactoryMethodLinear = void 0;
dl.prototype.InterpolantFactoryMethodSmooth = void 0;
class wA extends jr {}
wA.prototype.ValueTypeName = "color";
class ju extends jr {}
ju.prototype.ValueTypeName = "number";
class bR extends ac {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = (i - t) / (r - t);
    let c = e * a;
    for (let h = c + a; c !== h; c += 4) jn.slerpFlat(s, 0, o, c - a, o, c, l);
    return s;
  }
}
class Ko extends jr {
  InterpolantFactoryMethodLinear(e) {
    return new bR(this.times, this.values, this.getValueSize(), e);
  }
}
Ko.prototype.ValueTypeName = "quaternion";
Ko.prototype.DefaultInterpolation = sl;
Ko.prototype.InterpolantFactoryMethodSmooth = void 0;
class pl extends jr {}
pl.prototype.ValueTypeName = "string";
pl.prototype.ValueBufferType = Array;
pl.prototype.DefaultInterpolation = Gu;
pl.prototype.InterpolantFactoryMethodLinear = void 0;
pl.prototype.InterpolantFactoryMethodSmooth = void 0;
class Xu extends jr {}
Xu.prototype.ValueTypeName = "vector";
class Ku {
  constructor(e, t = -1, i, r = Ig) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = r),
      (this.uuid = ji()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      r = 1 / (e.fps || 1);
    for (let o = 0, a = i.length; o !== a; ++o) t.push(vH(i[o]).scale(r));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      r = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, o = i.length; s !== o; ++s) t.push(jr.toJSON(i[s]));
    return r;
  }
  static CreateFromMorphTargetSequence(e, t, i, r) {
    const s = t.length,
      o = [];
    for (let a = 0; a < s; a++) {
      let l = [],
        c = [];
      l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
      const h = CR(l);
      (l = x_(l, 1, h)),
        (c = x_(c, 1, h)),
        !r && l[0] === 0 && (l.push(s), c.push(c[0])),
        o.push(
          new ju(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / i)
        );
    }
    return new this(e, -1, o);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const r = e;
      i = (r.geometry && r.geometry.animations) || r.animations;
    }
    for (let r = 0; r < i.length; r++) if (i[r].name === t) return i[r];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const r = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        h = c.name.match(s);
      if (h && h.length > 1) {
        const d = h[1];
        let p = r[d];
        p || (r[d] = p = []), p.push(c);
      }
    }
    const o = [];
    for (const a in r)
      o.push(this.CreateFromMorphTargetSequence(a, r[a], t, i));
    return o;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (d, p, m, v, A) {
        if (m.length !== 0) {
          const x = [],
            g = [];
          MA(m, x, g, v), x.length !== 0 && A.push(new d(p, x, g));
        }
      },
      r = [],
      s = e.name || "default",
      o = e.fps || 30,
      a = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let d = 0; d < c.length; d++) {
      const p = c[d].keys;
      if (!(!p || p.length === 0))
        if (p[0].morphTargets) {
          const m = {};
          let v;
          for (v = 0; v < p.length; v++)
            if (p[v].morphTargets)
              for (let A = 0; A < p[v].morphTargets.length; A++)
                m[p[v].morphTargets[A]] = -1;
          for (const A in m) {
            const x = [],
              g = [];
            for (let _ = 0; _ !== p[v].morphTargets.length; ++_) {
              const S = p[v];
              x.push(S.time), g.push(S.morphTarget === A ? 1 : 0);
            }
            r.push(new ju(".morphTargetInfluence[" + A + "]", x, g));
          }
          l = m.length * o;
        } else {
          const m = ".bones[" + t[d].name + "]";
          i(Xu, m + ".position", p, "pos", r),
            i(Ko, m + ".quaternion", p, "rot", r),
            i(Xu, m + ".scale", p, "scl", r);
        }
    }
    return r.length === 0 ? null : new this(s, l, r, a);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let i = 0, r = e.length; i !== r; ++i) {
      const s = this.tracks[i];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function yH(n) {
  switch (n.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return ju;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Xu;
    case "color":
      return wA;
    case "quaternion":
      return Ko;
    case "bool":
    case "boolean":
      return dl;
    case "string":
      return pl;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n);
}
function vH(n) {
  if (n.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = yH(n.type);
  if (n.times === void 0) {
    const t = [],
      i = [];
    MA(n.keys, t, i, "value"), (n.times = t), (n.values = i);
  }
  return e.parse !== void 0
    ? e.parse(n)
    : new e(n.name, n.times, n.values, n.interpolation);
}
const al = {
  enabled: !1,
  files: {},
  add: function (n, e) {
    this.enabled !== !1 && (this.files[n] = e);
  },
  get: function (n) {
    if (this.enabled !== !1) return this.files[n];
  },
  remove: function (n) {
    delete this.files[n];
  },
  clear: function () {
    this.files = {};
  },
};
class CA {
  constructor(e, t, i) {
    const r = this;
    let s = !1,
      o = 0,
      a = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (h) {
        a++, s === !1 && r.onStart !== void 0 && r.onStart(h, o, a), (s = !0);
      }),
      (this.itemEnd = function (h) {
        o++,
          r.onProgress !== void 0 && r.onProgress(h, o, a),
          o === a && ((s = !1), r.onLoad !== void 0 && r.onLoad());
      }),
      (this.itemError = function (h) {
        r.onError !== void 0 && r.onError(h);
      }),
      (this.resolveURL = function (h) {
        return l ? l(h) : h;
      }),
      (this.setURLModifier = function (h) {
        return (l = h), this;
      }),
      (this.addHandler = function (h, d) {
        return c.push(h, d), this;
      }),
      (this.removeHandler = function (h) {
        const d = c.indexOf(h);
        return d !== -1 && c.splice(d, 2), this;
      }),
      (this.getHandler = function (h) {
        for (let d = 0, p = c.length; d < p; d += 2) {
          const m = c[d],
            v = c[d + 1];
          if ((m.global && (m.lastIndex = 0), m.test(h))) return v;
        }
        return null;
      });
  }
}
const vu = new CA();
let vi = class {
  constructor(e) {
    (this.manager = e !== void 0 ? e : vu),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.load(e, r, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
};
const Ts = {};
class xH extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class Ki extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = al.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (Ts[e] !== void 0) {
      Ts[e].push({ onLoad: t, onProgress: i, onError: r });
      return;
    }
    (Ts[e] = []), Ts[e].push({ onLoad: t, onProgress: i, onError: r });
    const o = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      l = this.responseType;
    fetch(o)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const h = Ts[e],
            d = c.body.getReader(),
            p = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
            m = p ? parseInt(p) : 0,
            v = m !== 0;
          let A = 0;
          const x = new ReadableStream({
            start(g) {
              _();
              function _() {
                d.read().then(({ done: S, value: w }) => {
                  if (S) g.close();
                  else {
                    A += w.byteLength;
                    const E = new ProgressEvent("progress", {
                      lengthComputable: v,
                      loaded: A,
                      total: m,
                    });
                    for (let P = 0, L = h.length; P < L; P++) {
                      const B = h[P];
                      B.onProgress && B.onProgress(E);
                    }
                    g.enqueue(w), _();
                  }
                });
              }
            },
          });
          return new Response(x);
        } else
          throw new xH(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((h) => new DOMParser().parseFromString(h, a));
          case "json":
            return c.json();
          default:
            if (a === void 0) return c.text();
            {
              const d = /charset="?([^;"\s]*)"?/i.exec(a),
                p = d && d[1] ? d[1].toLowerCase() : void 0,
                m = new TextDecoder(p);
              return c.arrayBuffer().then((v) => m.decode(v));
            }
        }
      })
      .then((c) => {
        al.add(e, c);
        const h = Ts[e];
        delete Ts[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const m = h[d];
          m.onLoad && m.onLoad(c);
        }
      })
      .catch((c) => {
        const h = Ts[e];
        if (h === void 0) throw (this.manager.itemError(e), c);
        delete Ts[e];
        for (let d = 0, p = h.length; d < p; d++) {
          const m = h[d];
          m.onError && m.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class _H extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ki(this.manager);
    o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const r = Ku.parse(e[i]);
      t.push(r);
    }
    return t;
  }
}
class AH extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = [],
      a = new pA(),
      l = new Ki(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(s.withCredentials);
    let c = 0;
    function h(d) {
      l.load(
        e[d],
        function (p) {
          const m = s.parse(p, !0);
          (o[d] = {
            width: m.width,
            height: m.height,
            format: m.format,
            mipmaps: m.mipmaps,
          }),
            (c += 1),
            c === 6 &&
              (m.mipmapCount === 1 && (a.minFilter = rn),
              (a.image = o),
              (a.format = m.format),
              (a.needsUpdate = !0),
              t && t(a));
        },
        i,
        r
      );
    }
    if (Array.isArray(e)) for (let d = 0, p = e.length; d < p; ++d) h(d);
    else
      l.load(
        e,
        function (d) {
          const p = s.parse(d, !0);
          if (p.isCubemap) {
            const m = p.mipmaps.length / p.mipmapCount;
            for (let v = 0; v < m; v++) {
              o[v] = { mipmaps: [] };
              for (let A = 0; A < p.mipmapCount; A++)
                o[v].mipmaps.push(p.mipmaps[v * p.mipmapCount + A]),
                  (o[v].format = p.format),
                  (o[v].width = p.width),
                  (o[v].height = p.height);
            }
            a.image = o;
          } else
            (a.image.width = p.width),
              (a.image.height = p.height),
              (a.mipmaps = p.mipmaps);
          p.mipmapCount === 1 && (a.minFilter = rn),
            (a.format = p.format),
            (a.needsUpdate = !0),
            t && t(a);
        },
        i,
        r
      );
    return a;
  }
}
class sh extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = al.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = eh("img");
    function l() {
      h(), al.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(d) {
      h(), r && r(d), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", l, !1),
        a.removeEventListener("error", c, !1);
    }
    return (
      a.addEventListener("load", l, !1),
      a.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class MH extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new Sh(),
      o = new sh(this.manager);
    o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
    let a = 0;
    function l(c) {
      o.load(
        e[c],
        function (h) {
          (s.images[c] = h), a++, a === 6 && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        r
      );
    }
    for (let c = 0; c < e.length; ++c) l(c);
    return s;
  }
}
class SH extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Bu(),
      a = new Ki(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (l) {
          const c = s.parse(l);
          c &&
            (c.image !== void 0
              ? (o.image = c.image)
              : c.data !== void 0 &&
                ((o.image.width = c.width),
                (o.image.height = c.height),
                (o.image.data = c.data)),
            (o.wrapS = c.wrapS !== void 0 ? c.wrapS : Wn),
            (o.wrapT = c.wrapT !== void 0 ? c.wrapT : Wn),
            (o.magFilter = c.magFilter !== void 0 ? c.magFilter : rn),
            (o.minFilter = c.minFilter !== void 0 ? c.minFilter : rn),
            (o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1),
            c.encoding !== void 0 && (o.encoding = c.encoding),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 &&
              ((o.mipmaps = c.mipmaps), (o.minFilter = fs)),
            c.mipmapCount === 1 && (o.minFilter = rn),
            c.generateMipmaps !== void 0 &&
              (o.generateMipmaps = c.generateMipmaps),
            (o.needsUpdate = !0),
            t && t(o, c));
        },
        i,
        r
      ),
      o
    );
  }
}
class Uh extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = new en(),
      o = new sh(this.manager);
    return (
      o.setCrossOrigin(this.crossOrigin),
      o.setPath(this.path),
      o.load(
        e,
        function (a) {
          (s.image = a), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        i,
        r
      ),
      s
    );
  }
}
class na extends Pt {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Ie(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class PR extends na {
  constructor(e, t, i) {
    super(e, i),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Pt.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Ie(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const fv = new st(),
  mE = new F(),
  gE = new F();
class EA {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new ge(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new st()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Fg()),
      (this._frameExtents = new ge(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Ot(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    mE.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(mE),
      gE.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(gE),
      t.updateMatrixWorld(),
      fv.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(fv),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(fv);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class wH extends EA {
  constructor() {
    super(new Vt(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      i = Vu * 2 * e.angle * this.focus,
      r = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (i !== t.fov || r !== t.aspect || s !== t.far) &&
      ((t.fov = i), (t.aspect = r), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class TA extends na {
  constructor(e, t, i = 0, r = Math.PI / 3, s = 0, o = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Pt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Pt()),
      (this.distance = i),
      (this.angle = r),
      (this.penumbra = s),
      (this.decay = o),
      (this.map = null),
      (this.shadow = new wH());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const yE = new st(),
  jc = new F(),
  hv = new F();
class CH extends EA {
  constructor() {
    super(new Vt(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new ge(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Ot(2, 1, 1, 1),
        new Ot(0, 1, 1, 1),
        new Ot(3, 1, 1, 1),
        new Ot(1, 1, 1, 1),
        new Ot(3, 0, 1, 1),
        new Ot(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new F(1, 0, 0),
        new F(-1, 0, 0),
        new F(0, 0, 1),
        new F(0, 0, -1),
        new F(0, 1, 0),
        new F(0, -1, 0),
      ]),
      (this._cubeUps = [
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 1, 0),
        new F(0, 0, 1),
        new F(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      r = this.matrix,
      s = e.distance || i.far;
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      jc.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(jc),
      hv.copy(i.position),
      hv.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(hv),
      i.updateMatrixWorld(),
      r.makeTranslation(-jc.x, -jc.y, -jc.z),
      yE.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(yE);
  }
}
class bA extends na {
  constructor(e, t, i = 0, r = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = r),
      (this.shadow = new CH());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class EH extends EA {
  constructor() {
    super(new kr(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class PA extends na {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Pt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Pt()),
      (this.shadow = new EH());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class BR extends na {
  constructor(e, t) {
    super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
  }
}
class RR extends na {
  constructor(e, t, i = 10, r = 10) {
    super(e, t),
      (this.isRectAreaLight = !0),
      (this.type = "RectAreaLight"),
      (this.width = i),
      (this.height = r);
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return (
      super.copy(e), (this.width = e.width), (this.height = e.height), this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.width = this.width), (t.object.height = this.height), t;
  }
}
class LR {
  constructor() {
    (this.isSphericalHarmonics3 = !0), (this.coefficients = []);
    for (let e = 0; e < 9; e++) this.coefficients.push(new F());
  }
  set(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
    return this;
  }
  zero() {
    for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
    return this;
  }
  getAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.282095),
      t.addScaledVector(o[1], 0.488603 * r),
      t.addScaledVector(o[2], 0.488603 * s),
      t.addScaledVector(o[3], 0.488603 * i),
      t.addScaledVector(o[4], 1.092548 * (i * r)),
      t.addScaledVector(o[5], 1.092548 * (r * s)),
      t.addScaledVector(o[6], 0.315392 * (3 * s * s - 1)),
      t.addScaledVector(o[7], 1.092548 * (i * s)),
      t.addScaledVector(o[8], 0.546274 * (i * i - r * r)),
      t
    );
  }
  getIrradianceAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z,
      o = this.coefficients;
    return (
      t.copy(o[0]).multiplyScalar(0.886227),
      t.addScaledVector(o[1], 2 * 0.511664 * r),
      t.addScaledVector(o[2], 2 * 0.511664 * s),
      t.addScaledVector(o[3], 2 * 0.511664 * i),
      t.addScaledVector(o[4], 2 * 0.429043 * i * r),
      t.addScaledVector(o[5], 2 * 0.429043 * r * s),
      t.addScaledVector(o[6], 0.743125 * s * s - 0.247708),
      t.addScaledVector(o[7], 2 * 0.429043 * i * s),
      t.addScaledVector(o[8], 0.429043 * (i * i - r * r)),
      t
    );
  }
  add(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  addScaledSH(e, t) {
    for (let i = 0; i < 9; i++)
      this.coefficients[i].addScaledVector(e.coefficients[i], t);
    return this;
  }
  scale(e) {
    for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
    return this;
  }
  lerp(e, t) {
    for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
    return this;
  }
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
    return !0;
  }
  copy(e) {
    return this.set(e.coefficients);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  fromArray(e, t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].fromArray(e, t + r * 3);
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.coefficients;
    for (let r = 0; r < 9; r++) i[r].toArray(e, t + r * 3);
    return e;
  }
  static getBasisAt(e, t) {
    const i = e.x,
      r = e.y,
      s = e.z;
    (t[0] = 0.282095),
      (t[1] = 0.488603 * r),
      (t[2] = 0.488603 * s),
      (t[3] = 0.488603 * i),
      (t[4] = 1.092548 * i * r),
      (t[5] = 1.092548 * r * s),
      (t[6] = 0.315392 * (3 * s * s - 1)),
      (t[7] = 1.092548 * i * s),
      (t[8] = 0.546274 * (i * i - r * r));
  }
}
class Vg extends na {
  constructor(e = new LR(), t = 1) {
    super(void 0, t), (this.isLightProbe = !0), (this.sh = e);
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  fromJSON(e) {
    return (this.intensity = e.intensity), this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (t.object.sh = this.sh.toArray()), t;
  }
}
class Wg extends vi {
  constructor(e) {
    super(e), (this.textures = {});
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ki(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = this.textures;
    function i(s) {
      return (
        t[s] === void 0 &&
          console.warn("THREE.MaterialLoader: Undefined texture", s),
        t[s]
      );
    }
    const r = Wg.createMaterialFromType(e.type);
    if (
      (e.uuid !== void 0 && (r.uuid = e.uuid),
      e.name !== void 0 && (r.name = e.name),
      e.color !== void 0 && r.color !== void 0 && r.color.setHex(e.color),
      e.roughness !== void 0 && (r.roughness = e.roughness),
      e.metalness !== void 0 && (r.metalness = e.metalness),
      e.sheen !== void 0 && (r.sheen = e.sheen),
      e.sheenColor !== void 0 && (r.sheenColor = new Ie().setHex(e.sheenColor)),
      e.sheenRoughness !== void 0 && (r.sheenRoughness = e.sheenRoughness),
      e.emissive !== void 0 &&
        r.emissive !== void 0 &&
        r.emissive.setHex(e.emissive),
      e.specular !== void 0 &&
        r.specular !== void 0 &&
        r.specular.setHex(e.specular),
      e.specularIntensity !== void 0 &&
        (r.specularIntensity = e.specularIntensity),
      e.specularColor !== void 0 &&
        r.specularColor !== void 0 &&
        r.specularColor.setHex(e.specularColor),
      e.shininess !== void 0 && (r.shininess = e.shininess),
      e.clearcoat !== void 0 && (r.clearcoat = e.clearcoat),
      e.clearcoatRoughness !== void 0 &&
        (r.clearcoatRoughness = e.clearcoatRoughness),
      e.iridescence !== void 0 && (r.iridescence = e.iridescence),
      e.iridescenceIOR !== void 0 && (r.iridescenceIOR = e.iridescenceIOR),
      e.iridescenceThicknessRange !== void 0 &&
        (r.iridescenceThicknessRange = e.iridescenceThicknessRange),
      e.transmission !== void 0 && (r.transmission = e.transmission),
      e.thickness !== void 0 && (r.thickness = e.thickness),
      e.attenuationDistance !== void 0 &&
        (r.attenuationDistance = e.attenuationDistance),
      e.attenuationColor !== void 0 &&
        r.attenuationColor !== void 0 &&
        r.attenuationColor.setHex(e.attenuationColor),
      e.fog !== void 0 && (r.fog = e.fog),
      e.flatShading !== void 0 && (r.flatShading = e.flatShading),
      e.blending !== void 0 && (r.blending = e.blending),
      e.combine !== void 0 && (r.combine = e.combine),
      e.side !== void 0 && (r.side = e.side),
      e.shadowSide !== void 0 && (r.shadowSide = e.shadowSide),
      e.opacity !== void 0 && (r.opacity = e.opacity),
      e.transparent !== void 0 && (r.transparent = e.transparent),
      e.alphaTest !== void 0 && (r.alphaTest = e.alphaTest),
      e.depthTest !== void 0 && (r.depthTest = e.depthTest),
      e.depthWrite !== void 0 && (r.depthWrite = e.depthWrite),
      e.colorWrite !== void 0 && (r.colorWrite = e.colorWrite),
      e.stencilWrite !== void 0 && (r.stencilWrite = e.stencilWrite),
      e.stencilWriteMask !== void 0 &&
        (r.stencilWriteMask = e.stencilWriteMask),
      e.stencilFunc !== void 0 && (r.stencilFunc = e.stencilFunc),
      e.stencilRef !== void 0 && (r.stencilRef = e.stencilRef),
      e.stencilFuncMask !== void 0 && (r.stencilFuncMask = e.stencilFuncMask),
      e.stencilFail !== void 0 && (r.stencilFail = e.stencilFail),
      e.stencilZFail !== void 0 && (r.stencilZFail = e.stencilZFail),
      e.stencilZPass !== void 0 && (r.stencilZPass = e.stencilZPass),
      e.wireframe !== void 0 && (r.wireframe = e.wireframe),
      e.wireframeLinewidth !== void 0 &&
        (r.wireframeLinewidth = e.wireframeLinewidth),
      e.wireframeLinecap !== void 0 &&
        (r.wireframeLinecap = e.wireframeLinecap),
      e.wireframeLinejoin !== void 0 &&
        (r.wireframeLinejoin = e.wireframeLinejoin),
      e.rotation !== void 0 && (r.rotation = e.rotation),
      e.linewidth !== 1 && (r.linewidth = e.linewidth),
      e.dashSize !== void 0 && (r.dashSize = e.dashSize),
      e.gapSize !== void 0 && (r.gapSize = e.gapSize),
      e.scale !== void 0 && (r.scale = e.scale),
      e.polygonOffset !== void 0 && (r.polygonOffset = e.polygonOffset),
      e.polygonOffsetFactor !== void 0 &&
        (r.polygonOffsetFactor = e.polygonOffsetFactor),
      e.polygonOffsetUnits !== void 0 &&
        (r.polygonOffsetUnits = e.polygonOffsetUnits),
      e.dithering !== void 0 && (r.dithering = e.dithering),
      e.alphaToCoverage !== void 0 && (r.alphaToCoverage = e.alphaToCoverage),
      e.premultipliedAlpha !== void 0 &&
        (r.premultipliedAlpha = e.premultipliedAlpha),
      e.forceSinglePass !== void 0 && (r.forceSinglePass = e.forceSinglePass),
      e.visible !== void 0 && (r.visible = e.visible),
      e.toneMapped !== void 0 && (r.toneMapped = e.toneMapped),
      e.userData !== void 0 && (r.userData = e.userData),
      e.vertexColors !== void 0 &&
        (typeof e.vertexColors == "number"
          ? (r.vertexColors = e.vertexColors > 0)
          : (r.vertexColors = e.vertexColors)),
      e.uniforms !== void 0)
    )
      for (const s in e.uniforms) {
        const o = e.uniforms[s];
        switch (((r.uniforms[s] = {}), o.type)) {
          case "t":
            r.uniforms[s].value = i(o.value);
            break;
          case "c":
            r.uniforms[s].value = new Ie().setHex(o.value);
            break;
          case "v2":
            r.uniforms[s].value = new ge().fromArray(o.value);
            break;
          case "v3":
            r.uniforms[s].value = new F().fromArray(o.value);
            break;
          case "v4":
            r.uniforms[s].value = new Ot().fromArray(o.value);
            break;
          case "m3":
            r.uniforms[s].value = new wt().fromArray(o.value);
            break;
          case "m4":
            r.uniforms[s].value = new st().fromArray(o.value);
            break;
          default:
            r.uniforms[s].value = o.value;
        }
      }
    if (
      (e.defines !== void 0 && (r.defines = e.defines),
      e.vertexShader !== void 0 && (r.vertexShader = e.vertexShader),
      e.fragmentShader !== void 0 && (r.fragmentShader = e.fragmentShader),
      e.glslVersion !== void 0 && (r.glslVersion = e.glslVersion),
      e.extensions !== void 0)
    )
      for (const s in e.extensions) r.extensions[s] = e.extensions[s];
    if (
      (e.size !== void 0 && (r.size = e.size),
      e.sizeAttenuation !== void 0 && (r.sizeAttenuation = e.sizeAttenuation),
      e.map !== void 0 && (r.map = i(e.map)),
      e.matcap !== void 0 && (r.matcap = i(e.matcap)),
      e.alphaMap !== void 0 && (r.alphaMap = i(e.alphaMap)),
      e.bumpMap !== void 0 && (r.bumpMap = i(e.bumpMap)),
      e.bumpScale !== void 0 && (r.bumpScale = e.bumpScale),
      e.normalMap !== void 0 && (r.normalMap = i(e.normalMap)),
      e.normalMapType !== void 0 && (r.normalMapType = e.normalMapType),
      e.normalScale !== void 0)
    ) {
      let s = e.normalScale;
      Array.isArray(s) === !1 && (s = [s, s]),
        (r.normalScale = new ge().fromArray(s));
    }
    return (
      e.displacementMap !== void 0 &&
        (r.displacementMap = i(e.displacementMap)),
      e.displacementScale !== void 0 &&
        (r.displacementScale = e.displacementScale),
      e.displacementBias !== void 0 &&
        (r.displacementBias = e.displacementBias),
      e.roughnessMap !== void 0 && (r.roughnessMap = i(e.roughnessMap)),
      e.metalnessMap !== void 0 && (r.metalnessMap = i(e.metalnessMap)),
      e.emissiveMap !== void 0 && (r.emissiveMap = i(e.emissiveMap)),
      e.emissiveIntensity !== void 0 &&
        (r.emissiveIntensity = e.emissiveIntensity),
      e.specularMap !== void 0 && (r.specularMap = i(e.specularMap)),
      e.specularIntensityMap !== void 0 &&
        (r.specularIntensityMap = i(e.specularIntensityMap)),
      e.specularColorMap !== void 0 &&
        (r.specularColorMap = i(e.specularColorMap)),
      e.envMap !== void 0 && (r.envMap = i(e.envMap)),
      e.envMapIntensity !== void 0 && (r.envMapIntensity = e.envMapIntensity),
      e.reflectivity !== void 0 && (r.reflectivity = e.reflectivity),
      e.refractionRatio !== void 0 && (r.refractionRatio = e.refractionRatio),
      e.lightMap !== void 0 && (r.lightMap = i(e.lightMap)),
      e.lightMapIntensity !== void 0 &&
        (r.lightMapIntensity = e.lightMapIntensity),
      e.aoMap !== void 0 && (r.aoMap = i(e.aoMap)),
      e.aoMapIntensity !== void 0 && (r.aoMapIntensity = e.aoMapIntensity),
      e.gradientMap !== void 0 && (r.gradientMap = i(e.gradientMap)),
      e.clearcoatMap !== void 0 && (r.clearcoatMap = i(e.clearcoatMap)),
      e.clearcoatRoughnessMap !== void 0 &&
        (r.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)),
      e.clearcoatNormalMap !== void 0 &&
        (r.clearcoatNormalMap = i(e.clearcoatNormalMap)),
      e.clearcoatNormalScale !== void 0 &&
        (r.clearcoatNormalScale = new ge().fromArray(e.clearcoatNormalScale)),
      e.iridescenceMap !== void 0 && (r.iridescenceMap = i(e.iridescenceMap)),
      e.iridescenceThicknessMap !== void 0 &&
        (r.iridescenceThicknessMap = i(e.iridescenceThicknessMap)),
      e.transmissionMap !== void 0 &&
        (r.transmissionMap = i(e.transmissionMap)),
      e.thicknessMap !== void 0 && (r.thicknessMap = i(e.thicknessMap)),
      e.sheenColorMap !== void 0 && (r.sheenColorMap = i(e.sheenColorMap)),
      e.sheenRoughnessMap !== void 0 &&
        (r.sheenRoughnessMap = i(e.sheenRoughnessMap)),
      r
    );
  }
  setTextures(e) {
    return (this.textures = e), this;
  }
  static createMaterialFromType(e) {
    const t = {
      ShadowMaterial: yR,
      SpriteMaterial: cA,
      RawShaderMaterial: vR,
      ShaderMaterial: hs,
      PointsMaterial: Eh,
      MeshPhysicalMaterial: $s,
      MeshStandardMaterial: oc,
      MeshPhongMaterial: xR,
      MeshToonMaterial: _R,
      MeshNormalMaterial: AR,
      MeshLambertMaterial: MR,
      MeshDepthMaterial: aA,
      MeshDistanceMaterial: lA,
      MeshBasicMaterial: Wi,
      MeshMatcapMaterial: SR,
      LineDashedMaterial: wR,
      LineBasicMaterial: oi,
      Material: Cn,
    };
    return new t[e]();
  }
}
class ls {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, r = e.length; i < r; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class IR extends ct {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class DR extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ki(s.manager);
    o.setPath(s.path),
      o.setRequestHeader(s.requestHeader),
      o.setWithCredentials(s.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            t(s.parse(JSON.parse(a)));
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
  parse(e) {
    const t = {},
      i = {};
    function r(m, v) {
      if (t[v] !== void 0) return t[v];
      const x = m.interleavedBuffers[v],
        g = s(m, x.buffer),
        _ = mu(x.type, g),
        S = new wh(_, x.stride);
      return (S.uuid = x.uuid), (t[v] = S), S;
    }
    function s(m, v) {
      if (i[v] !== void 0) return i[v];
      const x = m.arrayBuffers[v],
        g = new Uint32Array(x).buffer;
      return (i[v] = g), g;
    }
    const o = e.isInstancedBufferGeometry ? new IR() : new ct(),
      a = e.data.index;
    if (a !== void 0) {
      const m = mu(a.type, a.array);
      o.setIndex(new Dt(m, 1));
    }
    const l = e.data.attributes;
    for (const m in l) {
      const v = l[m];
      let A;
      if (v.isInterleavedBufferAttribute) {
        const x = r(e.data, v.data);
        A = new Xo(x, v.itemSize, v.offset, v.normalized);
      } else {
        const x = mu(v.type, v.array),
          g = v.isInstancedBufferAttribute ? Ju : Dt;
        A = new g(x, v.itemSize, v.normalized);
      }
      v.name !== void 0 && (A.name = v.name),
        v.usage !== void 0 && A.setUsage(v.usage),
        v.updateRange !== void 0 &&
          ((A.updateRange.offset = v.updateRange.offset),
          (A.updateRange.count = v.updateRange.count)),
        o.setAttribute(m, A);
    }
    const c = e.data.morphAttributes;
    if (c)
      for (const m in c) {
        const v = c[m],
          A = [];
        for (let x = 0, g = v.length; x < g; x++) {
          const _ = v[x];
          let S;
          if (_.isInterleavedBufferAttribute) {
            const w = r(e.data, _.data);
            S = new Xo(w, _.itemSize, _.offset, _.normalized);
          } else {
            const w = mu(_.type, _.array);
            S = new Dt(w, _.itemSize, _.normalized);
          }
          _.name !== void 0 && (S.name = _.name), A.push(S);
        }
        o.morphAttributes[m] = A;
      }
    e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
    const d = e.data.groups || e.data.drawcalls || e.data.offsets;
    if (d !== void 0)
      for (let m = 0, v = d.length; m !== v; ++m) {
        const A = d[m];
        o.addGroup(A.start, A.count, A.materialIndex);
      }
    const p = e.data.boundingSphere;
    if (p !== void 0) {
      const m = new F();
      p.center !== void 0 && m.fromArray(p.center),
        (o.boundingSphere = new Vr(m, p.radius));
    }
    return (
      e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    );
  }
}
class TH extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = this.path === "" ? ls.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || o;
    const a = new Ki(this.manager);
    a.setPath(this.path),
      a.setRequestHeader(this.requestHeader),
      a.setWithCredentials(this.withCredentials),
      a.load(
        e,
        function (l) {
          let c = null;
          try {
            c = JSON.parse(l);
          } catch (d) {
            r !== void 0 && r(d),
              console.error(
                "THREE:ObjectLoader: Can't parse " + e + ".",
                d.message
              );
            return;
          }
          const h = c.metadata;
          if (
            h === void 0 ||
            h.type === void 0 ||
            h.type.toLowerCase() === "geometry"
          ) {
            r !== void 0 && r(new Error("THREE.ObjectLoader: Can't load " + e)),
              console.error("THREE.ObjectLoader: Can't load " + e);
            return;
          }
          s.parse(c, t);
        },
        i,
        r
      );
  }
  async loadAsync(e, t) {
    const i = this,
      r = this.path === "" ? ls.extractUrlBase(e) : this.path;
    this.resourcePath = this.resourcePath || r;
    const s = new Ki(this.manager);
    s.setPath(this.path),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials);
    const o = await s.loadAsync(e, t),
      a = JSON.parse(o),
      l = a.metadata;
    if (
      l === void 0 ||
      l.type === void 0 ||
      l.type.toLowerCase() === "geometry"
    )
      throw new Error("THREE.ObjectLoader: Can't load " + e);
    return await i.parseAsync(a);
  }
  parse(e, t) {
    const i = this.parseAnimations(e.animations),
      r = this.parseShapes(e.shapes),
      s = this.parseGeometries(e.geometries, r),
      o = this.parseImages(e.images, function () {
        t !== void 0 && t(c);
      }),
      a = this.parseTextures(e.textures, o),
      l = this.parseMaterials(e.materials, a),
      c = this.parseObject(e.object, s, l, a, i),
      h = this.parseSkeletons(e.skeletons, c);
    if ((this.bindSkeletons(c, h), t !== void 0)) {
      let d = !1;
      for (const p in o)
        if (o[p].data instanceof HTMLImageElement) {
          d = !0;
          break;
        }
      d === !1 && t(c);
    }
    return c;
  }
  async parseAsync(e) {
    const t = this.parseAnimations(e.animations),
      i = this.parseShapes(e.shapes),
      r = this.parseGeometries(e.geometries, i),
      s = await this.parseImagesAsync(e.images),
      o = this.parseTextures(e.textures, s),
      a = this.parseMaterials(e.materials, o),
      l = this.parseObject(e.object, r, a, o, t),
      c = this.parseSkeletons(e.skeletons, l);
    return this.bindSkeletons(l, c), l;
  }
  parseShapes(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0, r = e.length; i < r; i++) {
        const s = new qa().fromJSON(e[i]);
        t[s.uuid] = s;
      }
    return t;
  }
  parseSkeletons(e, t) {
    const i = {},
      r = {};
    if (
      (t.traverse(function (s) {
        s.isBone && (r[s.uuid] = s);
      }),
      e !== void 0)
    )
      for (let s = 0, o = e.length; s < o; s++) {
        const a = new Ch().fromJSON(e[s], r);
        i[a.uuid] = a;
      }
    return i;
  }
  parseGeometries(e, t) {
    const i = {};
    if (e !== void 0) {
      const r = new DR();
      for (let s = 0, o = e.length; s < o; s++) {
        let a;
        const l = e[s];
        switch (l.type) {
          case "BufferGeometry":
          case "InstancedBufferGeometry":
            a = r.parse(l);
            break;
          default:
            l.type in pE
              ? (a = pE[l.type].fromJSON(l, t))
              : console.warn(
                  `THREE.ObjectLoader: Unsupported geometry type "${l.type}"`
                );
        }
        (a.uuid = l.uuid),
          l.name !== void 0 && (a.name = l.name),
          l.userData !== void 0 && (a.userData = l.userData),
          (i[l.uuid] = a);
      }
    }
    return i;
  }
  parseMaterials(e, t) {
    const i = {},
      r = {};
    if (e !== void 0) {
      const s = new Wg();
      s.setTextures(t);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o];
        i[l.uuid] === void 0 && (i[l.uuid] = s.parse(l)),
          (r[l.uuid] = i[l.uuid]);
      }
    }
    return r;
  }
  parseAnimations(e) {
    const t = {};
    if (e !== void 0)
      for (let i = 0; i < e.length; i++) {
        const r = e[i],
          s = Ku.parse(r);
        t[s.uuid] = s;
      }
    return t;
  }
  parseImages(e, t) {
    const i = this,
      r = {};
    let s;
    function o(l) {
      return (
        i.manager.itemStart(l),
        s.load(
          l,
          function () {
            i.manager.itemEnd(l);
          },
          void 0,
          function () {
            i.manager.itemError(l), i.manager.itemEnd(l);
          }
        )
      );
    }
    function a(l) {
      if (typeof l == "string") {
        const c = l,
          h = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : i.resourcePath + c;
        return o(h);
      } else
        return l.data
          ? { data: mu(l.type, l.data), width: l.width, height: l.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      const l = new CA(t);
      (s = new sh(l)), s.setCrossOrigin(this.crossOrigin);
      for (let c = 0, h = e.length; c < h; c++) {
        const d = e[c],
          p = d.url;
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, A = p.length; v < A; v++) {
            const x = p[v],
              g = a(x);
            g !== null &&
              (g instanceof HTMLImageElement
                ? m.push(g)
                : m.push(new Bu(g.data, g.width, g.height)));
          }
          r[d.uuid] = new Ha(m);
        } else {
          const m = a(d.url);
          r[d.uuid] = new Ha(m);
        }
      }
    }
    return r;
  }
  async parseImagesAsync(e) {
    const t = this,
      i = {};
    let r;
    async function s(o) {
      if (typeof o == "string") {
        const a = o,
          l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
        return await r.loadAsync(l);
      } else
        return o.data
          ? { data: mu(o.type, o.data), width: o.width, height: o.height }
          : null;
    }
    if (e !== void 0 && e.length > 0) {
      (r = new sh(this.manager)), r.setCrossOrigin(this.crossOrigin);
      for (let o = 0, a = e.length; o < a; o++) {
        const l = e[o],
          c = l.url;
        if (Array.isArray(c)) {
          const h = [];
          for (let d = 0, p = c.length; d < p; d++) {
            const m = c[d],
              v = await s(m);
            v !== null &&
              (v instanceof HTMLImageElement
                ? h.push(v)
                : h.push(new Bu(v.data, v.width, v.height)));
          }
          i[l.uuid] = new Ha(h);
        } else {
          const h = await s(l.url);
          i[l.uuid] = new Ha(h);
        }
      }
    }
    return i;
  }
  parseTextures(e, t) {
    function i(s, o) {
      return typeof s == "number"
        ? s
        : (console.warn(
            "THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",
            s
          ),
          o[s]);
    }
    const r = {};
    if (e !== void 0)
      for (let s = 0, o = e.length; s < o; s++) {
        const a = e[s];
        a.image === void 0 &&
          console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid),
          t[a.image] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined image", a.image);
        const l = t[a.image],
          c = l.data;
        let h;
        Array.isArray(c)
          ? ((h = new Sh()), c.length === 6 && (h.needsUpdate = !0))
          : (c && c.data ? (h = new Bu()) : (h = new en()),
            c && (h.needsUpdate = !0)),
          (h.source = l),
          (h.uuid = a.uuid),
          a.name !== void 0 && (h.name = a.name),
          a.mapping !== void 0 && (h.mapping = i(a.mapping, bH)),
          a.channel !== void 0 && (h.channel = a.channel),
          a.offset !== void 0 && h.offset.fromArray(a.offset),
          a.repeat !== void 0 && h.repeat.fromArray(a.repeat),
          a.center !== void 0 && h.center.fromArray(a.center),
          a.rotation !== void 0 && (h.rotation = a.rotation),
          a.wrap !== void 0 &&
            ((h.wrapS = i(a.wrap[0], vE)), (h.wrapT = i(a.wrap[1], vE))),
          a.format !== void 0 && (h.format = a.format),
          a.internalFormat !== void 0 && (h.internalFormat = a.internalFormat),
          a.type !== void 0 && (h.type = a.type),
          a.encoding !== void 0 && (h.encoding = a.encoding),
          a.minFilter !== void 0 && (h.minFilter = i(a.minFilter, xE)),
          a.magFilter !== void 0 && (h.magFilter = i(a.magFilter, xE)),
          a.anisotropy !== void 0 && (h.anisotropy = a.anisotropy),
          a.flipY !== void 0 && (h.flipY = a.flipY),
          a.generateMipmaps !== void 0 &&
            (h.generateMipmaps = a.generateMipmaps),
          a.premultiplyAlpha !== void 0 &&
            (h.premultiplyAlpha = a.premultiplyAlpha),
          a.unpackAlignment !== void 0 &&
            (h.unpackAlignment = a.unpackAlignment),
          a.userData !== void 0 && (h.userData = a.userData),
          (r[a.uuid] = h);
      }
    return r;
  }
  parseObject(e, t, i, r, s) {
    let o;
    function a(p) {
      return (
        t[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined geometry", p),
        t[p]
      );
    }
    function l(p) {
      if (p !== void 0) {
        if (Array.isArray(p)) {
          const m = [];
          for (let v = 0, A = p.length; v < A; v++) {
            const x = p[v];
            i[x] === void 0 &&
              console.warn("THREE.ObjectLoader: Undefined material", x),
              m.push(i[x]);
          }
          return m;
        }
        return (
          i[p] === void 0 &&
            console.warn("THREE.ObjectLoader: Undefined material", p),
          i[p]
        );
      }
    }
    function c(p) {
      return (
        r[p] === void 0 &&
          console.warn("THREE.ObjectLoader: Undefined texture", p),
        r[p]
      );
    }
    let h, d;
    switch (e.type) {
      case "Scene":
        (o = new Ym()),
          e.background !== void 0 &&
            (Number.isInteger(e.background)
              ? (o.background = new Ie(e.background))
              : (o.background = c(e.background))),
          e.environment !== void 0 && (o.environment = c(e.environment)),
          e.fog !== void 0 &&
            (e.fog.type === "Fog"
              ? (o.fog = new kg(e.fog.color, e.fog.near, e.fog.far))
              : e.fog.type === "FogExp2" &&
                (o.fog = new Og(e.fog.color, e.fog.density))),
          e.backgroundBlurriness !== void 0 &&
            (o.backgroundBlurriness = e.backgroundBlurriness),
          e.backgroundIntensity !== void 0 &&
            (o.backgroundIntensity = e.backgroundIntensity);
        break;
      case "PerspectiveCamera":
        (o = new Vt(e.fov, e.aspect, e.near, e.far)),
          e.focus !== void 0 && (o.focus = e.focus),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge),
          e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "OrthographicCamera":
        (o = new kr(e.left, e.right, e.top, e.bottom, e.near, e.far)),
          e.zoom !== void 0 && (o.zoom = e.zoom),
          e.view !== void 0 && (o.view = Object.assign({}, e.view));
        break;
      case "AmbientLight":
        o = new BR(e.color, e.intensity);
        break;
      case "DirectionalLight":
        o = new PA(e.color, e.intensity);
        break;
      case "PointLight":
        o = new bA(e.color, e.intensity, e.distance, e.decay);
        break;
      case "RectAreaLight":
        o = new RR(e.color, e.intensity, e.width, e.height);
        break;
      case "SpotLight":
        o = new TA(
          e.color,
          e.intensity,
          e.distance,
          e.angle,
          e.penumbra,
          e.decay
        );
        break;
      case "HemisphereLight":
        o = new PR(e.color, e.groundColor, e.intensity);
        break;
      case "LightProbe":
        o = new Vg().fromJSON(e);
        break;
      case "SkinnedMesh":
        (h = a(e.geometry)),
          (d = l(e.material)),
          (o = new fA(h, d)),
          e.bindMode !== void 0 && (o.bindMode = e.bindMode),
          e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix),
          e.skeleton !== void 0 && (o.skeleton = e.skeleton);
        break;
      case "Mesh":
        (h = a(e.geometry)), (d = l(e.material)), (o = new Pn(h, d));
        break;
      case "InstancedMesh":
        (h = a(e.geometry)), (d = l(e.material));
        const p = e.count,
          m = e.instanceMatrix,
          v = e.instanceColor;
        (o = new oR(h, d, p)),
          (o.instanceMatrix = new Ju(new Float32Array(m.array), 16)),
          v !== void 0 &&
            (o.instanceColor = new Ju(new Float32Array(v.array), v.itemSize));
        break;
      case "LOD":
        o = new sR();
        break;
      case "Line":
        o = new Ys(a(e.geometry), l(e.material));
        break;
      case "LineLoop":
        o = new hA(a(e.geometry), l(e.material));
        break;
      case "LineSegments":
        o = new Wr(a(e.geometry), l(e.material));
        break;
      case "PointCloud":
      case "Points":
        o = new dA(a(e.geometry), l(e.material));
        break;
      case "Sprite":
        o = new rR(l(e.material));
        break;
      case "Group":
        o = new Os();
        break;
      case "Bone":
        o = new Ug();
        break;
      default:
        o = new Pt();
    }
    if (
      ((o.uuid = e.uuid),
      e.name !== void 0 && (o.name = e.name),
      e.matrix !== void 0
        ? (o.matrix.fromArray(e.matrix),
          e.matrixAutoUpdate !== void 0 &&
            (o.matrixAutoUpdate = e.matrixAutoUpdate),
          o.matrixAutoUpdate &&
            o.matrix.decompose(o.position, o.quaternion, o.scale))
        : (e.position !== void 0 && o.position.fromArray(e.position),
          e.rotation !== void 0 && o.rotation.fromArray(e.rotation),
          e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion),
          e.scale !== void 0 && o.scale.fromArray(e.scale)),
      e.up !== void 0 && o.up.fromArray(e.up),
      e.castShadow !== void 0 && (o.castShadow = e.castShadow),
      e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow),
      e.shadow &&
        (e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias),
        e.shadow.normalBias !== void 0 &&
          (o.shadow.normalBias = e.shadow.normalBias),
        e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius),
        e.shadow.mapSize !== void 0 &&
          o.shadow.mapSize.fromArray(e.shadow.mapSize),
        e.shadow.camera !== void 0 &&
          (o.shadow.camera = this.parseObject(e.shadow.camera))),
      e.visible !== void 0 && (o.visible = e.visible),
      e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled),
      e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder),
      e.userData !== void 0 && (o.userData = e.userData),
      e.layers !== void 0 && (o.layers.mask = e.layers),
      e.children !== void 0)
    ) {
      const p = e.children;
      for (let m = 0; m < p.length; m++)
        o.add(this.parseObject(p[m], t, i, r, s));
    }
    if (e.animations !== void 0) {
      const p = e.animations;
      for (let m = 0; m < p.length; m++) {
        const v = p[m];
        o.animations.push(s[v]);
      }
    }
    if (e.type === "LOD") {
      e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
      const p = e.levels;
      for (let m = 0; m < p.length; m++) {
        const v = p[m],
          A = o.getObjectByProperty("uuid", v.object);
        A !== void 0 && o.addLevel(A, v.distance, v.hysteresis);
      }
    }
    return o;
  }
  bindSkeletons(e, t) {
    Object.keys(t).length !== 0 &&
      e.traverse(function (i) {
        if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
          const r = t[i.skeleton];
          r === void 0
            ? console.warn(
                "THREE.ObjectLoader: No skeleton found with UUID:",
                i.skeleton
              )
            : i.bind(r, i.bindMatrix);
        }
      });
  }
}
const bH = {
    UVMapping: Rg,
    CubeReflectionMapping: Wo,
    CubeRefractionMapping: Jo,
    EquirectangularReflectionMapping: Yf,
    EquirectangularRefractionMapping: Qf,
    CubeUVReflectionMapping: ec,
  },
  vE = {
    RepeatWrapping: jo,
    ClampToEdgeWrapping: Wn,
    MirroredRepeatWrapping: Uu,
  },
  xE = {
    NearestFilter: dn,
    NearestMipmapNearestFilter: Zf,
    NearestMipmapLinearFilter: bu,
    LinearFilter: rn,
    LinearMipmapNearestFilter: Lg,
    LinearMipmapLinearFilter: fs,
  };
class FR extends vi {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, r) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      o = al.get(e);
    if (o !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(o), s.manager.itemEnd(e);
        }, 0),
        o
      );
    const a = {};
    (a.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          al.add(e, l), t && t(l), s.manager.itemEnd(e);
        })
        .catch(function (l) {
          r && r(l), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
let Up;
class BA {
  static getContext() {
    return (
      Up === void 0 &&
        (Up = new (window.AudioContext || window.webkitAudioContext)()),
      Up
    );
  }
  static setContext(e) {
    Up = e;
  }
}
class PH extends vi {
  constructor(e) {
    super(e);
  }
  load(e, t, i, r) {
    const s = this,
      o = new Ki(this.manager);
    o.setResponseType("arraybuffer"),
      o.setPath(this.path),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (a) {
          try {
            const l = a.slice(0);
            BA.getContext().decodeAudioData(l, function (h) {
              t(h);
            });
          } catch (l) {
            r ? r(l) : console.error(l), s.manager.itemError(e);
          }
        },
        i,
        r
      );
  }
}
class BH extends Vg {
  constructor(e, t, i = 1) {
    super(void 0, i), (this.isHemisphereLightProbe = !0);
    const r = new Ie().set(e),
      s = new Ie().set(t),
      o = new F(r.r, r.g, r.b),
      a = new F(s.r, s.g, s.b),
      l = Math.sqrt(Math.PI),
      c = l * Math.sqrt(0.75);
    this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),
      this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c);
  }
}
class RH extends Vg {
  constructor(e, t = 1) {
    super(void 0, t), (this.isAmbientLightProbe = !0);
    const i = new Ie().set(e);
    this.sh.coefficients[0]
      .set(i.r, i.g, i.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI));
  }
}
const _E = new st(),
  AE = new st(),
  va = new st();
class LH {
  constructor() {
    (this.type = "StereoCamera"),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new Vt()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new Vt()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1),
      (this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null,
      });
  }
  update(e) {
    const t = this._cache;
    if (
      t.focus !== e.focus ||
      t.fov !== e.fov ||
      t.aspect !== e.aspect * this.aspect ||
      t.near !== e.near ||
      t.far !== e.far ||
      t.zoom !== e.zoom ||
      t.eyeSep !== this.eyeSep
    ) {
      (t.focus = e.focus),
        (t.fov = e.fov),
        (t.aspect = e.aspect * this.aspect),
        (t.near = e.near),
        (t.far = e.far),
        (t.zoom = e.zoom),
        (t.eyeSep = this.eyeSep),
        va.copy(e.projectionMatrix);
      const r = t.eyeSep / 2,
        s = (r * t.near) / t.focus,
        o = (t.near * Math.tan(Qa * t.fov * 0.5)) / t.zoom;
      let a, l;
      (AE.elements[12] = -r),
        (_E.elements[12] = r),
        (a = -o * t.aspect + s),
        (l = o * t.aspect + s),
        (va.elements[0] = (2 * t.near) / (l - a)),
        (va.elements[8] = (l + a) / (l - a)),
        this.cameraL.projectionMatrix.copy(va),
        (a = -o * t.aspect - s),
        (l = o * t.aspect - s),
        (va.elements[0] = (2 * t.near) / (l - a)),
        (va.elements[8] = (l + a) / (l - a)),
        this.cameraR.projectionMatrix.copy(va);
    }
    this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(AE),
      this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(_E);
  }
}
class RA {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = ME()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = ME();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function ME() {
  return (typeof performance > "u" ? Date : performance).now();
}
const xa = new F(),
  SE = new jn(),
  IH = new F(),
  _a = new F();
class DH extends Pt {
  constructor() {
    super(),
      (this.type = "AudioListener"),
      (this.context = BA.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null),
      (this.timeDelta = 0),
      (this._clock = new RA());
  }
  getInput() {
    return this.gain;
  }
  removeFilter() {
    return (
      this.filter !== null &&
        (this.gain.disconnect(this.filter),
        this.filter.disconnect(this.context.destination),
        this.gain.connect(this.context.destination),
        (this.filter = null)),
      this
    );
  }
  getFilter() {
    return this.filter;
  }
  setFilter(e) {
    return (
      this.filter !== null
        ? (this.gain.disconnect(this.filter),
          this.filter.disconnect(this.context.destination))
        : this.gain.disconnect(this.context.destination),
      (this.filter = e),
      this.gain.connect(this.filter),
      this.filter.connect(this.context.destination),
      this
    );
  }
  getMasterVolume() {
    return this.gain.gain.value;
  }
  setMasterVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e);
    const t = this.context.listener,
      i = this.up;
    if (
      ((this.timeDelta = this._clock.getDelta()),
      this.matrixWorld.decompose(xa, SE, IH),
      _a.set(0, 0, -1).applyQuaternion(SE),
      t.positionX)
    ) {
      const r = this.context.currentTime + this.timeDelta;
      t.positionX.linearRampToValueAtTime(xa.x, r),
        t.positionY.linearRampToValueAtTime(xa.y, r),
        t.positionZ.linearRampToValueAtTime(xa.z, r),
        t.forwardX.linearRampToValueAtTime(_a.x, r),
        t.forwardY.linearRampToValueAtTime(_a.y, r),
        t.forwardZ.linearRampToValueAtTime(_a.z, r),
        t.upX.linearRampToValueAtTime(i.x, r),
        t.upY.linearRampToValueAtTime(i.y, r),
        t.upZ.linearRampToValueAtTime(i.z, r);
    } else
      t.setPosition(xa.x, xa.y, xa.z),
        t.setOrientation(_a.x, _a.y, _a.z, i.x, i.y, i.z);
  }
}
class NR extends Pt {
  constructor(e) {
    super(),
      (this.type = "Audio"),
      (this.listener = e),
      (this.context = e.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(e.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.detune = 0),
      (this.loop = !1),
      (this.loopStart = 0),
      (this.loopEnd = 0),
      (this.offset = 0),
      (this.duration = void 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.source = null),
      (this.sourceType = "empty"),
      (this._startedAt = 0),
      (this._progress = 0),
      (this._connected = !1),
      (this.filters = []);
  }
  getOutput() {
    return this.gain;
  }
  setNodeSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "audioNode"),
      (this.source = e),
      this.connect(),
      this
    );
  }
  setMediaElementSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaNode"),
      (this.source = this.context.createMediaElementSource(e)),
      this.connect(),
      this
    );
  }
  setMediaStreamSource(e) {
    return (
      (this.hasPlaybackControl = !1),
      (this.sourceType = "mediaStreamNode"),
      (this.source = this.context.createMediaStreamSource(e)),
      this.connect(),
      this
    );
  }
  setBuffer(e) {
    return (
      (this.buffer = e),
      (this.sourceType = "buffer"),
      this.autoplay && this.play(),
      this
    );
  }
  play(e = 0) {
    if (this.isPlaying === !0) {
      console.warn("THREE.Audio: Audio is already playing.");
      return;
    }
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    this._startedAt = this.context.currentTime + e;
    const t = this.context.createBufferSource();
    return (
      (t.buffer = this.buffer),
      (t.loop = this.loop),
      (t.loopStart = this.loopStart),
      (t.loopEnd = this.loopEnd),
      (t.onended = this.onEnded.bind(this)),
      t.start(this._startedAt, this._progress + this.offset, this.duration),
      (this.isPlaying = !0),
      (this.source = t),
      this.setDetune(this.detune),
      this.setPlaybackRate(this.playbackRate),
      this.connect()
    );
  }
  pause() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      this.isPlaying === !0 &&
        ((this._progress +=
          Math.max(this.context.currentTime - this._startedAt, 0) *
          this.playbackRate),
        this.loop === !0 &&
          (this._progress =
            this._progress % (this.duration || this.buffer.duration)),
        this.source.stop(),
        (this.source.onended = null),
        (this.isPlaying = !1)),
      this
    );
  }
  stop() {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this._progress = 0),
      this.source !== null &&
        (this.source.stop(), (this.source.onended = null)),
      (this.isPlaying = !1),
      this
    );
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].connect(this.filters[e]);
      this.filters[this.filters.length - 1].connect(this.getOutput());
    } else this.source.connect(this.getOutput());
    return (this._connected = !0), this;
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0]);
      for (let e = 1, t = this.filters.length; e < t; e++)
        this.filters[e - 1].disconnect(this.filters[e]);
      this.filters[this.filters.length - 1].disconnect(this.getOutput());
    } else this.source.disconnect(this.getOutput());
    return (this._connected = !1), this;
  }
  getFilters() {
    return this.filters;
  }
  setFilters(e) {
    return (
      e || (e = []),
      this._connected === !0
        ? (this.disconnect(), (this.filters = e.slice()), this.connect())
        : (this.filters = e.slice()),
      this
    );
  }
  setDetune(e) {
    if (((this.detune = e), this.source.detune !== void 0))
      return (
        this.isPlaying === !0 &&
          this.source.detune.setTargetAtTime(
            this.detune,
            this.context.currentTime,
            0.01
          ),
        this
      );
  }
  getDetune() {
    return this.detune;
  }
  getFilter() {
    return this.getFilters()[0];
  }
  setFilter(e) {
    return this.setFilters(e ? [e] : []);
  }
  setPlaybackRate(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.playbackRate = e),
      this.isPlaying === !0 &&
        this.source.playbackRate.setTargetAtTime(
          this.playbackRate,
          this.context.currentTime,
          0.01
        ),
      this
    );
  }
  getPlaybackRate() {
    return this.playbackRate;
  }
  onEnded() {
    this.isPlaying = !1;
  }
  getLoop() {
    return this.hasPlaybackControl === !1
      ? (console.warn("THREE.Audio: this Audio has no playback control."), !1)
      : this.loop;
  }
  setLoop(e) {
    if (this.hasPlaybackControl === !1) {
      console.warn("THREE.Audio: this Audio has no playback control.");
      return;
    }
    return (
      (this.loop = e),
      this.isPlaying === !0 && (this.source.loop = this.loop),
      this
    );
  }
  setLoopStart(e) {
    return (this.loopStart = e), this;
  }
  setLoopEnd(e) {
    return (this.loopEnd = e), this;
  }
  getVolume() {
    return this.gain.gain.value;
  }
  setVolume(e) {
    return (
      this.gain.gain.setTargetAtTime(e, this.context.currentTime, 0.01), this
    );
  }
}
const Aa = new F(),
  wE = new jn(),
  FH = new F(),
  Ma = new F();
class NH extends NR {
  constructor(e) {
    super(e),
      (this.panner = this.context.createPanner()),
      (this.panner.panningModel = "HRTF"),
      this.panner.connect(this.gain);
  }
  disconnect() {
    super.disconnect(), this.panner.disconnect(this.gain);
  }
  getOutput() {
    return this.panner;
  }
  getRefDistance() {
    return this.panner.refDistance;
  }
  setRefDistance(e) {
    return (this.panner.refDistance = e), this;
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor;
  }
  setRolloffFactor(e) {
    return (this.panner.rolloffFactor = e), this;
  }
  getDistanceModel() {
    return this.panner.distanceModel;
  }
  setDistanceModel(e) {
    return (this.panner.distanceModel = e), this;
  }
  getMaxDistance() {
    return this.panner.maxDistance;
  }
  setMaxDistance(e) {
    return (this.panner.maxDistance = e), this;
  }
  setDirectionalCone(e, t, i) {
    return (
      (this.panner.coneInnerAngle = e),
      (this.panner.coneOuterAngle = t),
      (this.panner.coneOuterGain = i),
      this
    );
  }
  updateMatrixWorld(e) {
    if (
      (super.updateMatrixWorld(e),
      this.hasPlaybackControl === !0 && this.isPlaying === !1)
    )
      return;
    this.matrixWorld.decompose(Aa, wE, FH), Ma.set(0, 0, 1).applyQuaternion(wE);
    const t = this.panner;
    if (t.positionX) {
      const i = this.context.currentTime + this.listener.timeDelta;
      t.positionX.linearRampToValueAtTime(Aa.x, i),
        t.positionY.linearRampToValueAtTime(Aa.y, i),
        t.positionZ.linearRampToValueAtTime(Aa.z, i),
        t.orientationX.linearRampToValueAtTime(Ma.x, i),
        t.orientationY.linearRampToValueAtTime(Ma.y, i),
        t.orientationZ.linearRampToValueAtTime(Ma.z, i);
    } else t.setPosition(Aa.x, Aa.y, Aa.z), t.setOrientation(Ma.x, Ma.y, Ma.z);
  }
}
class OH {
  constructor(e, t = 2048) {
    (this.analyser = e.context.createAnalyser()),
      (this.analyser.fftSize = t),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      e.getOutput().connect(this.analyser);
  }
  getFrequencyData() {
    return this.analyser.getByteFrequencyData(this.data), this.data;
  }
  getAverageFrequency() {
    let e = 0;
    const t = this.getFrequencyData();
    for (let i = 0; i < t.length; i++) e += t[i];
    return e / t.length;
  }
}
class OR {
  constructor(e, t, i) {
    (this.binding = e), (this.valueSize = i);
    let r, s, o;
    switch (t) {
      case "quaternion":
        (r = this._slerp),
          (s = this._slerpAdditive),
          (o = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(i * 6)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (r = this._select),
          (s = this._select),
          (o = this._setAdditiveIdentityOther),
          (this.buffer = new Array(i * 5));
        break;
      default:
        (r = this._lerp),
          (s = this._lerpAdditive),
          (o = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(i * 5));
    }
    (this._mixBufferRegion = r),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = o),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const i = this.buffer,
      r = this.valueSize,
      s = e * r + r;
    let o = this.cumulativeWeight;
    if (o === 0) {
      for (let a = 0; a !== r; ++a) i[s + a] = i[a];
      o = t;
    } else {
      o += t;
      const a = t / o;
      this._mixBufferRegion(i, s, 0, a, r);
    }
    this.cumulativeWeight = o;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      r = i * this._addIndex;
    this.cumulativeWeightAdditive === 0 && this._setIdentity(),
      this._mixBufferRegionAdditive(t, r, 0, e, i),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      r = e * t + t,
      s = this.cumulativeWeight,
      o = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const l = t * this._origIndex;
      this._mixBufferRegion(i, r, l, 1 - s, t);
    }
    o > 0 && this._mixBufferRegionAdditive(i, r, this._addIndex * t, 1, t);
    for (let l = t, c = t + t; l !== c; ++l)
      if (i[l] !== i[l + t]) {
        a.setValue(i, r);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      r = i * this._origIndex;
    e.getValue(t, r);
    for (let s = i, o = r; s !== o; ++s) t[s] = t[r + (s % i)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = this.valueSize * 3;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, r, s) {
    if (r >= 0.5) for (let o = 0; o !== s; ++o) e[t + o] = e[i + o];
  }
  _slerp(e, t, i, r) {
    jn.slerpFlat(e, t, e, t, e, i, r);
  }
  _slerpAdditive(e, t, i, r, s) {
    const o = this._workIndex * s;
    jn.multiplyQuaternionsFlat(e, o, e, t, e, i),
      jn.slerpFlat(e, t, e, t, e, o, r);
  }
  _lerp(e, t, i, r, s) {
    const o = 1 - r;
    for (let a = 0; a !== s; ++a) {
      const l = t + a;
      e[l] = e[l] * o + e[i + a] * r;
    }
  }
  _lerpAdditive(e, t, i, r, s) {
    for (let o = 0; o !== s; ++o) {
      const a = t + o;
      e[a] = e[a] + e[i + o] * r;
    }
  }
}
const LA = "\\[\\]\\.:\\/",
  kH = new RegExp("[" + LA + "]", "g"),
  IA = "[^" + LA + "]",
  UH = "[^" + LA.replace("\\.", "") + "]",
  zH = /((?:WC+[\/:])*)/.source.replace("WC", IA),
  GH = /(WCOD+)?/.source.replace("WCOD", UH),
  HH = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", IA),
  VH = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", IA),
  WH = new RegExp("^" + zH + GH + HH + VH + "$"),
  JH = ["material", "materials", "bones", "map"];
class jH {
  constructor(e, t, i) {
    const r = i || bt.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, r));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      r = this._bindings[i];
    r !== void 0 && r.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let r = this._targetGroup.nCachedObjects_, s = i.length; r !== s; ++r)
      i[r].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}
class bt {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || bt.parseTrackName(t)),
      (this.node = bt.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new bt.Composite(e, t, i)
      : new bt(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(kH, "");
  }
  static parseTrackName(e) {
    const t = WH.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      r = i.nodeName && i.nodeName.lastIndexOf(".");
    if (r !== void 0 && r !== -1) {
      const s = i.nodeName.substring(r + 1);
      JH.indexOf(s) !== -1 &&
        ((i.nodeName = i.nodeName.substring(0, r)), (i.objectName = s));
    }
    if (i.propertyName === null || i.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (i !== void 0) return i;
    }
    if (e.children) {
      const i = function (s) {
          for (let o = 0; o < s.length; o++) {
            const a = s[o];
            if (a.name === t || a.uuid === t) return a;
            const l = i(a.children);
            if (l) return l;
          }
          return null;
        },
        r = i(e.children);
      if (r) return r;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) e[t++] = i[r];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let r = 0, s = i.length; r !== s; ++r) i[r] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      r = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = bt.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (i) {
      let c = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let h = 0; h < e.length; h++)
            if (e[h].name === c) {
              c = h;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[i] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[i];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const o = e[r];
    if (o === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          r +
          " but it wasn't found.",
        e
      );
      return;
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (a = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (r === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = o),
        (this.propertyIndex = s);
    } else
      o.fromArray !== void 0 && o.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = o))
        : Array.isArray(o)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = o))
        : (this.propertyName = r);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
bt.Composite = jH;
bt.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
bt.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
bt.prototype.GetterByBindingType = [
  bt.prototype._getValue_direct,
  bt.prototype._getValue_array,
  bt.prototype._getValue_arrayElement,
  bt.prototype._getValue_toArray,
];
bt.prototype.SetterByBindingTypeAndVersioning = [
  [
    bt.prototype._setValue_direct,
    bt.prototype._setValue_direct_setNeedsUpdate,
    bt.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    bt.prototype._setValue_array,
    bt.prototype._setValue_array_setNeedsUpdate,
    bt.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    bt.prototype._setValue_arrayElement,
    bt.prototype._setValue_arrayElement_setNeedsUpdate,
    bt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    bt.prototype._setValue_fromArray,
    bt.prototype._setValue_fromArray_setNeedsUpdate,
    bt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class XH {
  constructor() {
    (this.isAnimationObjectGroup = !0),
      (this.uuid = ji()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    const e = {};
    this._indicesByUUID = e;
    for (let i = 0, r = arguments.length; i !== r; ++i)
      e[arguments[i].uuid] = i;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    const t = this;
    this.stats = {
      objects: {
        get total() {
          return t._objects.length;
        },
        get inUse() {
          return this.total - t.nCachedObjects_;
        },
      },
      get bindingsPerObject() {
        return t._bindings.length;
      },
    };
  }
  add() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._paths,
      r = this._parsedPaths,
      s = this._bindings,
      o = s.length;
    let a,
      l = e.length,
      c = this.nCachedObjects_;
    for (let h = 0, d = arguments.length; h !== d; ++h) {
      const p = arguments[h],
        m = p.uuid;
      let v = t[m];
      if (v === void 0) {
        (v = l++), (t[m] = v), e.push(p);
        for (let A = 0, x = o; A !== x; ++A) s[A].push(new bt(p, i[A], r[A]));
      } else if (v < c) {
        a = e[v];
        const A = --c,
          x = e[A];
        (t[x.uuid] = v), (e[v] = x), (t[m] = A), (e[A] = p);
        for (let g = 0, _ = o; g !== _; ++g) {
          const S = s[g],
            w = S[A];
          let E = S[v];
          (S[v] = w), E === void 0 && (E = new bt(p, i[g], r[g])), (S[A] = E);
        }
      } else
        e[v] !== a &&
          console.error(
            "THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
          );
    }
    this.nCachedObjects_ = c;
  }
  remove() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_;
    for (let o = 0, a = arguments.length; o !== a; ++o) {
      const l = arguments[o],
        c = l.uuid,
        h = t[c];
      if (h !== void 0 && h >= s) {
        const d = s++,
          p = e[d];
        (t[p.uuid] = h), (e[h] = p), (t[c] = d), (e[d] = l);
        for (let m = 0, v = r; m !== v; ++m) {
          const A = i[m],
            x = A[d],
            g = A[h];
          (A[h] = x), (A[d] = g);
        }
      }
    }
    this.nCachedObjects_ = s;
  }
  uncache() {
    const e = this._objects,
      t = this._indicesByUUID,
      i = this._bindings,
      r = i.length;
    let s = this.nCachedObjects_,
      o = e.length;
    for (let a = 0, l = arguments.length; a !== l; ++a) {
      const c = arguments[a],
        h = c.uuid,
        d = t[h];
      if (d !== void 0)
        if ((delete t[h], d < s)) {
          const p = --s,
            m = e[p],
            v = --o,
            A = e[v];
          (t[m.uuid] = d), (e[d] = m), (t[A.uuid] = p), (e[p] = A), e.pop();
          for (let x = 0, g = r; x !== g; ++x) {
            const _ = i[x],
              S = _[p],
              w = _[v];
            (_[d] = S), (_[p] = w), _.pop();
          }
        } else {
          const p = --o,
            m = e[p];
          p > 0 && (t[m.uuid] = d), (e[d] = m), e.pop();
          for (let v = 0, A = r; v !== A; ++v) {
            const x = i[v];
            (x[d] = x[p]), x.pop();
          }
        }
    }
    this.nCachedObjects_ = s;
  }
  subscribe_(e, t) {
    const i = this._bindingsIndicesByPath;
    let r = i[e];
    const s = this._bindings;
    if (r !== void 0) return s[r];
    const o = this._paths,
      a = this._parsedPaths,
      l = this._objects,
      c = l.length,
      h = this.nCachedObjects_,
      d = new Array(c);
    (r = s.length), (i[e] = r), o.push(e), a.push(t), s.push(d);
    for (let p = h, m = l.length; p !== m; ++p) {
      const v = l[p];
      d[p] = new bt(v, e, t);
    }
    return d;
  }
  unsubscribe_(e) {
    const t = this._bindingsIndicesByPath,
      i = t[e];
    if (i !== void 0) {
      const r = this._paths,
        s = this._parsedPaths,
        o = this._bindings,
        a = o.length - 1,
        l = o[a],
        c = e[a];
      (t[c] = i),
        (o[i] = l),
        o.pop(),
        (s[i] = s[a]),
        s.pop(),
        (r[i] = r[a]),
        r.pop();
    }
  }
}
class kR {
  constructor(e, t, i = null, r = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = r);
    const s = t.tracks,
      o = s.length,
      a = new Array(o),
      l = { endingStart: za, endingEnd: za };
    for (let c = 0; c !== o; ++c) {
      const h = s[c].createInterpolant(null);
      (a[c] = h), (h.settings = l);
    }
    (this._interpolantSettings = l),
      (this._interpolants = a),
      (this._propertyBindings = new Array(o)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = FB),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const r = this._clip.duration,
        s = e._clip.duration,
        o = s / r,
        a = r / s;
      e.warp(1, o, t), this.warp(a, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      e !== null &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const r = this._mixer,
      s = r.time,
      o = this.timeScale;
    let a = this._timeScaleInterpolant;
    a === null &&
      ((a = r._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const l = a.parameterPositions,
      c = a.sampleValues;
    return (l[0] = s), (l[1] = s + i), (c[0] = e / o), (c[1] = t / o), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      e !== null &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, r) {
    if (!this.enabled) {
      this._updateWeight(e);
      return;
    }
    const s = this._startTime;
    if (s !== null) {
      const l = (e - s) * i;
      l < 0 || i === 0 ? (t = 0) : ((this._startTime = null), (t = i * l));
    }
    t *= this._updateTimeScale(e);
    const o = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const l = this._interpolants,
        c = this._propertyBindings;
      switch (this.blendMode) {
        case Y1:
          for (let h = 0, d = l.length; h !== d; ++h)
            l[h].evaluate(o), c[h].accumulateAdditive(a);
          break;
        case Ig:
        default:
          for (let h = 0, d = l.length; h !== d; ++h)
            l[h].evaluate(o), c[h].accumulate(r, a);
      }
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopFading(), r === 0 && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (i !== null) {
        const r = i.evaluate(e)[0];
        (t *= r),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            t === 0 ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop;
    let r = this.time + e,
      s = this._loopCount;
    const o = i === NB;
    if (e === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - r : r;
    if (i === DB) {
      s === -1 && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (r >= t) r = t;
        else if (r < 0) r = 0;
        else {
          this.time = r;
          break e;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = r),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (s === -1 &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, this.repetitions === 0, o))
            : this._setEndings(this.repetitions === 0, !0, o)),
        r >= t || r < 0)
      ) {
        const a = Math.floor(r / t);
        (r -= t * a), (s += Math.abs(a));
        const l = this.repetitions - s;
        if (l <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (r = e > 0 ? t : 0),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (l === 1) {
            const c = e < 0;
            this._setEndings(c, !c, o);
          } else this._setEndings(!1, !1, o);
          (this._loopCount = s),
            (this.time = r),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: a,
            });
        }
      } else this.time = r;
      if (o && (s & 1) === 1) return t - r;
    }
    return r;
  }
  _setEndings(e, t, i) {
    const r = this._interpolantSettings;
    i
      ? ((r.endingStart = Ga), (r.endingEnd = Ga))
      : (e
          ? (r.endingStart = this.zeroSlopeAtStart ? Ga : za)
          : (r.endingStart = qf),
        t ? (r.endingEnd = this.zeroSlopeAtEnd ? Ga : za) : (r.endingEnd = qf));
  }
  _scheduleFading(e, t, i) {
    const r = this._mixer,
      s = r.time;
    let o = this._weightInterpolant;
    o === null &&
      ((o = r._lendControlInterpolant()), (this._weightInterpolant = o));
    const a = o.parameterPositions,
      l = o.sampleValues;
    return (a[0] = s), (l[0] = t), (a[1] = s + e), (l[1] = i), this;
  }
}
const KH = new Float32Array(1);
class YH extends ds {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      r = e._clip.tracks,
      s = r.length,
      o = e._propertyBindings,
      a = e._interpolants,
      l = i.uuid,
      c = this._bindingsByRootAndName;
    let h = c[l];
    h === void 0 && ((h = {}), (c[l] = h));
    for (let d = 0; d !== s; ++d) {
      const p = r[d],
        m = p.name;
      let v = h[m];
      if (v !== void 0) ++v.referenceCount, (o[d] = v);
      else {
        if (((v = o[d]), v !== void 0)) {
          v._cacheIndex === null &&
            (++v.referenceCount, this._addInactiveBinding(v, l, m));
          continue;
        }
        const A = t && t._propertyBindings[d].binding.parsedPath;
        (v = new OR(bt.create(i, m, A), p.ValueTypeName, p.getValueSize())),
          ++v.referenceCount,
          this._addInactiveBinding(v, l, m),
          (o[d] = v);
      }
      a[d].resultBuffer = v.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (e._cacheIndex === null) {
        const i = (e._localRoot || this._root).uuid,
          r = e._clip.uuid,
          s = this._actionsByClip[r];
        this._bindAction(e, s && s.knownActions[0]),
          this._addInactiveAction(e, r, i);
      }
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let i = 0, r = t.length; i !== r; ++i) {
        const s = t[i];
        --s.useCount === 0 &&
          (s.restoreOriginalState(), this._takeBackBinding(s));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return t !== null && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const r = this._actions,
      s = this._actionsByClip;
    let o = s[t];
    if (o === void 0)
      (o = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = o);
    else {
      const a = o.knownActions;
      (e._byClipCacheIndex = a.length), a.push(e);
    }
    (e._cacheIndex = r.length), r.push(e), (o.actionByRoot[i] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      r = e._cacheIndex;
    (i._cacheIndex = r), (t[r] = i), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      o = this._actionsByClip,
      a = o[s],
      l = a.knownActions,
      c = l[l.length - 1],
      h = e._byClipCacheIndex;
    (c._byClipCacheIndex = h),
      (l[h] = c),
      l.pop(),
      (e._byClipCacheIndex = null);
    const d = a.actionByRoot,
      p = (e._localRoot || this._root).uuid;
    delete d[p],
      l.length === 0 && delete o[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, r = t.length; i !== r; ++i) {
      const s = t[i];
      --s.referenceCount === 0 && this._removeInactiveBinding(s);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = this._nActiveActions++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      r = --this._nActiveActions,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _addInactiveBinding(e, t, i) {
    const r = this._bindingsByRootAndName,
      s = this._bindings;
    let o = r[t];
    o === void 0 && ((o = {}), (r[t] = o)),
      (o[i] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      r = i.rootNode.uuid,
      s = i.path,
      o = this._bindingsByRootAndName,
      a = o[r],
      l = t[t.length - 1],
      c = e._cacheIndex;
    (l._cacheIndex = c),
      (t[c] = l),
      t.pop(),
      delete a[s],
      Object.keys(a).length === 0 && delete o[r];
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = this._nActiveBindings++,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      r = --this._nActiveBindings,
      s = t[r];
    (e._cacheIndex = r), (t[r] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let i = e[t];
    return (
      i === void 0 &&
        ((i = new SA(new Float32Array(2), new Float32Array(2), 1, KH)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      r = --this._nActiveControlInterpolants,
      s = t[r];
    (e.__cacheIndex = r), (t[r] = e), (s.__cacheIndex = i), (t[i] = s);
  }
  clipAction(e, t, i) {
    const r = t || this._root,
      s = r.uuid;
    let o = typeof e == "string" ? Ku.findByName(r, e) : e;
    const a = o !== null ? o.uuid : e,
      l = this._actionsByClip[a];
    let c = null;
    if (
      (i === void 0 && (o !== null ? (i = o.blendMode) : (i = Ig)),
      l !== void 0)
    ) {
      const d = l.actionByRoot[s];
      if (d !== void 0 && d.blendMode === i) return d;
      (c = l.knownActions[0]), o === null && (o = c._clip);
    }
    if (o === null) return null;
    const h = new kR(this, o, t, i);
    return this._bindAction(h, c), this._addInactiveAction(h, a, s), h;
  }
  existingAction(e, t) {
    const i = t || this._root,
      r = i.uuid,
      s = typeof e == "string" ? Ku.findByName(i, e) : e,
      o = s ? s.uuid : e,
      a = this._actionsByClip[o];
    return (a !== void 0 && a.actionByRoot[r]) || null;
  }
  stopAllAction() {
    const e = this._actions,
      t = this._nActiveActions;
    for (let i = t - 1; i >= 0; --i) e[i].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      i = this._nActiveActions,
      r = (this.time += e),
      s = Math.sign(e),
      o = (this._accuIndex ^= 1);
    for (let c = 0; c !== i; ++c) t[c]._update(r, e, s, o);
    const a = this._bindings,
      l = this._nActiveBindings;
    for (let c = 0; c !== l; ++c) a[c].apply(o);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      r = this._actionsByClip,
      s = r[i];
    if (s !== void 0) {
      const o = s.knownActions;
      for (let a = 0, l = o.length; a !== l; ++a) {
        const c = o[a];
        this._deactivateAction(c);
        const h = c._cacheIndex,
          d = t[t.length - 1];
        (c._cacheIndex = null),
          (c._byClipCacheIndex = null),
          (d._cacheIndex = h),
          (t[h] = d),
          t.pop(),
          this._removeInactiveBindingsForAction(c);
      }
      delete r[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip;
    for (const o in i) {
      const a = i[o].actionByRoot,
        l = a[t];
      l !== void 0 &&
        (this._deactivateAction(l), this._removeInactiveAction(l));
    }
    const r = this._bindingsByRootAndName,
      s = r[t];
    if (s !== void 0)
      for (const o in s) {
        const a = s[o];
        a.restoreOriginalState(), this._removeInactiveBinding(a);
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    i !== null && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class DA {
  constructor(e) {
    this.value = e;
  }
  clone() {
    return new DA(
      this.value.clone === void 0 ? this.value : this.value.clone()
    );
  }
}
let QH = 0;
class ZH extends ds {
  constructor() {
    super(),
      (this.isUniformsGroup = !0),
      Object.defineProperty(this, "id", { value: QH++ }),
      (this.name = ""),
      (this.usage = $f),
      (this.uniforms = []);
  }
  add(e) {
    return this.uniforms.push(e), this;
  }
  remove(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  setName(e) {
    return (this.name = e), this;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  dispose() {
    return this.dispatchEvent({ type: "dispose" }), this;
  }
  copy(e) {
    (this.name = e.name), (this.usage = e.usage);
    const t = e.uniforms;
    this.uniforms.length = 0;
    for (let i = 0, r = t.length; i < r; i++) this.uniforms.push(t[i].clone());
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class qH extends wh {
  constructor(e, t, i = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class $H {
  constructor(e, t, i, r, s) {
    (this.isGLBufferAttribute = !0),
      (this.name = ""),
      (this.buffer = e),
      (this.type = t),
      (this.itemSize = i),
      (this.elementSize = r),
      (this.count = s),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setBuffer(e) {
    return (this.buffer = e), this;
  }
  setType(e, t) {
    return (this.type = e), (this.elementSize = t), this;
  }
  setItemSize(e) {
    return (this.itemSize = e), this;
  }
  setCount(e) {
    return (this.count = e), this;
  }
}
class UR {
  constructor(e, t, i = 0, r = 1 / 0) {
    (this.ray = new Ah(e, t)),
      (this.near = i),
      (this.far = r),
      (this.camera = null),
      (this.layers = new Za()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return __(e, this, i, t), i.sort(CE), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let r = 0, s = e.length; r < s; r++) __(e[r], this, i, t);
    return i.sort(CE), i;
  }
}
function CE(n, e) {
  return n.distance - e.distance;
}
function __(n, e, t, i) {
  if ((n.layers.test(e.layers) && n.raycast(e, t), i === !0)) {
    const r = n.children;
    for (let s = 0, o = r.length; s < o; s++) __(r[s], e, t, !0);
  }
}
class A_ {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.phi = t), (this.theta = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + i * i)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, i)),
          (this.phi = Math.acos(pn(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class e5 {
  constructor(e = 1, t = 0, i = 0) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  set(e, t, i) {
    return (this.radius = e), (this.theta = t), (this.y = i), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.theta = e.theta), (this.y = e.y), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, i) {
    return (
      (this.radius = Math.sqrt(e * e + i * i)),
      (this.theta = Math.atan2(e, i)),
      (this.y = t),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const EE = new ge();
class t5 {
  constructor(e = new ge(1 / 0, 1 / 0), t = new ge(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = EE.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, EE).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const TE = new F(),
  zp = new F();
class n5 {
  constructor(e = new F(), t = new F()) {
    (this.start = e), (this.end = t);
  }
  set(e, t) {
    return this.start.copy(e), this.end.copy(t), this;
  }
  copy(e) {
    return this.start.copy(e.start), this.end.copy(e.end), this;
  }
  getCenter(e) {
    return e.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(e) {
    return e.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(e, t) {
    return this.delta(t).multiplyScalar(e).add(this.start);
  }
  closestPointToPointParameter(e, t) {
    TE.subVectors(e, this.start), zp.subVectors(this.end, this.start);
    const i = zp.dot(zp);
    let s = zp.dot(TE) / i;
    return t && (s = pn(s, 0, 1)), s;
  }
  closestPointToPoint(e, t, i) {
    const r = this.closestPointToPointParameter(e, t);
    return this.delta(i).multiplyScalar(r).add(this.start);
  }
  applyMatrix4(e) {
    return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
  }
  equals(e) {
    return e.start.equals(this.start) && e.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const bE = new F();
class i5 extends Pt {
  constructor(e, t) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = t),
      (this.type = "SpotLightHelper");
    const i = new ct(),
      r = [
        0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
        0, 0, 0, 0, -1, 1,
      ];
    for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
      const c = (o / l) * Math.PI * 2,
        h = (a / l) * Math.PI * 2;
      r.push(Math.cos(c), Math.sin(c), 1, Math.cos(h), Math.sin(h), 1);
    }
    i.setAttribute("position", new Ve(r, 3));
    const s = new oi({ fog: !1, toneMapped: !1 });
    (this.cone = new Wr(i, s)), this.add(this.cone), this.update();
  }
  dispose() {
    this.cone.geometry.dispose(), this.cone.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1);
    const e = this.light.distance ? this.light.distance : 1e3,
      t = e * Math.tan(this.light.angle);
    this.cone.scale.set(t, t, e),
      bE.setFromMatrixPosition(this.light.target.matrixWorld),
      this.cone.lookAt(bE),
      this.color !== void 0
        ? this.cone.material.color.set(this.color)
        : this.cone.material.color.copy(this.light.color);
  }
}
const mo = new F(),
  Gp = new st(),
  dv = new st();
class r5 extends Wr {
  constructor(e) {
    const t = zR(e),
      i = new ct(),
      r = [],
      s = [],
      o = new Ie(0, 0, 1),
      a = new Ie(0, 1, 0);
    for (let c = 0; c < t.length; c++) {
      const h = t[c];
      h.parent &&
        h.parent.isBone &&
        (r.push(0, 0, 0),
        r.push(0, 0, 0),
        s.push(o.r, o.g, o.b),
        s.push(a.r, a.g, a.b));
    }
    i.setAttribute("position", new Ve(r, 3)),
      i.setAttribute("color", new Ve(s, 3));
    const l = new oi({
      vertexColors: !0,
      depthTest: !1,
      depthWrite: !1,
      toneMapped: !1,
      transparent: !0,
    });
    super(i, l),
      (this.isSkeletonHelper = !0),
      (this.type = "SkeletonHelper"),
      (this.root = e),
      (this.bones = t),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  updateMatrixWorld(e) {
    const t = this.bones,
      i = this.geometry,
      r = i.getAttribute("position");
    dv.copy(this.root.matrixWorld).invert();
    for (let s = 0, o = 0; s < t.length; s++) {
      const a = t[s];
      a.parent &&
        a.parent.isBone &&
        (Gp.multiplyMatrices(dv, a.matrixWorld),
        mo.setFromMatrixPosition(Gp),
        r.setXYZ(o, mo.x, mo.y, mo.z),
        Gp.multiplyMatrices(dv, a.parent.matrixWorld),
        mo.setFromMatrixPosition(Gp),
        r.setXYZ(o + 1, mo.x, mo.y, mo.z),
        (o += 2));
    }
    (i.getAttribute("position").needsUpdate = !0), super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function zR(n) {
  const e = [];
  n.isBone === !0 && e.push(n);
  for (let t = 0; t < n.children.length; t++)
    e.push.apply(e, zR(n.children[t]));
  return e;
}
class s5 extends Pn {
  constructor(e, t, i) {
    const r = new sc(t, 4, 2),
      s = new Wi({ wireframe: !0, fog: !1, toneMapped: !1 });
    super(r, s),
      (this.light = e),
      (this.color = i),
      (this.type = "PointLightHelper"),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.color !== void 0
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
  }
}
const o5 = new F(),
  PE = new Ie(),
  BE = new Ie();
class a5 extends Pt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "HemisphereLightHelper");
    const r = new rc(t);
    r.rotateY(Math.PI * 0.5),
      (this.material = new Wi({ wireframe: !0, fog: !1, toneMapped: !1 })),
      this.color === void 0 && (this.material.vertexColors = !0);
    const s = r.getAttribute("position"),
      o = new Float32Array(s.count * 3);
    r.setAttribute("color", new Dt(o, 3)),
      this.add(new Pn(r, this.material)),
      this.update();
  }
  dispose() {
    this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
  update() {
    const e = this.children[0];
    if (this.color !== void 0) this.material.color.set(this.color);
    else {
      const t = e.geometry.getAttribute("color");
      PE.copy(this.light.color), BE.copy(this.light.groundColor);
      for (let i = 0, r = t.count; i < r; i++) {
        const s = i < r / 2 ? PE : BE;
        t.setXYZ(i, s.r, s.g, s.b);
      }
      t.needsUpdate = !0;
    }
    this.light.updateWorldMatrix(!0, !1),
      e.lookAt(o5.setFromMatrixPosition(this.light.matrixWorld).negate());
  }
}
class l5 extends Wr {
  constructor(e = 10, t = 10, i = 4473924, r = 8947848) {
    (i = new Ie(i)), (r = new Ie(r));
    const s = t / 2,
      o = e / t,
      a = e / 2,
      l = [],
      c = [];
    for (let p = 0, m = 0, v = -a; p <= t; p++, v += o) {
      l.push(-a, 0, v, a, 0, v), l.push(v, 0, -a, v, 0, a);
      const A = p === s ? i : r;
      A.toArray(c, m),
        (m += 3),
        A.toArray(c, m),
        (m += 3),
        A.toArray(c, m),
        (m += 3),
        A.toArray(c, m),
        (m += 3);
    }
    const h = new ct();
    h.setAttribute("position", new Ve(l, 3)),
      h.setAttribute("color", new Ve(c, 3));
    const d = new oi({ vertexColors: !0, toneMapped: !1 });
    super(h, d), (this.type = "GridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class u5 extends Wr {
  constructor(e = 10, t = 16, i = 8, r = 64, s = 4473924, o = 8947848) {
    (s = new Ie(s)), (o = new Ie(o));
    const a = [],
      l = [];
    if (t > 1)
      for (let d = 0; d < t; d++) {
        const p = (d / t) * (Math.PI * 2),
          m = Math.sin(p) * e,
          v = Math.cos(p) * e;
        a.push(0, 0, 0), a.push(m, 0, v);
        const A = d & 1 ? s : o;
        l.push(A.r, A.g, A.b), l.push(A.r, A.g, A.b);
      }
    for (let d = 0; d < i; d++) {
      const p = d & 1 ? s : o,
        m = e - (e / i) * d;
      for (let v = 0; v < r; v++) {
        let A = (v / r) * (Math.PI * 2),
          x = Math.sin(A) * m,
          g = Math.cos(A) * m;
        a.push(x, 0, g),
          l.push(p.r, p.g, p.b),
          (A = ((v + 1) / r) * (Math.PI * 2)),
          (x = Math.sin(A) * m),
          (g = Math.cos(A) * m),
          a.push(x, 0, g),
          l.push(p.r, p.g, p.b);
      }
    }
    const c = new ct();
    c.setAttribute("position", new Ve(a, 3)),
      c.setAttribute("color", new Ve(l, 3));
    const h = new oi({ vertexColors: !0, toneMapped: !1 });
    super(c, h), (this.type = "PolarGridHelper");
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const RE = new F(),
  Hp = new F(),
  LE = new F();
class c5 extends Pt {
  constructor(e, t, i) {
    super(),
      (this.light = e),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      (this.type = "DirectionalLightHelper"),
      t === void 0 && (t = 1);
    let r = new ct();
    r.setAttribute(
      "position",
      new Ve([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3)
    );
    const s = new oi({ fog: !1, toneMapped: !1 });
    (this.lightPlane = new Ys(r, s)),
      this.add(this.lightPlane),
      (r = new ct()),
      r.setAttribute("position", new Ve([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Ys(r, s)),
      this.add(this.targetLine),
      this.update();
  }
  dispose() {
    this.lightPlane.geometry.dispose(),
      this.lightPlane.material.dispose(),
      this.targetLine.geometry.dispose(),
      this.targetLine.material.dispose();
  }
  update() {
    this.light.updateWorldMatrix(!0, !1),
      this.light.target.updateWorldMatrix(!0, !1),
      RE.setFromMatrixPosition(this.light.matrixWorld),
      Hp.setFromMatrixPosition(this.light.target.matrixWorld),
      LE.subVectors(Hp, RE),
      this.lightPlane.lookAt(Hp),
      this.color !== void 0
        ? (this.lightPlane.material.color.set(this.color),
          this.targetLine.material.color.set(this.color))
        : (this.lightPlane.material.color.copy(this.light.color),
          this.targetLine.material.color.copy(this.light.color)),
      this.targetLine.lookAt(Hp),
      (this.targetLine.scale.z = LE.length());
  }
}
const Vp = new F(),
  fn = new Mh();
class f5 extends Wr {
  constructor(e) {
    const t = new ct(),
      i = new oi({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      r = [],
      s = [],
      o = {};
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4");
    function a(v, A) {
      l(v), l(A);
    }
    function l(v) {
      r.push(0, 0, 0),
        s.push(0, 0, 0),
        o[v] === void 0 && (o[v] = []),
        o[v].push(r.length / 3 - 1);
    }
    t.setAttribute("position", new Ve(r, 3)),
      t.setAttribute("color", new Ve(s, 3)),
      super(t, i),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = o),
      this.update();
    const c = new Ie(16755200),
      h = new Ie(16711680),
      d = new Ie(43775),
      p = new Ie(16777215),
      m = new Ie(3355443);
    this.setColors(c, h, d, p, m);
  }
  setColors(e, t, i, r, s) {
    const a = this.geometry.getAttribute("color");
    a.setXYZ(0, e.r, e.g, e.b),
      a.setXYZ(1, e.r, e.g, e.b),
      a.setXYZ(2, e.r, e.g, e.b),
      a.setXYZ(3, e.r, e.g, e.b),
      a.setXYZ(4, e.r, e.g, e.b),
      a.setXYZ(5, e.r, e.g, e.b),
      a.setXYZ(6, e.r, e.g, e.b),
      a.setXYZ(7, e.r, e.g, e.b),
      a.setXYZ(8, e.r, e.g, e.b),
      a.setXYZ(9, e.r, e.g, e.b),
      a.setXYZ(10, e.r, e.g, e.b),
      a.setXYZ(11, e.r, e.g, e.b),
      a.setXYZ(12, e.r, e.g, e.b),
      a.setXYZ(13, e.r, e.g, e.b),
      a.setXYZ(14, e.r, e.g, e.b),
      a.setXYZ(15, e.r, e.g, e.b),
      a.setXYZ(16, e.r, e.g, e.b),
      a.setXYZ(17, e.r, e.g, e.b),
      a.setXYZ(18, e.r, e.g, e.b),
      a.setXYZ(19, e.r, e.g, e.b),
      a.setXYZ(20, e.r, e.g, e.b),
      a.setXYZ(21, e.r, e.g, e.b),
      a.setXYZ(22, e.r, e.g, e.b),
      a.setXYZ(23, e.r, e.g, e.b),
      a.setXYZ(24, t.r, t.g, t.b),
      a.setXYZ(25, t.r, t.g, t.b),
      a.setXYZ(26, t.r, t.g, t.b),
      a.setXYZ(27, t.r, t.g, t.b),
      a.setXYZ(28, t.r, t.g, t.b),
      a.setXYZ(29, t.r, t.g, t.b),
      a.setXYZ(30, t.r, t.g, t.b),
      a.setXYZ(31, t.r, t.g, t.b),
      a.setXYZ(32, i.r, i.g, i.b),
      a.setXYZ(33, i.r, i.g, i.b),
      a.setXYZ(34, i.r, i.g, i.b),
      a.setXYZ(35, i.r, i.g, i.b),
      a.setXYZ(36, i.r, i.g, i.b),
      a.setXYZ(37, i.r, i.g, i.b),
      a.setXYZ(38, r.r, r.g, r.b),
      a.setXYZ(39, r.r, r.g, r.b),
      a.setXYZ(40, s.r, s.g, s.b),
      a.setXYZ(41, s.r, s.g, s.b),
      a.setXYZ(42, s.r, s.g, s.b),
      a.setXYZ(43, s.r, s.g, s.b),
      a.setXYZ(44, s.r, s.g, s.b),
      a.setXYZ(45, s.r, s.g, s.b),
      a.setXYZ(46, s.r, s.g, s.b),
      a.setXYZ(47, s.r, s.g, s.b),
      a.setXYZ(48, s.r, s.g, s.b),
      a.setXYZ(49, s.r, s.g, s.b),
      (a.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap,
      i = 1,
      r = 1;
    fn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      gn("c", t, e, fn, 0, 0, -1),
      gn("t", t, e, fn, 0, 0, 1),
      gn("n1", t, e, fn, -i, -r, -1),
      gn("n2", t, e, fn, i, -r, -1),
      gn("n3", t, e, fn, -i, r, -1),
      gn("n4", t, e, fn, i, r, -1),
      gn("f1", t, e, fn, -i, -r, 1),
      gn("f2", t, e, fn, i, -r, 1),
      gn("f3", t, e, fn, -i, r, 1),
      gn("f4", t, e, fn, i, r, 1),
      gn("u1", t, e, fn, i * 0.7, r * 1.1, -1),
      gn("u2", t, e, fn, -i * 0.7, r * 1.1, -1),
      gn("u3", t, e, fn, 0, r * 2, -1),
      gn("cf1", t, e, fn, -i, 0, 1),
      gn("cf2", t, e, fn, i, 0, 1),
      gn("cf3", t, e, fn, 0, -r, 1),
      gn("cf4", t, e, fn, 0, r, 1),
      gn("cn1", t, e, fn, -i, 0, -1),
      gn("cn2", t, e, fn, i, 0, -1),
      gn("cn3", t, e, fn, 0, -r, -1),
      gn("cn4", t, e, fn, 0, r, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function gn(n, e, t, i, r, s, o) {
  Vp.set(r, s, o).unproject(i);
  const a = e[n];
  if (a !== void 0) {
    const l = t.getAttribute("position");
    for (let c = 0, h = a.length; c < h; c++) l.setXYZ(a[c], Vp.x, Vp.y, Vp.z);
  }
}
const Wp = new Hr();
class h5 extends Wr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = new Float32Array(8 * 3),
      s = new ct();
    s.setIndex(new Dt(i, 1)),
      s.setAttribute("position", new Dt(r, 3)),
      super(s, new oi({ color: t, toneMapped: !1 })),
      (this.object = e),
      (this.type = "BoxHelper"),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  update(e) {
    if (
      (e !== void 0 &&
        console.warn("THREE.BoxHelper: .update() has no longer arguments."),
      this.object !== void 0 && Wp.setFromObject(this.object),
      Wp.isEmpty())
    )
      return;
    const t = Wp.min,
      i = Wp.max,
      r = this.geometry.attributes.position,
      s = r.array;
    (s[0] = i.x),
      (s[1] = i.y),
      (s[2] = i.z),
      (s[3] = t.x),
      (s[4] = i.y),
      (s[5] = i.z),
      (s[6] = t.x),
      (s[7] = t.y),
      (s[8] = i.z),
      (s[9] = i.x),
      (s[10] = t.y),
      (s[11] = i.z),
      (s[12] = i.x),
      (s[13] = i.y),
      (s[14] = t.z),
      (s[15] = t.x),
      (s[16] = i.y),
      (s[17] = t.z),
      (s[18] = t.x),
      (s[19] = t.y),
      (s[20] = t.z),
      (s[21] = i.x),
      (s[22] = t.y),
      (s[23] = t.z),
      (r.needsUpdate = !0),
      this.geometry.computeBoundingSphere();
  }
  setFromObject(e) {
    return (this.object = e), this.update(), this;
  }
  copy(e, t) {
    return super.copy(e, t), (this.object = e.object), this;
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class d5 extends Wr {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      r = [
        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
        1, -1, -1,
      ],
      s = new ct();
    s.setIndex(new Dt(i, 1)),
      s.setAttribute("position", new Ve(r, 3)),
      super(s, new oi({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class p5 extends Ys {
  constructor(e, t = 1, i = 16776960) {
    const r = i,
      s = [
        1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0,
        1, 1, 0,
      ],
      o = new ct();
    o.setAttribute("position", new Ve(s, 3)),
      o.computeBoundingSphere(),
      super(o, new oi({ color: r, toneMapped: !1 })),
      (this.type = "PlaneHelper"),
      (this.plane = e),
      (this.size = t);
    const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
      l = new ct();
    l.setAttribute("position", new Ve(a, 3)),
      l.computeBoundingSphere(),
      this.add(
        new Pn(
          l,
          new Wi({
            color: r,
            opacity: 0.2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1,
          })
        )
      );
  }
  updateMatrixWorld(e) {
    this.position.set(0, 0, 0),
      this.scale.set(0.5 * this.size, 0.5 * this.size, 1),
      this.lookAt(this.plane.normal),
      this.translateZ(-this.plane.constant),
      super.updateMatrixWorld(e);
  }
  dispose() {
    this.geometry.dispose(),
      this.material.dispose(),
      this.children[0].geometry.dispose(),
      this.children[0].material.dispose();
  }
}
const IE = new F();
let Jp, pv;
class m5 extends Pt {
  constructor(
    e = new F(0, 0, 1),
    t = new F(0, 0, 0),
    i = 1,
    r = 16776960,
    s = i * 0.2,
    o = s * 0.2
  ) {
    super(),
      (this.type = "ArrowHelper"),
      Jp === void 0 &&
        ((Jp = new ct()),
        Jp.setAttribute("position", new Ve([0, 0, 0, 0, 1, 0], 3)),
        (pv = new hl(0, 0.5, 1, 5, 1)),
        pv.translate(0, -0.5, 0)),
      this.position.copy(t),
      (this.line = new Ys(Jp, new oi({ color: r, toneMapped: !1 }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Pn(pv, new Wi({ color: r, toneMapped: !1 }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(e),
      this.setLength(i, s, o);
  }
  setDirection(e) {
    if (e.y > 0.99999) this.quaternion.set(0, 0, 0, 1);
    else if (e.y < -0.99999) this.quaternion.set(1, 0, 0, 0);
    else {
      IE.set(e.z, 0, -e.x).normalize();
      const t = Math.acos(e.y);
      this.quaternion.setFromAxisAngle(IE, t);
    }
  }
  setLength(e, t = e * 0.2, i = t * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, e - t), 1),
      this.line.updateMatrix(),
      this.cone.scale.set(i, t, i),
      (this.cone.position.y = e),
      this.cone.updateMatrix();
  }
  setColor(e) {
    this.line.material.color.set(e), this.cone.material.color.set(e);
  }
  copy(e) {
    return (
      super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    );
  }
  dispose() {
    this.line.geometry.dispose(),
      this.line.material.dispose(),
      this.cone.geometry.dispose(),
      this.cone.material.dispose();
  }
}
class g5 extends Wr {
  constructor(e = 1) {
    const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
      i = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1],
      r = new ct();
    r.setAttribute("position", new Ve(t, 3)),
      r.setAttribute("color", new Ve(i, 3));
    const s = new oi({ vertexColors: !0, toneMapped: !1 });
    super(r, s), (this.type = "AxesHelper");
  }
  setColors(e, t, i) {
    const r = new Ie(),
      s = this.geometry.attributes.color.array;
    return (
      r.set(e),
      r.toArray(s, 0),
      r.toArray(s, 3),
      r.set(t),
      r.toArray(s, 6),
      r.toArray(s, 9),
      r.set(i),
      r.toArray(s, 12),
      r.toArray(s, 15),
      (this.geometry.attributes.color.needsUpdate = !0),
      this
    );
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
class y5 {
  constructor() {
    (this.type = "ShapePath"),
      (this.color = new Ie()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  moveTo(e, t) {
    return (
      (this.currentPath = new th()),
      this.subPaths.push(this.currentPath),
      this.currentPath.moveTo(e, t),
      this
    );
  }
  lineTo(e, t) {
    return this.currentPath.lineTo(e, t), this;
  }
  quadraticCurveTo(e, t, i, r) {
    return this.currentPath.quadraticCurveTo(e, t, i, r), this;
  }
  bezierCurveTo(e, t, i, r, s, o) {
    return this.currentPath.bezierCurveTo(e, t, i, r, s, o), this;
  }
  splineThru(e) {
    return this.currentPath.splineThru(e), this;
  }
  toShapes(e) {
    function t(g) {
      const _ = [];
      for (let S = 0, w = g.length; S < w; S++) {
        const E = g[S],
          P = new qa();
        (P.curves = E.curves), _.push(P);
      }
      return _;
    }
    function i(g, _) {
      const S = _.length;
      let w = !1;
      for (let E = S - 1, P = 0; P < S; E = P++) {
        let L = _[E],
          B = _[P],
          b = B.x - L.x,
          R = B.y - L.y;
        if (Math.abs(R) > Number.EPSILON) {
          if (
            (R < 0 && ((L = _[P]), (b = -b), (B = _[E]), (R = -R)),
            g.y < L.y || g.y > B.y)
          )
            continue;
          if (g.y === L.y) {
            if (g.x === L.x) return !0;
          } else {
            const U = R * (g.x - L.x) - b * (g.y - L.y);
            if (U === 0) return !0;
            if (U < 0) continue;
            w = !w;
          }
        } else {
          if (g.y !== L.y) continue;
          if ((B.x <= g.x && g.x <= L.x) || (L.x <= g.x && g.x <= B.x))
            return !0;
        }
      }
      return w;
    }
    const r = as.isClockWise,
      s = this.subPaths;
    if (s.length === 0) return [];
    let o, a, l;
    const c = [];
    if (s.length === 1)
      return (a = s[0]), (l = new qa()), (l.curves = a.curves), c.push(l), c;
    let h = !r(s[0].getPoints());
    h = e ? !h : h;
    const d = [],
      p = [];
    let m = [],
      v = 0,
      A;
    (p[v] = void 0), (m[v] = []);
    for (let g = 0, _ = s.length; g < _; g++)
      (a = s[g]),
        (A = a.getPoints()),
        (o = r(A)),
        (o = e ? !o : o),
        o
          ? (!h && p[v] && v++,
            (p[v] = { s: new qa(), p: A }),
            (p[v].s.curves = a.curves),
            h && v++,
            (m[v] = []))
          : m[v].push({ h: a, p: A[0] });
    if (!p[0]) return t(s);
    if (p.length > 1) {
      let g = !1,
        _ = 0;
      for (let S = 0, w = p.length; S < w; S++) d[S] = [];
      for (let S = 0, w = p.length; S < w; S++) {
        const E = m[S];
        for (let P = 0; P < E.length; P++) {
          const L = E[P];
          let B = !0;
          for (let b = 0; b < p.length; b++)
            i(L.p, p[b].p) &&
              (S !== b && _++, B ? ((B = !1), d[b].push(L)) : (g = !0));
          B && d[S].push(L);
        }
      }
      _ > 0 && g === !1 && (m = d);
    }
    let x;
    for (let g = 0, _ = p.length; g < _; g++) {
      (l = p[g].s), c.push(l), (x = m[g]);
      for (let S = 0, w = x.length; S < w; S++) l.holes.push(x[S].h);
    }
    return c;
  }
}
class v5 extends ta {
  constructor(e, t, i, r, s, o) {
    console.warn(
      "THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry."
    ),
      super(e, t, i, r, s, o);
  }
}
class x5 extends Th {
  constructor(e, t, i, r) {
    console.warn(
      "THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry."
    ),
      super(e, t, i, r);
  }
}
class _5 extends bh {
  constructor(e, t, i, r) {
    console.warn(
      "THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry."
    ),
      super(e, t, i, r);
  }
}
class A5 extends Ph {
  constructor(e, t, i, r, s, o, a) {
    console.warn(
      "THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry."
    ),
      super(e, t, i, r, s, o, a);
  }
}
class M5 extends hl {
  constructor(e, t, i, r, s, o, a, l) {
    console.warn(
      "THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry."
    ),
      super(e, t, i, r, s, o, a, l);
  }
}
class S5 extends Bh {
  constructor(e, t) {
    console.warn(
      "THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry."
    ),
      super(e, t);
  }
}
class w5 extends Rh {
  constructor(e, t) {
    console.warn(
      "THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry."
    ),
      super(e, t);
  }
}
class C5 extends Lh {
  constructor(e, t) {
    console.warn(
      "THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry."
    ),
      super(e, t);
  }
}
class E5 extends ic {
  constructor(e, t, i, r) {
    console.warn(
      "THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry."
    ),
      super(e, t, i, r);
  }
}
class T5 extends rc {
  constructor(e, t) {
    console.warn(
      "THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry."
    ),
      super(e, t);
  }
}
class b5 extends tc {
  constructor(e, t, i, r) {
    console.warn(
      "THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry."
    ),
      super(e, t, i, r);
  }
}
class P5 extends qs {
  constructor(e, t, i, r) {
    console.warn(
      "THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry."
    ),
      super(e, t, i, r);
  }
}
class B5 extends Ih {
  constructor(e, t, i, r, s, o) {
    console.warn(
      "THREE.RingBufferGeometry has been renamed to THREE.RingGeometry."
    ),
      super(e, t, i, r, s, o);
  }
}
class R5 extends Dh {
  constructor(e, t) {
    console.warn(
      "THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry."
    ),
      super(e, t);
  }
}
class L5 extends sc {
  constructor(e, t, i, r, s, o, a) {
    console.warn(
      "THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry."
    ),
      super(e, t, i, r, s, o, a);
  }
}
class I5 extends Fh {
  constructor(e, t) {
    console.warn(
      "THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry."
    ),
      super(e, t);
  }
}
class D5 extends Nh {
  constructor(e, t, i, r, s) {
    console.warn(
      "THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry."
    ),
      super(e, t, i, r, s);
  }
}
class F5 extends Oh {
  constructor(e, t, i, r, s, o) {
    console.warn(
      "THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry."
    ),
      super(e, t, i, r, s, o);
  }
}
class N5 extends kh {
  constructor(e, t, i, r, s) {
    console.warn(
      "THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry."
    ),
      super(e, t, i, r, s);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Pg } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Pg));
const O5 = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping: X1,
      AddEquation: Ia,
      AddOperation: pB,
      AdditiveAnimationBlendMode: Y1,
      AdditiveBlending: kx,
      AlphaFormat: wB,
      AlwaysDepth: aB,
      AlwaysStencilFunc: GB,
      AmbientLight: BR,
      AmbientLightProbe: RH,
      AnimationAction: kR,
      AnimationClip: Ku,
      AnimationLoader: _H,
      AnimationMixer: YH,
      AnimationObjectGroup: XH,
      AnimationUtils: gH,
      ArcCurve: aR,
      ArrayCamera: eR,
      ArrowHelper: m5,
      Audio: NR,
      AudioAnalyser: OH,
      AudioContext: BA,
      AudioListener: DH,
      AudioLoader: PH,
      AxesHelper: g5,
      BackSide: mi,
      BasicDepthPacking: kB,
      BasicShadowMap: X2,
      Bone: Ug,
      BooleanKeyframeTrack: dl,
      Box2: t5,
      Box3: Hr,
      Box3Helper: d5,
      BoxBufferGeometry: v5,
      BoxGeometry: ta,
      BoxHelper: h5,
      BufferAttribute: Dt,
      BufferGeometry: ct,
      BufferGeometryLoader: DR,
      ByteType: xB,
      Cache: al,
      Camera: Mh,
      CameraHelper: f5,
      CanvasTexture: zG,
      CapsuleBufferGeometry: x5,
      CapsuleGeometry: Th,
      CatmullRomCurve3: lR,
      CineonToneMapping: yB,
      CircleBufferGeometry: _5,
      CircleGeometry: bh,
      ClampToEdgeWrapping: Wn,
      Clock: RA,
      Color: Ie,
      ColorKeyframeTrack: wA,
      ColorManagement: Si,
      CompressedArrayTexture: UG,
      CompressedTexture: pA,
      CompressedTextureLoader: AH,
      ConeBufferGeometry: A5,
      ConeGeometry: Ph,
      CubeCamera: rA,
      CubeReflectionMapping: Wo,
      CubeRefractionMapping: Jo,
      CubeTexture: Sh,
      CubeTextureLoader: MH,
      CubeUVReflectionMapping: ec,
      CubicBezierCurve: gA,
      CubicBezierCurve3: uR,
      CubicInterpolant: ER,
      CullFaceBack: Ox,
      CullFaceFront: j2,
      CullFaceFrontBack: zN,
      CullFaceNone: J2,
      Curve: Jr,
      CurvePath: fR,
      CustomBlending: K2,
      CustomToneMapping: vB,
      CylinderBufferGeometry: M5,
      CylinderGeometry: hl,
      Cylindrical: e5,
      Data3DTexture: tA,
      DataArrayTexture: Dg,
      DataTexture: Bu,
      DataTextureLoader: SH,
      DataUtils: YO,
      DecrementStencilOp: ZN,
      DecrementWrapStencilOp: $N,
      DefaultLoadingManager: vu,
      DepthFormat: Uo,
      DepthStencilFormat: rl,
      DepthTexture: tR,
      DirectionalLight: PA,
      DirectionalLightHelper: c5,
      DiscreteInterpolant: TR,
      DisplayP3ColorSpace: Z1,
      DodecahedronBufferGeometry: S5,
      DodecahedronGeometry: Bh,
      DoubleSide: dr,
      DstAlphaFactor: tB,
      DstColorFactor: iB,
      DynamicCopyUsage: dO,
      DynamicDrawUsage: Ya,
      DynamicReadUsage: cO,
      EdgesGeometry: hR,
      EllipseCurve: zg,
      EqualDepth: uB,
      EqualStencilFunc: iO,
      EquirectangularReflectionMapping: Yf,
      EquirectangularRefractionMapping: Qf,
      Euler: fl,
      EventDispatcher: ds,
      ExtrudeBufferGeometry: w5,
      ExtrudeGeometry: Rh,
      FileLoader: Ki,
      Float16BufferAttribute: tk,
      Float32BufferAttribute: Ve,
      Float64BufferAttribute: nk,
      FloatType: Ns,
      Fog: kg,
      FogExp2: Og,
      FramebufferTexture: kG,
      FrontSide: cs,
      Frustum: Fg,
      GLBufferAttribute: $H,
      GLSL1: mO,
      GLSL3: h_,
      GreaterDepth: fB,
      GreaterEqualDepth: cB,
      GreaterEqualStencilFunc: aO,
      GreaterStencilFunc: sO,
      GridHelper: l5,
      Group: Os,
      HalfFloatType: zu,
      HemisphereLight: PR,
      HemisphereLightHelper: a5,
      HemisphereLightProbe: BH,
      IcosahedronBufferGeometry: C5,
      IcosahedronGeometry: Lh,
      ImageBitmapLoader: FR,
      ImageLoader: sh,
      ImageUtils: eA,
      IncrementStencilOp: QN,
      IncrementWrapStencilOp: qN,
      InstancedBufferAttribute: Ju,
      InstancedBufferGeometry: IR,
      InstancedInterleavedBuffer: qH,
      InstancedMesh: oR,
      Int16BufferAttribute: $O,
      Int32BufferAttribute: ek,
      Int8BufferAttribute: QO,
      IntType: AB,
      InterleavedBuffer: wh,
      InterleavedBufferAttribute: Xo,
      Interpolant: ac,
      InterpolateDiscrete: Gu,
      InterpolateLinear: sl,
      InterpolateSmooth: vm,
      InvertStencilOp: eO,
      KeepStencilOp: xm,
      KeyframeTrack: jr,
      LOD: sR,
      LatheBufferGeometry: E5,
      LatheGeometry: ic,
      Layers: Za,
      LessDepth: lB,
      LessEqualDepth: Xm,
      LessEqualStencilFunc: rO,
      LessStencilFunc: nO,
      Light: na,
      LightProbe: Vg,
      Line: Ys,
      Line3: n5,
      LineBasicMaterial: oi,
      LineCurve: Gg,
      LineCurve3: cR,
      LineDashedMaterial: wR,
      LineLoop: hA,
      LineSegments: Wr,
      LinearEncoding: Ks,
      LinearFilter: rn,
      LinearInterpolant: SA,
      LinearMipMapLinearFilter: JN,
      LinearMipMapNearestFilter: WN,
      LinearMipmapLinearFilter: fs,
      LinearMipmapNearestFilter: Lg,
      LinearSRGBColorSpace: Hu,
      LinearToneMapping: mB,
      Loader: vi,
      LoaderUtils: ls,
      LoadingManager: CA,
      LoopOnce: DB,
      LoopPingPong: NB,
      LoopRepeat: FB,
      LuminanceAlphaFormat: EB,
      LuminanceFormat: CB,
      MOUSE: Ta,
      Material: Cn,
      MaterialLoader: Wg,
      MathUtils: $1,
      Matrix3: wt,
      Matrix4: st,
      MaxEquation: Hx,
      Mesh: Pn,
      MeshBasicMaterial: Wi,
      MeshDepthMaterial: aA,
      MeshDistanceMaterial: lA,
      MeshLambertMaterial: MR,
      MeshMatcapMaterial: SR,
      MeshNormalMaterial: AR,
      MeshPhongMaterial: xR,
      MeshPhysicalMaterial: $s,
      MeshStandardMaterial: oc,
      MeshToonMaterial: _R,
      MinEquation: Gx,
      MirroredRepeatWrapping: Uu,
      MixOperation: dB,
      MultiplyBlending: zx,
      MultiplyOperation: _h,
      NearestFilter: dn,
      NearestMipMapLinearFilter: VN,
      NearestMipMapNearestFilter: HN,
      NearestMipmapLinearFilter: bu,
      NearestMipmapNearestFilter: Zf,
      NeverDepth: oB,
      NeverStencilFunc: tO,
      NoBlending: zs,
      NoColorSpace: XN,
      NoToneMapping: Or,
      NormalAnimationBlendMode: Ig,
      NormalBlending: Xa,
      NotEqualDepth: hB,
      NotEqualStencilFunc: oO,
      NumberKeyframeTrack: ju,
      Object3D: Pt,
      ObjectLoader: TH,
      ObjectSpaceNormalMap: zB,
      OctahedronBufferGeometry: T5,
      OctahedronGeometry: rc,
      OneFactor: q2,
      OneMinusDstAlphaFactor: nB,
      OneMinusDstColorFactor: rB,
      OneMinusSrcAlphaFactor: j1,
      OneMinusSrcColorFactor: eB,
      OrthographicCamera: kr,
      PCFShadowMap: Bg,
      PCFSoftShadowMap: _f,
      PMREMGenerator: p_,
      Path: th,
      PerspectiveCamera: Vt,
      Plane: Mo,
      PlaneBufferGeometry: b5,
      PlaneGeometry: tc,
      PlaneHelper: p5,
      PointLight: bA,
      PointLightHelper: s5,
      Points: dA,
      PointsMaterial: Eh,
      PolarGridHelper: u5,
      PolyhedronBufferGeometry: P5,
      PolyhedronGeometry: qs,
      PositionalAudio: NH,
      PropertyBinding: bt,
      PropertyMixer: OR,
      QuadraticBezierCurve: yA,
      QuadraticBezierCurve3: vA,
      Quaternion: jn,
      QuaternionKeyframeTrack: Ko,
      QuaternionLinearInterpolant: bR,
      RED_GREEN_RGTC2_Format: c_,
      RED_RGTC1_Format: IB,
      REVISION: Pg,
      RGBADepthPacking: UB,
      RGBAFormat: Ti,
      RGBAIntegerFormat: RB,
      RGBA_ASTC_10x10_Format: o_,
      RGBA_ASTC_10x5_Format: i_,
      RGBA_ASTC_10x6_Format: r_,
      RGBA_ASTC_10x8_Format: s_,
      RGBA_ASTC_12x10_Format: a_,
      RGBA_ASTC_12x12_Format: l_,
      RGBA_ASTC_4x4_Format: Yx,
      RGBA_ASTC_5x4_Format: Qx,
      RGBA_ASTC_5x5_Format: Zx,
      RGBA_ASTC_6x5_Format: qx,
      RGBA_ASTC_6x6_Format: $x,
      RGBA_ASTC_8x5_Format: e_,
      RGBA_ASTC_8x6_Format: t_,
      RGBA_ASTC_8x8_Format: n_,
      RGBA_BPTC_Format: ym,
      RGBA_ETC2_EAC_Format: Kx,
      RGBA_PVRTC_2BPPV1_Format: jx,
      RGBA_PVRTC_4BPPV1_Format: Jx,
      RGBA_S3TC_DXT1_Format: pm,
      RGBA_S3TC_DXT3_Format: mm,
      RGBA_S3TC_DXT5_Format: gm,
      RGB_ETC1_Format: LB,
      RGB_ETC2_Format: Xx,
      RGB_PVRTC_2BPPV1_Format: Wx,
      RGB_PVRTC_4BPPV1_Format: Vx,
      RGB_S3TC_DXT1_Format: dm,
      RGFormat: PB,
      RGIntegerFormat: BB,
      RawShaderMaterial: vR,
      Ray: Ah,
      Raycaster: UR,
      RectAreaLight: RR,
      RedFormat: TB,
      RedIntegerFormat: bB,
      ReinhardToneMapping: gB,
      RepeatWrapping: jo,
      ReplaceStencilOp: YN,
      ReverseSubtractEquation: Q2,
      RingBufferGeometry: B5,
      RingGeometry: Ih,
      SIGNED_RED_GREEN_RGTC2_Format: f_,
      SIGNED_RED_RGTC1_Format: u_,
      SRGBColorSpace: Lr,
      Scene: Ym,
      ShaderChunk: mt,
      ShaderLib: Dr,
      ShaderMaterial: hs,
      ShadowMaterial: yR,
      Shape: qa,
      ShapeBufferGeometry: R5,
      ShapeGeometry: Dh,
      ShapePath: y5,
      ShapeUtils: as,
      ShortType: _B,
      Skeleton: Ch,
      SkeletonHelper: r5,
      SkinnedMesh: fA,
      Source: Ha,
      Sphere: Vr,
      SphereBufferGeometry: L5,
      SphereGeometry: sc,
      Spherical: A_,
      SphericalHarmonics3: LR,
      SplineCurve: xA,
      SpotLight: TA,
      SpotLightHelper: i5,
      Sprite: rR,
      SpriteMaterial: cA,
      SrcAlphaFactor: J1,
      SrcAlphaSaturateFactor: sB,
      SrcColorFactor: $2,
      StaticCopyUsage: hO,
      StaticDrawUsage: $f,
      StaticReadUsage: uO,
      StereoCamera: LH,
      StreamCopyUsage: pO,
      StreamDrawUsage: lO,
      StreamReadUsage: fO,
      StringKeyframeTrack: pl,
      SubtractEquation: Y2,
      SubtractiveBlending: Ux,
      TOUCH: ba,
      TangentSpaceNormalMap: Zs,
      TetrahedronBufferGeometry: I5,
      TetrahedronGeometry: Fh,
      Texture: en,
      TextureLoader: Uh,
      TorusBufferGeometry: D5,
      TorusGeometry: Nh,
      TorusKnotBufferGeometry: F5,
      TorusKnotGeometry: Oh,
      Triangle: Ei,
      TriangleFanDrawMode: Q1,
      TriangleStripDrawMode: OB,
      TrianglesDrawMode: jN,
      TubeBufferGeometry: N5,
      TubeGeometry: kh,
      TwoPassDoubleSide: GN,
      UVMapping: Rg,
      Uint16BufferAttribute: nA,
      Uint32BufferAttribute: iA,
      Uint8BufferAttribute: ZO,
      Uint8ClampedBufferAttribute: qO,
      Uniform: DA,
      UniformsGroup: ZH,
      UniformsLib: De,
      UniformsUtils: XB,
      UnsignedByteType: Xs,
      UnsignedInt248Type: Ka,
      UnsignedIntType: bo,
      UnsignedShort4444Type: MB,
      UnsignedShort5551Type: SB,
      UnsignedShortType: K1,
      VSMShadowMap: Ua,
      Vector2: ge,
      Vector3: F,
      Vector4: Ot,
      VectorKeyframeTrack: Xu,
      VideoTexture: OG,
      WebGL1Renderer: nR,
      WebGL3DRenderTarget: kO,
      WebGLArrayRenderTarget: OO,
      WebGLCubeRenderTarget: sA,
      WebGLMultipleRenderTargets: UO,
      WebGLRenderTarget: Gr,
      WebGLRenderer: uA,
      WebGLUtils: $B,
      WireframeGeometry: gR,
      WrapAroundEnding: qf,
      ZeroCurvatureEnding: za,
      ZeroFactor: Z2,
      ZeroSlopeEnding: Ga,
      ZeroStencilOp: KN,
      _SRGBAFormat: Km,
      sRGBEncoding: Tt,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
var Po = {},
  k5 = {
    get exports() {
      return Po;
    },
    set exports(n) {
      Po = n;
    },
  },
  ml = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ ml.ConcurrentRoot = 1;
ml.ContinuousEventPriority = 4;
ml.DefaultEventPriority = 16;
ml.DiscreteEventPriority = 1;
ml.IdleEventPriority = 536870912;
ml.LegacyRoot = 0;
(function (n) {
  n.exports = ml;
})(k5);
function U5(n) {
  let e;
  const t = new Set(),
    i = (c, h) => {
      const d = typeof c == "function" ? c(e) : c;
      if (d !== e) {
        const p = e;
        (e = h ? d : Object.assign({}, e, d)), t.forEach((m) => m(e, p));
      }
    },
    r = () => e,
    s = (c, h = r, d = Object.is) => {
      console.warn(
        "[DEPRECATED] Please use `subscribeWithSelector` middleware"
      );
      let p = h(e);
      function m() {
        const v = h(e);
        if (!d(p, v)) {
          const A = p;
          c((p = v), A);
        }
      }
      return t.add(m), () => t.delete(m);
    },
    l = {
      setState: i,
      getState: r,
      subscribe: (c, h, d) =>
        h || d ? s(c, h, d) : (t.add(c), () => t.delete(c)),
      destroy: () => t.clear(),
    };
  return (e = n(i, r, l)), l;
}
const z5 =
    typeof window > "u" ||
    !window.navigator ||
    /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
  DE = z5 ? H.useEffect : H.useLayoutEffect;
function GR(n) {
  const e = typeof n == "function" ? U5(n) : n,
    t = (i = e.getState, r = Object.is) => {
      const [, s] = H.useReducer((x) => x + 1, 0),
        o = e.getState(),
        a = H.useRef(o),
        l = H.useRef(i),
        c = H.useRef(r),
        h = H.useRef(!1),
        d = H.useRef();
      d.current === void 0 && (d.current = i(o));
      let p,
        m = !1;
      (a.current !== o || l.current !== i || c.current !== r || h.current) &&
        ((p = i(o)), (m = !r(d.current, p))),
        DE(() => {
          m && (d.current = p),
            (a.current = o),
            (l.current = i),
            (c.current = r),
            (h.current = !1);
        });
      const v = H.useRef(o);
      DE(() => {
        const x = () => {
            try {
              const _ = e.getState(),
                S = l.current(_);
              c.current(d.current, S) ||
                ((a.current = _), (d.current = S), s());
            } catch {
              (h.current = !0), s();
            }
          },
          g = e.subscribe(x);
        return e.getState() !== v.current && x(), g;
      }, []);
      const A = m ? p : d.current;
      return H.useDebugValue(A), A;
    };
  return (
    Object.assign(t, e),
    (t[Symbol.iterator] = function () {
      console.warn(
        "[useStore, api] = create() is deprecated and will be removed in v4"
      );
      const i = [t, e];
      return {
        next() {
          const r = i.length <= 0;
          return { value: i.shift(), done: r };
        },
      };
    }),
    t
  );
}
var M_ = {},
  G5 = {
    get exports() {
      return M_;
    },
    set exports(n) {
      M_ = n;
    },
  },
  Qm = {},
  H5 = {
    get exports() {
      return Qm;
    },
    set exports(n) {
      Qm = n;
    },
  },
  mv = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var FE;
function V5() {
  return (
    FE ||
      ((FE = 1),
      (function (n) {
        function e(I, G) {
          var z = I.length;
          I.push(G);
          e: for (; 0 < z; ) {
            var q = (z - 1) >>> 1,
              Q = I[q];
            if (0 < r(Q, G)) (I[q] = G), (I[z] = Q), (z = q);
            else break e;
          }
        }
        function t(I) {
          return I.length === 0 ? null : I[0];
        }
        function i(I) {
          if (I.length === 0) return null;
          var G = I[0],
            z = I.pop();
          if (z !== G) {
            I[0] = z;
            e: for (var q = 0, Q = I.length, ee = Q >>> 1; q < ee; ) {
              var ne = 2 * (q + 1) - 1,
                Ce = I[ne],
                _e = ne + 1,
                $ = I[_e];
              if (0 > r(Ce, z))
                _e < Q && 0 > r($, Ce)
                  ? ((I[q] = $), (I[_e] = z), (q = _e))
                  : ((I[q] = Ce), (I[ne] = z), (q = ne));
              else if (_e < Q && 0 > r($, z)) (I[q] = $), (I[_e] = z), (q = _e);
              else break e;
            }
          }
          return G;
        }
        function r(I, G) {
          var z = I.sortIndex - G.sortIndex;
          return z !== 0 ? z : I.id - G.id;
        }
        if (
          typeof performance == "object" &&
          typeof performance.now == "function"
        ) {
          var s = performance;
          n.unstable_now = function () {
            return s.now();
          };
        } else {
          var o = Date,
            a = o.now();
          n.unstable_now = function () {
            return o.now() - a;
          };
        }
        var l = [],
          c = [],
          h = 1,
          d = null,
          p = 3,
          m = !1,
          v = !1,
          A = !1,
          x = typeof setTimeout == "function" ? setTimeout : null,
          g = typeof clearTimeout == "function" ? clearTimeout : null,
          _ = typeof setImmediate < "u" ? setImmediate : null;
        typeof navigator < "u" &&
          navigator.scheduling !== void 0 &&
          navigator.scheduling.isInputPending !== void 0 &&
          navigator.scheduling.isInputPending.bind(navigator.scheduling);
        function S(I) {
          for (var G = t(c); G !== null; ) {
            if (G.callback === null) i(c);
            else if (G.startTime <= I)
              i(c), (G.sortIndex = G.expirationTime), e(l, G);
            else break;
            G = t(c);
          }
        }
        function w(I) {
          if (((A = !1), S(I), !v))
            if (t(l) !== null) (v = !0), oe(E);
            else {
              var G = t(c);
              G !== null && ae(w, G.startTime - I);
            }
        }
        function E(I, G) {
          (v = !1), A && ((A = !1), g(B), (B = -1)), (m = !0);
          var z = p;
          try {
            for (
              S(G), d = t(l);
              d !== null && (!(d.expirationTime > G) || (I && !U()));

            ) {
              var q = d.callback;
              if (typeof q == "function") {
                (d.callback = null), (p = d.priorityLevel);
                var Q = q(d.expirationTime <= G);
                (G = n.unstable_now()),
                  typeof Q == "function"
                    ? (d.callback = Q)
                    : d === t(l) && i(l),
                  S(G);
              } else i(l);
              d = t(l);
            }
            if (d !== null) var ee = !0;
            else {
              var ne = t(c);
              ne !== null && ae(w, ne.startTime - G), (ee = !1);
            }
            return ee;
          } finally {
            (d = null), (p = z), (m = !1);
          }
        }
        var P = !1,
          L = null,
          B = -1,
          b = 5,
          R = -1;
        function U() {
          return !(n.unstable_now() - R < b);
        }
        function j() {
          if (L !== null) {
            var I = n.unstable_now();
            R = I;
            var G = !0;
            try {
              G = L(!0, I);
            } finally {
              G ? V() : ((P = !1), (L = null));
            }
          } else P = !1;
        }
        var V;
        if (typeof _ == "function")
          V = function () {
            _(j);
          };
        else if (typeof MessageChannel < "u") {
          var J = new MessageChannel(),
            X = J.port2;
          (J.port1.onmessage = j),
            (V = function () {
              X.postMessage(null);
            });
        } else
          V = function () {
            x(j, 0);
          };
        function oe(I) {
          (L = I), P || ((P = !0), V());
        }
        function ae(I, G) {
          B = x(function () {
            I(n.unstable_now());
          }, G);
        }
        (n.unstable_IdlePriority = 5),
          (n.unstable_ImmediatePriority = 1),
          (n.unstable_LowPriority = 4),
          (n.unstable_NormalPriority = 3),
          (n.unstable_Profiling = null),
          (n.unstable_UserBlockingPriority = 2),
          (n.unstable_cancelCallback = function (I) {
            I.callback = null;
          }),
          (n.unstable_continueExecution = function () {
            v || m || ((v = !0), oe(E));
          }),
          (n.unstable_forceFrameRate = function (I) {
            0 > I || 125 < I
              ? console.error(
                  "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
                )
              : (b = 0 < I ? Math.floor(1e3 / I) : 5);
          }),
          (n.unstable_getCurrentPriorityLevel = function () {
            return p;
          }),
          (n.unstable_getFirstCallbackNode = function () {
            return t(l);
          }),
          (n.unstable_next = function (I) {
            switch (p) {
              case 1:
              case 2:
              case 3:
                var G = 3;
                break;
              default:
                G = p;
            }
            var z = p;
            p = G;
            try {
              return I();
            } finally {
              p = z;
            }
          }),
          (n.unstable_pauseExecution = function () {}),
          (n.unstable_requestPaint = function () {}),
          (n.unstable_runWithPriority = function (I, G) {
            switch (I) {
              case 1:
              case 2:
              case 3:
              case 4:
              case 5:
                break;
              default:
                I = 3;
            }
            var z = p;
            p = I;
            try {
              return G();
            } finally {
              p = z;
            }
          }),
          (n.unstable_scheduleCallback = function (I, G, z) {
            var q = n.unstable_now();
            switch (
              (typeof z == "object" && z !== null
                ? ((z = z.delay),
                  (z = typeof z == "number" && 0 < z ? q + z : q))
                : (z = q),
              I)
            ) {
              case 1:
                var Q = -1;
                break;
              case 2:
                Q = 250;
                break;
              case 5:
                Q = 1073741823;
                break;
              case 4:
                Q = 1e4;
                break;
              default:
                Q = 5e3;
            }
            return (
              (Q = z + Q),
              (I = {
                id: h++,
                callback: G,
                priorityLevel: I,
                startTime: z,
                expirationTime: Q,
                sortIndex: -1,
              }),
              z > q
                ? ((I.sortIndex = z),
                  e(c, I),
                  t(l) === null &&
                    I === t(c) &&
                    (A ? (g(B), (B = -1)) : (A = !0), ae(w, z - q)))
                : ((I.sortIndex = Q), e(l, I), v || m || ((v = !0), oe(E))),
              I
            );
          }),
          (n.unstable_shouldYield = U),
          (n.unstable_wrapCallback = function (I) {
            var G = p;
            return function () {
              var z = p;
              p = G;
              try {
                return I.apply(this, arguments);
              } finally {
                p = z;
              }
            };
          });
      })(mv)),
    mv
  );
}
var NE;
function W5() {
  return (
    NE ||
      ((NE = 1),
      (function (n) {
        n.exports = V5();
      })(H5)),
    Qm
  );
}
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var J5 = function (e) {
  var t = {},
    i = H,
    r = W5(),
    s = Object.assign;
  function o(u) {
    for (
      var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + u,
        y = 1;
      y < arguments.length;
      y++
    )
      f += "&args[]=" + encodeURIComponent(arguments[y]);
    return (
      "Minified React error #" +
      u +
      "; visit " +
      f +
      " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    );
  }
  var a = i.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    l = Symbol.for("react.element"),
    c = Symbol.for("react.portal"),
    h = Symbol.for("react.fragment"),
    d = Symbol.for("react.strict_mode"),
    p = Symbol.for("react.profiler"),
    m = Symbol.for("react.provider"),
    v = Symbol.for("react.context"),
    A = Symbol.for("react.forward_ref"),
    x = Symbol.for("react.suspense"),
    g = Symbol.for("react.suspense_list"),
    _ = Symbol.for("react.memo"),
    S = Symbol.for("react.lazy"),
    w = Symbol.for("react.offscreen"),
    E = Symbol.iterator;
  function P(u) {
    return u === null || typeof u != "object"
      ? null
      : ((u = (E && u[E]) || u["@@iterator"]),
        typeof u == "function" ? u : null);
  }
  function L(u) {
    if (u == null) return null;
    if (typeof u == "function") return u.displayName || u.name || null;
    if (typeof u == "string") return u;
    switch (u) {
      case h:
        return "Fragment";
      case c:
        return "Portal";
      case p:
        return "Profiler";
      case d:
        return "StrictMode";
      case x:
        return "Suspense";
      case g:
        return "SuspenseList";
    }
    if (typeof u == "object")
      switch (u.$$typeof) {
        case v:
          return (u.displayName || "Context") + ".Consumer";
        case m:
          return (u._context.displayName || "Context") + ".Provider";
        case A:
          var f = u.render;
          return (
            (u = u.displayName),
            u ||
              ((u = f.displayName || f.name || ""),
              (u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef")),
            u
          );
        case _:
          return (
            (f = u.displayName || null), f !== null ? f : L(u.type) || "Memo"
          );
        case S:
          (f = u._payload), (u = u._init);
          try {
            return L(u(f));
          } catch {}
      }
    return null;
  }
  function B(u) {
    var f = u.type;
    switch (u.tag) {
      case 24:
        return "Cache";
      case 9:
        return (f.displayName || "Context") + ".Consumer";
      case 10:
        return (f._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return (
          (u = f.render),
          (u = u.displayName || u.name || ""),
          f.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef")
        );
      case 7:
        return "Fragment";
      case 5:
        return f;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return L(f);
      case 8:
        return f === d ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof f == "function") return f.displayName || f.name || null;
        if (typeof f == "string") return f;
    }
    return null;
  }
  function b(u) {
    var f = u,
      y = u;
    if (u.alternate) for (; f.return; ) f = f.return;
    else {
      u = f;
      do (f = u), f.flags & 4098 && (y = f.return), (u = f.return);
      while (u);
    }
    return f.tag === 3 ? y : null;
  }
  function R(u) {
    if (b(u) !== u) throw Error(o(188));
  }
  function U(u) {
    var f = u.alternate;
    if (!f) {
      if (((f = b(u)), f === null)) throw Error(o(188));
      return f !== u ? null : u;
    }
    for (var y = u, M = f; ; ) {
      var C = y.return;
      if (C === null) break;
      var T = C.alternate;
      if (T === null) {
        if (((M = C.return), M !== null)) {
          y = M;
          continue;
        }
        break;
      }
      if (C.child === T.child) {
        for (T = C.child; T; ) {
          if (T === y) return R(C), u;
          if (T === M) return R(C), f;
          T = T.sibling;
        }
        throw Error(o(188));
      }
      if (y.return !== M.return) (y = C), (M = T);
      else {
        for (var O = !1, Y = C.child; Y; ) {
          if (Y === y) {
            (O = !0), (y = C), (M = T);
            break;
          }
          if (Y === M) {
            (O = !0), (M = C), (y = T);
            break;
          }
          Y = Y.sibling;
        }
        if (!O) {
          for (Y = T.child; Y; ) {
            if (Y === y) {
              (O = !0), (y = T), (M = C);
              break;
            }
            if (Y === M) {
              (O = !0), (M = T), (y = C);
              break;
            }
            Y = Y.sibling;
          }
          if (!O) throw Error(o(189));
        }
      }
      if (y.alternate !== M) throw Error(o(190));
    }
    if (y.tag !== 3) throw Error(o(188));
    return y.stateNode.current === y ? u : f;
  }
  function j(u) {
    return (u = U(u)), u !== null ? V(u) : null;
  }
  function V(u) {
    if (u.tag === 5 || u.tag === 6) return u;
    for (u = u.child; u !== null; ) {
      var f = V(u);
      if (f !== null) return f;
      u = u.sibling;
    }
    return null;
  }
  function J(u) {
    if (u.tag === 5 || u.tag === 6) return u;
    for (u = u.child; u !== null; ) {
      if (u.tag !== 4) {
        var f = J(u);
        if (f !== null) return f;
      }
      u = u.sibling;
    }
    return null;
  }
  var X = Array.isArray,
    oe = e.getPublicInstance,
    ae = e.getRootHostContext,
    I = e.getChildHostContext,
    G = e.prepareForCommit,
    z = e.resetAfterCommit,
    q = e.createInstance,
    Q = e.appendInitialChild,
    ee = e.finalizeInitialChildren,
    ne = e.prepareUpdate,
    Ce = e.shouldSetTextContent,
    _e = e.createTextInstance,
    $ = e.scheduleTimeout,
    je = e.cancelTimeout,
    Xe = e.noTimeout,
    ve = e.isPrimaryRenderer,
    Me = e.supportsMutation,
    me = e.supportsPersistence,
    se = e.supportsHydration,
    xe = e.getInstanceFromNode,
    Ne = e.preparePortalMount,
    Le = e.getCurrentEventPriority,
    We = e.detachDeletedInstance,
    Ke = e.supportsMicrotasks,
    Je = e.scheduleMicrotask,
    nt = e.supportsTestSelectors,
    _t = e.findFiberRoot,
    k = e.getBoundingRect,
    D = e.getTextContent,
    le = e.isHiddenSubtree,
    Ee = e.matchAccessibilityRole,
    Te = e.setFocusIfFocusable,
    Re = e.setupIntersectionObserver,
    et = e.appendChild,
    Ue = e.appendChildToContainer,
    de = e.commitTextUpdate,
    He = e.commitMount,
    W = e.commitUpdate,
    he = e.insertBefore,
    Ae = e.insertInContainerBefore,
    Pe = e.removeChild,
    qe = e.removeChildFromContainer,
    ft = e.resetTextContent,
    Ut = e.hideInstance,
    K = e.hideTextInstance,
    ce = e.unhideInstance,
    Se = e.unhideTextInstance,
    ke = e.clearContainer,
    Qe = e.cloneInstance,
    zt = e.createContainerChildSet,
    Wt = e.appendChildToContainerChildSet,
    Ln = e.finalizeContainerChildren,
    xr = e.replaceContainerChildren,
    Qt = e.cloneHiddenInstance,
    ai = e.cloneHiddenTextInstance,
    qi = e.canHydrateInstance,
    vl = e.canHydrateTextInstance,
    jh = e.canHydrateSuspenseInstance,
    Xh = e.isSuspenseInstancePending,
    uc = e.isSuspenseInstanceFallback,
    s0 = e.registerSuspenseInstanceRetry,
    N = e.getNextHydratableSibling,
    re = e.getFirstHydratableChild,
    pe = e.getFirstHydratableChildWithinContainer,
    te = e.getFirstHydratableChildWithinSuspenseInstance,
    ye = e.hydrateInstance,
    $e = e.hydrateTextInstance,
    rt = e.hydrateSuspenseInstance,
    ot = e.getNextHydratableInstanceAfterSuspenseInstance,
    ht = e.commitHydratedContainer,
    yt = e.commitHydratedSuspenseInstance,
    vt = e.clearSuspenseBoundary,
    At = e.clearSuspenseBoundaryFromContainer,
    Ft = e.shouldDeleteUnhydratedTailInstances,
    zn = e.didNotMatchHydratedContainerTextInstance,
    Ii = e.didNotMatchHydratedTextInstance,
    _r;
  function Jt(u) {
    if (_r === void 0)
      try {
        throw Error();
      } catch (y) {
        var f = y.stack.trim().match(/\n( *(at )?)/);
        _r = (f && f[1]) || "";
      }
    return (
      `
` +
      _r +
      u
    );
  }
  var Mt = !1;
  function sa(u, f) {
    if (!u || Mt) return "";
    Mt = !0;
    var y = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (f)
        if (
          ((f = function () {
            throw Error();
          }),
          Object.defineProperty(f.prototype, "props", {
            set: function () {
              throw Error();
            },
          }),
          typeof Reflect == "object" && Reflect.construct)
        ) {
          try {
            Reflect.construct(f, []);
          } catch (Be) {
            var M = Be;
          }
          Reflect.construct(u, [], f);
        } else {
          try {
            f.call();
          } catch (Be) {
            M = Be;
          }
          u.call(f.prototype);
        }
      else {
        try {
          throw Error();
        } catch (Be) {
          M = Be;
        }
        u();
      }
    } catch (Be) {
      if (Be && M && typeof Be.stack == "string") {
        for (
          var C = Be.stack.split(`
`),
            T = M.stack.split(`
`),
            O = C.length - 1,
            Y = T.length - 1;
          1 <= O && 0 <= Y && C[O] !== T[Y];

        )
          Y--;
        for (; 1 <= O && 0 <= Y; O--, Y--)
          if (C[O] !== T[Y]) {
            if (O !== 1 || Y !== 1)
              do
                if ((O--, Y--, 0 > Y || C[O] !== T[Y])) {
                  var fe =
                    `
` + C[O].replace(" at new ", " at ");
                  return (
                    u.displayName &&
                      fe.includes("<anonymous>") &&
                      (fe = fe.replace("<anonymous>", u.displayName)),
                    fe
                  );
                }
              while (1 <= O && 0 <= Y);
            break;
          }
      }
    } finally {
      (Mt = !1), (Error.prepareStackTrace = y);
    }
    return (u = u ? u.displayName || u.name : "") ? Jt(u) : "";
  }
  var vn = Object.prototype.hasOwnProperty,
    Ar = [],
    ps = -1;
  function xi(u) {
    return { current: u };
  }
  function Nt(u) {
    0 > ps || ((u.current = Ar[ps]), (Ar[ps] = null), ps--);
  }
  function dt(u, f) {
    ps++, (Ar[ps] = u.current), (u.current = f);
  }
  var Kn = {},
    xn = xi(Kn),
    Gt = xi(!1),
    Mr = Kn;
  function eo(u, f) {
    var y = u.type.contextTypes;
    if (!y) return Kn;
    var M = u.stateNode;
    if (M && M.__reactInternalMemoizedUnmaskedChildContext === f)
      return M.__reactInternalMemoizedMaskedChildContext;
    var C = {},
      T;
    for (T in y) C[T] = f[T];
    return (
      M &&
        ((u = u.stateNode),
        (u.__reactInternalMemoizedUnmaskedChildContext = f),
        (u.__reactInternalMemoizedMaskedChildContext = C)),
      C
    );
  }
  function Gn(u) {
    return (u = u.childContextTypes), u != null;
  }
  function Kh() {
    Nt(Gt), Nt(xn);
  }
  function dM(u, f, y) {
    if (xn.current !== Kn) throw Error(o(168));
    dt(xn, f), dt(Gt, y);
  }
  function pM(u, f, y) {
    var M = u.stateNode;
    if (((f = f.childContextTypes), typeof M.getChildContext != "function"))
      return y;
    M = M.getChildContext();
    for (var C in M) if (!(C in f)) throw Error(o(108, B(u) || "Unknown", C));
    return s({}, y, M);
  }
  function Yh(u) {
    return (
      (u =
        ((u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext) ||
        Kn),
      (Mr = xn.current),
      dt(xn, u),
      dt(Gt, Gt.current),
      !0
    );
  }
  function mM(u, f, y) {
    var M = u.stateNode;
    if (!M) throw Error(o(169));
    y
      ? ((u = pM(u, f, Mr)),
        (M.__reactInternalMemoizedMergedChildContext = u),
        Nt(Gt),
        Nt(xn),
        dt(xn, u))
      : Nt(Gt),
      dt(Gt, y);
  }
  var Sr = Math.clz32 ? Math.clz32 : jL,
    WL = Math.log,
    JL = Math.LN2;
  function jL(u) {
    return (u >>>= 0), u === 0 ? 32 : (31 - ((WL(u) / JL) | 0)) | 0;
  }
  var Qh = 64,
    Zh = 4194304;
  function cc(u) {
    switch (u & -u) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return u & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return u;
    }
  }
  function qh(u, f) {
    var y = u.pendingLanes;
    if (y === 0) return 0;
    var M = 0,
      C = u.suspendedLanes,
      T = u.pingedLanes,
      O = y & 268435455;
    if (O !== 0) {
      var Y = O & ~C;
      Y !== 0 ? (M = cc(Y)) : ((T &= O), T !== 0 && (M = cc(T)));
    } else (O = y & ~C), O !== 0 ? (M = cc(O)) : T !== 0 && (M = cc(T));
    if (M === 0) return 0;
    if (
      f !== 0 &&
      f !== M &&
      !(f & C) &&
      ((C = M & -M), (T = f & -f), C >= T || (C === 16 && (T & 4194240) !== 0))
    )
      return f;
    if ((M & 4 && (M |= y & 16), (f = u.entangledLanes), f !== 0))
      for (u = u.entanglements, f &= M; 0 < f; )
        (y = 31 - Sr(f)), (C = 1 << y), (M |= u[y]), (f &= ~C);
    return M;
  }
  function XL(u, f) {
    switch (u) {
      case 1:
      case 2:
      case 4:
        return f + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function KL(u, f) {
    for (
      var y = u.suspendedLanes,
        M = u.pingedLanes,
        C = u.expirationTimes,
        T = u.pendingLanes;
      0 < T;

    ) {
      var O = 31 - Sr(T),
        Y = 1 << O,
        fe = C[O];
      fe === -1
        ? (!(Y & y) || Y & M) && (C[O] = XL(Y, f))
        : fe <= f && (u.expiredLanes |= Y),
        (T &= ~Y);
    }
  }
  function o0(u) {
    return (
      (u = u.pendingLanes & -1073741825),
      u !== 0 ? u : u & 1073741824 ? 1073741824 : 0
    );
  }
  function a0(u) {
    for (var f = [], y = 0; 31 > y; y++) f.push(u);
    return f;
  }
  function fc(u, f, y) {
    (u.pendingLanes |= f),
      f !== 536870912 && ((u.suspendedLanes = 0), (u.pingedLanes = 0)),
      (u = u.eventTimes),
      (f = 31 - Sr(f)),
      (u[f] = y);
  }
  function YL(u, f) {
    var y = u.pendingLanes & ~f;
    (u.pendingLanes = f),
      (u.suspendedLanes = 0),
      (u.pingedLanes = 0),
      (u.expiredLanes &= f),
      (u.mutableReadLanes &= f),
      (u.entangledLanes &= f),
      (f = u.entanglements);
    var M = u.eventTimes;
    for (u = u.expirationTimes; 0 < y; ) {
      var C = 31 - Sr(y),
        T = 1 << C;
      (f[C] = 0), (M[C] = -1), (u[C] = -1), (y &= ~T);
    }
  }
  function l0(u, f) {
    var y = (u.entangledLanes |= f);
    for (u = u.entanglements; y; ) {
      var M = 31 - Sr(y),
        C = 1 << M;
      (C & f) | (u[M] & f) && (u[M] |= f), (y &= ~C);
    }
  }
  var Rt = 0;
  function gM(u) {
    return (
      (u &= -u), 1 < u ? (4 < u ? (u & 268435455 ? 16 : 536870912) : 4) : 1
    );
  }
  var u0 = r.unstable_scheduleCallback,
    yM = r.unstable_cancelCallback,
    QL = r.unstable_shouldYield,
    ZL = r.unstable_requestPaint,
    In = r.unstable_now,
    c0 = r.unstable_ImmediatePriority,
    qL = r.unstable_UserBlockingPriority,
    f0 = r.unstable_NormalPriority,
    $L = r.unstable_IdlePriority,
    $h = null,
    Xr = null;
  function eI(u) {
    if (Xr && typeof Xr.onCommitFiberRoot == "function")
      try {
        Xr.onCommitFiberRoot($h, u, void 0, (u.current.flags & 128) === 128);
      } catch {}
  }
  function tI(u, f) {
    return (u === f && (u !== 0 || 1 / u === 1 / f)) || (u !== u && f !== f);
  }
  var Kr = typeof Object.is == "function" ? Object.is : tI,
    ms = null,
    ed = !1,
    h0 = !1;
  function vM(u) {
    ms === null ? (ms = [u]) : ms.push(u);
  }
  function nI(u) {
    (ed = !0), vM(u);
  }
  function Yr() {
    if (!h0 && ms !== null) {
      h0 = !0;
      var u = 0,
        f = Rt;
      try {
        var y = ms;
        for (Rt = 1; u < y.length; u++) {
          var M = y[u];
          do M = M(!0);
          while (M !== null);
        }
        (ms = null), (ed = !1);
      } catch (C) {
        throw (ms !== null && (ms = ms.slice(u + 1)), u0(c0, Yr), C);
      } finally {
        (Rt = f), (h0 = !1);
      }
    }
    return null;
  }
  var iI = a.ReactCurrentBatchConfig;
  function td(u, f) {
    if (Kr(u, f)) return !0;
    if (
      typeof u != "object" ||
      u === null ||
      typeof f != "object" ||
      f === null
    )
      return !1;
    var y = Object.keys(u),
      M = Object.keys(f);
    if (y.length !== M.length) return !1;
    for (M = 0; M < y.length; M++) {
      var C = y[M];
      if (!vn.call(f, C) || !Kr(u[C], f[C])) return !1;
    }
    return !0;
  }
  function rI(u) {
    switch (u.tag) {
      case 5:
        return Jt(u.type);
      case 16:
        return Jt("Lazy");
      case 13:
        return Jt("Suspense");
      case 19:
        return Jt("SuspenseList");
      case 0:
      case 2:
      case 15:
        return (u = sa(u.type, !1)), u;
      case 11:
        return (u = sa(u.type.render, !1)), u;
      case 1:
        return (u = sa(u.type, !0)), u;
      default:
        return "";
    }
  }
  function wr(u, f) {
    if (u && u.defaultProps) {
      (f = s({}, f)), (u = u.defaultProps);
      for (var y in u) f[y] === void 0 && (f[y] = u[y]);
      return f;
    }
    return f;
  }
  var nd = xi(null),
    id = null,
    xl = null,
    d0 = null;
  function p0() {
    d0 = xl = id = null;
  }
  function xM(u, f, y) {
    ve
      ? (dt(nd, f._currentValue), (f._currentValue = y))
      : (dt(nd, f._currentValue2), (f._currentValue2 = y));
  }
  function m0(u) {
    var f = nd.current;
    Nt(nd), ve ? (u._currentValue = f) : (u._currentValue2 = f);
  }
  function g0(u, f, y) {
    for (; u !== null; ) {
      var M = u.alternate;
      if (
        ((u.childLanes & f) !== f
          ? ((u.childLanes |= f), M !== null && (M.childLanes |= f))
          : M !== null && (M.childLanes & f) !== f && (M.childLanes |= f),
        u === y)
      )
        break;
      u = u.return;
    }
  }
  function _l(u, f) {
    (id = u),
      (d0 = xl = null),
      (u = u.dependencies),
      u !== null &&
        u.firstContext !== null &&
        (u.lanes & f && (Ni = !0), (u.firstContext = null));
  }
  function $i(u) {
    var f = ve ? u._currentValue : u._currentValue2;
    if (d0 !== u)
      if (((u = { context: u, memoizedValue: f, next: null }), xl === null)) {
        if (id === null) throw Error(o(308));
        (xl = u), (id.dependencies = { lanes: 0, firstContext: u });
      } else xl = xl.next = u;
    return f;
  }
  var Qr = null,
    to = !1;
  function y0(u) {
    u.updateQueue = {
      baseState: u.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, interleaved: null, lanes: 0 },
      effects: null,
    };
  }
  function _M(u, f) {
    (u = u.updateQueue),
      f.updateQueue === u &&
        (f.updateQueue = {
          baseState: u.baseState,
          firstBaseUpdate: u.firstBaseUpdate,
          lastBaseUpdate: u.lastBaseUpdate,
          shared: u.shared,
          effects: u.effects,
        });
  }
  function gs(u, f) {
    return {
      eventTime: u,
      lane: f,
      tag: 0,
      payload: null,
      callback: null,
      next: null,
    };
  }
  function no(u, f) {
    var y = u.updateQueue;
    y !== null &&
      ((y = y.shared),
      _n !== null && u.mode & 1 && !(xt & 2)
        ? ((u = y.interleaved),
          u === null
            ? ((f.next = f), Qr === null ? (Qr = [y]) : Qr.push(y))
            : ((f.next = u.next), (u.next = f)),
          (y.interleaved = f))
        : ((u = y.pending),
          u === null ? (f.next = f) : ((f.next = u.next), (u.next = f)),
          (y.pending = f)));
  }
  function rd(u, f, y) {
    if (
      ((f = f.updateQueue), f !== null && ((f = f.shared), (y & 4194240) !== 0))
    ) {
      var M = f.lanes;
      (M &= u.pendingLanes), (y |= M), (f.lanes = y), l0(u, y);
    }
  }
  function AM(u, f) {
    var y = u.updateQueue,
      M = u.alternate;
    if (M !== null && ((M = M.updateQueue), y === M)) {
      var C = null,
        T = null;
      if (((y = y.firstBaseUpdate), y !== null)) {
        do {
          var O = {
            eventTime: y.eventTime,
            lane: y.lane,
            tag: y.tag,
            payload: y.payload,
            callback: y.callback,
            next: null,
          };
          T === null ? (C = T = O) : (T = T.next = O), (y = y.next);
        } while (y !== null);
        T === null ? (C = T = f) : (T = T.next = f);
      } else C = T = f;
      (y = {
        baseState: M.baseState,
        firstBaseUpdate: C,
        lastBaseUpdate: T,
        shared: M.shared,
        effects: M.effects,
      }),
        (u.updateQueue = y);
      return;
    }
    (u = y.lastBaseUpdate),
      u === null ? (y.firstBaseUpdate = f) : (u.next = f),
      (y.lastBaseUpdate = f);
  }
  function sd(u, f, y, M) {
    var C = u.updateQueue;
    to = !1;
    var T = C.firstBaseUpdate,
      O = C.lastBaseUpdate,
      Y = C.shared.pending;
    if (Y !== null) {
      C.shared.pending = null;
      var fe = Y,
        Be = fe.next;
      (fe.next = null), O === null ? (T = Be) : (O.next = Be), (O = fe);
      var Ge = u.alternate;
      Ge !== null &&
        ((Ge = Ge.updateQueue),
        (Y = Ge.lastBaseUpdate),
        Y !== O &&
          (Y === null ? (Ge.firstBaseUpdate = Be) : (Y.next = Be),
          (Ge.lastBaseUpdate = fe)));
    }
    if (T !== null) {
      var at = C.baseState;
      (O = 0), (Ge = Be = fe = null), (Y = T);
      do {
        var tt = Y.lane,
          Ht = Y.eventTime;
        if ((M & tt) === tt) {
          Ge !== null &&
            (Ge = Ge.next =
              {
                eventTime: Ht,
                lane: 0,
                tag: Y.tag,
                payload: Y.payload,
                callback: Y.callback,
                next: null,
              });
          e: {
            var Ze = u,
              qn = Y;
            switch (((tt = f), (Ht = y), qn.tag)) {
              case 1:
                if (((Ze = qn.payload), typeof Ze == "function")) {
                  at = Ze.call(Ht, at, tt);
                  break e;
                }
                at = Ze;
                break e;
              case 3:
                Ze.flags = (Ze.flags & -65537) | 128;
              case 0:
                if (
                  ((Ze = qn.payload),
                  (tt = typeof Ze == "function" ? Ze.call(Ht, at, tt) : Ze),
                  tt == null)
                )
                  break e;
                at = s({}, at, tt);
                break e;
              case 2:
                to = !0;
            }
          }
          Y.callback !== null &&
            Y.lane !== 0 &&
            ((u.flags |= 64),
            (tt = C.effects),
            tt === null ? (C.effects = [Y]) : tt.push(Y));
        } else
          (Ht = {
            eventTime: Ht,
            lane: tt,
            tag: Y.tag,
            payload: Y.payload,
            callback: Y.callback,
            next: null,
          }),
            Ge === null ? ((Be = Ge = Ht), (fe = at)) : (Ge = Ge.next = Ht),
            (O |= tt);
        if (((Y = Y.next), Y === null)) {
          if (((Y = C.shared.pending), Y === null)) break;
          (tt = Y),
            (Y = tt.next),
            (tt.next = null),
            (C.lastBaseUpdate = tt),
            (C.shared.pending = null);
        }
      } while (1);
      if (
        (Ge === null && (fe = at),
        (C.baseState = fe),
        (C.firstBaseUpdate = Be),
        (C.lastBaseUpdate = Ge),
        (f = C.shared.interleaved),
        f !== null)
      ) {
        C = f;
        do (O |= C.lane), (C = C.next);
        while (C !== f);
      } else T === null && (C.shared.lanes = 0);
      (Pl |= O), (u.lanes = O), (u.memoizedState = at);
    }
  }
  function MM(u, f, y) {
    if (((u = f.effects), (f.effects = null), u !== null))
      for (f = 0; f < u.length; f++) {
        var M = u[f],
          C = M.callback;
        if (C !== null) {
          if (((M.callback = null), (M = y), typeof C != "function"))
            throw Error(o(191, C));
          C.call(M);
        }
      }
  }
  var SM = new i.Component().refs;
  function v0(u, f, y, M) {
    (f = u.memoizedState),
      (y = y(M, f)),
      (y = y == null ? f : s({}, f, y)),
      (u.memoizedState = y),
      u.lanes === 0 && (u.updateQueue.baseState = y);
  }
  var od = {
    isMounted: function (u) {
      return (u = u._reactInternals) ? b(u) === u : !1;
    },
    enqueueSetState: function (u, f, y) {
      u = u._reactInternals;
      var M = ui(),
        C = so(u),
        T = gs(M, C);
      (T.payload = f),
        y != null && (T.callback = y),
        no(u, T),
        (f = rr(u, C, M)),
        f !== null && rd(f, u, C);
    },
    enqueueReplaceState: function (u, f, y) {
      u = u._reactInternals;
      var M = ui(),
        C = so(u),
        T = gs(M, C);
      (T.tag = 1),
        (T.payload = f),
        y != null && (T.callback = y),
        no(u, T),
        (f = rr(u, C, M)),
        f !== null && rd(f, u, C);
    },
    enqueueForceUpdate: function (u, f) {
      u = u._reactInternals;
      var y = ui(),
        M = so(u),
        C = gs(y, M);
      (C.tag = 2),
        f != null && (C.callback = f),
        no(u, C),
        (f = rr(u, M, y)),
        f !== null && rd(f, u, M);
    },
  };
  function wM(u, f, y, M, C, T, O) {
    return (
      (u = u.stateNode),
      typeof u.shouldComponentUpdate == "function"
        ? u.shouldComponentUpdate(M, T, O)
        : f.prototype && f.prototype.isPureReactComponent
        ? !td(y, M) || !td(C, T)
        : !0
    );
  }
  function CM(u, f, y) {
    var M = !1,
      C = Kn,
      T = f.contextType;
    return (
      typeof T == "object" && T !== null
        ? (T = $i(T))
        : ((C = Gn(f) ? Mr : xn.current),
          (M = f.contextTypes),
          (T = (M = M != null) ? eo(u, C) : Kn)),
      (f = new f(y, T)),
      (u.memoizedState =
        f.state !== null && f.state !== void 0 ? f.state : null),
      (f.updater = od),
      (u.stateNode = f),
      (f._reactInternals = u),
      M &&
        ((u = u.stateNode),
        (u.__reactInternalMemoizedUnmaskedChildContext = C),
        (u.__reactInternalMemoizedMaskedChildContext = T)),
      f
    );
  }
  function EM(u, f, y, M) {
    (u = f.state),
      typeof f.componentWillReceiveProps == "function" &&
        f.componentWillReceiveProps(y, M),
      typeof f.UNSAFE_componentWillReceiveProps == "function" &&
        f.UNSAFE_componentWillReceiveProps(y, M),
      f.state !== u && od.enqueueReplaceState(f, f.state, null);
  }
  function x0(u, f, y, M) {
    var C = u.stateNode;
    (C.props = y), (C.state = u.memoizedState), (C.refs = SM), y0(u);
    var T = f.contextType;
    typeof T == "object" && T !== null
      ? (C.context = $i(T))
      : ((T = Gn(f) ? Mr : xn.current), (C.context = eo(u, T))),
      (C.state = u.memoizedState),
      (T = f.getDerivedStateFromProps),
      typeof T == "function" && (v0(u, f, T, y), (C.state = u.memoizedState)),
      typeof f.getDerivedStateFromProps == "function" ||
        typeof C.getSnapshotBeforeUpdate == "function" ||
        (typeof C.UNSAFE_componentWillMount != "function" &&
          typeof C.componentWillMount != "function") ||
        ((f = C.state),
        typeof C.componentWillMount == "function" && C.componentWillMount(),
        typeof C.UNSAFE_componentWillMount == "function" &&
          C.UNSAFE_componentWillMount(),
        f !== C.state && od.enqueueReplaceState(C, C.state, null),
        sd(u, y, C, M),
        (C.state = u.memoizedState)),
      typeof C.componentDidMount == "function" && (u.flags |= 4194308);
  }
  var Al = [],
    Ml = 0,
    ad = null,
    ld = 0,
    er = [],
    tr = 0,
    oa = null,
    ys = 1,
    vs = "";
  function aa(u, f) {
    (Al[Ml++] = ld), (Al[Ml++] = ad), (ad = u), (ld = f);
  }
  function TM(u, f, y) {
    (er[tr++] = ys), (er[tr++] = vs), (er[tr++] = oa), (oa = u);
    var M = ys;
    u = vs;
    var C = 32 - Sr(M) - 1;
    (M &= ~(1 << C)), (y += 1);
    var T = 32 - Sr(f) + C;
    if (30 < T) {
      var O = C - (C % 5);
      (T = (M & ((1 << O) - 1)).toString(32)),
        (M >>= O),
        (C -= O),
        (ys = (1 << (32 - Sr(f) + C)) | (y << C) | M),
        (vs = T + u);
    } else (ys = (1 << T) | (y << C) | M), (vs = u);
  }
  function _0(u) {
    u.return !== null && (aa(u, 1), TM(u, 1, 0));
  }
  function A0(u) {
    for (; u === ad; )
      (ad = Al[--Ml]), (Al[Ml] = null), (ld = Al[--Ml]), (Al[Ml] = null);
    for (; u === oa; )
      (oa = er[--tr]),
        (er[tr] = null),
        (vs = er[--tr]),
        (er[tr] = null),
        (ys = er[--tr]),
        (er[tr] = null);
  }
  var Di = null,
    Fi = null,
    Zt = !1,
    hc = !1,
    Cr = null;
  function bM(u, f) {
    var y = sr(5, null, null, 0);
    (y.elementType = "DELETED"),
      (y.stateNode = f),
      (y.return = u),
      (f = u.deletions),
      f === null ? ((u.deletions = [y]), (u.flags |= 16)) : f.push(y);
  }
  function PM(u, f) {
    switch (u.tag) {
      case 5:
        return (
          (f = qi(f, u.type, u.pendingProps)),
          f !== null ? ((u.stateNode = f), (Di = u), (Fi = re(f)), !0) : !1
        );
      case 6:
        return (
          (f = vl(f, u.pendingProps)),
          f !== null ? ((u.stateNode = f), (Di = u), (Fi = null), !0) : !1
        );
      case 13:
        if (((f = jh(f)), f !== null)) {
          var y = oa !== null ? { id: ys, overflow: vs } : null;
          return (
            (u.memoizedState = {
              dehydrated: f,
              treeContext: y,
              retryLane: 1073741824,
            }),
            (y = sr(18, null, null, 0)),
            (y.stateNode = f),
            (y.return = u),
            (u.child = y),
            (Di = u),
            (Fi = null),
            !0
          );
        }
        return !1;
      default:
        return !1;
    }
  }
  function M0(u) {
    return (u.mode & 1) !== 0 && (u.flags & 128) === 0;
  }
  function S0(u) {
    if (Zt) {
      var f = Fi;
      if (f) {
        var y = f;
        if (!PM(u, f)) {
          if (M0(u)) throw Error(o(418));
          f = N(y);
          var M = Di;
          f && PM(u, f)
            ? bM(M, y)
            : ((u.flags = (u.flags & -4097) | 2), (Zt = !1), (Di = u));
        }
      } else {
        if (M0(u)) throw Error(o(418));
        (u.flags = (u.flags & -4097) | 2), (Zt = !1), (Di = u);
      }
    }
  }
  function BM(u) {
    for (
      u = u.return;
      u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13;

    )
      u = u.return;
    Di = u;
  }
  function dc(u) {
    if (!se || u !== Di) return !1;
    if (!Zt) return BM(u), (Zt = !0), !1;
    if (
      u.tag !== 3 &&
      (u.tag !== 5 || (Ft(u.type) && !Ce(u.type, u.memoizedProps)))
    ) {
      var f = Fi;
      if (f) {
        if (M0(u)) {
          for (u = Fi; u; ) u = N(u);
          throw Error(o(418));
        }
        for (; f; ) bM(u, f), (f = N(f));
      }
    }
    if ((BM(u), u.tag === 13)) {
      if (!se) throw Error(o(316));
      if (((u = u.memoizedState), (u = u !== null ? u.dehydrated : null), !u))
        throw Error(o(317));
      Fi = ot(u);
    } else Fi = Di ? N(u.stateNode) : null;
    return !0;
  }
  function Sl() {
    se && ((Fi = Di = null), (hc = Zt = !1));
  }
  function w0(u) {
    Cr === null ? (Cr = [u]) : Cr.push(u);
  }
  function pc(u, f, y) {
    if (
      ((u = y.ref),
      u !== null && typeof u != "function" && typeof u != "object")
    ) {
      if (y._owner) {
        if (((y = y._owner), y)) {
          if (y.tag !== 1) throw Error(o(309));
          var M = y.stateNode;
        }
        if (!M) throw Error(o(147, u));
        var C = M,
          T = "" + u;
        return f !== null &&
          f.ref !== null &&
          typeof f.ref == "function" &&
          f.ref._stringRef === T
          ? f.ref
          : ((f = function (O) {
              var Y = C.refs;
              Y === SM && (Y = C.refs = {}),
                O === null ? delete Y[T] : (Y[T] = O);
            }),
            (f._stringRef = T),
            f);
      }
      if (typeof u != "string") throw Error(o(284));
      if (!y._owner) throw Error(o(290, u));
    }
    return u;
  }
  function ud(u, f) {
    throw (
      ((u = Object.prototype.toString.call(f)),
      Error(
        o(
          31,
          u === "[object Object]"
            ? "object with keys {" + Object.keys(f).join(", ") + "}"
            : u
        )
      ))
    );
  }
  function RM(u) {
    var f = u._init;
    return f(u._payload);
  }
  function LM(u) {
    function f(ie, Z) {
      if (u) {
        var ue = ie.deletions;
        ue === null ? ((ie.deletions = [Z]), (ie.flags |= 16)) : ue.push(Z);
      }
    }
    function y(ie, Z) {
      if (!u) return null;
      for (; Z !== null; ) f(ie, Z), (Z = Z.sibling);
      return null;
    }
    function M(ie, Z) {
      for (ie = new Map(); Z !== null; )
        Z.key !== null ? ie.set(Z.key, Z) : ie.set(Z.index, Z), (Z = Z.sibling);
      return ie;
    }
    function C(ie, Z) {
      return (ie = ao(ie, Z)), (ie.index = 0), (ie.sibling = null), ie;
    }
    function T(ie, Z, ue) {
      return (
        (ie.index = ue),
        u
          ? ((ue = ie.alternate),
            ue !== null
              ? ((ue = ue.index), ue < Z ? ((ie.flags |= 2), Z) : ue)
              : ((ie.flags |= 2), Z))
          : ((ie.flags |= 1048576), Z)
      );
    }
    function O(ie) {
      return u && ie.alternate === null && (ie.flags |= 2), ie;
    }
    function Y(ie, Z, ue, Oe) {
      return Z === null || Z.tag !== 6
        ? ((Z = ay(ue, ie.mode, Oe)), (Z.return = ie), Z)
        : ((Z = C(Z, ue)), (Z.return = ie), Z);
    }
    function fe(ie, Z, ue, Oe) {
      var Ye = ue.type;
      return Ye === h
        ? Ge(ie, Z, ue.props.children, Oe, ue.key)
        : Z !== null &&
          (Z.elementType === Ye ||
            (typeof Ye == "object" &&
              Ye !== null &&
              Ye.$$typeof === S &&
              RM(Ye) === Z.type))
        ? ((Oe = C(Z, ue.props)),
          (Oe.ref = pc(ie, Z, ue)),
          (Oe.return = ie),
          Oe)
        : ((Oe = zd(ue.type, ue.key, ue.props, null, ie.mode, Oe)),
          (Oe.ref = pc(ie, Z, ue)),
          (Oe.return = ie),
          Oe);
    }
    function Be(ie, Z, ue, Oe) {
      return Z === null ||
        Z.tag !== 4 ||
        Z.stateNode.containerInfo !== ue.containerInfo ||
        Z.stateNode.implementation !== ue.implementation
        ? ((Z = ly(ue, ie.mode, Oe)), (Z.return = ie), Z)
        : ((Z = C(Z, ue.children || [])), (Z.return = ie), Z);
    }
    function Ge(ie, Z, ue, Oe, Ye) {
      return Z === null || Z.tag !== 7
        ? ((Z = pa(ue, ie.mode, Oe, Ye)), (Z.return = ie), Z)
        : ((Z = C(Z, ue)), (Z.return = ie), Z);
    }
    function at(ie, Z, ue) {
      if ((typeof Z == "string" && Z !== "") || typeof Z == "number")
        return (Z = ay("" + Z, ie.mode, ue)), (Z.return = ie), Z;
      if (typeof Z == "object" && Z !== null) {
        switch (Z.$$typeof) {
          case l:
            return (
              (ue = zd(Z.type, Z.key, Z.props, null, ie.mode, ue)),
              (ue.ref = pc(ie, null, Z)),
              (ue.return = ie),
              ue
            );
          case c:
            return (Z = ly(Z, ie.mode, ue)), (Z.return = ie), Z;
          case S:
            var Oe = Z._init;
            return at(ie, Oe(Z._payload), ue);
        }
        if (X(Z) || P(Z))
          return (Z = pa(Z, ie.mode, ue, null)), (Z.return = ie), Z;
        ud(ie, Z);
      }
      return null;
    }
    function tt(ie, Z, ue, Oe) {
      var Ye = Z !== null ? Z.key : null;
      if ((typeof ue == "string" && ue !== "") || typeof ue == "number")
        return Ye !== null ? null : Y(ie, Z, "" + ue, Oe);
      if (typeof ue == "object" && ue !== null) {
        switch (ue.$$typeof) {
          case l:
            return ue.key === Ye ? fe(ie, Z, ue, Oe) : null;
          case c:
            return ue.key === Ye ? Be(ie, Z, ue, Oe) : null;
          case S:
            return (Ye = ue._init), tt(ie, Z, Ye(ue._payload), Oe);
        }
        if (X(ue) || P(ue)) return Ye !== null ? null : Ge(ie, Z, ue, Oe, null);
        ud(ie, ue);
      }
      return null;
    }
    function Ht(ie, Z, ue, Oe, Ye) {
      if ((typeof Oe == "string" && Oe !== "") || typeof Oe == "number")
        return (ie = ie.get(ue) || null), Y(Z, ie, "" + Oe, Ye);
      if (typeof Oe == "object" && Oe !== null) {
        switch (Oe.$$typeof) {
          case l:
            return (
              (ie = ie.get(Oe.key === null ? ue : Oe.key) || null),
              fe(Z, ie, Oe, Ye)
            );
          case c:
            return (
              (ie = ie.get(Oe.key === null ? ue : Oe.key) || null),
              Be(Z, ie, Oe, Ye)
            );
          case S:
            var pt = Oe._init;
            return Ht(ie, Z, ue, pt(Oe._payload), Ye);
        }
        if (X(Oe) || P(Oe))
          return (ie = ie.get(ue) || null), Ge(Z, ie, Oe, Ye, null);
        ud(Z, Oe);
      }
      return null;
    }
    function Ze(ie, Z, ue, Oe) {
      for (
        var Ye = null, pt = null, lt = Z, Lt = (Z = 0), Fn = null;
        lt !== null && Lt < ue.length;
        Lt++
      ) {
        lt.index > Lt ? ((Fn = lt), (lt = null)) : (Fn = lt.sibling);
        var It = tt(ie, lt, ue[Lt], Oe);
        if (It === null) {
          lt === null && (lt = Fn);
          break;
        }
        u && lt && It.alternate === null && f(ie, lt),
          (Z = T(It, Z, Lt)),
          pt === null ? (Ye = It) : (pt.sibling = It),
          (pt = It),
          (lt = Fn);
      }
      if (Lt === ue.length) return y(ie, lt), Zt && aa(ie, Lt), Ye;
      if (lt === null) {
        for (; Lt < ue.length; Lt++)
          (lt = at(ie, ue[Lt], Oe)),
            lt !== null &&
              ((Z = T(lt, Z, Lt)),
              pt === null ? (Ye = lt) : (pt.sibling = lt),
              (pt = lt));
        return Zt && aa(ie, Lt), Ye;
      }
      for (lt = M(ie, lt); Lt < ue.length; Lt++)
        (Fn = Ht(lt, ie, Lt, ue[Lt], Oe)),
          Fn !== null &&
            (u &&
              Fn.alternate !== null &&
              lt.delete(Fn.key === null ? Lt : Fn.key),
            (Z = T(Fn, Z, Lt)),
            pt === null ? (Ye = Fn) : (pt.sibling = Fn),
            (pt = Fn));
      return (
        u &&
          lt.forEach(function (lo) {
            return f(ie, lo);
          }),
        Zt && aa(ie, Lt),
        Ye
      );
    }
    function qn(ie, Z, ue, Oe) {
      var Ye = P(ue);
      if (typeof Ye != "function") throw Error(o(150));
      if (((ue = Ye.call(ue)), ue == null)) throw Error(o(151));
      for (
        var pt = (Ye = null), lt = Z, Lt = (Z = 0), Fn = null, It = ue.next();
        lt !== null && !It.done;
        Lt++, It = ue.next()
      ) {
        lt.index > Lt ? ((Fn = lt), (lt = null)) : (Fn = lt.sibling);
        var lo = tt(ie, lt, It.value, Oe);
        if (lo === null) {
          lt === null && (lt = Fn);
          break;
        }
        u && lt && lo.alternate === null && f(ie, lt),
          (Z = T(lo, Z, Lt)),
          pt === null ? (Ye = lo) : (pt.sibling = lo),
          (pt = lo),
          (lt = Fn);
      }
      if (It.done) return y(ie, lt), Zt && aa(ie, Lt), Ye;
      if (lt === null) {
        for (; !It.done; Lt++, It = ue.next())
          (It = at(ie, It.value, Oe)),
            It !== null &&
              ((Z = T(It, Z, Lt)),
              pt === null ? (Ye = It) : (pt.sibling = It),
              (pt = It));
        return Zt && aa(ie, Lt), Ye;
      }
      for (lt = M(ie, lt); !It.done; Lt++, It = ue.next())
        (It = Ht(lt, ie, Lt, It.value, Oe)),
          It !== null &&
            (u &&
              It.alternate !== null &&
              lt.delete(It.key === null ? Lt : It.key),
            (Z = T(It, Z, Lt)),
            pt === null ? (Ye = It) : (pt.sibling = It),
            (pt = It));
      return (
        u &&
          lt.forEach(function (DI) {
            return f(ie, DI);
          }),
        Zt && aa(ie, Lt),
        Ye
      );
    }
    function or(ie, Z, ue, Oe) {
      if (
        (typeof ue == "object" &&
          ue !== null &&
          ue.type === h &&
          ue.key === null &&
          (ue = ue.props.children),
        typeof ue == "object" && ue !== null)
      ) {
        switch (ue.$$typeof) {
          case l:
            e: {
              for (var Ye = ue.key, pt = Z; pt !== null; ) {
                if (pt.key === Ye) {
                  if (((Ye = ue.type), Ye === h)) {
                    if (pt.tag === 7) {
                      y(ie, pt.sibling),
                        (Z = C(pt, ue.props.children)),
                        (Z.return = ie),
                        (ie = Z);
                      break e;
                    }
                  } else if (
                    pt.elementType === Ye ||
                    (typeof Ye == "object" &&
                      Ye !== null &&
                      Ye.$$typeof === S &&
                      RM(Ye) === pt.type)
                  ) {
                    y(ie, pt.sibling),
                      (Z = C(pt, ue.props)),
                      (Z.ref = pc(ie, pt, ue)),
                      (Z.return = ie),
                      (ie = Z);
                    break e;
                  }
                  y(ie, pt);
                  break;
                } else f(ie, pt);
                pt = pt.sibling;
              }
              ue.type === h
                ? ((Z = pa(ue.props.children, ie.mode, Oe, ue.key)),
                  (Z.return = ie),
                  (ie = Z))
                : ((Oe = zd(ue.type, ue.key, ue.props, null, ie.mode, Oe)),
                  (Oe.ref = pc(ie, Z, ue)),
                  (Oe.return = ie),
                  (ie = Oe));
            }
            return O(ie);
          case c:
            e: {
              for (pt = ue.key; Z !== null; ) {
                if (Z.key === pt)
                  if (
                    Z.tag === 4 &&
                    Z.stateNode.containerInfo === ue.containerInfo &&
                    Z.stateNode.implementation === ue.implementation
                  ) {
                    y(ie, Z.sibling),
                      (Z = C(Z, ue.children || [])),
                      (Z.return = ie),
                      (ie = Z);
                    break e;
                  } else {
                    y(ie, Z);
                    break;
                  }
                else f(ie, Z);
                Z = Z.sibling;
              }
              (Z = ly(ue, ie.mode, Oe)), (Z.return = ie), (ie = Z);
            }
            return O(ie);
          case S:
            return (pt = ue._init), or(ie, Z, pt(ue._payload), Oe);
        }
        if (X(ue)) return Ze(ie, Z, ue, Oe);
        if (P(ue)) return qn(ie, Z, ue, Oe);
        ud(ie, ue);
      }
      return (typeof ue == "string" && ue !== "") || typeof ue == "number"
        ? ((ue = "" + ue),
          Z !== null && Z.tag === 6
            ? (y(ie, Z.sibling), (Z = C(Z, ue)), (Z.return = ie), (ie = Z))
            : (y(ie, Z), (Z = ay(ue, ie.mode, Oe)), (Z.return = ie), (ie = Z)),
          O(ie))
        : y(ie, Z);
    }
    return or;
  }
  var wl = LM(!0),
    IM = LM(!1),
    mc = {},
    nr = xi(mc),
    gc = xi(mc),
    Cl = xi(mc);
  function Zr(u) {
    if (u === mc) throw Error(o(174));
    return u;
  }
  function C0(u, f) {
    dt(Cl, f), dt(gc, u), dt(nr, mc), (u = ae(f)), Nt(nr), dt(nr, u);
  }
  function El() {
    Nt(nr), Nt(gc), Nt(Cl);
  }
  function DM(u) {
    var f = Zr(Cl.current),
      y = Zr(nr.current);
    (f = I(y, u.type, f)), y !== f && (dt(gc, u), dt(nr, f));
  }
  function E0(u) {
    gc.current === u && (Nt(nr), Nt(gc));
  }
  var tn = xi(0);
  function cd(u) {
    for (var f = u; f !== null; ) {
      if (f.tag === 13) {
        var y = f.memoizedState;
        if (y !== null && ((y = y.dehydrated), y === null || Xh(y) || uc(y)))
          return f;
      } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
        if (f.flags & 128) return f;
      } else if (f.child !== null) {
        (f.child.return = f), (f = f.child);
        continue;
      }
      if (f === u) break;
      for (; f.sibling === null; ) {
        if (f.return === null || f.return === u) return null;
        f = f.return;
      }
      (f.sibling.return = f.return), (f = f.sibling);
    }
    return null;
  }
  var T0 = [];
  function b0() {
    for (var u = 0; u < T0.length; u++) {
      var f = T0[u];
      ve
        ? (f._workInProgressVersionPrimary = null)
        : (f._workInProgressVersionSecondary = null);
    }
    T0.length = 0;
  }
  var fd = a.ReactCurrentDispatcher,
    ir = a.ReactCurrentBatchConfig,
    Tl = 0,
    cn = null,
    Yn = null,
    Dn = null,
    hd = !1,
    yc = !1,
    vc = 0,
    sI = 0;
  function Qn() {
    throw Error(o(321));
  }
  function P0(u, f) {
    if (f === null) return !1;
    for (var y = 0; y < f.length && y < u.length; y++)
      if (!Kr(u[y], f[y])) return !1;
    return !0;
  }
  function B0(u, f, y, M, C, T) {
    if (
      ((Tl = T),
      (cn = f),
      (f.memoizedState = null),
      (f.updateQueue = null),
      (f.lanes = 0),
      (fd.current = u === null || u.memoizedState === null ? uI : cI),
      (u = y(M, C)),
      yc)
    ) {
      T = 0;
      do {
        if (((yc = !1), (vc = 0), 25 <= T)) throw Error(o(301));
        (T += 1),
          (Dn = Yn = null),
          (f.updateQueue = null),
          (fd.current = fI),
          (u = y(M, C));
      } while (yc);
    }
    if (
      ((fd.current = yd),
      (f = Yn !== null && Yn.next !== null),
      (Tl = 0),
      (Dn = Yn = cn = null),
      (hd = !1),
      f)
    )
      throw Error(o(300));
    return u;
  }
  function R0() {
    var u = vc !== 0;
    return (vc = 0), u;
  }
  function xs() {
    var u = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null,
    };
    return Dn === null ? (cn.memoizedState = Dn = u) : (Dn = Dn.next = u), Dn;
  }
  function qr() {
    if (Yn === null) {
      var u = cn.alternate;
      u = u !== null ? u.memoizedState : null;
    } else u = Yn.next;
    var f = Dn === null ? cn.memoizedState : Dn.next;
    if (f !== null) (Dn = f), (Yn = u);
    else {
      if (u === null) throw Error(o(310));
      (Yn = u),
        (u = {
          memoizedState: Yn.memoizedState,
          baseState: Yn.baseState,
          baseQueue: Yn.baseQueue,
          queue: Yn.queue,
          next: null,
        }),
        Dn === null ? (cn.memoizedState = Dn = u) : (Dn = Dn.next = u);
    }
    return Dn;
  }
  function la(u, f) {
    return typeof f == "function" ? f(u) : f;
  }
  function dd(u) {
    var f = qr(),
      y = f.queue;
    if (y === null) throw Error(o(311));
    y.lastRenderedReducer = u;
    var M = Yn,
      C = M.baseQueue,
      T = y.pending;
    if (T !== null) {
      if (C !== null) {
        var O = C.next;
        (C.next = T.next), (T.next = O);
      }
      (M.baseQueue = C = T), (y.pending = null);
    }
    if (C !== null) {
      (T = C.next), (M = M.baseState);
      var Y = (O = null),
        fe = null,
        Be = T;
      do {
        var Ge = Be.lane;
        if ((Tl & Ge) === Ge)
          fe !== null &&
            (fe = fe.next =
              {
                lane: 0,
                action: Be.action,
                hasEagerState: Be.hasEagerState,
                eagerState: Be.eagerState,
                next: null,
              }),
            (M = Be.hasEagerState ? Be.eagerState : u(M, Be.action));
        else {
          var at = {
            lane: Ge,
            action: Be.action,
            hasEagerState: Be.hasEagerState,
            eagerState: Be.eagerState,
            next: null,
          };
          fe === null ? ((Y = fe = at), (O = M)) : (fe = fe.next = at),
            (cn.lanes |= Ge),
            (Pl |= Ge);
        }
        Be = Be.next;
      } while (Be !== null && Be !== T);
      fe === null ? (O = M) : (fe.next = Y),
        Kr(M, f.memoizedState) || (Ni = !0),
        (f.memoizedState = M),
        (f.baseState = O),
        (f.baseQueue = fe),
        (y.lastRenderedState = M);
    }
    if (((u = y.interleaved), u !== null)) {
      C = u;
      do (T = C.lane), (cn.lanes |= T), (Pl |= T), (C = C.next);
      while (C !== u);
    } else C === null && (y.lanes = 0);
    return [f.memoizedState, y.dispatch];
  }
  function pd(u) {
    var f = qr(),
      y = f.queue;
    if (y === null) throw Error(o(311));
    y.lastRenderedReducer = u;
    var M = y.dispatch,
      C = y.pending,
      T = f.memoizedState;
    if (C !== null) {
      y.pending = null;
      var O = (C = C.next);
      do (T = u(T, O.action)), (O = O.next);
      while (O !== C);
      Kr(T, f.memoizedState) || (Ni = !0),
        (f.memoizedState = T),
        f.baseQueue === null && (f.baseState = T),
        (y.lastRenderedState = T);
    }
    return [T, M];
  }
  function FM() {}
  function NM(u, f) {
    var y = cn,
      M = qr(),
      C = f(),
      T = !Kr(M.memoizedState, C);
    if (
      (T && ((M.memoizedState = C), (Ni = !0)),
      (M = M.queue),
      _c(UM.bind(null, y, M, u), [u]),
      M.getSnapshot !== f || T || (Dn !== null && Dn.memoizedState.tag & 1))
    ) {
      if (
        ((y.flags |= 2048),
        xc(9, kM.bind(null, y, M, C, f), void 0, null),
        _n === null)
      )
        throw Error(o(349));
      Tl & 30 || OM(y, f, C);
    }
    return C;
  }
  function OM(u, f, y) {
    (u.flags |= 16384),
      (u = { getSnapshot: f, value: y }),
      (f = cn.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (cn.updateQueue = f),
          (f.stores = [u]))
        : ((y = f.stores), y === null ? (f.stores = [u]) : y.push(u));
  }
  function kM(u, f, y, M) {
    (f.value = y), (f.getSnapshot = M), zM(f) && rr(u, 1, -1);
  }
  function UM(u, f, y) {
    return y(function () {
      zM(f) && rr(u, 1, -1);
    });
  }
  function zM(u) {
    var f = u.getSnapshot;
    u = u.value;
    try {
      var y = f();
      return !Kr(u, y);
    } catch {
      return !0;
    }
  }
  function L0(u) {
    var f = xs();
    return (
      typeof u == "function" && (u = u()),
      (f.memoizedState = f.baseState = u),
      (u = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: la,
        lastRenderedState: u,
      }),
      (f.queue = u),
      (u = u.dispatch = lI.bind(null, cn, u)),
      [f.memoizedState, u]
    );
  }
  function xc(u, f, y, M) {
    return (
      (u = { tag: u, create: f, destroy: y, deps: M, next: null }),
      (f = cn.updateQueue),
      f === null
        ? ((f = { lastEffect: null, stores: null }),
          (cn.updateQueue = f),
          (f.lastEffect = u.next = u))
        : ((y = f.lastEffect),
          y === null
            ? (f.lastEffect = u.next = u)
            : ((M = y.next), (y.next = u), (u.next = M), (f.lastEffect = u))),
      u
    );
  }
  function GM() {
    return qr().memoizedState;
  }
  function md(u, f, y, M) {
    var C = xs();
    (cn.flags |= u),
      (C.memoizedState = xc(1 | f, y, void 0, M === void 0 ? null : M));
  }
  function gd(u, f, y, M) {
    var C = qr();
    M = M === void 0 ? null : M;
    var T = void 0;
    if (Yn !== null) {
      var O = Yn.memoizedState;
      if (((T = O.destroy), M !== null && P0(M, O.deps))) {
        C.memoizedState = xc(f, y, T, M);
        return;
      }
    }
    (cn.flags |= u), (C.memoizedState = xc(1 | f, y, T, M));
  }
  function I0(u, f) {
    return md(8390656, 8, u, f);
  }
  function _c(u, f) {
    return gd(2048, 8, u, f);
  }
  function HM(u, f) {
    return gd(4, 2, u, f);
  }
  function VM(u, f) {
    return gd(4, 4, u, f);
  }
  function WM(u, f) {
    if (typeof f == "function")
      return (
        (u = u()),
        f(u),
        function () {
          f(null);
        }
      );
    if (f != null)
      return (
        (u = u()),
        (f.current = u),
        function () {
          f.current = null;
        }
      );
  }
  function JM(u, f, y) {
    return (
      (y = y != null ? y.concat([u]) : null), gd(4, 4, WM.bind(null, f, u), y)
    );
  }
  function D0() {}
  function jM(u, f) {
    var y = qr();
    f = f === void 0 ? null : f;
    var M = y.memoizedState;
    return M !== null && f !== null && P0(f, M[1])
      ? M[0]
      : ((y.memoizedState = [u, f]), u);
  }
  function XM(u, f) {
    var y = qr();
    f = f === void 0 ? null : f;
    var M = y.memoizedState;
    return M !== null && f !== null && P0(f, M[1])
      ? M[0]
      : ((u = u()), (y.memoizedState = [u, f]), u);
  }
  function oI(u, f) {
    var y = Rt;
    (Rt = y !== 0 && 4 > y ? y : 4), u(!0);
    var M = ir.transition;
    ir.transition = {};
    try {
      u(!1), f();
    } finally {
      (Rt = y), (ir.transition = M);
    }
  }
  function KM() {
    return qr().memoizedState;
  }
  function aI(u, f, y) {
    var M = so(u);
    (y = {
      lane: M,
      action: y,
      hasEagerState: !1,
      eagerState: null,
      next: null,
    }),
      YM(u)
        ? QM(f, y)
        : (ZM(u, f, y),
          (y = ui()),
          (u = rr(u, M, y)),
          u !== null && qM(u, f, M));
  }
  function lI(u, f, y) {
    var M = so(u),
      C = {
        lane: M,
        action: y,
        hasEagerState: !1,
        eagerState: null,
        next: null,
      };
    if (YM(u)) QM(f, C);
    else {
      ZM(u, f, C);
      var T = u.alternate;
      if (
        u.lanes === 0 &&
        (T === null || T.lanes === 0) &&
        ((T = f.lastRenderedReducer), T !== null)
      )
        try {
          var O = f.lastRenderedState,
            Y = T(O, y);
          if (((C.hasEagerState = !0), (C.eagerState = Y), Kr(Y, O))) return;
        } catch {
        } finally {
        }
      (y = ui()), (u = rr(u, M, y)), u !== null && qM(u, f, M);
    }
  }
  function YM(u) {
    var f = u.alternate;
    return u === cn || (f !== null && f === cn);
  }
  function QM(u, f) {
    yc = hd = !0;
    var y = u.pending;
    y === null ? (f.next = f) : ((f.next = y.next), (y.next = f)),
      (u.pending = f);
  }
  function ZM(u, f, y) {
    _n !== null && u.mode & 1 && !(xt & 2)
      ? ((u = f.interleaved),
        u === null
          ? ((y.next = y), Qr === null ? (Qr = [f]) : Qr.push(f))
          : ((y.next = u.next), (u.next = y)),
        (f.interleaved = y))
      : ((u = f.pending),
        u === null ? (y.next = y) : ((y.next = u.next), (u.next = y)),
        (f.pending = y));
  }
  function qM(u, f, y) {
    if (y & 4194240) {
      var M = f.lanes;
      (M &= u.pendingLanes), (y |= M), (f.lanes = y), l0(u, y);
    }
  }
  var yd = {
      readContext: $i,
      useCallback: Qn,
      useContext: Qn,
      useEffect: Qn,
      useImperativeHandle: Qn,
      useInsertionEffect: Qn,
      useLayoutEffect: Qn,
      useMemo: Qn,
      useReducer: Qn,
      useRef: Qn,
      useState: Qn,
      useDebugValue: Qn,
      useDeferredValue: Qn,
      useTransition: Qn,
      useMutableSource: Qn,
      useSyncExternalStore: Qn,
      useId: Qn,
      unstable_isNewReconciler: !1,
    },
    uI = {
      readContext: $i,
      useCallback: function (u, f) {
        return (xs().memoizedState = [u, f === void 0 ? null : f]), u;
      },
      useContext: $i,
      useEffect: I0,
      useImperativeHandle: function (u, f, y) {
        return (
          (y = y != null ? y.concat([u]) : null),
          md(4194308, 4, WM.bind(null, f, u), y)
        );
      },
      useLayoutEffect: function (u, f) {
        return md(4194308, 4, u, f);
      },
      useInsertionEffect: function (u, f) {
        return md(4, 2, u, f);
      },
      useMemo: function (u, f) {
        var y = xs();
        return (
          (f = f === void 0 ? null : f),
          (u = u()),
          (y.memoizedState = [u, f]),
          u
        );
      },
      useReducer: function (u, f, y) {
        var M = xs();
        return (
          (f = y !== void 0 ? y(f) : f),
          (M.memoizedState = M.baseState = f),
          (u = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: u,
            lastRenderedState: f,
          }),
          (M.queue = u),
          (u = u.dispatch = aI.bind(null, cn, u)),
          [M.memoizedState, u]
        );
      },
      useRef: function (u) {
        var f = xs();
        return (u = { current: u }), (f.memoizedState = u);
      },
      useState: L0,
      useDebugValue: D0,
      useDeferredValue: function (u) {
        var f = L0(u),
          y = f[0],
          M = f[1];
        return (
          I0(
            function () {
              var C = ir.transition;
              ir.transition = {};
              try {
                M(u);
              } finally {
                ir.transition = C;
              }
            },
            [u]
          ),
          y
        );
      },
      useTransition: function () {
        var u = L0(!1),
          f = u[0];
        return (u = oI.bind(null, u[1])), (xs().memoizedState = u), [f, u];
      },
      useMutableSource: function () {},
      useSyncExternalStore: function (u, f, y) {
        var M = cn,
          C = xs();
        if (Zt) {
          if (y === void 0) throw Error(o(407));
          y = y();
        } else {
          if (((y = f()), _n === null)) throw Error(o(349));
          Tl & 30 || OM(M, f, y);
        }
        C.memoizedState = y;
        var T = { value: y, getSnapshot: f };
        return (
          (C.queue = T),
          I0(UM.bind(null, M, T, u), [u]),
          (M.flags |= 2048),
          xc(9, kM.bind(null, M, T, y, f), void 0, null),
          y
        );
      },
      useId: function () {
        var u = xs(),
          f = _n.identifierPrefix;
        if (Zt) {
          var y = vs,
            M = ys;
          (y = (M & ~(1 << (32 - Sr(M) - 1))).toString(32) + y),
            (f = ":" + f + "R" + y),
            (y = vc++),
            0 < y && (f += "H" + y.toString(32)),
            (f += ":");
        } else (y = sI++), (f = ":" + f + "r" + y.toString(32) + ":");
        return (u.memoizedState = f);
      },
      unstable_isNewReconciler: !1,
    },
    cI = {
      readContext: $i,
      useCallback: jM,
      useContext: $i,
      useEffect: _c,
      useImperativeHandle: JM,
      useInsertionEffect: HM,
      useLayoutEffect: VM,
      useMemo: XM,
      useReducer: dd,
      useRef: GM,
      useState: function () {
        return dd(la);
      },
      useDebugValue: D0,
      useDeferredValue: function (u) {
        var f = dd(la),
          y = f[0],
          M = f[1];
        return (
          _c(
            function () {
              var C = ir.transition;
              ir.transition = {};
              try {
                M(u);
              } finally {
                ir.transition = C;
              }
            },
            [u]
          ),
          y
        );
      },
      useTransition: function () {
        var u = dd(la)[0],
          f = qr().memoizedState;
        return [u, f];
      },
      useMutableSource: FM,
      useSyncExternalStore: NM,
      useId: KM,
      unstable_isNewReconciler: !1,
    },
    fI = {
      readContext: $i,
      useCallback: jM,
      useContext: $i,
      useEffect: _c,
      useImperativeHandle: JM,
      useInsertionEffect: HM,
      useLayoutEffect: VM,
      useMemo: XM,
      useReducer: pd,
      useRef: GM,
      useState: function () {
        return pd(la);
      },
      useDebugValue: D0,
      useDeferredValue: function (u) {
        var f = pd(la),
          y = f[0],
          M = f[1];
        return (
          _c(
            function () {
              var C = ir.transition;
              ir.transition = {};
              try {
                M(u);
              } finally {
                ir.transition = C;
              }
            },
            [u]
          ),
          y
        );
      },
      useTransition: function () {
        var u = pd(la)[0],
          f = qr().memoizedState;
        return [u, f];
      },
      useMutableSource: FM,
      useSyncExternalStore: NM,
      useId: KM,
      unstable_isNewReconciler: !1,
    };
  function F0(u, f) {
    try {
      var y = "",
        M = f;
      do (y += rI(M)), (M = M.return);
      while (M);
      var C = y;
    } catch (T) {
      C =
        `
Error generating stack: ` +
        T.message +
        `
` +
        T.stack;
    }
    return { value: u, source: f, stack: C };
  }
  function N0(u, f) {
    try {
      console.error(f.value);
    } catch (y) {
      setTimeout(function () {
        throw y;
      });
    }
  }
  var hI = typeof WeakMap == "function" ? WeakMap : Map;
  function $M(u, f, y) {
    (y = gs(-1, y)), (y.tag = 3), (y.payload = { element: null });
    var M = f.value;
    return (
      (y.callback = function () {
        Id || ((Id = !0), (ey = M)), N0(u, f);
      }),
      y
    );
  }
  function eS(u, f, y) {
    (y = gs(-1, y)), (y.tag = 3);
    var M = u.type.getDerivedStateFromError;
    if (typeof M == "function") {
      var C = f.value;
      (y.payload = function () {
        return M(C);
      }),
        (y.callback = function () {
          N0(u, f);
        });
    }
    var T = u.stateNode;
    return (
      T !== null &&
        typeof T.componentDidCatch == "function" &&
        (y.callback = function () {
          N0(u, f),
            typeof M != "function" &&
              (io === null ? (io = new Set([this])) : io.add(this));
          var O = f.stack;
          this.componentDidCatch(f.value, {
            componentStack: O !== null ? O : "",
          });
        }),
      y
    );
  }
  function tS(u, f, y) {
    var M = u.pingCache;
    if (M === null) {
      M = u.pingCache = new hI();
      var C = new Set();
      M.set(f, C);
    } else (C = M.get(f)), C === void 0 && ((C = new Set()), M.set(f, C));
    C.has(y) || (C.add(y), (u = EI.bind(null, u, f, y)), f.then(u, u));
  }
  function nS(u) {
    do {
      var f;
      if (
        ((f = u.tag === 13) &&
          ((f = u.memoizedState),
          (f = f !== null ? f.dehydrated !== null : !0)),
        f)
      )
        return u;
      u = u.return;
    } while (u !== null);
    return null;
  }
  function iS(u, f, y, M, C) {
    return u.mode & 1
      ? ((u.flags |= 65536), (u.lanes = C), u)
      : (u === f
          ? (u.flags |= 65536)
          : ((u.flags |= 128),
            (y.flags |= 131072),
            (y.flags &= -52805),
            y.tag === 1 &&
              (y.alternate === null
                ? (y.tag = 17)
                : ((f = gs(-1, 1)), (f.tag = 2), no(y, f))),
            (y.lanes |= 1)),
        u);
  }
  function $r(u) {
    u.flags |= 4;
  }
  function rS(u, f) {
    if (u !== null && u.child === f.child) return !0;
    if (f.flags & 16) return !1;
    for (u = f.child; u !== null; ) {
      if (u.flags & 12854 || u.subtreeFlags & 12854) return !1;
      u = u.sibling;
    }
    return !0;
  }
  var Ac, Mc, vd, xd;
  if (Me)
    (Ac = function (u, f) {
      for (var y = f.child; y !== null; ) {
        if (y.tag === 5 || y.tag === 6) Q(u, y.stateNode);
        else if (y.tag !== 4 && y.child !== null) {
          (y.child.return = y), (y = y.child);
          continue;
        }
        if (y === f) break;
        for (; y.sibling === null; ) {
          if (y.return === null || y.return === f) return;
          y = y.return;
        }
        (y.sibling.return = y.return), (y = y.sibling);
      }
    }),
      (Mc = function () {}),
      (vd = function (u, f, y, M, C) {
        if (((u = u.memoizedProps), u !== M)) {
          var T = f.stateNode,
            O = Zr(nr.current);
          (y = ne(T, y, u, M, C, O)), (f.updateQueue = y) && $r(f);
        }
      }),
      (xd = function (u, f, y, M) {
        y !== M && $r(f);
      });
  else if (me) {
    Ac = function (u, f, y, M) {
      for (var C = f.child; C !== null; ) {
        if (C.tag === 5) {
          var T = C.stateNode;
          y && M && (T = Qt(T, C.type, C.memoizedProps, C)), Q(u, T);
        } else if (C.tag === 6)
          (T = C.stateNode), y && M && (T = ai(T, C.memoizedProps, C)), Q(u, T);
        else if (C.tag !== 4) {
          if (C.tag === 22 && C.memoizedState !== null)
            (T = C.child), T !== null && (T.return = C), Ac(u, C, !0, !0);
          else if (C.child !== null) {
            (C.child.return = C), (C = C.child);
            continue;
          }
        }
        if (C === f) break;
        for (; C.sibling === null; ) {
          if (C.return === null || C.return === f) return;
          C = C.return;
        }
        (C.sibling.return = C.return), (C = C.sibling);
      }
    };
    var sS = function (u, f, y, M) {
      for (var C = f.child; C !== null; ) {
        if (C.tag === 5) {
          var T = C.stateNode;
          y && M && (T = Qt(T, C.type, C.memoizedProps, C)), Wt(u, T);
        } else if (C.tag === 6)
          (T = C.stateNode),
            y && M && (T = ai(T, C.memoizedProps, C)),
            Wt(u, T);
        else if (C.tag !== 4) {
          if (C.tag === 22 && C.memoizedState !== null)
            (T = C.child), T !== null && (T.return = C), sS(u, C, !0, !0);
          else if (C.child !== null) {
            (C.child.return = C), (C = C.child);
            continue;
          }
        }
        if (C === f) break;
        for (; C.sibling === null; ) {
          if (C.return === null || C.return === f) return;
          C = C.return;
        }
        (C.sibling.return = C.return), (C = C.sibling);
      }
    };
    (Mc = function (u, f) {
      var y = f.stateNode;
      if (!rS(u, f)) {
        u = y.containerInfo;
        var M = zt(u);
        sS(M, f, !1, !1), (y.pendingChildren = M), $r(f), Ln(u, M);
      }
    }),
      (vd = function (u, f, y, M, C) {
        var T = u.stateNode,
          O = u.memoizedProps;
        if ((u = rS(u, f)) && O === M) f.stateNode = T;
        else {
          var Y = f.stateNode,
            fe = Zr(nr.current),
            Be = null;
          O !== M && (Be = ne(Y, y, O, M, C, fe)),
            u && Be === null
              ? (f.stateNode = T)
              : ((T = Qe(T, Be, y, O, M, f, u, Y)),
                ee(T, y, M, C, fe) && $r(f),
                (f.stateNode = T),
                u ? $r(f) : Ac(T, f, !1, !1));
        }
      }),
      (xd = function (u, f, y, M) {
        y !== M
          ? ((u = Zr(Cl.current)),
            (y = Zr(nr.current)),
            (f.stateNode = _e(M, u, y, f)),
            $r(f))
          : (f.stateNode = u.stateNode);
      });
  } else (Mc = function () {}), (vd = function () {}), (xd = function () {});
  function Sc(u, f) {
    if (!Zt)
      switch (u.tailMode) {
        case "hidden":
          f = u.tail;
          for (var y = null; f !== null; )
            f.alternate !== null && (y = f), (f = f.sibling);
          y === null ? (u.tail = null) : (y.sibling = null);
          break;
        case "collapsed":
          y = u.tail;
          for (var M = null; y !== null; )
            y.alternate !== null && (M = y), (y = y.sibling);
          M === null
            ? f || u.tail === null
              ? (u.tail = null)
              : (u.tail.sibling = null)
            : (M.sibling = null);
      }
  }
  function Zn(u) {
    var f = u.alternate !== null && u.alternate.child === u.child,
      y = 0,
      M = 0;
    if (f)
      for (var C = u.child; C !== null; )
        (y |= C.lanes | C.childLanes),
          (M |= C.subtreeFlags & 14680064),
          (M |= C.flags & 14680064),
          (C.return = u),
          (C = C.sibling);
    else
      for (C = u.child; C !== null; )
        (y |= C.lanes | C.childLanes),
          (M |= C.subtreeFlags),
          (M |= C.flags),
          (C.return = u),
          (C = C.sibling);
    return (u.subtreeFlags |= M), (u.childLanes = y), f;
  }
  function dI(u, f, y) {
    var M = f.pendingProps;
    switch ((A0(f), f.tag)) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return Zn(f), null;
      case 1:
        return Gn(f.type) && Kh(), Zn(f), null;
      case 3:
        return (
          (M = f.stateNode),
          El(),
          Nt(Gt),
          Nt(xn),
          b0(),
          M.pendingContext &&
            ((M.context = M.pendingContext), (M.pendingContext = null)),
          (u === null || u.child === null) &&
            (dc(f)
              ? $r(f)
              : u === null ||
                (u.memoizedState.isDehydrated && !(f.flags & 256)) ||
                ((f.flags |= 1024), Cr !== null && (iy(Cr), (Cr = null)))),
          Mc(u, f),
          Zn(f),
          null
        );
      case 5:
        E0(f), (y = Zr(Cl.current));
        var C = f.type;
        if (u !== null && f.stateNode != null)
          vd(u, f, C, M, y),
            u.ref !== f.ref && ((f.flags |= 512), (f.flags |= 2097152));
        else {
          if (!M) {
            if (f.stateNode === null) throw Error(o(166));
            return Zn(f), null;
          }
          if (((u = Zr(nr.current)), dc(f))) {
            if (!se) throw Error(o(175));
            (u = ye(f.stateNode, f.type, f.memoizedProps, y, u, f, !hc)),
              (f.updateQueue = u),
              u !== null && $r(f);
          } else {
            var T = q(C, M, y, u, f);
            Ac(T, f, !1, !1), (f.stateNode = T), ee(T, C, M, y, u) && $r(f);
          }
          f.ref !== null && ((f.flags |= 512), (f.flags |= 2097152));
        }
        return Zn(f), null;
      case 6:
        if (u && f.stateNode != null) xd(u, f, u.memoizedProps, M);
        else {
          if (typeof M != "string" && f.stateNode === null) throw Error(o(166));
          if (((u = Zr(Cl.current)), (y = Zr(nr.current)), dc(f))) {
            if (!se) throw Error(o(176));
            if (
              ((u = f.stateNode),
              (M = f.memoizedProps),
              (y = $e(u, M, f, !hc)) && ((C = Di), C !== null))
            )
              switch (((T = (C.mode & 1) !== 0), C.tag)) {
                case 3:
                  zn(C.stateNode.containerInfo, u, M, T);
                  break;
                case 5:
                  Ii(C.type, C.memoizedProps, C.stateNode, u, M, T);
              }
            y && $r(f);
          } else f.stateNode = _e(M, u, y, f);
        }
        return Zn(f), null;
      case 13:
        if (
          (Nt(tn),
          (M = f.memoizedState),
          Zt && Fi !== null && f.mode & 1 && !(f.flags & 128))
        ) {
          for (u = Fi; u; ) u = N(u);
          return Sl(), (f.flags |= 98560), f;
        }
        if (M !== null && M.dehydrated !== null) {
          if (((M = dc(f)), u === null)) {
            if (!M) throw Error(o(318));
            if (!se) throw Error(o(344));
            if (
              ((u = f.memoizedState),
              (u = u !== null ? u.dehydrated : null),
              !u)
            )
              throw Error(o(317));
            rt(u, f);
          } else
            Sl(), !(f.flags & 128) && (f.memoizedState = null), (f.flags |= 4);
          return Zn(f), null;
        }
        return (
          Cr !== null && (iy(Cr), (Cr = null)),
          f.flags & 128
            ? ((f.lanes = y), f)
            : ((M = M !== null),
              (y = !1),
              u === null ? dc(f) : (y = u.memoizedState !== null),
              M &&
                !y &&
                ((f.child.flags |= 8192),
                f.mode & 1 &&
                  (u === null || tn.current & 1 ? En === 0 && (En = 3) : sy())),
              f.updateQueue !== null && (f.flags |= 4),
              Zn(f),
              null)
        );
      case 4:
        return (
          El(),
          Mc(u, f),
          u === null && Ne(f.stateNode.containerInfo),
          Zn(f),
          null
        );
      case 10:
        return m0(f.type._context), Zn(f), null;
      case 17:
        return Gn(f.type) && Kh(), Zn(f), null;
      case 19:
        if ((Nt(tn), (C = f.memoizedState), C === null)) return Zn(f), null;
        if (((M = (f.flags & 128) !== 0), (T = C.rendering), T === null))
          if (M) Sc(C, !1);
          else {
            if (En !== 0 || (u !== null && u.flags & 128))
              for (u = f.child; u !== null; ) {
                if (((T = cd(u)), T !== null)) {
                  for (
                    f.flags |= 128,
                      Sc(C, !1),
                      u = T.updateQueue,
                      u !== null && ((f.updateQueue = u), (f.flags |= 4)),
                      f.subtreeFlags = 0,
                      u = y,
                      M = f.child;
                    M !== null;

                  )
                    (y = M),
                      (C = u),
                      (y.flags &= 14680066),
                      (T = y.alternate),
                      T === null
                        ? ((y.childLanes = 0),
                          (y.lanes = C),
                          (y.child = null),
                          (y.subtreeFlags = 0),
                          (y.memoizedProps = null),
                          (y.memoizedState = null),
                          (y.updateQueue = null),
                          (y.dependencies = null),
                          (y.stateNode = null))
                        : ((y.childLanes = T.childLanes),
                          (y.lanes = T.lanes),
                          (y.child = T.child),
                          (y.subtreeFlags = 0),
                          (y.deletions = null),
                          (y.memoizedProps = T.memoizedProps),
                          (y.memoizedState = T.memoizedState),
                          (y.updateQueue = T.updateQueue),
                          (y.type = T.type),
                          (C = T.dependencies),
                          (y.dependencies =
                            C === null
                              ? null
                              : {
                                  lanes: C.lanes,
                                  firstContext: C.firstContext,
                                })),
                      (M = M.sibling);
                  return dt(tn, (tn.current & 1) | 2), f.child;
                }
                u = u.sibling;
              }
            C.tail !== null &&
              In() > $0 &&
              ((f.flags |= 128), (M = !0), Sc(C, !1), (f.lanes = 4194304));
          }
        else {
          if (!M)
            if (((u = cd(T)), u !== null)) {
              if (
                ((f.flags |= 128),
                (M = !0),
                (u = u.updateQueue),
                u !== null && ((f.updateQueue = u), (f.flags |= 4)),
                Sc(C, !0),
                C.tail === null &&
                  C.tailMode === "hidden" &&
                  !T.alternate &&
                  !Zt)
              )
                return Zn(f), null;
            } else
              2 * In() - C.renderingStartTime > $0 &&
                y !== 1073741824 &&
                ((f.flags |= 128), (M = !0), Sc(C, !1), (f.lanes = 4194304));
          C.isBackwards
            ? ((T.sibling = f.child), (f.child = T))
            : ((u = C.last),
              u !== null ? (u.sibling = T) : (f.child = T),
              (C.last = T));
        }
        return C.tail !== null
          ? ((f = C.tail),
            (C.rendering = f),
            (C.tail = f.sibling),
            (C.renderingStartTime = In()),
            (f.sibling = null),
            (u = tn.current),
            dt(tn, M ? (u & 1) | 2 : u & 1),
            f)
          : (Zn(f), null);
      case 22:
      case 23:
        return (
          ry(),
          (M = f.memoizedState !== null),
          u !== null && (u.memoizedState !== null) !== M && (f.flags |= 8192),
          M && f.mode & 1
            ? Oi & 1073741824 &&
              (Zn(f), Me && f.subtreeFlags & 6 && (f.flags |= 8192))
            : Zn(f),
          null
        );
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(o(156, f.tag));
  }
  var pI = a.ReactCurrentOwner,
    Ni = !1;
  function li(u, f, y, M) {
    f.child = u === null ? IM(f, null, y, M) : wl(f, u.child, y, M);
  }
  function oS(u, f, y, M, C) {
    y = y.render;
    var T = f.ref;
    return (
      _l(f, C),
      (M = B0(u, f, y, M, T, C)),
      (y = R0()),
      u !== null && !Ni
        ? ((f.updateQueue = u.updateQueue),
          (f.flags &= -2053),
          (u.lanes &= ~C),
          _s(u, f, C))
        : (Zt && y && _0(f), (f.flags |= 1), li(u, f, M, C), f.child)
    );
  }
  function aS(u, f, y, M, C) {
    if (u === null) {
      var T = y.type;
      return typeof T == "function" &&
        !oy(T) &&
        T.defaultProps === void 0 &&
        y.compare === null &&
        y.defaultProps === void 0
        ? ((f.tag = 15), (f.type = T), lS(u, f, T, M, C))
        : ((u = zd(y.type, null, M, f, f.mode, C)),
          (u.ref = f.ref),
          (u.return = f),
          (f.child = u));
    }
    if (((T = u.child), !(u.lanes & C))) {
      var O = T.memoizedProps;
      if (
        ((y = y.compare), (y = y !== null ? y : td), y(O, M) && u.ref === f.ref)
      )
        return _s(u, f, C);
    }
    return (
      (f.flags |= 1),
      (u = ao(T, M)),
      (u.ref = f.ref),
      (u.return = f),
      (f.child = u)
    );
  }
  function lS(u, f, y, M, C) {
    if (u !== null && td(u.memoizedProps, M) && u.ref === f.ref)
      if (((Ni = !1), (u.lanes & C) !== 0)) u.flags & 131072 && (Ni = !0);
      else return (f.lanes = u.lanes), _s(u, f, C);
    return O0(u, f, y, M, C);
  }
  function uS(u, f, y) {
    var M = f.pendingProps,
      C = M.children,
      T = u !== null ? u.memoizedState : null;
    if (M.mode === "hidden")
      if (!(f.mode & 1))
        (f.memoizedState = { baseLanes: 0, cachePool: null }),
          dt(bl, Oi),
          (Oi |= y);
      else if (y & 1073741824)
        (f.memoizedState = { baseLanes: 0, cachePool: null }),
          (M = T !== null ? T.baseLanes : y),
          dt(bl, Oi),
          (Oi |= M);
      else
        return (
          (u = T !== null ? T.baseLanes | y : y),
          (f.lanes = f.childLanes = 1073741824),
          (f.memoizedState = { baseLanes: u, cachePool: null }),
          (f.updateQueue = null),
          dt(bl, Oi),
          (Oi |= u),
          null
        );
    else
      T !== null ? ((M = T.baseLanes | y), (f.memoizedState = null)) : (M = y),
        dt(bl, Oi),
        (Oi |= M);
    return li(u, f, C, y), f.child;
  }
  function cS(u, f) {
    var y = f.ref;
    ((u === null && y !== null) || (u !== null && u.ref !== y)) &&
      ((f.flags |= 512), (f.flags |= 2097152));
  }
  function O0(u, f, y, M, C) {
    var T = Gn(y) ? Mr : xn.current;
    return (
      (T = eo(f, T)),
      _l(f, C),
      (y = B0(u, f, y, M, T, C)),
      (M = R0()),
      u !== null && !Ni
        ? ((f.updateQueue = u.updateQueue),
          (f.flags &= -2053),
          (u.lanes &= ~C),
          _s(u, f, C))
        : (Zt && M && _0(f), (f.flags |= 1), li(u, f, y, C), f.child)
    );
  }
  function fS(u, f, y, M, C) {
    if (Gn(y)) {
      var T = !0;
      Yh(f);
    } else T = !1;
    if ((_l(f, C), f.stateNode === null))
      u !== null &&
        ((u.alternate = null), (f.alternate = null), (f.flags |= 2)),
        CM(f, y, M),
        x0(f, y, M, C),
        (M = !0);
    else if (u === null) {
      var O = f.stateNode,
        Y = f.memoizedProps;
      O.props = Y;
      var fe = O.context,
        Be = y.contextType;
      typeof Be == "object" && Be !== null
        ? (Be = $i(Be))
        : ((Be = Gn(y) ? Mr : xn.current), (Be = eo(f, Be)));
      var Ge = y.getDerivedStateFromProps,
        at =
          typeof Ge == "function" ||
          typeof O.getSnapshotBeforeUpdate == "function";
      at ||
        (typeof O.UNSAFE_componentWillReceiveProps != "function" &&
          typeof O.componentWillReceiveProps != "function") ||
        ((Y !== M || fe !== Be) && EM(f, O, M, Be)),
        (to = !1);
      var tt = f.memoizedState;
      (O.state = tt),
        sd(f, M, O, C),
        (fe = f.memoizedState),
        Y !== M || tt !== fe || Gt.current || to
          ? (typeof Ge == "function" &&
              (v0(f, y, Ge, M), (fe = f.memoizedState)),
            (Y = to || wM(f, y, Y, M, tt, fe, Be))
              ? (at ||
                  (typeof O.UNSAFE_componentWillMount != "function" &&
                    typeof O.componentWillMount != "function") ||
                  (typeof O.componentWillMount == "function" &&
                    O.componentWillMount(),
                  typeof O.UNSAFE_componentWillMount == "function" &&
                    O.UNSAFE_componentWillMount()),
                typeof O.componentDidMount == "function" &&
                  (f.flags |= 4194308))
              : (typeof O.componentDidMount == "function" &&
                  (f.flags |= 4194308),
                (f.memoizedProps = M),
                (f.memoizedState = fe)),
            (O.props = M),
            (O.state = fe),
            (O.context = Be),
            (M = Y))
          : (typeof O.componentDidMount == "function" && (f.flags |= 4194308),
            (M = !1));
    } else {
      (O = f.stateNode),
        _M(u, f),
        (Y = f.memoizedProps),
        (Be = f.type === f.elementType ? Y : wr(f.type, Y)),
        (O.props = Be),
        (at = f.pendingProps),
        (tt = O.context),
        (fe = y.contextType),
        typeof fe == "object" && fe !== null
          ? (fe = $i(fe))
          : ((fe = Gn(y) ? Mr : xn.current), (fe = eo(f, fe)));
      var Ht = y.getDerivedStateFromProps;
      (Ge =
        typeof Ht == "function" ||
        typeof O.getSnapshotBeforeUpdate == "function") ||
        (typeof O.UNSAFE_componentWillReceiveProps != "function" &&
          typeof O.componentWillReceiveProps != "function") ||
        ((Y !== at || tt !== fe) && EM(f, O, M, fe)),
        (to = !1),
        (tt = f.memoizedState),
        (O.state = tt),
        sd(f, M, O, C);
      var Ze = f.memoizedState;
      Y !== at || tt !== Ze || Gt.current || to
        ? (typeof Ht == "function" && (v0(f, y, Ht, M), (Ze = f.memoizedState)),
          (Be = to || wM(f, y, Be, M, tt, Ze, fe) || !1)
            ? (Ge ||
                (typeof O.UNSAFE_componentWillUpdate != "function" &&
                  typeof O.componentWillUpdate != "function") ||
                (typeof O.componentWillUpdate == "function" &&
                  O.componentWillUpdate(M, Ze, fe),
                typeof O.UNSAFE_componentWillUpdate == "function" &&
                  O.UNSAFE_componentWillUpdate(M, Ze, fe)),
              typeof O.componentDidUpdate == "function" && (f.flags |= 4),
              typeof O.getSnapshotBeforeUpdate == "function" &&
                (f.flags |= 1024))
            : (typeof O.componentDidUpdate != "function" ||
                (Y === u.memoizedProps && tt === u.memoizedState) ||
                (f.flags |= 4),
              typeof O.getSnapshotBeforeUpdate != "function" ||
                (Y === u.memoizedProps && tt === u.memoizedState) ||
                (f.flags |= 1024),
              (f.memoizedProps = M),
              (f.memoizedState = Ze)),
          (O.props = M),
          (O.state = Ze),
          (O.context = fe),
          (M = Be))
        : (typeof O.componentDidUpdate != "function" ||
            (Y === u.memoizedProps && tt === u.memoizedState) ||
            (f.flags |= 4),
          typeof O.getSnapshotBeforeUpdate != "function" ||
            (Y === u.memoizedProps && tt === u.memoizedState) ||
            (f.flags |= 1024),
          (M = !1));
    }
    return k0(u, f, y, M, T, C);
  }
  function k0(u, f, y, M, C, T) {
    cS(u, f);
    var O = (f.flags & 128) !== 0;
    if (!M && !O) return C && mM(f, y, !1), _s(u, f, T);
    (M = f.stateNode), (pI.current = f);
    var Y =
      O && typeof y.getDerivedStateFromError != "function" ? null : M.render();
    return (
      (f.flags |= 1),
      u !== null && O
        ? ((f.child = wl(f, u.child, null, T)), (f.child = wl(f, null, Y, T)))
        : li(u, f, Y, T),
      (f.memoizedState = M.state),
      C && mM(f, y, !0),
      f.child
    );
  }
  function hS(u) {
    var f = u.stateNode;
    f.pendingContext
      ? dM(u, f.pendingContext, f.pendingContext !== f.context)
      : f.context && dM(u, f.context, !1),
      C0(u, f.containerInfo);
  }
  function dS(u, f, y, M, C) {
    return Sl(), w0(C), (f.flags |= 256), li(u, f, y, M), f.child;
  }
  var _d = { dehydrated: null, treeContext: null, retryLane: 0 };
  function Ad(u) {
    return { baseLanes: u, cachePool: null };
  }
  function pS(u, f, y) {
    var M = f.pendingProps,
      C = tn.current,
      T = !1,
      O = (f.flags & 128) !== 0,
      Y;
    if (
      ((Y = O) ||
        (Y = u !== null && u.memoizedState === null ? !1 : (C & 2) !== 0),
      Y
        ? ((T = !0), (f.flags &= -129))
        : (u === null || u.memoizedState !== null) && (C |= 1),
      dt(tn, C & 1),
      u === null)
    )
      return (
        S0(f),
        (u = f.memoizedState),
        u !== null && ((u = u.dehydrated), u !== null)
          ? (f.mode & 1
              ? uc(u)
                ? (f.lanes = 8)
                : (f.lanes = 1073741824)
              : (f.lanes = 1),
            null)
          : ((C = M.children),
            (u = M.fallback),
            T
              ? ((M = f.mode),
                (T = f.child),
                (C = { mode: "hidden", children: C }),
                !(M & 1) && T !== null
                  ? ((T.childLanes = 0), (T.pendingProps = C))
                  : (T = Gd(C, M, 0, null)),
                (u = pa(u, M, y, null)),
                (T.return = f),
                (u.return = f),
                (T.sibling = u),
                (f.child = T),
                (f.child.memoizedState = Ad(y)),
                (f.memoizedState = _d),
                u)
              : U0(f, C))
      );
    if (((C = u.memoizedState), C !== null)) {
      if (((Y = C.dehydrated), Y !== null)) {
        if (O)
          return f.flags & 256
            ? ((f.flags &= -257), Md(u, f, y, Error(o(422))))
            : f.memoizedState !== null
            ? ((f.child = u.child), (f.flags |= 128), null)
            : ((T = M.fallback),
              (C = f.mode),
              (M = Gd({ mode: "visible", children: M.children }, C, 0, null)),
              (T = pa(T, C, y, null)),
              (T.flags |= 2),
              (M.return = f),
              (T.return = f),
              (M.sibling = T),
              (f.child = M),
              f.mode & 1 && wl(f, u.child, null, y),
              (f.child.memoizedState = Ad(y)),
              (f.memoizedState = _d),
              T);
        if (!(f.mode & 1)) f = Md(u, f, y, null);
        else if (uc(Y)) f = Md(u, f, y, Error(o(419)));
        else if (((M = (y & u.childLanes) !== 0), Ni || M)) {
          if (((M = _n), M !== null)) {
            switch (y & -y) {
              case 4:
                T = 2;
                break;
              case 16:
                T = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                T = 32;
                break;
              case 536870912:
                T = 268435456;
                break;
              default:
                T = 0;
            }
            (M = T & (M.suspendedLanes | y) ? 0 : T),
              M !== 0 && M !== C.retryLane && ((C.retryLane = M), rr(u, M, -1));
          }
          sy(), (f = Md(u, f, y, Error(o(421))));
        } else
          Xh(Y)
            ? ((f.flags |= 128),
              (f.child = u.child),
              (f = TI.bind(null, u)),
              s0(Y, f),
              (f = null))
            : ((y = C.treeContext),
              se &&
                ((Fi = te(Y)),
                (Di = f),
                (Zt = !0),
                (Cr = null),
                (hc = !1),
                y !== null &&
                  ((er[tr++] = ys),
                  (er[tr++] = vs),
                  (er[tr++] = oa),
                  (ys = y.id),
                  (vs = y.overflow),
                  (oa = f))),
              (f = U0(f, f.pendingProps.children)),
              (f.flags |= 4096));
        return f;
      }
      return T
        ? ((M = gS(u, f, M.children, M.fallback, y)),
          (T = f.child),
          (C = u.child.memoizedState),
          (T.memoizedState =
            C === null
              ? Ad(y)
              : { baseLanes: C.baseLanes | y, cachePool: null }),
          (T.childLanes = u.childLanes & ~y),
          (f.memoizedState = _d),
          M)
        : ((y = mS(u, f, M.children, y)), (f.memoizedState = null), y);
    }
    return T
      ? ((M = gS(u, f, M.children, M.fallback, y)),
        (T = f.child),
        (C = u.child.memoizedState),
        (T.memoizedState =
          C === null ? Ad(y) : { baseLanes: C.baseLanes | y, cachePool: null }),
        (T.childLanes = u.childLanes & ~y),
        (f.memoizedState = _d),
        M)
      : ((y = mS(u, f, M.children, y)), (f.memoizedState = null), y);
  }
  function U0(u, f) {
    return (
      (f = Gd({ mode: "visible", children: f }, u.mode, 0, null)),
      (f.return = u),
      (u.child = f)
    );
  }
  function mS(u, f, y, M) {
    var C = u.child;
    return (
      (u = C.sibling),
      (y = ao(C, { mode: "visible", children: y })),
      !(f.mode & 1) && (y.lanes = M),
      (y.return = f),
      (y.sibling = null),
      u !== null &&
        ((M = f.deletions),
        M === null ? ((f.deletions = [u]), (f.flags |= 16)) : M.push(u)),
      (f.child = y)
    );
  }
  function gS(u, f, y, M, C) {
    var T = f.mode;
    u = u.child;
    var O = u.sibling,
      Y = { mode: "hidden", children: y };
    return (
      !(T & 1) && f.child !== u
        ? ((y = f.child),
          (y.childLanes = 0),
          (y.pendingProps = Y),
          (f.deletions = null))
        : ((y = ao(u, Y)), (y.subtreeFlags = u.subtreeFlags & 14680064)),
      O !== null ? (M = ao(O, M)) : ((M = pa(M, T, C, null)), (M.flags |= 2)),
      (M.return = f),
      (y.return = f),
      (y.sibling = M),
      (f.child = y),
      M
    );
  }
  function Md(u, f, y, M) {
    return (
      M !== null && w0(M),
      wl(f, u.child, null, y),
      (u = U0(f, f.pendingProps.children)),
      (u.flags |= 2),
      (f.memoizedState = null),
      u
    );
  }
  function yS(u, f, y) {
    u.lanes |= f;
    var M = u.alternate;
    M !== null && (M.lanes |= f), g0(u.return, f, y);
  }
  function z0(u, f, y, M, C) {
    var T = u.memoizedState;
    T === null
      ? (u.memoizedState = {
          isBackwards: f,
          rendering: null,
          renderingStartTime: 0,
          last: M,
          tail: y,
          tailMode: C,
        })
      : ((T.isBackwards = f),
        (T.rendering = null),
        (T.renderingStartTime = 0),
        (T.last = M),
        (T.tail = y),
        (T.tailMode = C));
  }
  function vS(u, f, y) {
    var M = f.pendingProps,
      C = M.revealOrder,
      T = M.tail;
    if ((li(u, f, M.children, y), (M = tn.current), M & 2))
      (M = (M & 1) | 2), (f.flags |= 128);
    else {
      if (u !== null && u.flags & 128)
        e: for (u = f.child; u !== null; ) {
          if (u.tag === 13) u.memoizedState !== null && yS(u, y, f);
          else if (u.tag === 19) yS(u, y, f);
          else if (u.child !== null) {
            (u.child.return = u), (u = u.child);
            continue;
          }
          if (u === f) break e;
          for (; u.sibling === null; ) {
            if (u.return === null || u.return === f) break e;
            u = u.return;
          }
          (u.sibling.return = u.return), (u = u.sibling);
        }
      M &= 1;
    }
    if ((dt(tn, M), !(f.mode & 1))) f.memoizedState = null;
    else
      switch (C) {
        case "forwards":
          for (y = f.child, C = null; y !== null; )
            (u = y.alternate),
              u !== null && cd(u) === null && (C = y),
              (y = y.sibling);
          (y = C),
            y === null
              ? ((C = f.child), (f.child = null))
              : ((C = y.sibling), (y.sibling = null)),
            z0(f, !1, C, y, T);
          break;
        case "backwards":
          for (y = null, C = f.child, f.child = null; C !== null; ) {
            if (((u = C.alternate), u !== null && cd(u) === null)) {
              f.child = C;
              break;
            }
            (u = C.sibling), (C.sibling = y), (y = C), (C = u);
          }
          z0(f, !0, y, null, T);
          break;
        case "together":
          z0(f, !1, null, null, void 0);
          break;
        default:
          f.memoizedState = null;
      }
    return f.child;
  }
  function _s(u, f, y) {
    if (
      (u !== null && (f.dependencies = u.dependencies),
      (Pl |= f.lanes),
      !(y & f.childLanes))
    )
      return null;
    if (u !== null && f.child !== u.child) throw Error(o(153));
    if (f.child !== null) {
      for (
        u = f.child, y = ao(u, u.pendingProps), f.child = y, y.return = f;
        u.sibling !== null;

      )
        (u = u.sibling),
          (y = y.sibling = ao(u, u.pendingProps)),
          (y.return = f);
      y.sibling = null;
    }
    return f.child;
  }
  function mI(u, f, y) {
    switch (f.tag) {
      case 3:
        hS(f), Sl();
        break;
      case 5:
        DM(f);
        break;
      case 1:
        Gn(f.type) && Yh(f);
        break;
      case 4:
        C0(f, f.stateNode.containerInfo);
        break;
      case 10:
        xM(f, f.type._context, f.memoizedProps.value);
        break;
      case 13:
        var M = f.memoizedState;
        if (M !== null)
          return M.dehydrated !== null
            ? (dt(tn, tn.current & 1), (f.flags |= 128), null)
            : y & f.child.childLanes
            ? pS(u, f, y)
            : (dt(tn, tn.current & 1),
              (u = _s(u, f, y)),
              u !== null ? u.sibling : null);
        dt(tn, tn.current & 1);
        break;
      case 19:
        if (((M = (y & f.childLanes) !== 0), u.flags & 128)) {
          if (M) return vS(u, f, y);
          f.flags |= 128;
        }
        var C = f.memoizedState;
        if (
          (C !== null &&
            ((C.rendering = null), (C.tail = null), (C.lastEffect = null)),
          dt(tn, tn.current),
          M)
        )
          break;
        return null;
      case 22:
      case 23:
        return (f.lanes = 0), uS(u, f, y);
    }
    return _s(u, f, y);
  }
  function gI(u, f) {
    switch ((A0(f), f.tag)) {
      case 1:
        return (
          Gn(f.type) && Kh(),
          (u = f.flags),
          u & 65536 ? ((f.flags = (u & -65537) | 128), f) : null
        );
      case 3:
        return (
          El(),
          Nt(Gt),
          Nt(xn),
          b0(),
          (u = f.flags),
          u & 65536 && !(u & 128) ? ((f.flags = (u & -65537) | 128), f) : null
        );
      case 5:
        return E0(f), null;
      case 13:
        if (
          (Nt(tn), (u = f.memoizedState), u !== null && u.dehydrated !== null)
        ) {
          if (f.alternate === null) throw Error(o(340));
          Sl();
        }
        return (
          (u = f.flags), u & 65536 ? ((f.flags = (u & -65537) | 128), f) : null
        );
      case 19:
        return Nt(tn), null;
      case 4:
        return El(), null;
      case 10:
        return m0(f.type._context), null;
      case 22:
      case 23:
        return ry(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Sd = !1,
    ua = !1,
    yI = typeof WeakSet == "function" ? WeakSet : Set,
    Fe = null;
  function wd(u, f) {
    var y = u.ref;
    if (y !== null)
      if (typeof y == "function")
        try {
          y(null);
        } catch (M) {
          Mi(u, f, M);
        }
      else y.current = null;
  }
  function G0(u, f, y) {
    try {
      y();
    } catch (M) {
      Mi(u, f, M);
    }
  }
  var xS = !1;
  function vI(u, f) {
    for (G(u.containerInfo), Fe = f; Fe !== null; )
      if (
        ((u = Fe), (f = u.child), (u.subtreeFlags & 1028) !== 0 && f !== null)
      )
        (f.return = u), (Fe = f);
      else
        for (; Fe !== null; ) {
          u = Fe;
          try {
            var y = u.alternate;
            if (u.flags & 1024)
              switch (u.tag) {
                case 0:
                case 11:
                case 15:
                  break;
                case 1:
                  if (y !== null) {
                    var M = y.memoizedProps,
                      C = y.memoizedState,
                      T = u.stateNode,
                      O = T.getSnapshotBeforeUpdate(
                        u.elementType === u.type ? M : wr(u.type, M),
                        C
                      );
                    T.__reactInternalSnapshotBeforeUpdate = O;
                  }
                  break;
                case 3:
                  Me && ke(u.stateNode.containerInfo);
                  break;
                case 5:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  throw Error(o(163));
              }
          } catch (Y) {
            Mi(u, u.return, Y);
          }
          if (((f = u.sibling), f !== null)) {
            (f.return = u.return), (Fe = f);
            break;
          }
          Fe = u.return;
        }
    return (y = xS), (xS = !1), y;
  }
  function ca(u, f, y) {
    var M = f.updateQueue;
    if (((M = M !== null ? M.lastEffect : null), M !== null)) {
      var C = (M = M.next);
      do {
        if ((C.tag & u) === u) {
          var T = C.destroy;
          (C.destroy = void 0), T !== void 0 && G0(f, y, T);
        }
        C = C.next;
      } while (C !== M);
    }
  }
  function wc(u, f) {
    if (
      ((f = f.updateQueue), (f = f !== null ? f.lastEffect : null), f !== null)
    ) {
      var y = (f = f.next);
      do {
        if ((y.tag & u) === u) {
          var M = y.create;
          y.destroy = M();
        }
        y = y.next;
      } while (y !== f);
    }
  }
  function H0(u) {
    var f = u.ref;
    if (f !== null) {
      var y = u.stateNode;
      switch (u.tag) {
        case 5:
          u = oe(y);
          break;
        default:
          u = y;
      }
      typeof f == "function" ? f(u) : (f.current = u);
    }
  }
  function _S(u, f, y) {
    if (Xr && typeof Xr.onCommitFiberUnmount == "function")
      try {
        Xr.onCommitFiberUnmount($h, f);
      } catch {}
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (
          ((u = f.updateQueue), u !== null && ((u = u.lastEffect), u !== null))
        ) {
          var M = (u = u.next);
          do {
            var C = M,
              T = C.destroy;
            (C = C.tag),
              T !== void 0 && (C & 2 || C & 4) && G0(f, y, T),
              (M = M.next);
          } while (M !== u);
        }
        break;
      case 1:
        if (
          (wd(f, y),
          (u = f.stateNode),
          typeof u.componentWillUnmount == "function")
        )
          try {
            (u.props = f.memoizedProps),
              (u.state = f.memoizedState),
              u.componentWillUnmount();
          } catch (O) {
            Mi(f, y, O);
          }
        break;
      case 5:
        wd(f, y);
        break;
      case 4:
        Me
          ? ES(u, f, y)
          : me &&
            me &&
            ((f = f.stateNode.containerInfo), (y = zt(f)), xr(f, y));
    }
  }
  function AS(u, f, y) {
    for (var M = f; ; )
      if ((_S(u, M, y), M.child === null || (Me && M.tag === 4))) {
        if (M === f) break;
        for (; M.sibling === null; ) {
          if (M.return === null || M.return === f) return;
          M = M.return;
        }
        (M.sibling.return = M.return), (M = M.sibling);
      } else (M.child.return = M), (M = M.child);
  }
  function MS(u) {
    var f = u.alternate;
    f !== null && ((u.alternate = null), MS(f)),
      (u.child = null),
      (u.deletions = null),
      (u.sibling = null),
      u.tag === 5 && ((f = u.stateNode), f !== null && We(f)),
      (u.stateNode = null),
      (u.return = null),
      (u.dependencies = null),
      (u.memoizedProps = null),
      (u.memoizedState = null),
      (u.pendingProps = null),
      (u.stateNode = null),
      (u.updateQueue = null);
  }
  function SS(u) {
    return u.tag === 5 || u.tag === 3 || u.tag === 4;
  }
  function wS(u) {
    e: for (;;) {
      for (; u.sibling === null; ) {
        if (u.return === null || SS(u.return)) return null;
        u = u.return;
      }
      for (
        u.sibling.return = u.return, u = u.sibling;
        u.tag !== 5 && u.tag !== 6 && u.tag !== 18;

      ) {
        if (u.flags & 2 || u.child === null || u.tag === 4) continue e;
        (u.child.return = u), (u = u.child);
      }
      if (!(u.flags & 2)) return u.stateNode;
    }
  }
  function CS(u) {
    if (Me) {
      e: {
        for (var f = u.return; f !== null; ) {
          if (SS(f)) break e;
          f = f.return;
        }
        throw Error(o(160));
      }
      var y = f;
      switch (y.tag) {
        case 5:
          (f = y.stateNode),
            y.flags & 32 && (ft(f), (y.flags &= -33)),
            (y = wS(u)),
            W0(u, y, f);
          break;
        case 3:
        case 4:
          (f = y.stateNode.containerInfo), (y = wS(u)), V0(u, y, f);
          break;
        default:
          throw Error(o(161));
      }
    }
  }
  function V0(u, f, y) {
    var M = u.tag;
    if (M === 5 || M === 6) (u = u.stateNode), f ? Ae(y, u, f) : Ue(y, u);
    else if (M !== 4 && ((u = u.child), u !== null))
      for (V0(u, f, y), u = u.sibling; u !== null; )
        V0(u, f, y), (u = u.sibling);
  }
  function W0(u, f, y) {
    var M = u.tag;
    if (M === 5 || M === 6) (u = u.stateNode), f ? he(y, u, f) : et(y, u);
    else if (M !== 4 && ((u = u.child), u !== null))
      for (W0(u, f, y), u = u.sibling; u !== null; )
        W0(u, f, y), (u = u.sibling);
  }
  function ES(u, f, y) {
    for (var M = f, C = !1, T, O; ; ) {
      if (!C) {
        C = M.return;
        e: for (;;) {
          if (C === null) throw Error(o(160));
          switch (((T = C.stateNode), C.tag)) {
            case 5:
              O = !1;
              break e;
            case 3:
              (T = T.containerInfo), (O = !0);
              break e;
            case 4:
              (T = T.containerInfo), (O = !0);
              break e;
          }
          C = C.return;
        }
        C = !0;
      }
      if (M.tag === 5 || M.tag === 6)
        AS(u, M, y), O ? qe(T, M.stateNode) : Pe(T, M.stateNode);
      else if (M.tag === 18) O ? At(T, M.stateNode) : vt(T, M.stateNode);
      else if (M.tag === 4) {
        if (M.child !== null) {
          (T = M.stateNode.containerInfo),
            (O = !0),
            (M.child.return = M),
            (M = M.child);
          continue;
        }
      } else if ((_S(u, M, y), M.child !== null)) {
        (M.child.return = M), (M = M.child);
        continue;
      }
      if (M === f) break;
      for (; M.sibling === null; ) {
        if (M.return === null || M.return === f) return;
        (M = M.return), M.tag === 4 && (C = !1);
      }
      (M.sibling.return = M.return), (M = M.sibling);
    }
  }
  function J0(u, f) {
    if (Me) {
      switch (f.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          ca(3, f, f.return), wc(3, f), ca(5, f, f.return);
          return;
        case 1:
          return;
        case 5:
          var y = f.stateNode;
          if (y != null) {
            var M = f.memoizedProps;
            u = u !== null ? u.memoizedProps : M;
            var C = f.type,
              T = f.updateQueue;
            (f.updateQueue = null), T !== null && W(y, T, C, u, M, f);
          }
          return;
        case 6:
          if (f.stateNode === null) throw Error(o(162));
          (y = f.memoizedProps),
            de(f.stateNode, u !== null ? u.memoizedProps : y, y);
          return;
        case 3:
          se &&
            u !== null &&
            u.memoizedState.isDehydrated &&
            ht(f.stateNode.containerInfo);
          return;
        case 12:
          return;
        case 13:
          Cd(f);
          return;
        case 19:
          Cd(f);
          return;
        case 17:
          return;
      }
      throw Error(o(163));
    }
    switch (f.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        ca(3, f, f.return), wc(3, f), ca(5, f, f.return);
        return;
      case 12:
        return;
      case 13:
        Cd(f);
        return;
      case 19:
        Cd(f);
        return;
      case 3:
        se &&
          u !== null &&
          u.memoizedState.isDehydrated &&
          ht(f.stateNode.containerInfo);
        break;
      case 22:
      case 23:
        return;
    }
    e: if (me) {
      switch (f.tag) {
        case 1:
        case 5:
        case 6:
          break e;
        case 3:
        case 4:
          (f = f.stateNode), xr(f.containerInfo, f.pendingChildren);
          break e;
      }
      throw Error(o(163));
    }
  }
  function Cd(u) {
    var f = u.updateQueue;
    if (f !== null) {
      u.updateQueue = null;
      var y = u.stateNode;
      y === null && (y = u.stateNode = new yI()),
        f.forEach(function (M) {
          var C = bI.bind(null, u, M);
          y.has(M) || (y.add(M), M.then(C, C));
        });
    }
  }
  function xI(u, f) {
    for (Fe = f; Fe !== null; ) {
      f = Fe;
      var y = f.deletions;
      if (y !== null)
        for (var M = 0; M < y.length; M++) {
          var C = y[M];
          try {
            var T = u;
            Me ? ES(T, C, f) : AS(T, C, f);
            var O = C.alternate;
            O !== null && (O.return = null), (C.return = null);
          } catch (Ye) {
            Mi(C, f, Ye);
          }
        }
      if (((y = f.child), f.subtreeFlags & 12854 && y !== null))
        (y.return = f), (Fe = y);
      else
        for (; Fe !== null; ) {
          f = Fe;
          try {
            var Y = f.flags;
            if ((Y & 32 && Me && ft(f.stateNode), Y & 512)) {
              var fe = f.alternate;
              if (fe !== null) {
                var Be = fe.ref;
                Be !== null &&
                  (typeof Be == "function" ? Be(null) : (Be.current = null));
              }
            }
            if (Y & 8192)
              switch (f.tag) {
                case 13:
                  if (f.memoizedState !== null) {
                    var Ge = f.alternate;
                    (Ge === null || Ge.memoizedState === null) && (q0 = In());
                  }
                  break;
                case 22:
                  var at = f.memoizedState !== null,
                    tt = f.alternate,
                    Ht = tt !== null && tt.memoizedState !== null;
                  if (((y = f), Me)) {
                    e: if (((M = y), (C = at), (T = null), Me))
                      for (var Ze = M; ; ) {
                        if (Ze.tag === 5) {
                          if (T === null) {
                            T = Ze;
                            var qn = Ze.stateNode;
                            C ? Ut(qn) : ce(Ze.stateNode, Ze.memoizedProps);
                          }
                        } else if (Ze.tag === 6) {
                          if (T === null) {
                            var or = Ze.stateNode;
                            C ? K(or) : Se(or, Ze.memoizedProps);
                          }
                        } else if (
                          ((Ze.tag !== 22 && Ze.tag !== 23) ||
                            Ze.memoizedState === null ||
                            Ze === M) &&
                          Ze.child !== null
                        ) {
                          (Ze.child.return = Ze), (Ze = Ze.child);
                          continue;
                        }
                        if (Ze === M) break;
                        for (; Ze.sibling === null; ) {
                          if (Ze.return === null || Ze.return === M) break e;
                          T === Ze && (T = null), (Ze = Ze.return);
                        }
                        T === Ze && (T = null),
                          (Ze.sibling.return = Ze.return),
                          (Ze = Ze.sibling);
                      }
                  }
                  if (at && !Ht && y.mode & 1) {
                    Fe = y;
                    for (var ie = y.child; ie !== null; ) {
                      for (y = Fe = ie; Fe !== null; ) {
                        M = Fe;
                        var Z = M.child;
                        switch (M.tag) {
                          case 0:
                          case 11:
                          case 14:
                          case 15:
                            ca(4, M, M.return);
                            break;
                          case 1:
                            wd(M, M.return);
                            var ue = M.stateNode;
                            if (typeof ue.componentWillUnmount == "function") {
                              var Oe = M.return;
                              try {
                                (ue.props = M.memoizedProps),
                                  (ue.state = M.memoizedState),
                                  ue.componentWillUnmount();
                              } catch (Ye) {
                                Mi(M, Oe, Ye);
                              }
                            }
                            break;
                          case 5:
                            wd(M, M.return);
                            break;
                          case 22:
                            if (M.memoizedState !== null) {
                              PS(y);
                              continue;
                            }
                        }
                        Z !== null ? ((Z.return = M), (Fe = Z)) : PS(y);
                      }
                      ie = ie.sibling;
                    }
                  }
              }
            switch (Y & 4102) {
              case 2:
                CS(f), (f.flags &= -3);
                break;
              case 6:
                CS(f), (f.flags &= -3), J0(f.alternate, f);
                break;
              case 4096:
                f.flags &= -4097;
                break;
              case 4100:
                (f.flags &= -4097), J0(f.alternate, f);
                break;
              case 4:
                J0(f.alternate, f);
            }
          } catch (Ye) {
            Mi(f, f.return, Ye);
          }
          if (((y = f.sibling), y !== null)) {
            (y.return = f.return), (Fe = y);
            break;
          }
          Fe = f.return;
        }
    }
  }
  function _I(u, f, y) {
    (Fe = u), TS(u);
  }
  function TS(u, f, y) {
    for (var M = (u.mode & 1) !== 0; Fe !== null; ) {
      var C = Fe,
        T = C.child;
      if (C.tag === 22 && M) {
        var O = C.memoizedState !== null || Sd;
        if (!O) {
          var Y = C.alternate,
            fe = (Y !== null && Y.memoizedState !== null) || ua;
          Y = Sd;
          var Be = ua;
          if (((Sd = O), (ua = fe) && !Be))
            for (Fe = C; Fe !== null; )
              (O = Fe),
                (fe = O.child),
                O.tag === 22 && O.memoizedState !== null
                  ? BS(C)
                  : fe !== null
                  ? ((fe.return = O), (Fe = fe))
                  : BS(C);
          for (; T !== null; ) (Fe = T), TS(T), (T = T.sibling);
          (Fe = C), (Sd = Y), (ua = Be);
        }
        bS(u);
      } else
        C.subtreeFlags & 8772 && T !== null
          ? ((T.return = C), (Fe = T))
          : bS(u);
    }
  }
  function bS(u) {
    for (; Fe !== null; ) {
      var f = Fe;
      if (f.flags & 8772) {
        var y = f.alternate;
        try {
          if (f.flags & 8772)
            switch (f.tag) {
              case 0:
              case 11:
              case 15:
                ua || wc(5, f);
                break;
              case 1:
                var M = f.stateNode;
                if (f.flags & 4 && !ua)
                  if (y === null) M.componentDidMount();
                  else {
                    var C =
                      f.elementType === f.type
                        ? y.memoizedProps
                        : wr(f.type, y.memoizedProps);
                    M.componentDidUpdate(
                      C,
                      y.memoizedState,
                      M.__reactInternalSnapshotBeforeUpdate
                    );
                  }
                var T = f.updateQueue;
                T !== null && MM(f, T, M);
                break;
              case 3:
                var O = f.updateQueue;
                if (O !== null) {
                  if (((y = null), f.child !== null))
                    switch (f.child.tag) {
                      case 5:
                        y = oe(f.child.stateNode);
                        break;
                      case 1:
                        y = f.child.stateNode;
                    }
                  MM(f, O, y);
                }
                break;
              case 5:
                var Y = f.stateNode;
                y === null && f.flags & 4 && He(Y, f.type, f.memoizedProps, f);
                break;
              case 6:
                break;
              case 4:
                break;
              case 12:
                break;
              case 13:
                if (se && f.memoizedState === null) {
                  var fe = f.alternate;
                  if (fe !== null) {
                    var Be = fe.memoizedState;
                    if (Be !== null) {
                      var Ge = Be.dehydrated;
                      Ge !== null && yt(Ge);
                    }
                  }
                }
                break;
              case 19:
              case 17:
              case 21:
              case 22:
              case 23:
                break;
              default:
                throw Error(o(163));
            }
          ua || (f.flags & 512 && H0(f));
        } catch (at) {
          Mi(f, f.return, at);
        }
      }
      if (f === u) {
        Fe = null;
        break;
      }
      if (((y = f.sibling), y !== null)) {
        (y.return = f.return), (Fe = y);
        break;
      }
      Fe = f.return;
    }
  }
  function PS(u) {
    for (; Fe !== null; ) {
      var f = Fe;
      if (f === u) {
        Fe = null;
        break;
      }
      var y = f.sibling;
      if (y !== null) {
        (y.return = f.return), (Fe = y);
        break;
      }
      Fe = f.return;
    }
  }
  function BS(u) {
    for (; Fe !== null; ) {
      var f = Fe;
      try {
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            var y = f.return;
            try {
              wc(4, f);
            } catch (fe) {
              Mi(f, y, fe);
            }
            break;
          case 1:
            var M = f.stateNode;
            if (typeof M.componentDidMount == "function") {
              var C = f.return;
              try {
                M.componentDidMount();
              } catch (fe) {
                Mi(f, C, fe);
              }
            }
            var T = f.return;
            try {
              H0(f);
            } catch (fe) {
              Mi(f, T, fe);
            }
            break;
          case 5:
            var O = f.return;
            try {
              H0(f);
            } catch (fe) {
              Mi(f, O, fe);
            }
        }
      } catch (fe) {
        Mi(f, f.return, fe);
      }
      if (f === u) {
        Fe = null;
        break;
      }
      var Y = f.sibling;
      if (Y !== null) {
        (Y.return = f.return), (Fe = Y);
        break;
      }
      Fe = f.return;
    }
  }
  var Ed = 0,
    Td = 1,
    bd = 2,
    Pd = 3,
    Bd = 4;
  if (typeof Symbol == "function" && Symbol.for) {
    var Cc = Symbol.for;
    (Ed = Cc("selector.component")),
      (Td = Cc("selector.has_pseudo_class")),
      (bd = Cc("selector.role")),
      (Pd = Cc("selector.test_id")),
      (Bd = Cc("selector.text"));
  }
  function j0(u) {
    var f = xe(u);
    if (f != null) {
      if (typeof f.memoizedProps["data-testname"] != "string")
        throw Error(o(364));
      return f;
    }
    if (((u = _t(u)), u === null)) throw Error(o(362));
    return u.stateNode.current;
  }
  function X0(u, f) {
    switch (f.$$typeof) {
      case Ed:
        if (u.type === f.value) return !0;
        break;
      case Td:
        e: {
          (f = f.value), (u = [u, 0]);
          for (var y = 0; y < u.length; ) {
            var M = u[y++],
              C = u[y++],
              T = f[C];
            if (M.tag !== 5 || !le(M)) {
              for (; T != null && X0(M, T); ) C++, (T = f[C]);
              if (C === f.length) {
                f = !0;
                break e;
              } else
                for (M = M.child; M !== null; ) u.push(M, C), (M = M.sibling);
            }
          }
          f = !1;
        }
        return f;
      case bd:
        if (u.tag === 5 && Ee(u.stateNode, f.value)) return !0;
        break;
      case Bd:
        if (
          (u.tag === 5 || u.tag === 6) &&
          ((u = D(u)), u !== null && 0 <= u.indexOf(f.value))
        )
          return !0;
        break;
      case Pd:
        if (
          u.tag === 5 &&
          ((u = u.memoizedProps["data-testname"]),
          typeof u == "string" && u.toLowerCase() === f.value.toLowerCase())
        )
          return !0;
        break;
      default:
        throw Error(o(365));
    }
    return !1;
  }
  function K0(u) {
    switch (u.$$typeof) {
      case Ed:
        return "<" + (L(u.value) || "Unknown") + ">";
      case Td:
        return ":has(" + (K0(u) || "") + ")";
      case bd:
        return '[role="' + u.value + '"]';
      case Bd:
        return '"' + u.value + '"';
      case Pd:
        return '[data-testname="' + u.value + '"]';
      default:
        throw Error(o(365));
    }
  }
  function RS(u, f) {
    var y = [];
    u = [u, 0];
    for (var M = 0; M < u.length; ) {
      var C = u[M++],
        T = u[M++],
        O = f[T];
      if (C.tag !== 5 || !le(C)) {
        for (; O != null && X0(C, O); ) T++, (O = f[T]);
        if (T === f.length) y.push(C);
        else for (C = C.child; C !== null; ) u.push(C, T), (C = C.sibling);
      }
    }
    return y;
  }
  function Y0(u, f) {
    if (!nt) throw Error(o(363));
    (u = j0(u)), (u = RS(u, f)), (f = []), (u = Array.from(u));
    for (var y = 0; y < u.length; ) {
      var M = u[y++];
      if (M.tag === 5) le(M) || f.push(M.stateNode);
      else for (M = M.child; M !== null; ) u.push(M), (M = M.sibling);
    }
    return f;
  }
  var AI = Math.ceil,
    Rd = a.ReactCurrentDispatcher,
    Q0 = a.ReactCurrentOwner,
    mn = a.ReactCurrentBatchConfig,
    xt = 0,
    _n = null,
    An = null,
    Hn = 0,
    Oi = 0,
    bl = xi(0),
    En = 0,
    Ec = null,
    Pl = 0,
    Ld = 0,
    Z0 = 0,
    Tc = null,
    _i = null,
    q0 = 0,
    $0 = 1 / 0;
  function Bl() {
    $0 = In() + 500;
  }
  var Id = !1,
    ey = null,
    io = null,
    Dd = !1,
    ro = null,
    Fd = 0,
    bc = 0,
    ty = null,
    Nd = -1,
    Od = 0;
  function ui() {
    return xt & 6 ? In() : Nd !== -1 ? Nd : (Nd = In());
  }
  function so(u) {
    return u.mode & 1
      ? xt & 2 && Hn !== 0
        ? Hn & -Hn
        : iI.transition !== null
        ? (Od === 0 &&
            ((u = Qh), (Qh <<= 1), !(Qh & 4194240) && (Qh = 64), (Od = u)),
          Od)
        : ((u = Rt), u !== 0 ? u : Le())
      : 1;
  }
  function rr(u, f, y) {
    if (50 < bc) throw ((bc = 0), (ty = null), Error(o(185)));
    var M = kd(u, f);
    return M === null
      ? null
      : (fc(M, f, y),
        (!(xt & 2) || M !== _n) &&
          (M === _n && (!(xt & 2) && (Ld |= f), En === 4 && oo(M, Hn)),
          Ai(M, y),
          f === 1 && xt === 0 && !(u.mode & 1) && (Bl(), ed && Yr())),
        M);
  }
  function kd(u, f) {
    u.lanes |= f;
    var y = u.alternate;
    for (y !== null && (y.lanes |= f), y = u, u = u.return; u !== null; )
      (u.childLanes |= f),
        (y = u.alternate),
        y !== null && (y.childLanes |= f),
        (y = u),
        (u = u.return);
    return y.tag === 3 ? y.stateNode : null;
  }
  function Ai(u, f) {
    var y = u.callbackNode;
    KL(u, f);
    var M = qh(u, u === _n ? Hn : 0);
    if (M === 0)
      y !== null && yM(y), (u.callbackNode = null), (u.callbackPriority = 0);
    else if (((f = M & -M), u.callbackPriority !== f)) {
      if ((y != null && yM(y), f === 1))
        u.tag === 0 ? nI(IS.bind(null, u)) : vM(IS.bind(null, u)),
          Ke
            ? Je(function () {
                xt === 0 && Yr();
              })
            : u0(c0, Yr),
          (y = null);
      else {
        switch (gM(M)) {
          case 1:
            y = c0;
            break;
          case 4:
            y = qL;
            break;
          case 16:
            y = f0;
            break;
          case 536870912:
            y = $L;
            break;
          default:
            y = f0;
        }
        y = HS(y, LS.bind(null, u));
      }
      (u.callbackPriority = f), (u.callbackNode = y);
    }
  }
  function LS(u, f) {
    if (((Nd = -1), (Od = 0), xt & 6)) throw Error(o(327));
    var y = u.callbackNode;
    if (da() && u.callbackNode !== y) return null;
    var M = qh(u, u === _n ? Hn : 0);
    if (M === 0) return null;
    if (M & 30 || M & u.expiredLanes || f) f = Ud(u, M);
    else {
      f = M;
      var C = xt;
      xt |= 2;
      var T = NS();
      (_n !== u || Hn !== f) && (Bl(), fa(u, f));
      do
        try {
          wI();
          break;
        } catch (Y) {
          FS(u, Y);
        }
      while (1);
      p0(),
        (Rd.current = T),
        (xt = C),
        An !== null ? (f = 0) : ((_n = null), (Hn = 0), (f = En));
    }
    if (f !== 0) {
      if (
        (f === 2 && ((C = o0(u)), C !== 0 && ((M = C), (f = ny(u, C)))),
        f === 1)
      )
        throw ((y = Ec), fa(u, 0), oo(u, M), Ai(u, In()), y);
      if (f === 6) oo(u, M);
      else {
        if (
          ((C = u.current.alternate),
          !(M & 30) &&
            !MI(C) &&
            ((f = Ud(u, M)),
            f === 2 && ((T = o0(u)), T !== 0 && ((M = T), (f = ny(u, T)))),
            f === 1))
        )
          throw ((y = Ec), fa(u, 0), oo(u, M), Ai(u, In()), y);
        switch (((u.finishedWork = C), (u.finishedLanes = M), f)) {
          case 0:
          case 1:
            throw Error(o(345));
          case 2:
            ha(u, _i);
            break;
          case 3:
            if (
              (oo(u, M),
              (M & 130023424) === M && ((f = q0 + 500 - In()), 10 < f))
            ) {
              if (qh(u, 0) !== 0) break;
              if (((C = u.suspendedLanes), (C & M) !== M)) {
                ui(), (u.pingedLanes |= u.suspendedLanes & C);
                break;
              }
              u.timeoutHandle = $(ha.bind(null, u, _i), f);
              break;
            }
            ha(u, _i);
            break;
          case 4:
            if ((oo(u, M), (M & 4194240) === M)) break;
            for (f = u.eventTimes, C = -1; 0 < M; ) {
              var O = 31 - Sr(M);
              (T = 1 << O), (O = f[O]), O > C && (C = O), (M &= ~T);
            }
            if (
              ((M = C),
              (M = In() - M),
              (M =
                (120 > M
                  ? 120
                  : 480 > M
                  ? 480
                  : 1080 > M
                  ? 1080
                  : 1920 > M
                  ? 1920
                  : 3e3 > M
                  ? 3e3
                  : 4320 > M
                  ? 4320
                  : 1960 * AI(M / 1960)) - M),
              10 < M)
            ) {
              u.timeoutHandle = $(ha.bind(null, u, _i), M);
              break;
            }
            ha(u, _i);
            break;
          case 5:
            ha(u, _i);
            break;
          default:
            throw Error(o(329));
        }
      }
    }
    return Ai(u, In()), u.callbackNode === y ? LS.bind(null, u) : null;
  }
  function ny(u, f) {
    var y = Tc;
    return (
      u.current.memoizedState.isDehydrated && (fa(u, f).flags |= 256),
      (u = Ud(u, f)),
      u !== 2 && ((f = _i), (_i = y), f !== null && iy(f)),
      u
    );
  }
  function iy(u) {
    _i === null ? (_i = u) : _i.push.apply(_i, u);
  }
  function MI(u) {
    for (var f = u; ; ) {
      if (f.flags & 16384) {
        var y = f.updateQueue;
        if (y !== null && ((y = y.stores), y !== null))
          for (var M = 0; M < y.length; M++) {
            var C = y[M],
              T = C.getSnapshot;
            C = C.value;
            try {
              if (!Kr(T(), C)) return !1;
            } catch {
              return !1;
            }
          }
      }
      if (((y = f.child), f.subtreeFlags & 16384 && y !== null))
        (y.return = f), (f = y);
      else {
        if (f === u) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === u) return !0;
          f = f.return;
        }
        (f.sibling.return = f.return), (f = f.sibling);
      }
    }
    return !0;
  }
  function oo(u, f) {
    for (
      f &= ~Z0,
        f &= ~Ld,
        u.suspendedLanes |= f,
        u.pingedLanes &= ~f,
        u = u.expirationTimes;
      0 < f;

    ) {
      var y = 31 - Sr(f),
        M = 1 << y;
      (u[y] = -1), (f &= ~M);
    }
  }
  function IS(u) {
    if (xt & 6) throw Error(o(327));
    da();
    var f = qh(u, 0);
    if (!(f & 1)) return Ai(u, In()), null;
    var y = Ud(u, f);
    if (u.tag !== 0 && y === 2) {
      var M = o0(u);
      M !== 0 && ((f = M), (y = ny(u, M)));
    }
    if (y === 1) throw ((y = Ec), fa(u, 0), oo(u, f), Ai(u, In()), y);
    if (y === 6) throw Error(o(345));
    return (
      (u.finishedWork = u.current.alternate),
      (u.finishedLanes = f),
      ha(u, _i),
      Ai(u, In()),
      null
    );
  }
  function DS(u) {
    ro !== null && ro.tag === 0 && !(xt & 6) && da();
    var f = xt;
    xt |= 1;
    var y = mn.transition,
      M = Rt;
    try {
      if (((mn.transition = null), (Rt = 1), u)) return u();
    } finally {
      (Rt = M), (mn.transition = y), (xt = f), !(xt & 6) && Yr();
    }
  }
  function ry() {
    (Oi = bl.current), Nt(bl);
  }
  function fa(u, f) {
    (u.finishedWork = null), (u.finishedLanes = 0);
    var y = u.timeoutHandle;
    if ((y !== Xe && ((u.timeoutHandle = Xe), je(y)), An !== null))
      for (y = An.return; y !== null; ) {
        var M = y;
        switch ((A0(M), M.tag)) {
          case 1:
            (M = M.type.childContextTypes), M != null && Kh();
            break;
          case 3:
            El(), Nt(Gt), Nt(xn), b0();
            break;
          case 5:
            E0(M);
            break;
          case 4:
            El();
            break;
          case 13:
            Nt(tn);
            break;
          case 19:
            Nt(tn);
            break;
          case 10:
            m0(M.type._context);
            break;
          case 22:
          case 23:
            ry();
        }
        y = y.return;
      }
    if (
      ((_n = u),
      (An = u = ao(u.current, null)),
      (Hn = Oi = f),
      (En = 0),
      (Ec = null),
      (Z0 = Ld = Pl = 0),
      (_i = Tc = null),
      Qr !== null)
    ) {
      for (f = 0; f < Qr.length; f++)
        if (((y = Qr[f]), (M = y.interleaved), M !== null)) {
          y.interleaved = null;
          var C = M.next,
            T = y.pending;
          if (T !== null) {
            var O = T.next;
            (T.next = C), (M.next = O);
          }
          y.pending = M;
        }
      Qr = null;
    }
    return u;
  }
  function FS(u, f) {
    do {
      var y = An;
      try {
        if ((p0(), (fd.current = yd), hd)) {
          for (var M = cn.memoizedState; M !== null; ) {
            var C = M.queue;
            C !== null && (C.pending = null), (M = M.next);
          }
          hd = !1;
        }
        if (
          ((Tl = 0),
          (Dn = Yn = cn = null),
          (yc = !1),
          (vc = 0),
          (Q0.current = null),
          y === null || y.return === null)
        ) {
          (En = 1), (Ec = f), (An = null);
          break;
        }
        e: {
          var T = u,
            O = y.return,
            Y = y,
            fe = f;
          if (
            ((f = Hn),
            (Y.flags |= 32768),
            fe !== null &&
              typeof fe == "object" &&
              typeof fe.then == "function")
          ) {
            var Be = fe,
              Ge = Y,
              at = Ge.tag;
            if (!(Ge.mode & 1) && (at === 0 || at === 11 || at === 15)) {
              var tt = Ge.alternate;
              tt
                ? ((Ge.updateQueue = tt.updateQueue),
                  (Ge.memoizedState = tt.memoizedState),
                  (Ge.lanes = tt.lanes))
                : ((Ge.updateQueue = null), (Ge.memoizedState = null));
            }
            var Ht = nS(O);
            if (Ht !== null) {
              (Ht.flags &= -257),
                iS(Ht, O, Y, T, f),
                Ht.mode & 1 && tS(T, Be, f),
                (f = Ht),
                (fe = Be);
              var Ze = f.updateQueue;
              if (Ze === null) {
                var qn = new Set();
                qn.add(fe), (f.updateQueue = qn);
              } else Ze.add(fe);
              break e;
            } else {
              if (!(f & 1)) {
                tS(T, Be, f), sy();
                break e;
              }
              fe = Error(o(426));
            }
          } else if (Zt && Y.mode & 1) {
            var or = nS(O);
            if (or !== null) {
              !(or.flags & 65536) && (or.flags |= 256),
                iS(or, O, Y, T, f),
                w0(fe);
              break e;
            }
          }
          (T = fe),
            En !== 4 && (En = 2),
            Tc === null ? (Tc = [T]) : Tc.push(T),
            (fe = F0(fe, Y)),
            (Y = O);
          do {
            switch (Y.tag) {
              case 3:
                (Y.flags |= 65536), (f &= -f), (Y.lanes |= f);
                var ie = $M(Y, fe, f);
                AM(Y, ie);
                break e;
              case 1:
                T = fe;
                var Z = Y.type,
                  ue = Y.stateNode;
                if (
                  !(Y.flags & 128) &&
                  (typeof Z.getDerivedStateFromError == "function" ||
                    (ue !== null &&
                      typeof ue.componentDidCatch == "function" &&
                      (io === null || !io.has(ue))))
                ) {
                  (Y.flags |= 65536), (f &= -f), (Y.lanes |= f);
                  var Oe = eS(Y, T, f);
                  AM(Y, Oe);
                  break e;
                }
            }
            Y = Y.return;
          } while (Y !== null);
        }
        kS(y);
      } catch (Ye) {
        (f = Ye), An === y && y !== null && (An = y = y.return);
        continue;
      }
      break;
    } while (1);
  }
  function NS() {
    var u = Rd.current;
    return (Rd.current = yd), u === null ? yd : u;
  }
  function sy() {
    (En === 0 || En === 3 || En === 2) && (En = 4),
      _n === null || (!(Pl & 268435455) && !(Ld & 268435455)) || oo(_n, Hn);
  }
  function Ud(u, f) {
    var y = xt;
    xt |= 2;
    var M = NS();
    (_n === u && Hn === f) || fa(u, f);
    do
      try {
        SI();
        break;
      } catch (C) {
        FS(u, C);
      }
    while (1);
    if ((p0(), (xt = y), (Rd.current = M), An !== null)) throw Error(o(261));
    return (_n = null), (Hn = 0), En;
  }
  function SI() {
    for (; An !== null; ) OS(An);
  }
  function wI() {
    for (; An !== null && !QL(); ) OS(An);
  }
  function OS(u) {
    var f = GS(u.alternate, u, Oi);
    (u.memoizedProps = u.pendingProps),
      f === null ? kS(u) : (An = f),
      (Q0.current = null);
  }
  function kS(u) {
    var f = u;
    do {
      var y = f.alternate;
      if (((u = f.return), f.flags & 32768)) {
        if (((y = gI(y, f)), y !== null)) {
          (y.flags &= 32767), (An = y);
          return;
        }
        if (u !== null)
          (u.flags |= 32768), (u.subtreeFlags = 0), (u.deletions = null);
        else {
          (En = 6), (An = null);
          return;
        }
      } else if (((y = dI(y, f, Oi)), y !== null)) {
        An = y;
        return;
      }
      if (((f = f.sibling), f !== null)) {
        An = f;
        return;
      }
      An = f = u;
    } while (f !== null);
    En === 0 && (En = 5);
  }
  function ha(u, f) {
    var y = Rt,
      M = mn.transition;
    try {
      (mn.transition = null), (Rt = 1), CI(u, f, y);
    } finally {
      (mn.transition = M), (Rt = y);
    }
    return null;
  }
  function CI(u, f, y) {
    do da();
    while (ro !== null);
    if (xt & 6) throw Error(o(327));
    var M = u.finishedWork,
      C = u.finishedLanes;
    if (M === null) return null;
    if (((u.finishedWork = null), (u.finishedLanes = 0), M === u.current))
      throw Error(o(177));
    (u.callbackNode = null), (u.callbackPriority = 0);
    var T = M.lanes | M.childLanes;
    if (
      (YL(u, T),
      u === _n && ((An = _n = null), (Hn = 0)),
      (!(M.subtreeFlags & 2064) && !(M.flags & 2064)) ||
        Dd ||
        ((Dd = !0),
        HS(f0, function () {
          return da(), null;
        })),
      (T = (M.flags & 15990) !== 0),
      M.subtreeFlags & 15990 || T)
    ) {
      (T = mn.transition), (mn.transition = null);
      var O = Rt;
      Rt = 1;
      var Y = xt;
      (xt |= 4),
        (Q0.current = null),
        vI(u, M),
        xI(u, M),
        z(u.containerInfo),
        (u.current = M),
        _I(M),
        ZL(),
        (xt = Y),
        (Rt = O),
        (mn.transition = T);
    } else u.current = M;
    if (
      (Dd && ((Dd = !1), (ro = u), (Fd = C)),
      (T = u.pendingLanes),
      T === 0 && (io = null),
      eI(M.stateNode),
      Ai(u, In()),
      f !== null)
    )
      for (y = u.onRecoverableError, M = 0; M < f.length; M++) y(f[M]);
    if (Id) throw ((Id = !1), (u = ey), (ey = null), u);
    return (
      Fd & 1 && u.tag !== 0 && da(),
      (T = u.pendingLanes),
      T & 1 ? (u === ty ? bc++ : ((bc = 0), (ty = u))) : (bc = 0),
      Yr(),
      null
    );
  }
  function da() {
    if (ro !== null) {
      var u = gM(Fd),
        f = mn.transition,
        y = Rt;
      try {
        if (((mn.transition = null), (Rt = 16 > u ? 16 : u), ro === null))
          var M = !1;
        else {
          if (((u = ro), (ro = null), (Fd = 0), xt & 6)) throw Error(o(331));
          var C = xt;
          for (xt |= 4, Fe = u.current; Fe !== null; ) {
            var T = Fe,
              O = T.child;
            if (Fe.flags & 16) {
              var Y = T.deletions;
              if (Y !== null) {
                for (var fe = 0; fe < Y.length; fe++) {
                  var Be = Y[fe];
                  for (Fe = Be; Fe !== null; ) {
                    var Ge = Fe;
                    switch (Ge.tag) {
                      case 0:
                      case 11:
                      case 15:
                        ca(8, Ge, T);
                    }
                    var at = Ge.child;
                    if (at !== null) (at.return = Ge), (Fe = at);
                    else
                      for (; Fe !== null; ) {
                        Ge = Fe;
                        var tt = Ge.sibling,
                          Ht = Ge.return;
                        if ((MS(Ge), Ge === Be)) {
                          Fe = null;
                          break;
                        }
                        if (tt !== null) {
                          (tt.return = Ht), (Fe = tt);
                          break;
                        }
                        Fe = Ht;
                      }
                  }
                }
                var Ze = T.alternate;
                if (Ze !== null) {
                  var qn = Ze.child;
                  if (qn !== null) {
                    Ze.child = null;
                    do {
                      var or = qn.sibling;
                      (qn.sibling = null), (qn = or);
                    } while (qn !== null);
                  }
                }
                Fe = T;
              }
            }
            if (T.subtreeFlags & 2064 && O !== null) (O.return = T), (Fe = O);
            else
              e: for (; Fe !== null; ) {
                if (((T = Fe), T.flags & 2048))
                  switch (T.tag) {
                    case 0:
                    case 11:
                    case 15:
                      ca(9, T, T.return);
                  }
                var ie = T.sibling;
                if (ie !== null) {
                  (ie.return = T.return), (Fe = ie);
                  break e;
                }
                Fe = T.return;
              }
          }
          var Z = u.current;
          for (Fe = Z; Fe !== null; ) {
            O = Fe;
            var ue = O.child;
            if (O.subtreeFlags & 2064 && ue !== null)
              (ue.return = O), (Fe = ue);
            else
              e: for (O = Z; Fe !== null; ) {
                if (((Y = Fe), Y.flags & 2048))
                  try {
                    switch (Y.tag) {
                      case 0:
                      case 11:
                      case 15:
                        wc(9, Y);
                    }
                  } catch (Ye) {
                    Mi(Y, Y.return, Ye);
                  }
                if (Y === O) {
                  Fe = null;
                  break e;
                }
                var Oe = Y.sibling;
                if (Oe !== null) {
                  (Oe.return = Y.return), (Fe = Oe);
                  break e;
                }
                Fe = Y.return;
              }
          }
          if (
            ((xt = C),
            Yr(),
            Xr && typeof Xr.onPostCommitFiberRoot == "function")
          )
            try {
              Xr.onPostCommitFiberRoot($h, u);
            } catch {}
          M = !0;
        }
        return M;
      } finally {
        (Rt = y), (mn.transition = f);
      }
    }
    return !1;
  }
  function US(u, f, y) {
    (f = F0(y, f)),
      (f = $M(u, f, 1)),
      no(u, f),
      (f = ui()),
      (u = kd(u, 1)),
      u !== null && (fc(u, 1, f), Ai(u, f));
  }
  function Mi(u, f, y) {
    if (u.tag === 3) US(u, u, y);
    else
      for (; f !== null; ) {
        if (f.tag === 3) {
          US(f, u, y);
          break;
        } else if (f.tag === 1) {
          var M = f.stateNode;
          if (
            typeof f.type.getDerivedStateFromError == "function" ||
            (typeof M.componentDidCatch == "function" &&
              (io === null || !io.has(M)))
          ) {
            (u = F0(y, u)),
              (u = eS(f, u, 1)),
              no(f, u),
              (u = ui()),
              (f = kd(f, 1)),
              f !== null && (fc(f, 1, u), Ai(f, u));
            break;
          }
        }
        f = f.return;
      }
  }
  function EI(u, f, y) {
    var M = u.pingCache;
    M !== null && M.delete(f),
      (f = ui()),
      (u.pingedLanes |= u.suspendedLanes & y),
      _n === u &&
        (Hn & y) === y &&
        (En === 4 || (En === 3 && (Hn & 130023424) === Hn && 500 > In() - q0)
          ? fa(u, 0)
          : (Z0 |= y)),
      Ai(u, f);
  }
  function zS(u, f) {
    f === 0 &&
      (u.mode & 1
        ? ((f = Zh), (Zh <<= 1), !(Zh & 130023424) && (Zh = 4194304))
        : (f = 1));
    var y = ui();
    (u = kd(u, f)), u !== null && (fc(u, f, y), Ai(u, y));
  }
  function TI(u) {
    var f = u.memoizedState,
      y = 0;
    f !== null && (y = f.retryLane), zS(u, y);
  }
  function bI(u, f) {
    var y = 0;
    switch (u.tag) {
      case 13:
        var M = u.stateNode,
          C = u.memoizedState;
        C !== null && (y = C.retryLane);
        break;
      case 19:
        M = u.stateNode;
        break;
      default:
        throw Error(o(314));
    }
    M !== null && M.delete(f), zS(u, y);
  }
  var GS;
  GS = function (u, f, y) {
    if (u !== null)
      if (u.memoizedProps !== f.pendingProps || Gt.current) Ni = !0;
      else {
        if (!(u.lanes & y) && !(f.flags & 128)) return (Ni = !1), mI(u, f, y);
        Ni = !!(u.flags & 131072);
      }
    else (Ni = !1), Zt && f.flags & 1048576 && TM(f, ld, f.index);
    switch (((f.lanes = 0), f.tag)) {
      case 2:
        var M = f.type;
        u !== null &&
          ((u.alternate = null), (f.alternate = null), (f.flags |= 2)),
          (u = f.pendingProps);
        var C = eo(f, xn.current);
        _l(f, y), (C = B0(null, f, M, u, C, y));
        var T = R0();
        return (
          (f.flags |= 1),
          typeof C == "object" &&
          C !== null &&
          typeof C.render == "function" &&
          C.$$typeof === void 0
            ? ((f.tag = 1),
              (f.memoizedState = null),
              (f.updateQueue = null),
              Gn(M) ? ((T = !0), Yh(f)) : (T = !1),
              (f.memoizedState =
                C.state !== null && C.state !== void 0 ? C.state : null),
              y0(f),
              (C.updater = od),
              (f.stateNode = C),
              (C._reactInternals = f),
              x0(f, M, u, y),
              (f = k0(null, f, M, !0, T, y)))
            : ((f.tag = 0), Zt && T && _0(f), li(null, f, C, y), (f = f.child)),
          f
        );
      case 16:
        M = f.elementType;
        e: {
          switch (
            (u !== null &&
              ((u.alternate = null), (f.alternate = null), (f.flags |= 2)),
            (u = f.pendingProps),
            (C = M._init),
            (M = C(M._payload)),
            (f.type = M),
            (C = f.tag = BI(M)),
            (u = wr(M, u)),
            C)
          ) {
            case 0:
              f = O0(null, f, M, u, y);
              break e;
            case 1:
              f = fS(null, f, M, u, y);
              break e;
            case 11:
              f = oS(null, f, M, u, y);
              break e;
            case 14:
              f = aS(null, f, M, wr(M.type, u), y);
              break e;
          }
          throw Error(o(306, M, ""));
        }
        return f;
      case 0:
        return (
          (M = f.type),
          (C = f.pendingProps),
          (C = f.elementType === M ? C : wr(M, C)),
          O0(u, f, M, C, y)
        );
      case 1:
        return (
          (M = f.type),
          (C = f.pendingProps),
          (C = f.elementType === M ? C : wr(M, C)),
          fS(u, f, M, C, y)
        );
      case 3:
        e: {
          if ((hS(f), u === null)) throw Error(o(387));
          (M = f.pendingProps),
            (T = f.memoizedState),
            (C = T.element),
            _M(u, f),
            sd(f, M, null, y);
          var O = f.memoizedState;
          if (((M = O.element), se && T.isDehydrated))
            if (
              ((T = {
                element: M,
                isDehydrated: !1,
                cache: O.cache,
                transitions: O.transitions,
              }),
              (f.updateQueue.baseState = T),
              (f.memoizedState = T),
              f.flags & 256)
            ) {
              (C = Error(o(423))), (f = dS(u, f, M, y, C));
              break e;
            } else if (M !== C) {
              (C = Error(o(424))), (f = dS(u, f, M, y, C));
              break e;
            } else
              for (
                se &&
                  ((Fi = pe(f.stateNode.containerInfo)),
                  (Di = f),
                  (Zt = !0),
                  (Cr = null),
                  (hc = !1)),
                  y = IM(f, null, M, y),
                  f.child = y;
                y;

              )
                (y.flags = (y.flags & -3) | 4096), (y = y.sibling);
          else {
            if ((Sl(), M === C)) {
              f = _s(u, f, y);
              break e;
            }
            li(u, f, M, y);
          }
          f = f.child;
        }
        return f;
      case 5:
        return (
          DM(f),
          u === null && S0(f),
          (M = f.type),
          (C = f.pendingProps),
          (T = u !== null ? u.memoizedProps : null),
          (O = C.children),
          Ce(M, C) ? (O = null) : T !== null && Ce(M, T) && (f.flags |= 32),
          cS(u, f),
          li(u, f, O, y),
          f.child
        );
      case 6:
        return u === null && S0(f), null;
      case 13:
        return pS(u, f, y);
      case 4:
        return (
          C0(f, f.stateNode.containerInfo),
          (M = f.pendingProps),
          u === null ? (f.child = wl(f, null, M, y)) : li(u, f, M, y),
          f.child
        );
      case 11:
        return (
          (M = f.type),
          (C = f.pendingProps),
          (C = f.elementType === M ? C : wr(M, C)),
          oS(u, f, M, C, y)
        );
      case 7:
        return li(u, f, f.pendingProps, y), f.child;
      case 8:
        return li(u, f, f.pendingProps.children, y), f.child;
      case 12:
        return li(u, f, f.pendingProps.children, y), f.child;
      case 10:
        e: {
          if (
            ((M = f.type._context),
            (C = f.pendingProps),
            (T = f.memoizedProps),
            (O = C.value),
            xM(f, M, O),
            T !== null)
          )
            if (Kr(T.value, O)) {
              if (T.children === C.children && !Gt.current) {
                f = _s(u, f, y);
                break e;
              }
            } else
              for (T = f.child, T !== null && (T.return = f); T !== null; ) {
                var Y = T.dependencies;
                if (Y !== null) {
                  O = T.child;
                  for (var fe = Y.firstContext; fe !== null; ) {
                    if (fe.context === M) {
                      if (T.tag === 1) {
                        (fe = gs(-1, y & -y)), (fe.tag = 2);
                        var Be = T.updateQueue;
                        if (Be !== null) {
                          Be = Be.shared;
                          var Ge = Be.pending;
                          Ge === null
                            ? (fe.next = fe)
                            : ((fe.next = Ge.next), (Ge.next = fe)),
                            (Be.pending = fe);
                        }
                      }
                      (T.lanes |= y),
                        (fe = T.alternate),
                        fe !== null && (fe.lanes |= y),
                        g0(T.return, y, f),
                        (Y.lanes |= y);
                      break;
                    }
                    fe = fe.next;
                  }
                } else if (T.tag === 10) O = T.type === f.type ? null : T.child;
                else if (T.tag === 18) {
                  if (((O = T.return), O === null)) throw Error(o(341));
                  (O.lanes |= y),
                    (Y = O.alternate),
                    Y !== null && (Y.lanes |= y),
                    g0(O, y, f),
                    (O = T.sibling);
                } else O = T.child;
                if (O !== null) O.return = T;
                else
                  for (O = T; O !== null; ) {
                    if (O === f) {
                      O = null;
                      break;
                    }
                    if (((T = O.sibling), T !== null)) {
                      (T.return = O.return), (O = T);
                      break;
                    }
                    O = O.return;
                  }
                T = O;
              }
          li(u, f, C.children, y), (f = f.child);
        }
        return f;
      case 9:
        return (
          (C = f.type),
          (M = f.pendingProps.children),
          _l(f, y),
          (C = $i(C)),
          (M = M(C)),
          (f.flags |= 1),
          li(u, f, M, y),
          f.child
        );
      case 14:
        return (
          (M = f.type),
          (C = wr(M, f.pendingProps)),
          (C = wr(M.type, C)),
          aS(u, f, M, C, y)
        );
      case 15:
        return lS(u, f, f.type, f.pendingProps, y);
      case 17:
        return (
          (M = f.type),
          (C = f.pendingProps),
          (C = f.elementType === M ? C : wr(M, C)),
          u !== null &&
            ((u.alternate = null), (f.alternate = null), (f.flags |= 2)),
          (f.tag = 1),
          Gn(M) ? ((u = !0), Yh(f)) : (u = !1),
          _l(f, y),
          CM(f, M, C),
          x0(f, M, C, y),
          k0(null, f, M, !0, u, y)
        );
      case 19:
        return vS(u, f, y);
      case 22:
        return uS(u, f, y);
    }
    throw Error(o(156, f.tag));
  };
  function HS(u, f) {
    return u0(u, f);
  }
  function PI(u, f, y, M) {
    (this.tag = u),
      (this.key = y),
      (this.sibling =
        this.child =
        this.return =
        this.stateNode =
        this.type =
        this.elementType =
          null),
      (this.index = 0),
      (this.ref = null),
      (this.pendingProps = f),
      (this.dependencies =
        this.memoizedState =
        this.updateQueue =
        this.memoizedProps =
          null),
      (this.mode = M),
      (this.subtreeFlags = this.flags = 0),
      (this.deletions = null),
      (this.childLanes = this.lanes = 0),
      (this.alternate = null);
  }
  function sr(u, f, y, M) {
    return new PI(u, f, y, M);
  }
  function oy(u) {
    return (u = u.prototype), !(!u || !u.isReactComponent);
  }
  function BI(u) {
    if (typeof u == "function") return oy(u) ? 1 : 0;
    if (u != null) {
      if (((u = u.$$typeof), u === A)) return 11;
      if (u === _) return 14;
    }
    return 2;
  }
  function ao(u, f) {
    var y = u.alternate;
    return (
      y === null
        ? ((y = sr(u.tag, f, u.key, u.mode)),
          (y.elementType = u.elementType),
          (y.type = u.type),
          (y.stateNode = u.stateNode),
          (y.alternate = u),
          (u.alternate = y))
        : ((y.pendingProps = f),
          (y.type = u.type),
          (y.flags = 0),
          (y.subtreeFlags = 0),
          (y.deletions = null)),
      (y.flags = u.flags & 14680064),
      (y.childLanes = u.childLanes),
      (y.lanes = u.lanes),
      (y.child = u.child),
      (y.memoizedProps = u.memoizedProps),
      (y.memoizedState = u.memoizedState),
      (y.updateQueue = u.updateQueue),
      (f = u.dependencies),
      (y.dependencies =
        f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }),
      (y.sibling = u.sibling),
      (y.index = u.index),
      (y.ref = u.ref),
      y
    );
  }
  function zd(u, f, y, M, C, T) {
    var O = 2;
    if (((M = u), typeof u == "function")) oy(u) && (O = 1);
    else if (typeof u == "string") O = 5;
    else
      e: switch (u) {
        case h:
          return pa(y.children, C, T, f);
        case d:
          (O = 8), (C |= 8);
          break;
        case p:
          return (
            (u = sr(12, y, f, C | 2)), (u.elementType = p), (u.lanes = T), u
          );
        case x:
          return (u = sr(13, y, f, C)), (u.elementType = x), (u.lanes = T), u;
        case g:
          return (u = sr(19, y, f, C)), (u.elementType = g), (u.lanes = T), u;
        case w:
          return Gd(y, C, T, f);
        default:
          if (typeof u == "object" && u !== null)
            switch (u.$$typeof) {
              case m:
                O = 10;
                break e;
              case v:
                O = 9;
                break e;
              case A:
                O = 11;
                break e;
              case _:
                O = 14;
                break e;
              case S:
                (O = 16), (M = null);
                break e;
            }
          throw Error(o(130, u == null ? u : typeof u, ""));
      }
    return (
      (f = sr(O, y, f, C)), (f.elementType = u), (f.type = M), (f.lanes = T), f
    );
  }
  function pa(u, f, y, M) {
    return (u = sr(7, u, M, f)), (u.lanes = y), u;
  }
  function Gd(u, f, y, M) {
    return (
      (u = sr(22, u, M, f)),
      (u.elementType = w),
      (u.lanes = y),
      (u.stateNode = {}),
      u
    );
  }
  function ay(u, f, y) {
    return (u = sr(6, u, null, f)), (u.lanes = y), u;
  }
  function ly(u, f, y) {
    return (
      (f = sr(4, u.children !== null ? u.children : [], u.key, f)),
      (f.lanes = y),
      (f.stateNode = {
        containerInfo: u.containerInfo,
        pendingChildren: null,
        implementation: u.implementation,
      }),
      f
    );
  }
  function RI(u, f, y, M, C) {
    (this.tag = f),
      (this.containerInfo = u),
      (this.finishedWork =
        this.pingCache =
        this.current =
        this.pendingChildren =
          null),
      (this.timeoutHandle = Xe),
      (this.callbackNode = this.pendingContext = this.context = null),
      (this.callbackPriority = 0),
      (this.eventTimes = a0(0)),
      (this.expirationTimes = a0(-1)),
      (this.entangledLanes =
        this.finishedLanes =
        this.mutableReadLanes =
        this.expiredLanes =
        this.pingedLanes =
        this.suspendedLanes =
        this.pendingLanes =
          0),
      (this.entanglements = a0(0)),
      (this.identifierPrefix = M),
      (this.onRecoverableError = C),
      se && (this.mutableSourceEagerHydrationData = null);
  }
  function VS(u, f, y, M, C, T, O, Y, fe) {
    return (
      (u = new RI(u, f, y, Y, fe)),
      f === 1 ? ((f = 1), T === !0 && (f |= 8)) : (f = 0),
      (T = sr(3, null, null, f)),
      (u.current = T),
      (T.stateNode = u),
      (T.memoizedState = {
        element: M,
        isDehydrated: y,
        cache: null,
        transitions: null,
      }),
      y0(T),
      u
    );
  }
  function WS(u) {
    if (!u) return Kn;
    u = u._reactInternals;
    e: {
      if (b(u) !== u || u.tag !== 1) throw Error(o(170));
      var f = u;
      do {
        switch (f.tag) {
          case 3:
            f = f.stateNode.context;
            break e;
          case 1:
            if (Gn(f.type)) {
              f = f.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        f = f.return;
      } while (f !== null);
      throw Error(o(171));
    }
    if (u.tag === 1) {
      var y = u.type;
      if (Gn(y)) return pM(u, y, f);
    }
    return f;
  }
  function JS(u) {
    var f = u._reactInternals;
    if (f === void 0)
      throw typeof u.render == "function"
        ? Error(o(188))
        : ((u = Object.keys(u).join(",")), Error(o(268, u)));
    return (u = j(f)), u === null ? null : u.stateNode;
  }
  function jS(u, f) {
    if (((u = u.memoizedState), u !== null && u.dehydrated !== null)) {
      var y = u.retryLane;
      u.retryLane = y !== 0 && y < f ? y : f;
    }
  }
  function uy(u, f) {
    jS(u, f), (u = u.alternate) && jS(u, f);
  }
  function LI(u) {
    return (u = j(u)), u === null ? null : u.stateNode;
  }
  function II() {
    return null;
  }
  return (
    (t.attemptContinuousHydration = function (u) {
      if (u.tag === 13) {
        var f = ui();
        rr(u, 134217728, f), uy(u, 134217728);
      }
    }),
    (t.attemptHydrationAtCurrentPriority = function (u) {
      if (u.tag === 13) {
        var f = ui(),
          y = so(u);
        rr(u, y, f), uy(u, y);
      }
    }),
    (t.attemptSynchronousHydration = function (u) {
      switch (u.tag) {
        case 3:
          var f = u.stateNode;
          if (f.current.memoizedState.isDehydrated) {
            var y = cc(f.pendingLanes);
            y !== 0 && (l0(f, y | 1), Ai(f, In()), !(xt & 6) && (Bl(), Yr()));
          }
          break;
        case 13:
          var M = ui();
          DS(function () {
            return rr(u, 1, M);
          }),
            uy(u, 1);
      }
    }),
    (t.batchedUpdates = function (u, f) {
      var y = xt;
      xt |= 1;
      try {
        return u(f);
      } finally {
        (xt = y), xt === 0 && (Bl(), ed && Yr());
      }
    }),
    (t.createComponentSelector = function (u) {
      return { $$typeof: Ed, value: u };
    }),
    (t.createContainer = function (u, f, y, M, C, T, O) {
      return VS(u, f, !1, null, y, M, C, T, O);
    }),
    (t.createHasPseudoClassSelector = function (u) {
      return { $$typeof: Td, value: u };
    }),
    (t.createHydrationContainer = function (u, f, y, M, C, T, O, Y, fe) {
      return (
        (u = VS(y, M, !0, u, C, T, O, Y, fe)),
        (u.context = WS(null)),
        (y = u.current),
        (M = ui()),
        (C = so(y)),
        (T = gs(M, C)),
        (T.callback = f ?? null),
        no(y, T),
        (u.current.lanes = C),
        fc(u, C, M),
        Ai(u, M),
        u
      );
    }),
    (t.createPortal = function (u, f, y) {
      var M =
        3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: c,
        key: M == null ? null : "" + M,
        children: u,
        containerInfo: f,
        implementation: y,
      };
    }),
    (t.createRoleSelector = function (u) {
      return { $$typeof: bd, value: u };
    }),
    (t.createTestNameSelector = function (u) {
      return { $$typeof: Pd, value: u };
    }),
    (t.createTextSelector = function (u) {
      return { $$typeof: Bd, value: u };
    }),
    (t.deferredUpdates = function (u) {
      var f = Rt,
        y = mn.transition;
      try {
        return (mn.transition = null), (Rt = 16), u();
      } finally {
        (Rt = f), (mn.transition = y);
      }
    }),
    (t.discreteUpdates = function (u, f, y, M, C) {
      var T = Rt,
        O = mn.transition;
      try {
        return (mn.transition = null), (Rt = 1), u(f, y, M, C);
      } finally {
        (Rt = T), (mn.transition = O), xt === 0 && Bl();
      }
    }),
    (t.findAllNodes = Y0),
    (t.findBoundingRects = function (u, f) {
      if (!nt) throw Error(o(363));
      (f = Y0(u, f)), (u = []);
      for (var y = 0; y < f.length; y++) u.push(k(f[y]));
      for (f = u.length - 1; 0 < f; f--) {
        y = u[f];
        for (
          var M = y.x, C = M + y.width, T = y.y, O = T + y.height, Y = f - 1;
          0 <= Y;
          Y--
        )
          if (f !== Y) {
            var fe = u[Y],
              Be = fe.x,
              Ge = Be + fe.width,
              at = fe.y,
              tt = at + fe.height;
            if (M >= Be && T >= at && C <= Ge && O <= tt) {
              u.splice(f, 1);
              break;
            } else if (M !== Be || y.width !== fe.width || tt < T || at > O) {
              if (!(T !== at || y.height !== fe.height || Ge < M || Be > C)) {
                Be > M && ((fe.width += Be - M), (fe.x = M)),
                  Ge < C && (fe.width = C - Be),
                  u.splice(f, 1);
                break;
              }
            } else {
              at > T && ((fe.height += at - T), (fe.y = T)),
                tt < O && (fe.height = O - at),
                u.splice(f, 1);
              break;
            }
          }
      }
      return u;
    }),
    (t.findHostInstance = JS),
    (t.findHostInstanceWithNoPortals = function (u) {
      return (
        (u = U(u)),
        (u = u !== null ? J(u) : null),
        u === null ? null : u.stateNode
      );
    }),
    (t.findHostInstanceWithWarning = function (u) {
      return JS(u);
    }),
    (t.flushControlled = function (u) {
      var f = xt;
      xt |= 1;
      var y = mn.transition,
        M = Rt;
      try {
        (mn.transition = null), (Rt = 1), u();
      } finally {
        (Rt = M), (mn.transition = y), (xt = f), xt === 0 && (Bl(), Yr());
      }
    }),
    (t.flushPassiveEffects = da),
    (t.flushSync = DS),
    (t.focusWithin = function (u, f) {
      if (!nt) throw Error(o(363));
      for (u = j0(u), f = RS(u, f), f = Array.from(f), u = 0; u < f.length; ) {
        var y = f[u++];
        if (!le(y)) {
          if (y.tag === 5 && Te(y.stateNode)) return !0;
          for (y = y.child; y !== null; ) f.push(y), (y = y.sibling);
        }
      }
      return !1;
    }),
    (t.getCurrentUpdatePriority = function () {
      return Rt;
    }),
    (t.getFindAllNodesFailureDescription = function (u, f) {
      if (!nt) throw Error(o(363));
      var y = 0,
        M = [];
      u = [j0(u), 0];
      for (var C = 0; C < u.length; ) {
        var T = u[C++],
          O = u[C++],
          Y = f[O];
        if (
          (T.tag !== 5 || !le(T)) &&
          (X0(T, Y) && (M.push(K0(Y)), O++, O > y && (y = O)), O < f.length)
        )
          for (T = T.child; T !== null; ) u.push(T, O), (T = T.sibling);
      }
      if (y < f.length) {
        for (u = []; y < f.length; y++) u.push(K0(f[y]));
        return (
          `findAllNodes was able to match part of the selector:
  ` +
          (M.join(" > ") +
            `

No matching component was found for:
  `) +
          u.join(" > ")
        );
      }
      return null;
    }),
    (t.getPublicRootInstance = function (u) {
      if (((u = u.current), !u.child)) return null;
      switch (u.child.tag) {
        case 5:
          return oe(u.child.stateNode);
        default:
          return u.child.stateNode;
      }
    }),
    (t.injectIntoDevTools = function (u) {
      if (
        ((u = {
          bundleType: u.bundleType,
          version: u.version,
          rendererPackageName: u.rendererPackageName,
          rendererConfig: u.rendererConfig,
          overrideHookState: null,
          overrideHookStateDeletePath: null,
          overrideHookStateRenamePath: null,
          overrideProps: null,
          overridePropsDeletePath: null,
          overridePropsRenamePath: null,
          setErrorHandler: null,
          setSuspenseHandler: null,
          scheduleUpdate: null,
          currentDispatcherRef: a.ReactCurrentDispatcher,
          findHostInstanceByFiber: LI,
          findFiberByHostInstance: u.findFiberByHostInstance || II,
          findHostInstancesForRefresh: null,
          scheduleRefresh: null,
          scheduleRoot: null,
          setRefreshHandler: null,
          getCurrentFiber: null,
          reconcilerVersion: "18.0.0-fc46dba67-20220329",
        }),
        typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
      )
        u = !1;
      else {
        var f = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (f.isDisabled || !f.supportsFiber) u = !0;
        else {
          try {
            ($h = f.inject(u)), (Xr = f);
          } catch {}
          u = !!f.checkDCE;
        }
      }
      return u;
    }),
    (t.isAlreadyRendering = function () {
      return !1;
    }),
    (t.observeVisibleRects = function (u, f, y, M) {
      if (!nt) throw Error(o(363));
      u = Y0(u, f);
      var C = Re(u, y, M).disconnect;
      return {
        disconnect: function () {
          C();
        },
      };
    }),
    (t.registerMutableSourceForHydration = function (u, f) {
      var y = f._getVersion;
      (y = y(f._source)),
        u.mutableSourceEagerHydrationData == null
          ? (u.mutableSourceEagerHydrationData = [f, y])
          : u.mutableSourceEagerHydrationData.push(f, y);
    }),
    (t.runWithPriority = function (u, f) {
      var y = Rt;
      try {
        return (Rt = u), f();
      } finally {
        Rt = y;
      }
    }),
    (t.shouldError = function () {
      return null;
    }),
    (t.shouldSuspend = function () {
      return !1;
    }),
    (t.updateContainer = function (u, f, y, M) {
      var C = f.current,
        T = ui(),
        O = so(C);
      return (
        (y = WS(y)),
        f.context === null ? (f.context = y) : (f.pendingContext = y),
        (f = gs(T, O)),
        (f.payload = { element: u }),
        (M = M === void 0 ? null : M),
        M !== null && (f.callback = M),
        no(C, f),
        (u = rr(C, O, T)),
        u !== null && rd(u, C, O),
        O
      );
    }),
    t
  );
};
(function (n) {
  n.exports = J5;
})(G5);
const j5 = bb(M_);
var Zm = {},
  X5 = {
    get exports() {
      return Zm;
    },
    set exports(n) {
      Zm = n;
    },
  },
  HR = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ (function (n) {
  function e(I, G) {
    var z = I.length;
    I.push(G);
    e: for (; 0 < z; ) {
      var q = (z - 1) >>> 1,
        Q = I[q];
      if (0 < r(Q, G)) (I[q] = G), (I[z] = Q), (z = q);
      else break e;
    }
  }
  function t(I) {
    return I.length === 0 ? null : I[0];
  }
  function i(I) {
    if (I.length === 0) return null;
    var G = I[0],
      z = I.pop();
    if (z !== G) {
      I[0] = z;
      e: for (var q = 0, Q = I.length, ee = Q >>> 1; q < ee; ) {
        var ne = 2 * (q + 1) - 1,
          Ce = I[ne],
          _e = ne + 1,
          $ = I[_e];
        if (0 > r(Ce, z))
          _e < Q && 0 > r($, Ce)
            ? ((I[q] = $), (I[_e] = z), (q = _e))
            : ((I[q] = Ce), (I[ne] = z), (q = ne));
        else if (_e < Q && 0 > r($, z)) (I[q] = $), (I[_e] = z), (q = _e);
        else break e;
      }
    }
    return G;
  }
  function r(I, G) {
    var z = I.sortIndex - G.sortIndex;
    return z !== 0 ? z : I.id - G.id;
  }
  if (typeof performance == "object" && typeof performance.now == "function") {
    var s = performance;
    n.unstable_now = function () {
      return s.now();
    };
  } else {
    var o = Date,
      a = o.now();
    n.unstable_now = function () {
      return o.now() - a;
    };
  }
  var l = [],
    c = [],
    h = 1,
    d = null,
    p = 3,
    m = !1,
    v = !1,
    A = !1,
    x = typeof setTimeout == "function" ? setTimeout : null,
    g = typeof clearTimeout == "function" ? clearTimeout : null,
    _ = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" &&
    navigator.scheduling !== void 0 &&
    navigator.scheduling.isInputPending !== void 0 &&
    navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function S(I) {
    for (var G = t(c); G !== null; ) {
      if (G.callback === null) i(c);
      else if (G.startTime <= I)
        i(c), (G.sortIndex = G.expirationTime), e(l, G);
      else break;
      G = t(c);
    }
  }
  function w(I) {
    if (((A = !1), S(I), !v))
      if (t(l) !== null) (v = !0), oe(E);
      else {
        var G = t(c);
        G !== null && ae(w, G.startTime - I);
      }
  }
  function E(I, G) {
    (v = !1), A && ((A = !1), g(B), (B = -1)), (m = !0);
    var z = p;
    try {
      for (
        S(G), d = t(l);
        d !== null && (!(d.expirationTime > G) || (I && !U()));

      ) {
        var q = d.callback;
        if (typeof q == "function") {
          (d.callback = null), (p = d.priorityLevel);
          var Q = q(d.expirationTime <= G);
          (G = n.unstable_now()),
            typeof Q == "function" ? (d.callback = Q) : d === t(l) && i(l),
            S(G);
        } else i(l);
        d = t(l);
      }
      if (d !== null) var ee = !0;
      else {
        var ne = t(c);
        ne !== null && ae(w, ne.startTime - G), (ee = !1);
      }
      return ee;
    } finally {
      (d = null), (p = z), (m = !1);
    }
  }
  var P = !1,
    L = null,
    B = -1,
    b = 5,
    R = -1;
  function U() {
    return !(n.unstable_now() - R < b);
  }
  function j() {
    if (L !== null) {
      var I = n.unstable_now();
      R = I;
      var G = !0;
      try {
        G = L(!0, I);
      } finally {
        G ? V() : ((P = !1), (L = null));
      }
    } else P = !1;
  }
  var V;
  if (typeof _ == "function")
    V = function () {
      _(j);
    };
  else if (typeof MessageChannel < "u") {
    var J = new MessageChannel(),
      X = J.port2;
    (J.port1.onmessage = j),
      (V = function () {
        X.postMessage(null);
      });
  } else
    V = function () {
      x(j, 0);
    };
  function oe(I) {
    (L = I), P || ((P = !0), V());
  }
  function ae(I, G) {
    B = x(function () {
      I(n.unstable_now());
    }, G);
  }
  (n.unstable_IdlePriority = 5),
    (n.unstable_ImmediatePriority = 1),
    (n.unstable_LowPriority = 4),
    (n.unstable_NormalPriority = 3),
    (n.unstable_Profiling = null),
    (n.unstable_UserBlockingPriority = 2),
    (n.unstable_cancelCallback = function (I) {
      I.callback = null;
    }),
    (n.unstable_continueExecution = function () {
      v || m || ((v = !0), oe(E));
    }),
    (n.unstable_forceFrameRate = function (I) {
      0 > I || 125 < I
        ? console.error(
            "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
          )
        : (b = 0 < I ? Math.floor(1e3 / I) : 5);
    }),
    (n.unstable_getCurrentPriorityLevel = function () {
      return p;
    }),
    (n.unstable_getFirstCallbackNode = function () {
      return t(l);
    }),
    (n.unstable_next = function (I) {
      switch (p) {
        case 1:
        case 2:
        case 3:
          var G = 3;
          break;
        default:
          G = p;
      }
      var z = p;
      p = G;
      try {
        return I();
      } finally {
        p = z;
      }
    }),
    (n.unstable_pauseExecution = function () {}),
    (n.unstable_requestPaint = function () {}),
    (n.unstable_runWithPriority = function (I, G) {
      switch (I) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          I = 3;
      }
      var z = p;
      p = I;
      try {
        return G();
      } finally {
        p = z;
      }
    }),
    (n.unstable_scheduleCallback = function (I, G, z) {
      var q = n.unstable_now();
      switch (
        (typeof z == "object" && z !== null
          ? ((z = z.delay), (z = typeof z == "number" && 0 < z ? q + z : q))
          : (z = q),
        I)
      ) {
        case 1:
          var Q = -1;
          break;
        case 2:
          Q = 250;
          break;
        case 5:
          Q = 1073741823;
          break;
        case 4:
          Q = 1e4;
          break;
        default:
          Q = 5e3;
      }
      return (
        (Q = z + Q),
        (I = {
          id: h++,
          callback: G,
          priorityLevel: I,
          startTime: z,
          expirationTime: Q,
          sortIndex: -1,
        }),
        z > q
          ? ((I.sortIndex = z),
            e(c, I),
            t(l) === null &&
              I === t(c) &&
              (A ? (g(B), (B = -1)) : (A = !0), ae(w, z - q)))
          : ((I.sortIndex = Q), e(l, I), v || m || ((v = !0), oe(E))),
        I
      );
    }),
    (n.unstable_shouldYield = U),
    (n.unstable_wrapCallback = function (I) {
      var G = p;
      return function () {
        var z = p;
        p = G;
        try {
          return I.apply(this, arguments);
        } finally {
          p = z;
        }
      };
    });
})(HR);
(function (n) {
  n.exports = HR;
})(X5);
function VR(n, e, t = (i, r) => i === r) {
  if (n === e) return !0;
  if (!n || !e) return !1;
  const i = n.length;
  if (e.length !== i) return !1;
  for (let r = 0; r < i; r++) if (!t(n[r], e[r])) return !1;
  return !0;
}
const Ls = [];
function WR(n, e, t = !1, i = {}) {
  for (const s of Ls)
    if (VR(e, s.keys, s.equal)) {
      if (t) return;
      if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
      if (Object.prototype.hasOwnProperty.call(s, "response"))
        return s.response;
      if (!t) throw s.promise;
    }
  const r = {
    keys: e,
    equal: i.equal,
    promise: n(...e)
      .then((s) => (r.response = s))
      .then(() => {
        i.lifespan &&
          i.lifespan > 0 &&
          setTimeout(() => {
            const s = Ls.indexOf(r);
            s !== -1 && Ls.splice(s, 1);
          }, i.lifespan);
      })
      .catch((s) => (r.error = s)),
  };
  if ((Ls.push(r), !t)) throw r.promise;
}
const K5 = (n, e, t) => WR(n, e, !1, t),
  Y5 = (n, e, t) => void WR(n, e, !0, t),
  Q5 = (n) => {
    if (n === void 0 || n.length === 0) Ls.splice(0, Ls.length);
    else {
      const e = Ls.find((t) => VR(n, t.keys, t.equal));
      if (e) {
        const t = Ls.indexOf(e);
        t !== -1 && Ls.splice(t, 1);
      }
    }
  },
  FA = {},
  Z5 = (n) => void Object.assign(FA, n);
function q5(n, e) {
  function t(h, { args: d = [], attach: p, ...m }, v) {
    let A = `${h[0].toUpperCase()}${h.slice(1)}`,
      x;
    if (h === "primitive") {
      if (m.object === void 0)
        throw new Error("R3F: Primitives without 'object' are invalid!");
      const g = m.object;
      x = tu(g, { type: h, root: v, attach: p, primitive: !0 });
    } else {
      const g = FA[A];
      if (!g)
        throw new Error(
          `R3F: ${A} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`
        );
      if (!Array.isArray(d))
        throw new Error("R3F: The args prop must be an array!");
      x = tu(new g(...d), {
        type: h,
        root: v,
        attach: p,
        memoizedProps: { args: d },
      });
    }
    return (
      x.__r3f.attach === void 0 &&
        (x instanceof ct
          ? (x.__r3f.attach = "geometry")
          : x instanceof Cn && (x.__r3f.attach = "material")),
      A !== "inject" && yv(x, m),
      x
    );
  }
  function i(h, d) {
    let p = !1;
    if (d) {
      var m, v;
      (m = d.__r3f) != null && m.attach
        ? gv(h, d, d.__r3f.attach)
        : d.isObject3D && h.isObject3D && (h.add(d), (p = !0)),
        p || (v = h.__r3f) == null || v.objects.push(d),
        d.__r3f || tu(d, {}),
        (d.__r3f.parent = h),
        w_(d),
        nu(d);
    }
  }
  function r(h, d, p) {
    let m = !1;
    if (d) {
      var v, A;
      if ((v = d.__r3f) != null && v.attach) gv(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        (d.parent = h), d.dispatchEvent({ type: "added" });
        const x = h.children.filter((_) => _ !== d),
          g = x.indexOf(p);
        (h.children = [...x.slice(0, g), d, ...x.slice(g)]), (m = !0);
      }
      m || (A = h.__r3f) == null || A.objects.push(d),
        d.__r3f || tu(d, {}),
        (d.__r3f.parent = h),
        w_(d),
        nu(d);
    }
  }
  function s(h, d, p = !1) {
    h && [...h].forEach((m) => o(d, m, p));
  }
  function o(h, d, p) {
    if (d) {
      var m, v, A;
      if (
        (d.__r3f && (d.__r3f.parent = null),
        (m = h.__r3f) != null &&
          m.objects &&
          (h.__r3f.objects = h.__r3f.objects.filter((w) => w !== d)),
        (v = d.__r3f) != null && v.attach)
      )
        GE(h, d, d.__r3f.attach);
      else if (d.isObject3D && h.isObject3D) {
        var x;
        h.remove(d), (x = d.__r3f) != null && x.root && oV(d.__r3f.root, d);
      }
      const _ = (A = d.__r3f) == null ? void 0 : A.primitive,
        S = p === void 0 ? d.dispose !== null && !_ : p;
      if (!_) {
        var g;
        s((g = d.__r3f) == null ? void 0 : g.objects, d, S),
          s(d.children, d, S);
      }
      d.__r3f &&
        (delete d.__r3f.root,
        delete d.__r3f.objects,
        delete d.__r3f.handlers,
        delete d.__r3f.memoizedProps,
        _ || delete d.__r3f),
        S &&
          d.dispose &&
          d.type !== "Scene" &&
          Zm.unstable_scheduleCallback(Zm.unstable_IdlePriority, () => {
            try {
              d.dispose();
            } catch {}
          }),
        nu(h);
    }
  }
  function a(h, d, p, m) {
    var v;
    const A = (v = h.__r3f) == null ? void 0 : v.parent;
    if (!A) return;
    const x = t(d, p, h.__r3f.root);
    if (h.children) {
      for (const g of h.children) g.__r3f && i(x, g);
      h.children = h.children.filter((g) => !g.__r3f);
    }
    h.__r3f.objects.forEach((g) => i(x, g)),
      (h.__r3f.objects = []),
      h.__r3f.autoRemovedBeforeAppend || o(A, h),
      x.parent && (x.__r3f.autoRemovedBeforeAppend = !0),
      i(A, x),
      x.raycast &&
        x.__r3f.eventCount &&
        x.__r3f.root.getState().internal.interaction.push(x),
      [m, m.alternate].forEach((g) => {
        g !== null &&
          ((g.stateNode = x),
          g.ref &&
            (typeof g.ref == "function" ? g.ref(x) : (g.ref.current = x)));
      });
  }
  const l = () =>
    console.warn(
      "Text is not allowed in the R3F tree! This could be stray whitespace or characters."
    );
  return {
    reconciler: j5({
      createInstance: t,
      removeChild: o,
      appendChild: i,
      appendInitialChild: i,
      insertBefore: r,
      supportsMutation: !0,
      isPrimaryRenderer: !1,
      supportsPersistence: !1,
      supportsHydration: !1,
      noTimeout: -1,
      appendChildToContainer: (h, d) => {
        if (!d) return;
        const p = h.getState().scene;
        p.__r3f && ((p.__r3f.root = h), i(p, d));
      },
      removeChildFromContainer: (h, d) => {
        d && o(h.getState().scene, d);
      },
      insertInContainerBefore: (h, d, p) => {
        if (!d || !p) return;
        const m = h.getState().scene;
        m.__r3f && r(m, d, p);
      },
      getRootHostContext: () => null,
      getChildHostContext: (h) => h,
      finalizeInitialChildren(h) {
        var d;
        return !!((d = h == null ? void 0 : h.__r3f) != null ? d : {}).handlers;
      },
      prepareUpdate(h, d, p, m) {
        if (h.__r3f.primitive && m.object && m.object !== h) return [!0];
        {
          const { args: v = [], children: A, ...x } = m,
            { args: g = [], children: _, ...S } = p;
          if (!Array.isArray(v))
            throw new Error("R3F: the args prop must be an array!");
          if (v.some((E, P) => E !== g[P])) return [!0];
          const w = ZR(h, x, S, !0);
          return w.changes.length ? [!1, w] : null;
        }
      },
      commitUpdate(h, [d, p], m, v, A, x) {
        d ? a(h, m, A, x) : yv(h, p);
      },
      commitMount(h, d, p, m) {
        var v;
        const A = (v = h.__r3f) != null ? v : {};
        h.raycast &&
          A.handlers &&
          A.eventCount &&
          h.__r3f.root.getState().internal.interaction.push(h);
      },
      getPublicInstance: (h) => h,
      prepareForCommit: () => null,
      preparePortalMount: (h) => tu(h.getState().scene),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance(h) {
        var d;
        const { attach: p, parent: m } = (d = h.__r3f) != null ? d : {};
        p && m && GE(m, h, p), h.isObject3D && (h.visible = !1), nu(h);
      },
      unhideInstance(h, d) {
        var p;
        const { attach: m, parent: v } = (p = h.__r3f) != null ? p : {};
        m && v && gv(v, h, m),
          ((h.isObject3D && d.visible == null) || d.visible) &&
            (h.visible = !0),
          nu(h);
      },
      createTextInstance: l,
      hideTextInstance: l,
      unhideTextInstance: l,
      getCurrentEventPriority: () => (e ? e() : Po.DefaultEventPriority),
      beforeActiveInstanceBlur: () => {},
      afterActiveInstanceBlur: () => {},
      detachDeletedInstance: () => {},
      now:
        typeof performance < "u" && Kt.fun(performance.now)
          ? performance.now
          : Kt.fun(Date.now)
          ? Date.now
          : () => 0,
      scheduleTimeout: Kt.fun(setTimeout) ? setTimeout : void 0,
      cancelTimeout: Kt.fun(clearTimeout) ? clearTimeout : void 0,
    }),
    applyProps: yv,
  };
}
var OE, kE;
const JR = () => {
    var n;
    return (n = FA.ColorManagement) != null ? n : null;
  },
  jR = (n) => n && n.isOrthographicCamera,
  $5 = (n) => n && n.hasOwnProperty("current"),
  zh =
    typeof window < "u" &&
    (((OE = window.document) != null && OE.createElement) ||
      ((kE = window.navigator) == null ? void 0 : kE.product) === "ReactNative")
      ? H.useLayoutEffect
      : H.useEffect;
function XR(n) {
  const e = H.useRef(n);
  return zh(() => void (e.current = n), [n]), e;
}
function eV({ set: n }) {
  return zh(() => (n(new Promise(() => null)), () => n(!1)), [n]), null;
}
class KR extends H.Component {
  constructor(...e) {
    super(...e), (this.state = { error: !1 });
  }
  componentDidCatch(e) {
    this.props.set(e);
  }
  render() {
    return this.state.error ? null : this.props.children;
  }
}
KR.getDerivedStateFromError = () => ({ error: !0 });
const YR = "__default",
  UE = new Map(),
  tV = (n) => n && !!n.memoized && !!n.changes;
function QR(n) {
  const e = typeof window < "u" ? window.devicePixelRatio : 1;
  return Array.isArray(n) ? Math.min(Math.max(n[0], e), n[1]) : n;
}
const Xc = (n) => {
    var e;
    return (e = n.__r3f) == null ? void 0 : e.root.getState();
  },
  Kt = {
    obj: (n) => n === Object(n) && !Kt.arr(n) && typeof n != "function",
    fun: (n) => typeof n == "function",
    str: (n) => typeof n == "string",
    num: (n) => typeof n == "number",
    boo: (n) => typeof n == "boolean",
    und: (n) => n === void 0,
    arr: (n) => Array.isArray(n),
    equ(
      n,
      e,
      { arrays: t = "shallow", objects: i = "reference", strict: r = !0 } = {}
    ) {
      if (typeof n != typeof e || !!n != !!e) return !1;
      if (Kt.str(n) || Kt.num(n)) return n === e;
      const s = Kt.obj(n);
      if (s && i === "reference") return n === e;
      const o = Kt.arr(n);
      if (o && t === "reference") return n === e;
      if ((o || s) && n === e) return !0;
      let a;
      for (a in n) if (!(a in e)) return !1;
      if (s && t === "shallow" && i === "shallow") {
        for (a in r ? e : n)
          if (!Kt.equ(n[a], e[a], { strict: r, objects: "reference" }))
            return !1;
      } else for (a in r ? e : n) if (n[a] !== e[a]) return !1;
      if (Kt.und(a)) {
        if (
          (o && n.length === 0 && e.length === 0) ||
          (s && Object.keys(n).length === 0 && Object.keys(e).length === 0)
        )
          return !0;
        if (n !== e) return !1;
      }
      return !0;
    },
  };
function nV(n) {
  const e = { nodes: {}, materials: {} };
  return (
    n &&
      n.traverse((t) => {
        t.name && (e.nodes[t.name] = t),
          t.material &&
            !e.materials[t.material.name] &&
            (e.materials[t.material.name] = t.material);
      }),
    e
  );
}
function iV(n) {
  n.dispose && n.type !== "Scene" && n.dispose();
  for (const e in n) e.dispose == null || e.dispose(), delete n[e];
}
function tu(n, e) {
  const t = n;
  return (
    ((e != null && e.primitive) || !t.__r3f) &&
      (t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e,
      }),
    n
  );
}
function S_(n, e) {
  let t = n;
  if (e.includes("-")) {
    const i = e.split("-"),
      r = i.pop();
    return (t = i.reduce((s, o) => s[o], n)), { target: t, key: r };
  } else return { target: t, key: e };
}
const zE = /-\d+$/;
function gv(n, e, t) {
  if (Kt.str(t)) {
    if (zE.test(t)) {
      const s = t.replace(zE, ""),
        { target: o, key: a } = S_(n, s);
      Array.isArray(o[a]) || (o[a] = []);
    }
    const { target: i, key: r } = S_(n, t);
    (e.__r3f.previousAttach = i[r]), (i[r] = e);
  } else e.__r3f.previousAttach = t(n, e);
}
function GE(n, e, t) {
  var i, r;
  if (Kt.str(t)) {
    const { target: s, key: o } = S_(n, t),
      a = e.__r3f.previousAttach;
    a === void 0 ? delete s[o] : (s[o] = a);
  } else
    (i = e.__r3f) == null || i.previousAttach == null || i.previousAttach(n, e);
  (r = e.__r3f) == null || delete r.previousAttach;
}
function ZR(
  n,
  { children: e, key: t, ref: i, ...r },
  { children: s, key: o, ref: a, ...l } = {},
  c = !1
) {
  var h;
  const d = (h = n == null ? void 0 : n.__r3f) != null ? h : {},
    p = Object.entries(r),
    m = [];
  if (c) {
    const A = Object.keys(l);
    for (let x = 0; x < A.length; x++)
      r.hasOwnProperty(A[x]) || p.unshift([A[x], YR + "remove"]);
  }
  p.forEach(([A, x]) => {
    var g;
    if (
      ((g = n.__r3f) != null && g.primitive && A === "object") ||
      Kt.equ(x, l[A])
    )
      return;
    if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(A))
      return m.push([A, x, !0, []]);
    let _ = [];
    A.includes("-") && (_ = A.split("-")), m.push([A, x, !1, _]);
    for (const S in r) {
      const w = r[S];
      S.startsWith(`${A}-`) && m.push([S, w, !1, S.split("-")]);
    }
  });
  const v = { ...r };
  return (
    d.memoizedProps && d.memoizedProps.args && (v.args = d.memoizedProps.args),
    d.memoizedProps &&
      d.memoizedProps.attach &&
      (v.attach = d.memoizedProps.attach),
    { memoized: v, changes: m }
  );
}
function yv(n, e) {
  var t, i, r;
  const s = (t = n.__r3f) != null ? t : {},
    o = s.root,
    a =
      (i = o == null || o.getState == null ? void 0 : o.getState()) != null
        ? i
        : {},
    { memoized: l, changes: c } = tV(e) ? e : ZR(n, e),
    h = s.eventCount;
  n.__r3f && (n.__r3f.memoizedProps = l);
  for (let p = 0; p < c.length; p++) {
    let [m, v, A, x] = c[p],
      g = n,
      _ = g[m];
    if (x.length && ((_ = x.reduce((S, w) => S[w], n)), !(_ && _.set))) {
      const [S, ...w] = x.reverse();
      (g = w.reverse().reduce((E, P) => E[P], n)), (m = S);
    }
    if (v === YR + "remove")
      if (g.constructor) {
        let S = UE.get(g.constructor);
        S || ((S = new g.constructor()), UE.set(g.constructor, S)), (v = S[m]);
      } else v = 0;
    if (A)
      v ? (s.handlers[m] = v) : delete s.handlers[m],
        (s.eventCount = Object.keys(s.handlers).length);
    else if (_ && _.set && (_.copy || _ instanceof Za)) {
      if (Array.isArray(v)) _.fromArray ? _.fromArray(v) : _.set(...v);
      else if (_.copy && v && v.constructor && _.constructor === v.constructor)
        _.copy(v);
      else if (v !== void 0) {
        const S = _ instanceof Ie;
        !S && _.setScalar
          ? _.setScalar(v)
          : _ instanceof Za && v instanceof Za
          ? (_.mask = v.mask)
          : _.set(v),
          !JR() && !a.linear && S && _.convertSRGBToLinear();
      }
    } else
      (g[m] = v),
        !a.linear &&
          g[m] instanceof en &&
          g[m].format === Ti &&
          g[m].type === Xs &&
          (g[m].encoding = Tt);
    nu(n);
  }
  if (s.parent && a.internal && n.raycast && h !== s.eventCount) {
    const p = a.internal.interaction.indexOf(n);
    p > -1 && a.internal.interaction.splice(p, 1),
      s.eventCount && a.internal.interaction.push(n);
  }
  return (
    !(c.length === 1 && c[0][0] === "onUpdate") &&
      c.length &&
      (r = n.__r3f) != null &&
      r.parent &&
      w_(n),
    n
  );
}
function nu(n) {
  var e, t;
  const i =
    (e = n.__r3f) == null || (t = e.root) == null || t.getState == null
      ? void 0
      : t.getState();
  i && i.internal.frames === 0 && i.invalidate();
}
function w_(n) {
  n.onUpdate == null || n.onUpdate(n);
}
function rV(n, e) {
  n.manual ||
    (jR(n)
      ? ((n.left = e.width / -2),
        (n.right = e.width / 2),
        (n.top = e.height / 2),
        (n.bottom = e.height / -2))
      : (n.aspect = e.width / e.height),
    n.updateProjectionMatrix(),
    n.updateMatrixWorld());
}
function jp(n) {
  return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId;
}
function sV() {
  var n;
  const e = (typeof self < "u" && self) || (typeof window < "u" && window);
  if (!e) return Po.DefaultEventPriority;
  switch ((n = e.event) == null ? void 0 : n.type) {
    case "click":
    case "contextmenu":
    case "dblclick":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
      return Po.DiscreteEventPriority;
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "pointerenter":
    case "pointerleave":
    case "wheel":
      return Po.ContinuousEventPriority;
    default:
      return Po.DefaultEventPriority;
  }
}
function qR(n, e, t, i) {
  const r = t.get(e);
  r &&
    (t.delete(e),
    t.size === 0 && (n.delete(i), r.target.releasePointerCapture(i)));
}
function oV(n, e) {
  const { internal: t } = n.getState();
  (t.interaction = t.interaction.filter((i) => i !== e)),
    (t.initialHits = t.initialHits.filter((i) => i !== e)),
    t.hovered.forEach((i, r) => {
      (i.eventObject === e || i.object === e) && t.hovered.delete(r);
    }),
    t.capturedMap.forEach((i, r) => {
      qR(t.capturedMap, e, i, r);
    });
}
function aV(n) {
  function e(l) {
    const { internal: c } = n.getState(),
      h = l.offsetX - c.initialClick[0],
      d = l.offsetY - c.initialClick[1];
    return Math.round(Math.sqrt(h * h + d * d));
  }
  function t(l) {
    return l.filter((c) =>
      ["Move", "Over", "Enter", "Out", "Leave"].some((h) => {
        var d;
        return (d = c.__r3f) == null ? void 0 : d.handlers["onPointer" + h];
      })
    );
  }
  function i(l, c) {
    const h = n.getState(),
      d = new Set(),
      p = [],
      m = c ? c(h.internal.interaction) : h.internal.interaction;
    for (let g = 0; g < m.length; g++) {
      const _ = Xc(m[g]);
      _ && (_.raycaster.camera = void 0);
    }
    h.previousRoot || h.events.compute == null || h.events.compute(l, h);
    function v(g) {
      const _ = Xc(g);
      if (!_ || !_.events.enabled || _.raycaster.camera === null) return [];
      if (_.raycaster.camera === void 0) {
        var S;
        _.events.compute == null ||
          _.events.compute(
            l,
            _,
            (S = _.previousRoot) == null ? void 0 : S.getState()
          ),
          _.raycaster.camera === void 0 && (_.raycaster.camera = null);
      }
      return _.raycaster.camera ? _.raycaster.intersectObject(g, !0) : [];
    }
    let A = m
      .flatMap(v)
      .sort((g, _) => {
        const S = Xc(g.object),
          w = Xc(_.object);
        return !S || !w
          ? g.distance - _.distance
          : w.events.priority - S.events.priority || g.distance - _.distance;
      })
      .filter((g) => {
        const _ = jp(g);
        return d.has(_) ? !1 : (d.add(_), !0);
      });
    h.events.filter && (A = h.events.filter(A, h));
    for (const g of A) {
      let _ = g.object;
      for (; _; ) {
        var x;
        (x = _.__r3f) != null &&
          x.eventCount &&
          p.push({ ...g, eventObject: _ }),
          (_ = _.parent);
      }
    }
    if ("pointerId" in l && h.internal.capturedMap.has(l.pointerId))
      for (let g of h.internal.capturedMap.get(l.pointerId).values())
        d.has(jp(g.intersection)) || p.push(g.intersection);
    return p;
  }
  function r(l, c, h, d) {
    const p = n.getState();
    if (l.length) {
      const m = { stopped: !1 };
      for (const v of l) {
        const A = Xc(v.object) || p,
          { raycaster: x, pointer: g, camera: _, internal: S } = A,
          w = new F(g.x, g.y, 0).unproject(_),
          E = (R) => {
            var U, j;
            return (U =
              (j = S.capturedMap.get(R)) == null
                ? void 0
                : j.has(v.eventObject)) != null
              ? U
              : !1;
          },
          P = (R) => {
            const U = { intersection: v, target: c.target };
            S.capturedMap.has(R)
              ? S.capturedMap.get(R).set(v.eventObject, U)
              : S.capturedMap.set(R, new Map([[v.eventObject, U]])),
              c.target.setPointerCapture(R);
          },
          L = (R) => {
            const U = S.capturedMap.get(R);
            U && qR(S.capturedMap, v.eventObject, U, R);
          };
        let B = {};
        for (let R in c) {
          let U = c[R];
          typeof U != "function" && (B[R] = U);
        }
        let b = {
          ...v,
          ...B,
          pointer: g,
          intersections: l,
          stopped: m.stopped,
          delta: h,
          unprojectedPoint: w,
          ray: x.ray,
          camera: _,
          stopPropagation() {
            const R = "pointerId" in c && S.capturedMap.get(c.pointerId);
            if (
              (!R || R.has(v.eventObject)) &&
              ((b.stopped = m.stopped = !0),
              S.hovered.size &&
                Array.from(S.hovered.values()).find(
                  (U) => U.eventObject === v.eventObject
                ))
            ) {
              const U = l.slice(0, l.indexOf(v));
              s([...U, v]);
            }
          },
          target: {
            hasPointerCapture: E,
            setPointerCapture: P,
            releasePointerCapture: L,
          },
          currentTarget: {
            hasPointerCapture: E,
            setPointerCapture: P,
            releasePointerCapture: L,
          },
          nativeEvent: c,
        };
        if ((d(b), m.stopped === !0)) break;
      }
    }
    return l;
  }
  function s(l) {
    const { internal: c } = n.getState();
    for (const h of c.hovered.values())
      if (
        !l.length ||
        !l.find(
          (d) =>
            d.object === h.object &&
            d.index === h.index &&
            d.instanceId === h.instanceId
        )
      ) {
        const p = h.eventObject.__r3f,
          m = p == null ? void 0 : p.handlers;
        if ((c.hovered.delete(jp(h)), p != null && p.eventCount)) {
          const v = { ...h, intersections: l };
          m.onPointerOut == null || m.onPointerOut(v),
            m.onPointerLeave == null || m.onPointerLeave(v);
        }
      }
  }
  function o(l, c) {
    for (let h = 0; h < c.length; h++) {
      const d = c[h].__r3f;
      d == null ||
        d.handlers.onPointerMissed == null ||
        d.handlers.onPointerMissed(l);
    }
  }
  function a(l) {
    switch (l) {
      case "onPointerLeave":
      case "onPointerCancel":
        return () => s([]);
      case "onLostPointerCapture":
        return (c) => {
          const { internal: h } = n.getState();
          "pointerId" in c &&
            h.capturedMap.has(c.pointerId) &&
            requestAnimationFrame(() => {
              h.capturedMap.has(c.pointerId) &&
                (h.capturedMap.delete(c.pointerId), s([]));
            });
        };
    }
    return function (h) {
      const { onPointerMissed: d, internal: p } = n.getState();
      p.lastEvent.current = h;
      const m = l === "onPointerMove",
        v = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
        x = i(h, m ? t : void 0),
        g = v ? e(h) : 0;
      l === "onPointerDown" &&
        ((p.initialClick = [h.offsetX, h.offsetY]),
        (p.initialHits = x.map((S) => S.eventObject))),
        v && !x.length && g <= 2 && (o(h, p.interaction), d && d(h)),
        m && s(x);
      function _(S) {
        const w = S.eventObject,
          E = w.__r3f,
          P = E == null ? void 0 : E.handlers;
        if (E != null && E.eventCount)
          if (m) {
            if (
              P.onPointerOver ||
              P.onPointerEnter ||
              P.onPointerOut ||
              P.onPointerLeave
            ) {
              const L = jp(S),
                B = p.hovered.get(L);
              B
                ? B.stopped && S.stopPropagation()
                : (p.hovered.set(L, S),
                  P.onPointerOver == null || P.onPointerOver(S),
                  P.onPointerEnter == null || P.onPointerEnter(S));
            }
            P.onPointerMove == null || P.onPointerMove(S);
          } else {
            const L = P[l];
            L
              ? (!v || p.initialHits.includes(w)) &&
                (o(
                  h,
                  p.interaction.filter((B) => !p.initialHits.includes(B))
                ),
                L(S))
              : v &&
                p.initialHits.includes(w) &&
                o(
                  h,
                  p.interaction.filter((B) => !p.initialHits.includes(B))
                );
          }
      }
      r(x, h, g, _);
    };
  }
  return { handlePointer: a };
}
const $R = (n) => !!(n != null && n.render),
  e3 = H.createContext(null),
  lV = (n, e) => {
    const t = GR((a, l) => {
        const c = new F(),
          h = new F(),
          d = new F();
        function p(g = l().camera, _ = h, S = l().size) {
          const { width: w, height: E, top: P, left: L } = S,
            B = w / E;
          _ instanceof F ? d.copy(_) : d.set(..._);
          const b = g.getWorldPosition(c).distanceTo(d);
          if (jR(g))
            return {
              width: w / g.zoom,
              height: E / g.zoom,
              top: P,
              left: L,
              factor: 1,
              distance: b,
              aspect: B,
            };
          {
            const R = (g.fov * Math.PI) / 180,
              U = 2 * Math.tan(R / 2) * b,
              j = U * (w / E);
            return {
              width: j,
              height: U,
              top: P,
              left: L,
              factor: w / j,
              distance: b,
              aspect: B,
            };
          }
        }
        let m;
        const v = (g) =>
            a((_) => ({ performance: { ..._.performance, current: g } })),
          A = new ge();
        return {
          set: a,
          get: l,
          gl: null,
          camera: null,
          raycaster: null,
          events: { priority: 1, enabled: !0, connected: !1 },
          xr: null,
          scene: null,
          invalidate: (g = 1) => n(l(), g),
          advance: (g, _) => e(g, _, l()),
          legacy: !1,
          linear: !1,
          flat: !1,
          controls: null,
          clock: new RA(),
          pointer: A,
          mouse: A,
          frameloop: "always",
          onPointerMissed: void 0,
          performance: {
            current: 1,
            min: 0.5,
            max: 1,
            debounce: 200,
            regress: () => {
              const g = l();
              m && clearTimeout(m),
                g.performance.current !== g.performance.min &&
                  v(g.performance.min),
                (m = setTimeout(
                  () => v(l().performance.max),
                  g.performance.debounce
                ));
            },
          },
          size: { width: 0, height: 0, top: 0, left: 0, updateStyle: !1 },
          viewport: {
            initialDpr: 0,
            dpr: 0,
            width: 0,
            height: 0,
            top: 0,
            left: 0,
            aspect: 0,
            distance: 0,
            factor: 0,
            getCurrentViewport: p,
          },
          setEvents: (g) => a((_) => ({ ..._, events: { ..._.events, ...g } })),
          setSize: (g, _, S, w, E) => {
            const P = l().camera,
              L = {
                width: g,
                height: _,
                top: w || 0,
                left: E || 0,
                updateStyle: S,
              };
            a((B) => ({ size: L, viewport: { ...B.viewport, ...p(P, h, L) } }));
          },
          setDpr: (g) =>
            a((_) => {
              const S = QR(g);
              return {
                viewport: {
                  ..._.viewport,
                  dpr: S,
                  initialDpr: _.viewport.initialDpr || S,
                },
              };
            }),
          setFrameloop: (g = "always") => {
            const _ = l().clock;
            _.stop(),
              (_.elapsedTime = 0),
              g !== "never" && (_.start(), (_.elapsedTime = 0)),
              a(() => ({ frameloop: g }));
          },
          previousRoot: void 0,
          internal: {
            active: !1,
            priority: 0,
            frames: 0,
            lastEvent: H.createRef(),
            interaction: [],
            hovered: new Map(),
            subscribers: [],
            initialClick: [0, 0],
            initialHits: [],
            capturedMap: new Map(),
            subscribe: (g, _, S) => {
              const w = l().internal;
              return (
                (w.priority = w.priority + (_ > 0 ? 1 : 0)),
                w.subscribers.push({ ref: g, priority: _, store: S }),
                (w.subscribers = w.subscribers.sort(
                  (E, P) => E.priority - P.priority
                )),
                () => {
                  const E = l().internal;
                  E != null &&
                    E.subscribers &&
                    ((E.priority = E.priority - (_ > 0 ? 1 : 0)),
                    (E.subscribers = E.subscribers.filter((P) => P.ref !== g)));
                }
              );
            },
          },
        };
      }),
      i = t.getState();
    let r = i.size,
      s = i.viewport.dpr,
      o = i.camera;
    return (
      t.subscribe(() => {
        const { camera: a, size: l, viewport: c, gl: h, set: d } = t.getState();
        if (l !== r || c.dpr !== s) {
          var p;
          (r = l), (s = c.dpr), rV(a, l), h.setPixelRatio(c.dpr);
          const m =
            (p = l.updateStyle) != null
              ? p
              : typeof HTMLCanvasElement < "u" &&
                h.domElement instanceof HTMLCanvasElement;
          h.setSize(l.width, l.height, m);
        }
        a !== o &&
          ((o = a),
          d((m) => ({
            viewport: { ...m.viewport, ...m.viewport.getCurrentViewport(a) },
          })));
      }),
      t.subscribe((a) => n(a)),
      t
    );
  };
let Xp,
  uV = new Set(),
  cV = new Set(),
  fV = new Set();
function vv(n, e) {
  if (n.size) for (const { callback: t } of n.values()) t(e);
}
function Kc(n, e) {
  switch (n) {
    case "before":
      return vv(uV, e);
    case "after":
      return vv(cV, e);
    case "tail":
      return vv(fV, e);
  }
}
let xv, _v;
function Av(n, e, t) {
  let i = e.clock.getDelta();
  for (
    e.frameloop === "never" &&
      typeof n == "number" &&
      ((i = n - e.clock.elapsedTime),
      (e.clock.oldTime = e.clock.elapsedTime),
      (e.clock.elapsedTime = n)),
      xv = e.internal.subscribers,
      Xp = 0;
    Xp < xv.length;
    Xp++
  )
    (_v = xv[Xp]), _v.ref.current(_v.store.getState(), i, t);
  return (
    !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera),
    (e.internal.frames = Math.max(0, e.internal.frames - 1)),
    e.frameloop === "always" ? 1 : e.internal.frames
  );
}
function hV(n) {
  let e = !1,
    t,
    i,
    r;
  function s(l) {
    (i = requestAnimationFrame(s)), (e = !0), (t = 0), Kc("before", l);
    for (const h of n.values()) {
      var c;
      (r = h.store.getState()),
        r.internal.active &&
          (r.frameloop === "always" || r.internal.frames > 0) &&
          !((c = r.gl.xr) != null && c.isPresenting) &&
          (t += Av(l, r));
    }
    if ((Kc("after", l), t === 0))
      return Kc("tail", l), (e = !1), cancelAnimationFrame(i);
  }
  function o(l, c = 1) {
    var h;
    if (!l) return n.forEach((d) => o(d.store.getState()), c);
    ((h = l.gl.xr) != null && h.isPresenting) ||
      !l.internal.active ||
      l.frameloop === "never" ||
      ((l.internal.frames = Math.min(60, l.internal.frames + c)),
      e || ((e = !0), requestAnimationFrame(s)));
  }
  function a(l, c = !0, h, d) {
    if ((c && Kc("before", l), h)) Av(l, h, d);
    else for (const p of n.values()) Av(l, p.store.getState());
    c && Kc("after", l);
  }
  return { loop: s, invalidate: o, advance: a };
}
function t3() {
  const n = H.useContext(e3);
  if (!n)
    throw new Error("R3F: Hooks can only be used within the Canvas component!");
  return n;
}
function Gi(n = (t) => t, e) {
  return t3()(n, e);
}
function lc(n, e = 0) {
  const t = t3(),
    i = t.getState().internal.subscribe,
    r = XR(n);
  return zh(() => i(r, e, t), [e, i, t]), null;
}
function n3(n, e) {
  return function (t, ...i) {
    const r = new t();
    return (
      n && n(r),
      Promise.all(
        i.map(
          (s) =>
            new Promise((o, a) =>
              r.load(
                s,
                (l) => {
                  l.scene && Object.assign(l, nV(l.scene)), o(l);
                },
                e,
                (l) => a(new Error(`Could not load ${s}: ${l.message})`))
              )
            )
        )
      )
    );
  };
}
function ia(n, e, t, i) {
  const r = Array.isArray(e) ? e : [e],
    s = K5(n3(t, i), [n, ...r], { equal: Kt.equ });
  return Array.isArray(e) ? s : s[0];
}
ia.preload = function (n, e, t) {
  const i = Array.isArray(e) ? e : [e];
  return Y5(n3(t), [n, ...i]);
};
ia.clear = function (n, e) {
  const t = Array.isArray(e) ? e : [e];
  return Q5([n, ...t]);
};
const Yu = new Map(),
  { invalidate: HE, advance: VE } = hV(Yu),
  { reconciler: qm, applyProps: Is } = q5(Yu, sV),
  eu = { objects: "shallow", strict: !1 },
  dV = (n, e) => {
    const t = typeof n == "function" ? n(e) : n;
    return $R(t)
      ? t
      : new uA({
          powerPreference: "high-performance",
          canvas: e,
          antialias: !0,
          alpha: !0,
          ...n,
        });
  };
function pV(n, e) {
  if (e) return e;
  if (
    typeof HTMLCanvasElement < "u" &&
    n instanceof HTMLCanvasElement &&
    n.parentElement
  ) {
    const {
      width: t,
      height: i,
      top: r,
      left: s,
    } = n.parentElement.getBoundingClientRect();
    return { width: t, height: i, top: r, left: s };
  } else if (typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas)
    return { width: n.width, height: n.height, top: 0, left: 0 };
  return { width: 0, height: 0, top: 0, left: 0 };
}
function mV(n) {
  const e = Yu.get(n),
    t = e == null ? void 0 : e.fiber,
    i = e == null ? void 0 : e.store;
  e && console.warn("R3F.createRoot should only be called once!");
  const r = typeof reportError == "function" ? reportError : console.error,
    s = i || lV(HE, VE),
    o =
      t ||
      qm.createContainer(s, Po.ConcurrentRoot, null, !1, null, "", r, null);
  e || Yu.set(n, { fiber: o, store: s });
  let a,
    l = !1,
    c;
  return {
    configure(h = {}) {
      let {
          gl: d,
          size: p,
          scene: m,
          events: v,
          onCreated: A,
          shadows: x = !1,
          linear: g = !1,
          flat: _ = !1,
          legacy: S = !1,
          orthographic: w = !1,
          frameloop: E = "always",
          dpr: P = [1, 2],
          performance: L,
          raycaster: B,
          camera: b,
          onPointerMissed: R,
        } = h,
        U = s.getState(),
        j = U.gl;
      U.gl || U.set({ gl: (j = dV(d, n)) });
      let V = U.raycaster;
      V || U.set({ raycaster: (V = new UR()) });
      const { params: J, ...X } = B || {};
      if (
        (Kt.equ(X, V, eu) || Is(V, { ...X }),
        Kt.equ(J, V.params, eu) || Is(V, { params: { ...V.params, ...J } }),
        !U.camera || (U.camera === c && !Kt.equ(c, b, eu)))
      ) {
        c = b;
        const q = b instanceof Mh,
          Q = q
            ? b
            : w
            ? new kr(0, 0, 0, 0, 0.1, 1e3)
            : new Vt(75, 0, 0.1, 1e3);
        q ||
          ((Q.position.z = 5),
          b && Is(Q, b),
          !U.camera && !(b != null && b.rotation) && Q.lookAt(0, 0, 0)),
          U.set({ camera: Q });
      }
      if (!U.scene) {
        let q;
        m instanceof Ym ? (q = m) : ((q = new Ym()), m && Is(q, m)),
          U.set({ scene: tu(q) });
      }
      if (!U.xr) {
        const q = (ne, Ce) => {
            const _e = s.getState();
            _e.frameloop !== "never" && VE(ne, !0, _e, Ce);
          },
          Q = () => {
            const ne = s.getState();
            (ne.gl.xr.enabled = ne.gl.xr.isPresenting),
              ne.gl.xr.setAnimationLoop(ne.gl.xr.isPresenting ? q : null),
              ne.gl.xr.isPresenting || HE(ne);
          },
          ee = {
            connect() {
              const ne = s.getState().gl;
              ne.xr.addEventListener("sessionstart", Q),
                ne.xr.addEventListener("sessionend", Q);
            },
            disconnect() {
              const ne = s.getState().gl;
              ne.xr.removeEventListener("sessionstart", Q),
                ne.xr.removeEventListener("sessionend", Q);
            },
          };
        j.xr && ee.connect(), U.set({ xr: ee });
      }
      if (j.shadowMap) {
        const q = j.shadowMap.enabled,
          Q = j.shadowMap.type;
        if (((j.shadowMap.enabled = !!x), Kt.boo(x))) j.shadowMap.type = _f;
        else if (Kt.str(x)) {
          var oe;
          const ee = { basic: X2, percentage: Bg, soft: _f, variance: Ua };
          j.shadowMap.type = (oe = ee[x]) != null ? oe : _f;
        } else Kt.obj(x) && Object.assign(j.shadowMap, x);
        (q !== j.shadowMap.enabled || Q !== j.shadowMap.type) &&
          (j.shadowMap.needsUpdate = !0);
      }
      const ae = JR();
      ae &&
        ("enabled" in ae
          ? (ae.enabled = !S)
          : "legacyMode" in ae && (ae.legacyMode = S));
      const I = g ? Ks : Tt,
        G = _ ? Or : X1;
      j.outputEncoding !== I && (j.outputEncoding = I),
        j.toneMapping !== G && (j.toneMapping = G),
        U.legacy !== S && U.set(() => ({ legacy: S })),
        U.linear !== g && U.set(() => ({ linear: g })),
        U.flat !== _ && U.set(() => ({ flat: _ })),
        d && !Kt.fun(d) && !$R(d) && !Kt.equ(d, j, eu) && Is(j, d),
        v && !U.events.handlers && U.set({ events: v(s) });
      const z = pV(n, p);
      return (
        Kt.equ(z, U.size, eu) ||
          U.setSize(z.width, z.height, z.updateStyle, z.top, z.left),
        P && U.viewport.dpr !== QR(P) && U.setDpr(P),
        U.frameloop !== E && U.setFrameloop(E),
        U.onPointerMissed || U.set({ onPointerMissed: R }),
        L &&
          !Kt.equ(L, U.performance, eu) &&
          U.set((q) => ({ performance: { ...q.performance, ...L } })),
        (a = A),
        (l = !0),
        this
      );
    },
    render(h) {
      return (
        l || this.configure(),
        qm.updateContainer(
          H.createElement(gV, {
            store: s,
            children: h,
            onCreated: a,
            rootElement: n,
          }),
          o,
          null,
          () => {}
        ),
        s
      );
    },
    unmount() {
      i3(n);
    },
  };
}
function gV({ store: n, children: e, onCreated: t, rootElement: i }) {
  return (
    zh(() => {
      const r = n.getState();
      r.set((s) => ({ internal: { ...s.internal, active: !0 } })),
        t && t(r),
        n.getState().events.connected ||
          r.events.connect == null ||
          r.events.connect(i);
    }, []),
    H.createElement(e3.Provider, { value: n }, e)
  );
}
function i3(n, e) {
  const t = Yu.get(n),
    i = t == null ? void 0 : t.fiber;
  if (i) {
    const r = t == null ? void 0 : t.store.getState();
    r && (r.internal.active = !1),
      qm.updateContainer(null, i, null, () => {
        r &&
          setTimeout(() => {
            try {
              var s, o, a, l;
              r.events.disconnect == null || r.events.disconnect(),
                (s = r.gl) == null ||
                  (o = s.renderLists) == null ||
                  o.dispose == null ||
                  o.dispose(),
                (a = r.gl) == null ||
                  a.forceContextLoss == null ||
                  a.forceContextLoss(),
                (l = r.gl) != null && l.xr && r.xr.disconnect(),
                iV(r),
                Yu.delete(n),
                e && e(n);
            } catch {}
          }, 500);
      });
  }
}
qm.injectIntoDevTools({
  bundleType: 0,
  rendererPackageName: "@react-three/fiber",
  version: H.version,
});
function vr() {
  return (
    (vr = Object.assign
      ? Object.assign.bind()
      : function (n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var i in t)
              Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
          }
          return n;
        }),
    vr.apply(this, arguments)
  );
}
function C_(n, e, t) {
  var i, r, s, o, a;
  e == null && (e = 100);
  function l() {
    var h = Date.now() - o;
    h < e && h >= 0
      ? (i = setTimeout(l, e - h))
      : ((i = null), t || ((a = n.apply(s, r)), (s = r = null)));
  }
  var c = function () {
    (s = this), (r = arguments), (o = Date.now());
    var h = t && !i;
    return (
      i || (i = setTimeout(l, e)), h && ((a = n.apply(s, r)), (s = r = null)), a
    );
  };
  return (
    (c.clear = function () {
      i && (clearTimeout(i), (i = null));
    }),
    (c.flush = function () {
      i && ((a = n.apply(s, r)), (s = r = null), clearTimeout(i), (i = null));
    }),
    c
  );
}
C_.debounce = C_;
var WE = C_;
function yV(n) {
  let {
    debounce: e,
    scroll: t,
    polyfill: i,
    offsetSize: r,
  } = n === void 0 ? { debounce: 0, scroll: !1, offsetSize: !1 } : n;
  const s = i || (typeof window > "u" ? class {} : window.ResizeObserver);
  if (!s)
    throw new Error(
      "This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills"
    );
  const [o, a] = H.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0,
    }),
    l = H.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: o,
    }),
    c = e ? (typeof e == "number" ? e : e.scroll) : null,
    h = e ? (typeof e == "number" ? e : e.resize) : null,
    d = H.useRef(!1);
  H.useEffect(() => ((d.current = !0), () => void (d.current = !1)));
  const [p, m, v] = H.useMemo(() => {
    const _ = () => {
      if (!l.current.element) return;
      const {
          left: S,
          top: w,
          width: E,
          height: P,
          bottom: L,
          right: B,
          x: b,
          y: R,
        } = l.current.element.getBoundingClientRect(),
        U = {
          left: S,
          top: w,
          width: E,
          height: P,
          bottom: L,
          right: B,
          x: b,
          y: R,
        };
      l.current.element instanceof HTMLElement &&
        r &&
        ((U.height = l.current.element.offsetHeight),
        (U.width = l.current.element.offsetWidth)),
        Object.freeze(U),
        d.current &&
          !AV(l.current.lastBounds, U) &&
          a((l.current.lastBounds = U));
    };
    return [_, h ? WE(_, h) : _, c ? WE(_, c) : _];
  }, [a, r, c, h]);
  function A() {
    l.current.scrollContainers &&
      (l.current.scrollContainers.forEach((_) =>
        _.removeEventListener("scroll", v, !0)
      ),
      (l.current.scrollContainers = null)),
      l.current.resizeObserver &&
        (l.current.resizeObserver.disconnect(),
        (l.current.resizeObserver = null));
  }
  function x() {
    l.current.element &&
      ((l.current.resizeObserver = new s(v)),
      l.current.resizeObserver.observe(l.current.element),
      t &&
        l.current.scrollContainers &&
        l.current.scrollContainers.forEach((_) =>
          _.addEventListener("scroll", v, { capture: !0, passive: !0 })
        ));
  }
  const g = (_) => {
    !_ ||
      _ === l.current.element ||
      (A(), (l.current.element = _), (l.current.scrollContainers = r3(_)), x());
  };
  return (
    xV(v, !!t),
    vV(m),
    H.useEffect(() => {
      A(), x();
    }, [t, v, m]),
    H.useEffect(() => A, []),
    [g, o, p]
  );
}
function vV(n) {
  H.useEffect(() => {
    const e = n;
    return (
      window.addEventListener("resize", e),
      () => void window.removeEventListener("resize", e)
    );
  }, [n]);
}
function xV(n, e) {
  H.useEffect(() => {
    if (e) {
      const t = n;
      return (
        window.addEventListener("scroll", t, { capture: !0, passive: !0 }),
        () => void window.removeEventListener("scroll", t, !0)
      );
    }
  }, [n, e]);
}
function r3(n) {
  const e = [];
  if (!n || n === document.body) return e;
  const {
    overflow: t,
    overflowX: i,
    overflowY: r,
  } = window.getComputedStyle(n);
  return (
    [t, i, r].some((s) => s === "auto" || s === "scroll") && e.push(n),
    [...e, ...r3(n.parentElement)]
  );
}
const _V = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
  AV = (n, e) => _V.every((t) => n[t] === e[t]);
var MV = Object.defineProperty,
  SV = Object.defineProperties,
  wV = Object.getOwnPropertyDescriptors,
  JE = Object.getOwnPropertySymbols,
  CV = Object.prototype.hasOwnProperty,
  EV = Object.prototype.propertyIsEnumerable,
  jE = (n, e, t) =>
    e in n
      ? MV(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  XE = (n, e) => {
    for (var t in e || (e = {})) CV.call(e, t) && jE(n, t, e[t]);
    if (JE) for (var t of JE(e)) EV.call(e, t) && jE(n, t, e[t]);
    return n;
  },
  TV = (n, e) => SV(n, wV(e));
function s3(n, e, t) {
  if (!n) return;
  if (t(n) === !0) return n;
  let i = e ? n.return : n.child;
  for (; i; ) {
    const r = s3(i, e, t);
    if (r) return r;
    i = e ? null : i.sibling;
  }
}
function o3(n) {
  try {
    return Object.defineProperties(n, {
      _currentRenderer: {
        get() {
          return null;
        },
        set() {},
      },
      _currentRenderer2: {
        get() {
          return null;
        },
        set() {},
      },
    });
  } catch {
    return n;
  }
}
const NA = o3(H.createContext(null));
class a3 extends H.Component {
  render() {
    return H.createElement(
      NA.Provider,
      { value: this._reactInternals },
      this.props.children
    );
  }
}
const { ReactCurrentOwner: KE, ReactCurrentDispatcher: YE } =
  H.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
function bV() {
  const n = H.useContext(NA);
  if (n === null)
    throw new Error(
      "its-fine: useFiber must be called within a <FiberProvider />!"
    );
  const e = H.useId();
  return H.useMemo(() => {
    var i;
    return (i = KE == null ? void 0 : KE.current) != null
      ? i
      : s3(n, !1, (r) => {
          let s = r.memoizedState;
          for (; s; ) {
            if (s.memoizedState === e) return !0;
            s = s.next;
          }
        });
  }, [n, e]);
}
function PV() {
  var n, e;
  const t = bV(),
    [i] = H.useState(() => new Map());
  i.clear();
  let r = t;
  for (; r; ) {
    const s = (n = r.type) == null ? void 0 : n._context;
    s &&
      s !== NA &&
      !i.has(s) &&
      i.set(
        s,
        (e = YE == null ? void 0 : YE.current) == null
          ? void 0
          : e.readContext(o3(s))
      ),
      (r = r.return);
  }
  return i;
}
function BV() {
  const n = PV();
  return H.useMemo(
    () =>
      Array.from(n.keys()).reduce(
        (e, t) => (i) =>
          H.createElement(
            e,
            null,
            H.createElement(t.Provider, TV(XE({}, i), { value: n.get(t) }))
          ),
        (e) => H.createElement(a3, XE({}, e))
      ),
    [n]
  );
}
const Mv = {
  onClick: ["click", !1],
  onContextMenu: ["contextmenu", !1],
  onDoubleClick: ["dblclick", !1],
  onWheel: ["wheel", !0],
  onPointerDown: ["pointerdown", !0],
  onPointerUp: ["pointerup", !0],
  onPointerLeave: ["pointerleave", !0],
  onPointerMove: ["pointermove", !0],
  onPointerCancel: ["pointercancel", !0],
  onLostPointerCapture: ["lostpointercapture", !0],
};
function RV(n) {
  const { handlePointer: e } = aV(n);
  return {
    priority: 1,
    enabled: !0,
    compute(t, i, r) {
      i.pointer.set(
        (t.offsetX / i.size.width) * 2 - 1,
        -(t.offsetY / i.size.height) * 2 + 1
      ),
        i.raycaster.setFromCamera(i.pointer, i.camera);
    },
    connected: void 0,
    handlers: Object.keys(Mv).reduce((t, i) => ({ ...t, [i]: e(i) }), {}),
    update: () => {
      var t;
      const { events: i, internal: r } = n.getState();
      (t = r.lastEvent) != null &&
        t.current &&
        i.handlers &&
        i.handlers.onPointerMove(r.lastEvent.current);
    },
    connect: (t) => {
      var i;
      const { set: r, events: s } = n.getState();
      s.disconnect == null || s.disconnect(),
        r((o) => ({ events: { ...o.events, connected: t } })),
        Object.entries((i = s.handlers) != null ? i : []).forEach(([o, a]) => {
          const [l, c] = Mv[o];
          t.addEventListener(l, a, { passive: c });
        });
    },
    disconnect: () => {
      const { set: t, events: i } = n.getState();
      if (i.connected) {
        var r;
        Object.entries((r = i.handlers) != null ? r : []).forEach(([s, o]) => {
          if (i && i.connected instanceof HTMLElement) {
            const [a] = Mv[s];
            i.connected.removeEventListener(a, o);
          }
        }),
          t((s) => ({ events: { ...s.events, connected: void 0 } }));
      }
    },
  };
}
const LV = H.forwardRef(function (
    {
      children: e,
      fallback: t,
      resize: i,
      style: r,
      gl: s,
      events: o = RV,
      eventSource: a,
      eventPrefix: l,
      shadows: c,
      linear: h,
      flat: d,
      legacy: p,
      orthographic: m,
      frameloop: v,
      dpr: A,
      performance: x,
      raycaster: g,
      camera: _,
      onPointerMissed: S,
      onCreated: w,
      ...E
    },
    P
  ) {
    H.useMemo(() => Z5(O5), []);
    const L = BV(),
      [B, b] = yV({ scroll: !0, debounce: { scroll: 50, resize: 0 }, ...i }),
      R = H.useRef(null),
      U = H.useRef(null);
    H.useImperativeHandle(P, () => R.current);
    const j = XR(S),
      [V, J] = H.useState(!1),
      [X, oe] = H.useState(!1);
    if (V) throw V;
    if (X) throw X;
    const ae = H.useRef(null);
    zh(() => {
      const G = R.current;
      b.width > 0 &&
        b.height > 0 &&
        G &&
        (ae.current || (ae.current = mV(G)),
        ae.current.configure({
          gl: s,
          events: o,
          shadows: c,
          linear: h,
          flat: d,
          legacy: p,
          orthographic: m,
          frameloop: v,
          dpr: A,
          performance: x,
          raycaster: g,
          camera: _,
          size: b,
          onPointerMissed: (...z) =>
            j.current == null ? void 0 : j.current(...z),
          onCreated: (z) => {
            z.events.connect == null ||
              z.events.connect(a ? ($5(a) ? a.current : a) : U.current),
              l &&
                z.setEvents({
                  compute: (q, Q) => {
                    const ee = q[l + "X"],
                      ne = q[l + "Y"];
                    Q.pointer.set(
                      (ee / Q.size.width) * 2 - 1,
                      -(ne / Q.size.height) * 2 + 1
                    ),
                      Q.raycaster.setFromCamera(Q.pointer, Q.camera);
                  },
                }),
              w == null || w(z);
          },
        }),
        ae.current.render(
          H.createElement(
            L,
            null,
            H.createElement(
              KR,
              { set: oe },
              H.createElement(
                H.Suspense,
                { fallback: H.createElement(eV, { set: J }) },
                e
              )
            )
          )
        ));
    }),
      H.useEffect(() => {
        const G = R.current;
        if (G) return () => i3(G);
      }, []);
    const I = a ? "none" : "auto";
    return H.createElement(
      "div",
      vr(
        {
          ref: U,
          style: {
            position: "relative",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            pointerEvents: I,
            ...r,
          },
        },
        E
      ),
      H.createElement(
        "div",
        { ref: B, style: { width: "100%", height: "100%" } },
        H.createElement("canvas", { ref: R, style: { display: "block" } }, t)
      )
    );
  }),
  Jg = H.forwardRef(function (e, t) {
    return H.createElement(
      a3,
      null,
      H.createElement(LV, vr({}, e, { ref: t }))
    );
  }),
  Gh = new F(),
  OA = new F(),
  IV = new F();
function DV(n, e, t) {
  const i = Gh.setFromMatrixPosition(n.matrixWorld);
  i.project(e);
  const r = t.width / 2,
    s = t.height / 2;
  return [i.x * r + r, -(i.y * s) + s];
}
function FV(n, e) {
  const t = Gh.setFromMatrixPosition(n.matrixWorld),
    i = OA.setFromMatrixPosition(e.matrixWorld),
    r = t.sub(i),
    s = e.getWorldDirection(IV);
  return r.angleTo(s) > Math.PI / 2;
}
function NV(n, e, t, i) {
  const r = Gh.setFromMatrixPosition(n.matrixWorld),
    s = r.clone();
  s.project(e), t.setFromCamera(s, e);
  const o = t.intersectObjects(i, !0);
  if (o.length) {
    const a = o[0].distance;
    return r.distanceTo(t.ray.origin) < a;
  }
  return !0;
}
function OV(n, e) {
  if (e instanceof kr) return e.zoom;
  if (e instanceof Vt) {
    const t = Gh.setFromMatrixPosition(n.matrixWorld),
      i = OA.setFromMatrixPosition(e.matrixWorld),
      r = (e.fov * Math.PI) / 180,
      s = t.distanceTo(i);
    return 1 / (2 * Math.tan(r / 2) * s);
  } else return 1;
}
function kV(n, e, t) {
  if (e instanceof Vt || e instanceof kr) {
    const i = Gh.setFromMatrixPosition(n.matrixWorld),
      r = OA.setFromMatrixPosition(e.matrixWorld),
      s = i.distanceTo(r),
      o = (t[1] - t[0]) / (e.far - e.near),
      a = t[1] - o * e.far;
    return Math.round(o * s + a);
  }
}
const E_ = (n) => (Math.abs(n) < 1e-10 ? 0 : n);
function l3(n, e, t = "") {
  let i = "matrix3d(";
  for (let r = 0; r !== 16; r++)
    i += E_(e[r] * n.elements[r]) + (r !== 15 ? "," : ")");
  return t + i;
}
const UV = (
    (n) => (e) =>
      l3(e, n)
  )([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
  zV = (
    (n) => (e, t) =>
      l3(e, n(t), "translate(-50%,-50%)")
  )((n) => [
    1 / n,
    1 / n,
    1 / n,
    1,
    -1 / n,
    -1 / n,
    -1 / n,
    -1,
    1 / n,
    1 / n,
    1 / n,
    1,
    1,
    1,
    1,
    1,
  ]);
function GV(n) {
  return n && typeof n == "object" && "current" in n;
}
const HV = H.forwardRef(
  (
    {
      children: n,
      eps: e = 0.001,
      style: t,
      className: i,
      prepend: r,
      center: s,
      fullscreen: o,
      portal: a,
      distanceFactor: l,
      sprite: c = !1,
      transform: h = !1,
      occlude: d,
      onOcclude: p,
      castShadow: m,
      receiveShadow: v,
      material: A,
      geometry: x,
      zIndexRange: g = [16777271, 0],
      calculatePosition: _ = DV,
      as: S = "div",
      wrapperClass: w,
      pointerEvents: E = "auto",
      ...P
    },
    L
  ) => {
    const {
        gl: B,
        camera: b,
        scene: R,
        size: U,
        raycaster: j,
        events: V,
        viewport: J,
      } = Gi(),
      [X] = H.useState(() => document.createElement(S)),
      oe = H.useRef(),
      ae = H.useRef(null),
      I = H.useRef(0),
      G = H.useRef([0, 0]),
      z = H.useRef(null),
      q = H.useRef(null),
      Q =
        (a == null ? void 0 : a.current) ||
        V.connected ||
        B.domElement.parentNode,
      ee = H.useRef(null),
      ne = H.useRef(!1),
      Ce = H.useMemo(
        () =>
          (d && d !== "blending") || (Array.isArray(d) && d.length && GV(d[0])),
        [d]
      );
    H.useLayoutEffect(() => {
      const ve = B.domElement;
      d && d === "blending"
        ? ((ve.style.zIndex = `${Math.floor(g[0] / 2)}`),
          (ve.style.position = "absolute"),
          (ve.style.pointerEvents = "none"))
        : ((ve.style.zIndex = null),
          (ve.style.position = null),
          (ve.style.pointerEvents = null));
    }, [d]),
      H.useLayoutEffect(() => {
        if (ae.current) {
          const ve = (oe.current = k2(X));
          if ((R.updateMatrixWorld(), h))
            X.style.cssText =
              "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
          else {
            const Me = _(ae.current, b, U);
            X.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Me[0]}px,${Me[1]}px,0);transform-origin:0 0;`;
          }
          return (
            Q && (r ? Q.prepend(X) : Q.appendChild(X)),
            () => {
              Q && Q.removeChild(X), ve.unmount();
            }
          );
        }
      }, [Q, h]),
      H.useLayoutEffect(() => {
        w && (X.className = w);
      }, [w]);
    const _e = H.useMemo(
        () =>
          h
            ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: U.width,
                height: U.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none",
              }
            : {
                position: "absolute",
                transform: s ? "translate3d(-50%,-50%,0)" : "none",
                ...(o && {
                  top: -U.height / 2,
                  left: -U.width / 2,
                  width: U.width,
                  height: U.height,
                }),
                ...t,
              },
        [t, s, o, U, h]
      ),
      $ = H.useMemo(() => ({ position: "absolute", pointerEvents: E }), [E]);
    H.useLayoutEffect(() => {
      if (((ne.current = !1), h)) {
        var ve;
        (ve = oe.current) == null ||
          ve.render(
            H.createElement(
              "div",
              { ref: z, style: _e },
              H.createElement(
                "div",
                { ref: q, style: $ },
                H.createElement("div", {
                  ref: L,
                  className: i,
                  style: t,
                  children: n,
                })
              )
            )
          );
      } else {
        var Me;
        (Me = oe.current) == null ||
          Me.render(
            H.createElement("div", {
              ref: L,
              style: _e,
              className: i,
              children: n,
            })
          );
      }
    });
    const je = H.useRef(!0);
    lc((ve) => {
      if (ae.current) {
        b.updateMatrixWorld(), ae.current.updateWorldMatrix(!0, !1);
        const Me = h ? G.current : _(ae.current, b, U);
        if (
          h ||
          Math.abs(I.current - b.zoom) > e ||
          Math.abs(G.current[0] - Me[0]) > e ||
          Math.abs(G.current[1] - Me[1]) > e
        ) {
          const me = FV(ae.current, b);
          let se = !1;
          Ce &&
            (d !== "blending"
              ? (se = [R])
              : Array.isArray(d) && (se = d.map((We) => We.current)));
          const xe = je.current;
          if (se) {
            const We = NV(ae.current, b, j, se);
            je.current = We && !me;
          } else je.current = !me;
          xe !== je.current &&
            (p
              ? p(!je.current)
              : (X.style.display = je.current ? "block" : "none"));
          const Ne = Math.floor(g[0] / 2),
            Le = d ? (Ce ? [g[0], Ne] : [Ne - 1, 0]) : g;
          if (((X.style.zIndex = `${kV(ae.current, b, Le)}`), h)) {
            const [We, Ke] = [U.width / 2, U.height / 2],
              Je = b.projectionMatrix.elements[5] * Ke,
              {
                isOrthographicCamera: nt,
                top: _t,
                left: k,
                bottom: D,
                right: le,
              } = b,
              Ee = UV(b.matrixWorldInverse),
              Te = nt
                ? `scale(${Je})translate(${E_(-(le + k) / 2)}px,${E_(
                    (_t + D) / 2
                  )}px)`
                : `translateZ(${Je}px)`;
            let Re = ae.current.matrixWorld;
            c &&
              ((Re = b.matrixWorldInverse
                .clone()
                .transpose()
                .copyPosition(Re)
                .scale(ae.current.scale)),
              (Re.elements[3] = Re.elements[7] = Re.elements[11] = 0),
              (Re.elements[15] = 1)),
              (X.style.width = U.width + "px"),
              (X.style.height = U.height + "px"),
              (X.style.perspective = nt ? "" : `${Je}px`),
              z.current &&
                q.current &&
                ((z.current.style.transform = `${Te}${Ee}translate(${We}px,${Ke}px)`),
                (q.current.style.transform = zV(Re, 1 / ((l || 10) / 400))));
          } else {
            const We = l === void 0 ? 1 : OV(ae.current, b) * l;
            X.style.transform = `translate3d(${Me[0]}px,${Me[1]}px,0) scale(${We})`;
          }
          (G.current = Me), (I.current = b.zoom);
        }
      }
      if (!Ce && ee.current && !ne.current)
        if (h) {
          if (z.current) {
            const Me = z.current.children[0];
            if (Me != null && Me.clientWidth && Me != null && Me.clientHeight) {
              const { isOrthographicCamera: me } = b;
              if (me || x)
                P.scale &&
                  (Array.isArray(P.scale)
                    ? P.scale instanceof F
                      ? ee.current.scale.copy(P.scale.clone().divideScalar(1))
                      : ee.current.scale.set(
                          1 / P.scale[0],
                          1 / P.scale[1],
                          1 / P.scale[2]
                        )
                    : ee.current.scale.setScalar(1 / P.scale));
              else {
                const se = (l || 10) / 400,
                  xe = Me.clientWidth * se,
                  Ne = Me.clientHeight * se;
                ee.current.scale.set(xe, Ne, 1);
              }
              ne.current = !0;
            }
          }
        } else {
          const Me = X.children[0];
          if (Me != null && Me.clientWidth && Me != null && Me.clientHeight) {
            const me = 1 / J.factor,
              se = Me.clientWidth * me,
              xe = Me.clientHeight * me;
            ee.current.scale.set(se, xe, 1), (ne.current = !0);
          }
          ee.current.lookAt(ve.camera.position);
        }
    });
    const Xe = H.useMemo(
      () => ({
        vertexShader: h
          ? void 0
          : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
        fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `,
      }),
      [h]
    );
    return H.createElement(
      "group",
      vr({}, P, { ref: ae }),
      d &&
        !Ce &&
        H.createElement(
          "mesh",
          { castShadow: m, receiveShadow: v, ref: ee },
          x || H.createElement("planeGeometry", null),
          A ||
            H.createElement("shaderMaterial", {
              side: dr,
              vertexShader: Xe.vertexShader,
              fragmentShader: Xe.fragmentShader,
            })
        )
    );
  }
);
let Yc = 0;
const VV = GR(
  (n) => (
    (vu.onStart = (e, t, i) => {
      n({
        active: !0,
        item: e,
        loaded: t,
        total: i,
        progress: ((t - Yc) / (i - Yc)) * 100,
      });
    }),
    (vu.onLoad = () => {
      n({ active: !1 });
    }),
    (vu.onError = (e) => n((t) => ({ errors: [...t.errors, e] }))),
    (vu.onProgress = (e, t, i) => {
      t === i && (Yc = i),
        n({
          active: !0,
          item: e,
          loaded: t,
          total: i,
          progress: ((t - Yc) / (i - Yc)) * 100 || 100,
        });
    }),
    { errors: [], active: !1, progress: 0, item: "", loaded: 0, total: 0 }
  )
);
function kA(n) {
  return function (e) {
    n.forEach(function (t) {
      typeof t == "function" ? t(e) : t != null && (t.current = e);
    });
  };
}
function Ru(n, e, t) {
  return (
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
function QE(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(n);
    e &&
      (i = i.filter(function (r) {
        return Object.getOwnPropertyDescriptor(n, r).enumerable;
      })),
      t.push.apply(t, i);
  }
  return t;
}
function ZE(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2
      ? QE(Object(t), !0).forEach(function (i) {
          Ru(n, i, t[i]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t))
      : QE(Object(t)).forEach(function (i) {
          Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i));
        });
  }
  return n;
}
new ge();
new ge();
function u3(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
var lr = function n(e, t, i) {
    var r = this;
    u3(this, n),
      Ru(this, "dot2", function (s, o) {
        return r.x * s + r.y * o;
      }),
      Ru(this, "dot3", function (s, o, a) {
        return r.x * s + r.y * o + r.z * a;
      }),
      (this.x = e),
      (this.y = t),
      (this.z = i);
  },
  WV = [
    new lr(1, 1, 0),
    new lr(-1, 1, 0),
    new lr(1, -1, 0),
    new lr(-1, -1, 0),
    new lr(1, 0, 1),
    new lr(-1, 0, 1),
    new lr(1, 0, -1),
    new lr(-1, 0, -1),
    new lr(0, 1, 1),
    new lr(0, -1, 1),
    new lr(0, 1, -1),
    new lr(0, -1, -1),
  ],
  qE = [
    151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140,
    36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120,
    234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33,
    88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71,
    134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
    230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161,
    1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130,
    116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250,
    124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227,
    47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44,
    154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98,
    108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34,
    242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14,
    239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121,
    50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243,
    141, 128, 195, 78, 66, 215, 61, 156, 180,
  ],
  $E = new Array(512),
  eT = new Array(512),
  JV = function (e) {
    e > 0 && e < 1 && (e *= 65536),
      (e = Math.floor(e)),
      e < 256 && (e |= e << 8);
    for (var t = 0; t < 256; t++) {
      var i;
      t & 1 ? (i = qE[t] ^ (e & 255)) : (i = qE[t] ^ ((e >> 8) & 255)),
        ($E[t] = $E[t + 256] = i),
        (eT[t] = eT[t + 256] = WV[i % 12]);
    }
  };
JV(0);
function jV(n) {
  if (typeof n == "number") n = Math.abs(n);
  else if (typeof n == "string") {
    var e = n;
    n = 0;
    for (var t = 0; t < e.length; t++)
      n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647;
  }
  return n === 0 && (n = 311), n;
}
function tT(n) {
  var e = jV(n);
  return function () {
    var t = (e * 48271) % 2147483647;
    return (e = t), t / 2147483647;
  };
}
var XV = function n(e) {
    var t = this;
    u3(this, n),
      Ru(this, "seed", 0),
      Ru(this, "init", function (i) {
        (t.seed = i), (t.value = tT(i));
      }),
      Ru(this, "value", tT(this.seed)),
      this.init(e);
  },
  KV = new XV(Math.random()),
  YV = { radius: 1, center: [0, 0, 0] };
function QV(n, e) {
  for (
    var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : KV,
      i = ZE(ZE({}, YV), e),
      r = i.radius,
      s = i.center,
      o = 0;
    o < n.length;
    o += 3
  ) {
    var a = Math.pow(t.value(), 0.3333333333333333),
      l = t.value() * 2 - 1,
      c = t.value() * 2 - 1,
      h = t.value() * 2 - 1,
      d = Math.sqrt(l * l + c * c + h * h);
    (l = (a * l) / d),
      (c = (a * c) / d),
      (h = (a * h) / d),
      (n[o] = l * r + s[0]),
      (n[o + 1] = c * r + s[1]),
      (n[o + 2] = h * r + s[2]);
  }
  return n;
}
function oh(n) {
  return (
    (oh =
      typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              typeof Symbol == "function" &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    oh(n)
  );
}
function ZV(n, e) {
  if (oh(n) !== "object" || n === null) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var i = t.call(n, e || "default");
    if (oh(i) !== "object") return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function qV(n) {
  var e = ZV(n, "string");
  return oh(e) === "symbol" ? e : String(e);
}
function ut(n, e, t) {
  return (
    (e = qV(e)),
    e in n
      ? Object.defineProperty(n, e, {
          value: t,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (n[e] = t),
    n
  );
}
const nT = (n, e) => ((n % e) + e) % e;
let $V = class extends ds {
  constructor(e, t) {
    super(),
      ut(this, "object", void 0),
      ut(this, "domElement", void 0),
      ut(this, "enabled", !0),
      ut(this, "target", new F()),
      ut(this, "minDistance", 0),
      ut(this, "maxDistance", 1 / 0),
      ut(this, "minZoom", 0),
      ut(this, "maxZoom", 1 / 0),
      ut(this, "minPolarAngle", 0),
      ut(this, "maxPolarAngle", Math.PI),
      ut(this, "minAzimuthAngle", -1 / 0),
      ut(this, "maxAzimuthAngle", 1 / 0),
      ut(this, "enableDamping", !1),
      ut(this, "dampingFactor", 0.05),
      ut(this, "enableZoom", !0),
      ut(this, "zoomSpeed", 1),
      ut(this, "enableRotate", !0),
      ut(this, "rotateSpeed", 1),
      ut(this, "enablePan", !0),
      ut(this, "panSpeed", 1),
      ut(this, "screenSpacePanning", !0),
      ut(this, "keyPanSpeed", 7),
      ut(this, "autoRotate", !1),
      ut(this, "autoRotateSpeed", 2),
      ut(this, "reverseOrbit", !1),
      ut(this, "keys", {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      ut(this, "mouseButtons", {
        LEFT: Ta.ROTATE,
        MIDDLE: Ta.DOLLY,
        RIGHT: Ta.PAN,
      }),
      ut(this, "touches", { ONE: ba.ROTATE, TWO: ba.DOLLY_PAN }),
      ut(this, "target0", void 0),
      ut(this, "position0", void 0),
      ut(this, "zoom0", void 0),
      ut(this, "_domElementKeyEvents", null),
      ut(this, "getPolarAngle", void 0),
      ut(this, "getAzimuthalAngle", void 0),
      ut(this, "setPolarAngle", void 0),
      ut(this, "setAzimuthalAngle", void 0),
      ut(this, "getDistance", void 0),
      ut(this, "listenToKeyEvents", void 0),
      ut(this, "saveState", void 0),
      ut(this, "reset", void 0),
      ut(this, "update", void 0),
      ut(this, "connect", void 0),
      ut(this, "dispose", void 0),
      (this.object = e),
      (this.domElement = t),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object instanceof Vt ? this.object.zoom : 1),
      (this.getPolarAngle = () => h.phi),
      (this.getAzimuthalAngle = () => h.theta),
      (this.setPolarAngle = (W) => {
        let he = nT(W, 2 * Math.PI),
          Ae = h.phi;
        Ae < 0 && (Ae += 2 * Math.PI), he < 0 && (he += 2 * Math.PI);
        let Pe = Math.abs(he - Ae);
        2 * Math.PI - Pe < Pe &&
          (he < Ae ? (he += 2 * Math.PI) : (Ae += 2 * Math.PI)),
          (d.phi = he - Ae),
          i.update();
      }),
      (this.setAzimuthalAngle = (W) => {
        let he = nT(W, 2 * Math.PI),
          Ae = h.theta;
        Ae < 0 && (Ae += 2 * Math.PI), he < 0 && (he += 2 * Math.PI);
        let Pe = Math.abs(he - Ae);
        2 * Math.PI - Pe < Pe &&
          (he < Ae ? (he += 2 * Math.PI) : (Ae += 2 * Math.PI)),
          (d.theta = he - Ae),
          i.update();
      }),
      (this.getDistance = () => i.object.position.distanceTo(i.target)),
      (this.listenToKeyEvents = (W) => {
        W.addEventListener("keydown", le), (this._domElementKeyEvents = W);
      }),
      (this.saveState = () => {
        i.target0.copy(i.target),
          i.position0.copy(i.object.position),
          (i.zoom0 = i.object instanceof Vt ? i.object.zoom : 1);
      }),
      (this.reset = () => {
        i.target.copy(i.target0),
          i.object.position.copy(i.position0),
          i.object instanceof Vt &&
            ((i.object.zoom = i.zoom0), i.object.updateProjectionMatrix()),
          i.dispatchEvent(r),
          i.update(),
          (l = a.NONE);
      }),
      (this.update = (() => {
        const W = new F(),
          he = new jn().setFromUnitVectors(e.up, new F(0, 1, 0)),
          Ae = he.clone().invert(),
          Pe = new F(),
          qe = new jn(),
          ft = 2 * Math.PI;
        return function () {
          const K = i.object.position;
          W.copy(K).sub(i.target),
            W.applyQuaternion(he),
            h.setFromVector3(W),
            i.autoRotate && l === a.NONE && j(R()),
            i.enableDamping
              ? ((h.theta += d.theta * i.dampingFactor),
                (h.phi += d.phi * i.dampingFactor))
              : ((h.theta += d.theta), (h.phi += d.phi));
          let ce = i.minAzimuthAngle,
            Se = i.maxAzimuthAngle;
          return (
            isFinite(ce) &&
              isFinite(Se) &&
              (ce < -Math.PI ? (ce += ft) : ce > Math.PI && (ce -= ft),
              Se < -Math.PI ? (Se += ft) : Se > Math.PI && (Se -= ft),
              ce <= Se
                ? (h.theta = Math.max(ce, Math.min(Se, h.theta)))
                : (h.theta =
                    h.theta > (ce + Se) / 2
                      ? Math.max(ce, h.theta)
                      : Math.min(Se, h.theta))),
            (h.phi = Math.max(
              i.minPolarAngle,
              Math.min(i.maxPolarAngle, h.phi)
            )),
            h.makeSafe(),
            (h.radius *= p),
            (h.radius = Math.max(
              i.minDistance,
              Math.min(i.maxDistance, h.radius)
            )),
            i.enableDamping === !0
              ? i.target.addScaledVector(m, i.dampingFactor)
              : i.target.add(m),
            W.setFromSpherical(h),
            W.applyQuaternion(Ae),
            K.copy(i.target).add(W),
            i.object.lookAt(i.target),
            i.enableDamping === !0
              ? ((d.theta *= 1 - i.dampingFactor),
                (d.phi *= 1 - i.dampingFactor),
                m.multiplyScalar(1 - i.dampingFactor))
              : (d.set(0, 0, 0), m.set(0, 0, 0)),
            (p = 1),
            v ||
            Pe.distanceToSquared(i.object.position) > c ||
            8 * (1 - qe.dot(i.object.quaternion)) > c
              ? (i.dispatchEvent(r),
                Pe.copy(i.object.position),
                qe.copy(i.object.quaternion),
                (v = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.connect = (W) => {
        W === document &&
          console.error(
            'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'
          ),
          (i.domElement = W),
          (i.domElement.style.touchAction = "none"),
          i.domElement.addEventListener("contextmenu", Re),
          i.domElement.addEventListener("pointerdown", We),
          i.domElement.addEventListener("pointercancel", nt),
          i.domElement.addEventListener("wheel", D);
      }),
      (this.dispose = () => {
        var W, he, Ae, Pe, qe, ft;
        (W = i.domElement) === null ||
          W === void 0 ||
          W.removeEventListener("contextmenu", Re),
          (he = i.domElement) === null ||
            he === void 0 ||
            he.removeEventListener("pointerdown", We),
          (Ae = i.domElement) === null ||
            Ae === void 0 ||
            Ae.removeEventListener("pointercancel", nt),
          (Pe = i.domElement) === null ||
            Pe === void 0 ||
            Pe.removeEventListener("wheel", D),
          (qe = i.domElement) === null ||
            qe === void 0 ||
            qe.ownerDocument.removeEventListener("pointermove", Ke),
          (ft = i.domElement) === null ||
            ft === void 0 ||
            ft.ownerDocument.removeEventListener("pointerup", Je),
          i._domElementKeyEvents !== null &&
            i._domElementKeyEvents.removeEventListener("keydown", le);
      });
    const i = this,
      r = { type: "change" },
      s = { type: "start" },
      o = { type: "end" },
      a = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let l = a.NONE;
    const c = 1e-6,
      h = new A_(),
      d = new A_();
    let p = 1;
    const m = new F();
    let v = !1;
    const A = new ge(),
      x = new ge(),
      g = new ge(),
      _ = new ge(),
      S = new ge(),
      w = new ge(),
      E = new ge(),
      P = new ge(),
      L = new ge(),
      B = [],
      b = {};
    function R() {
      return ((2 * Math.PI) / 60 / 60) * i.autoRotateSpeed;
    }
    function U() {
      return Math.pow(0.95, i.zoomSpeed);
    }
    function j(W) {
      i.reverseOrbit ? (d.theta += W) : (d.theta -= W);
    }
    function V(W) {
      i.reverseOrbit ? (d.phi += W) : (d.phi -= W);
    }
    const J = (() => {
        const W = new F();
        return function (Ae, Pe) {
          W.setFromMatrixColumn(Pe, 0), W.multiplyScalar(-Ae), m.add(W);
        };
      })(),
      X = (() => {
        const W = new F();
        return function (Ae, Pe) {
          i.screenSpacePanning === !0
            ? W.setFromMatrixColumn(Pe, 1)
            : (W.setFromMatrixColumn(Pe, 0), W.crossVectors(i.object.up, W)),
            W.multiplyScalar(Ae),
            m.add(W);
        };
      })(),
      oe = (() => {
        const W = new F();
        return function (Ae, Pe) {
          const qe = i.domElement;
          if (qe && i.object instanceof Vt && i.object.isPerspectiveCamera) {
            const ft = i.object.position;
            W.copy(ft).sub(i.target);
            let Ut = W.length();
            (Ut *= Math.tan(((i.object.fov / 2) * Math.PI) / 180)),
              J((2 * Ae * Ut) / qe.clientHeight, i.object.matrix),
              X((2 * Pe * Ut) / qe.clientHeight, i.object.matrix);
          } else
            qe && i.object instanceof kr && i.object.isOrthographicCamera
              ? (J(
                  (Ae * (i.object.right - i.object.left)) /
                    i.object.zoom /
                    qe.clientWidth,
                  i.object.matrix
                ),
                X(
                  (Pe * (i.object.top - i.object.bottom)) /
                    i.object.zoom /
                    qe.clientHeight,
                  i.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (i.enablePan = !1));
        };
      })();
    function ae(W) {
      i.object instanceof Vt && i.object.isPerspectiveCamera
        ? (p /= W)
        : i.object instanceof kr && i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom * W)
          )),
          i.object.updateProjectionMatrix(),
          (v = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function I(W) {
      i.object instanceof Vt && i.object.isPerspectiveCamera
        ? (p *= W)
        : i.object instanceof kr && i.object.isOrthographicCamera
        ? ((i.object.zoom = Math.max(
            i.minZoom,
            Math.min(i.maxZoom, i.object.zoom / W)
          )),
          i.object.updateProjectionMatrix(),
          (v = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (i.enableZoom = !1));
    }
    function G(W) {
      A.set(W.clientX, W.clientY);
    }
    function z(W) {
      E.set(W.clientX, W.clientY);
    }
    function q(W) {
      _.set(W.clientX, W.clientY);
    }
    function Q(W) {
      x.set(W.clientX, W.clientY),
        g.subVectors(x, A).multiplyScalar(i.rotateSpeed);
      const he = i.domElement;
      he &&
        (j((2 * Math.PI * g.x) / he.clientHeight),
        V((2 * Math.PI * g.y) / he.clientHeight)),
        A.copy(x),
        i.update();
    }
    function ee(W) {
      P.set(W.clientX, W.clientY),
        L.subVectors(P, E),
        L.y > 0 ? ae(U()) : L.y < 0 && I(U()),
        E.copy(P),
        i.update();
    }
    function ne(W) {
      S.set(W.clientX, W.clientY),
        w.subVectors(S, _).multiplyScalar(i.panSpeed),
        oe(w.x, w.y),
        _.copy(S),
        i.update();
    }
    function Ce(W) {
      W.deltaY < 0 ? I(U()) : W.deltaY > 0 && ae(U()), i.update();
    }
    function _e(W) {
      let he = !1;
      switch (W.code) {
        case i.keys.UP:
          oe(0, i.keyPanSpeed), (he = !0);
          break;
        case i.keys.BOTTOM:
          oe(0, -i.keyPanSpeed), (he = !0);
          break;
        case i.keys.LEFT:
          oe(i.keyPanSpeed, 0), (he = !0);
          break;
        case i.keys.RIGHT:
          oe(-i.keyPanSpeed, 0), (he = !0);
          break;
      }
      he && (W.preventDefault(), i.update());
    }
    function $() {
      if (B.length == 1) A.set(B[0].pageX, B[0].pageY);
      else {
        const W = 0.5 * (B[0].pageX + B[1].pageX),
          he = 0.5 * (B[0].pageY + B[1].pageY);
        A.set(W, he);
      }
    }
    function je() {
      if (B.length == 1) _.set(B[0].pageX, B[0].pageY);
      else {
        const W = 0.5 * (B[0].pageX + B[1].pageX),
          he = 0.5 * (B[0].pageY + B[1].pageY);
        _.set(W, he);
      }
    }
    function Xe() {
      const W = B[0].pageX - B[1].pageX,
        he = B[0].pageY - B[1].pageY,
        Ae = Math.sqrt(W * W + he * he);
      E.set(0, Ae);
    }
    function ve() {
      i.enableZoom && Xe(), i.enablePan && je();
    }
    function Me() {
      i.enableZoom && Xe(), i.enableRotate && $();
    }
    function me(W) {
      if (B.length == 1) x.set(W.pageX, W.pageY);
      else {
        const Ae = He(W),
          Pe = 0.5 * (W.pageX + Ae.x),
          qe = 0.5 * (W.pageY + Ae.y);
        x.set(Pe, qe);
      }
      g.subVectors(x, A).multiplyScalar(i.rotateSpeed);
      const he = i.domElement;
      he &&
        (j((2 * Math.PI * g.x) / he.clientHeight),
        V((2 * Math.PI * g.y) / he.clientHeight)),
        A.copy(x);
    }
    function se(W) {
      if (B.length == 1) S.set(W.pageX, W.pageY);
      else {
        const he = He(W),
          Ae = 0.5 * (W.pageX + he.x),
          Pe = 0.5 * (W.pageY + he.y);
        S.set(Ae, Pe);
      }
      w.subVectors(S, _).multiplyScalar(i.panSpeed), oe(w.x, w.y), _.copy(S);
    }
    function xe(W) {
      const he = He(W),
        Ae = W.pageX - he.x,
        Pe = W.pageY - he.y,
        qe = Math.sqrt(Ae * Ae + Pe * Pe);
      P.set(0, qe),
        L.set(0, Math.pow(P.y / E.y, i.zoomSpeed)),
        ae(L.y),
        E.copy(P);
    }
    function Ne(W) {
      i.enableZoom && xe(W), i.enablePan && se(W);
    }
    function Le(W) {
      i.enableZoom && xe(W), i.enableRotate && me(W);
    }
    function We(W) {
      if (i.enabled !== !1) {
        if (B.length === 0) {
          var he, Ae;
          (he = i.domElement) === null ||
            he === void 0 ||
            he.ownerDocument.addEventListener("pointermove", Ke),
            (Ae = i.domElement) === null ||
              Ae === void 0 ||
              Ae.ownerDocument.addEventListener("pointerup", Je);
        }
        et(W), W.pointerType === "touch" ? Ee(W) : _t(W);
      }
    }
    function Ke(W) {
      i.enabled !== !1 && (W.pointerType === "touch" ? Te(W) : k(W));
    }
    function Je(W) {
      if ((Ue(W), B.length === 0)) {
        var he, Ae, Pe;
        (he = i.domElement) === null ||
          he === void 0 ||
          he.releasePointerCapture(W.pointerId),
          (Ae = i.domElement) === null ||
            Ae === void 0 ||
            Ae.ownerDocument.removeEventListener("pointermove", Ke),
          (Pe = i.domElement) === null ||
            Pe === void 0 ||
            Pe.ownerDocument.removeEventListener("pointerup", Je);
      }
      i.dispatchEvent(o), (l = a.NONE);
    }
    function nt(W) {
      Ue(W);
    }
    function _t(W) {
      let he;
      switch (W.button) {
        case 0:
          he = i.mouseButtons.LEFT;
          break;
        case 1:
          he = i.mouseButtons.MIDDLE;
          break;
        case 2:
          he = i.mouseButtons.RIGHT;
          break;
        default:
          he = -1;
      }
      switch (he) {
        case Ta.DOLLY:
          if (i.enableZoom === !1) return;
          z(W), (l = a.DOLLY);
          break;
        case Ta.ROTATE:
          if (W.ctrlKey || W.metaKey || W.shiftKey) {
            if (i.enablePan === !1) return;
            q(W), (l = a.PAN);
          } else {
            if (i.enableRotate === !1) return;
            G(W), (l = a.ROTATE);
          }
          break;
        case Ta.PAN:
          if (W.ctrlKey || W.metaKey || W.shiftKey) {
            if (i.enableRotate === !1) return;
            G(W), (l = a.ROTATE);
          } else {
            if (i.enablePan === !1) return;
            q(W), (l = a.PAN);
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && i.dispatchEvent(s);
    }
    function k(W) {
      if (i.enabled !== !1)
        switch (l) {
          case a.ROTATE:
            if (i.enableRotate === !1) return;
            Q(W);
            break;
          case a.DOLLY:
            if (i.enableZoom === !1) return;
            ee(W);
            break;
          case a.PAN:
            if (i.enablePan === !1) return;
            ne(W);
            break;
        }
    }
    function D(W) {
      i.enabled === !1 ||
        i.enableZoom === !1 ||
        (l !== a.NONE && l !== a.ROTATE) ||
        (W.preventDefault(), i.dispatchEvent(s), Ce(W), i.dispatchEvent(o));
    }
    function le(W) {
      i.enabled === !1 || i.enablePan === !1 || _e(W);
    }
    function Ee(W) {
      switch ((de(W), B.length)) {
        case 1:
          switch (i.touches.ONE) {
            case ba.ROTATE:
              if (i.enableRotate === !1) return;
              $(), (l = a.TOUCH_ROTATE);
              break;
            case ba.PAN:
              if (i.enablePan === !1) return;
              je(), (l = a.TOUCH_PAN);
              break;
            default:
              l = a.NONE;
          }
          break;
        case 2:
          switch (i.touches.TWO) {
            case ba.DOLLY_PAN:
              if (i.enableZoom === !1 && i.enablePan === !1) return;
              ve(), (l = a.TOUCH_DOLLY_PAN);
              break;
            case ba.DOLLY_ROTATE:
              if (i.enableZoom === !1 && i.enableRotate === !1) return;
              Me(), (l = a.TOUCH_DOLLY_ROTATE);
              break;
            default:
              l = a.NONE;
          }
          break;
        default:
          l = a.NONE;
      }
      l !== a.NONE && i.dispatchEvent(s);
    }
    function Te(W) {
      switch ((de(W), l)) {
        case a.TOUCH_ROTATE:
          if (i.enableRotate === !1) return;
          me(W), i.update();
          break;
        case a.TOUCH_PAN:
          if (i.enablePan === !1) return;
          se(W), i.update();
          break;
        case a.TOUCH_DOLLY_PAN:
          if (i.enableZoom === !1 && i.enablePan === !1) return;
          Ne(W), i.update();
          break;
        case a.TOUCH_DOLLY_ROTATE:
          if (i.enableZoom === !1 && i.enableRotate === !1) return;
          Le(W), i.update();
          break;
        default:
          l = a.NONE;
      }
    }
    function Re(W) {
      i.enabled !== !1 && W.preventDefault();
    }
    function et(W) {
      B.push(W);
    }
    function Ue(W) {
      delete b[W.pointerId];
      for (let he = 0; he < B.length; he++)
        if (B[he].pointerId == W.pointerId) {
          B.splice(he, 1);
          return;
        }
    }
    function de(W) {
      let he = b[W.pointerId];
      he === void 0 && ((he = new ge()), (b[W.pointerId] = he)),
        he.set(W.pageX, W.pageY);
    }
    function He(W) {
      const he = W.pointerId === B[0].pointerId ? B[1] : B[0];
      return b[he.pointerId];
    }
    t !== void 0 && this.connect(t), this.update();
  }
};
class UA extends vi {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new r9(t);
      }),
      this.register(function (t) {
        return new f9(t);
      }),
      this.register(function (t) {
        return new h9(t);
      }),
      this.register(function (t) {
        return new o9(t);
      }),
      this.register(function (t) {
        return new a9(t);
      }),
      this.register(function (t) {
        return new l9(t);
      }),
      this.register(function (t) {
        return new u9(t);
      }),
      this.register(function (t) {
        return new i9(t);
      }),
      this.register(function (t) {
        return new c9(t);
      }),
      this.register(function (t) {
        return new s9(t);
      }),
      this.register(function (t) {
        return new t9(t);
      }),
      this.register(function (t) {
        return new d9(t);
      });
  }
  load(e, t, i, r) {
    const s = this;
    let o;
    this.resourcePath !== ""
      ? (o = this.resourcePath)
      : this.path !== ""
      ? (o = this.path)
      : (o = ls.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (c) {
        r ? r(c) : console.error(c),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      l = new Ki(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            s.parse(
              c,
              o,
              function (h) {
                t(h), s.manager.itemEnd(e);
              },
              a
            );
          } catch (h) {
            a(h);
          }
        },
        i,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, r) {
    let s;
    const o = {},
      a = {};
    if (typeof e == "string") s = e;
    else if (ls.decodeText(new Uint8Array(e, 0, 4)) === c3) {
      try {
        o[Ct.KHR_BINARY_GLTF] = new p9(e);
      } catch (d) {
        r && r(d);
        return;
      }
      s = o[Ct.KHR_BINARY_GLTF].content;
    } else s = ls.decodeText(new Uint8Array(e));
    const l = JSON.parse(s);
    if (l.asset === void 0 || l.asset.version[0] < 2) {
      r &&
        r(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const c = new T9(l, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let h = 0; h < this.pluginCallbacks.length; h++) {
      const d = this.pluginCallbacks[h](c);
      (a[d.name] = d), (o[d.name] = !0);
    }
    if (l.extensionsUsed)
      for (let h = 0; h < l.extensionsUsed.length; ++h) {
        const d = l.extensionsUsed[h],
          p = l.extensionsRequired || [];
        switch (d) {
          case Ct.KHR_MATERIALS_UNLIT:
            o[d] = new n9();
            break;
          case Ct.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            o[d] = new y9();
            break;
          case Ct.KHR_DRACO_MESH_COMPRESSION:
            o[d] = new m9(l, this.dracoLoader);
            break;
          case Ct.KHR_TEXTURE_TRANSFORM:
            o[d] = new g9();
            break;
          case Ct.KHR_MESH_QUANTIZATION:
            o[d] = new v9();
            break;
          default:
            p.indexOf(d) >= 0 &&
              a[d] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".');
        }
      }
    c.setExtensions(o), c.setPlugins(a), c.parse(i, r);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (r, s) {
      i.parse(e, t, r, s);
    });
  }
}
function e9() {
  let n = {};
  return {
    get: function (e) {
      return n[e];
    },
    add: function (e, t) {
      n[e] = t;
    },
    remove: function (e) {
      delete n[e];
    },
    removeAll: function () {
      n = {};
    },
  };
}
const Ct = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
};
class t9 {
  constructor(e) {
    (this.parser = e),
      (this.name = Ct.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, r = t.length; i < r; i++) {
      const s = t[i];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let r = t.cache.get(i);
    if (r) return r;
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let c;
    const h = new Ie(16777215);
    l.color !== void 0 && h.fromArray(l.color);
    const d = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (c = new PA(h)), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        (c = new bA(h)), (c.distance = d);
        break;
      case "spot":
        (c = new TA(h)),
          (c.distance = d),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      c.position.set(0, 0, 0),
      (c.decay = 2),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = t.createUniqueName(l.name || "light_" + e)),
      (r = Promise.resolve(c)),
      t.cache.add(i, r),
      r
    );
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      s = i.json.nodes[e],
      a = ((s.extensions && s.extensions[this.name]) || {}).light;
    return a === void 0
      ? null
      : this._loadLight(a).then(function (l) {
          return i._getNodeRef(t.cache, a, l);
        });
  }
}
class n9 {
  constructor() {
    this.name = Ct.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Wi;
  }
  extendParams(e, t, i) {
    const r = [];
    (e.color = new Ie(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const o = s.baseColorFactor;
        e.color.fromArray(o), (e.opacity = o[3]);
      }
      s.baseColorTexture !== void 0 &&
        r.push(i.assignTexture(e, "map", s.baseColorTexture, Tt));
    }
    return Promise.all(r);
  }
}
class i9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class r9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : $s;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    if (
      (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
      o.clearcoatTexture !== void 0 &&
        s.push(i.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
      o.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
      o.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            o.clearcoatRoughnessTexture
          )
        ),
      o.clearcoatNormalTexture !== void 0 &&
        (s.push(
          i.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)
        ),
        o.clearcoatNormalTexture.scale !== void 0))
    ) {
      const a = o.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new ge(a, a);
    }
    return Promise.all(s);
  }
}
class s9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : $s;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
      o.iridescenceTexture !== void 0 &&
        s.push(i.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
      o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      o.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
      o.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
      o.iridescenceThicknessTexture !== void 0 &&
        s.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            o.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class o9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : $s;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new Ie(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const o = r.extensions[this.name];
    return (
      o.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(o.sheenColorFactor),
      o.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = o.sheenRoughnessFactor),
      o.sheenColorTexture !== void 0 &&
        s.push(i.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Tt)),
      o.sheenRoughnessTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class a9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : $s;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    return (
      o.transmissionFactor !== void 0 &&
        (t.transmission = o.transmissionFactor),
      o.transmissionTexture !== void 0 &&
        s.push(i.assignTexture(t, "transmissionMap", o.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class l9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : $s;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0),
      o.thicknessTexture !== void 0 &&
        s.push(i.assignTexture(t, "thicknessMap", o.thicknessTexture)),
      (t.attenuationDistance = o.attenuationDistance || 1 / 0);
    const a = o.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new Ie(a[0], a[1], a[2])), Promise.all(s);
  }
}
class u9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : $s;
  }
  extendMaterialParams(e, t) {
    const r = this.parser.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = r.extensions[this.name];
    return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class c9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const i = this.parser.json.materials[e];
    return !i.extensions || !i.extensions[this.name] ? null : $s;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      r = i.json.materials[e];
    if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
    const s = [],
      o = r.extensions[this.name];
    (t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1),
      o.specularTexture !== void 0 &&
        s.push(i.assignTexture(t, "specularIntensityMap", o.specularTexture));
    const a = o.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Ie(a[0], a[1], a[2])),
      o.specularColorTexture !== void 0 &&
        s.push(
          i.assignTexture(t, "specularColorMap", o.specularColorTexture, Tt)
        ),
      Promise.all(s)
    );
  }
}
class f9 {
  constructor(e) {
    (this.parser = e), (this.name = Ct.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      r = i.textures[e];
    if (!r.extensions || !r.extensions[this.name]) return null;
    const s = r.extensions[this.name],
      o = t.options.ktx2Loader;
    if (!o) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, o);
  }
}
class h9 {
  constructor(e) {
    (this.parser = e),
      (this.name = Ct.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      r = i.json,
      s = r.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const o = s.extensions[t],
      a = r.images[o.source];
    let l = i.textureLoader;
    if (a.uri) {
      const c = i.options.manager.getHandler(a.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return i.loadTextureImage(e, o.source, l);
      if (r.extensionsRequired && r.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class d9 {
  constructor(e) {
    (this.name = Ct.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const r = i.extensions[this.name],
        s = this.parser.getDependency("buffer", r.buffer),
        o = this.parser.options.meshoptDecoder;
      if (!o || !o.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (a) {
        const l = r.byteOffset || 0,
          c = r.byteLength || 0,
          h = r.count,
          d = r.byteStride,
          p = new Uint8Array(a, l, c);
        return o.decodeGltfBufferAsync
          ? o
              .decodeGltfBufferAsync(h, d, p, r.mode, r.filter)
              .then(function (m) {
                return m.buffer;
              })
          : o.ready.then(function () {
              const m = new ArrayBuffer(h * d);
              return (
                o.decodeGltfBuffer(
                  new Uint8Array(m),
                  h,
                  d,
                  p,
                  r.mode,
                  r.filter
                ),
                m
              );
            });
      });
    } else return null;
  }
}
const c3 = "glTF",
  Qc = 12,
  iT = { JSON: 1313821514, BIN: 5130562 };
class p9 {
  constructor(e) {
    (this.name = Ct.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, Qc);
    if (
      ((this.header = {
        magic: ls.decodeText(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== c3)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - Qc,
      r = new DataView(e, Qc);
    let s = 0;
    for (; s < i; ) {
      const o = r.getUint32(s, !0);
      s += 4;
      const a = r.getUint32(s, !0);
      if (((s += 4), a === iT.JSON)) {
        const l = new Uint8Array(e, Qc + s, o);
        this.content = ls.decodeText(l);
      } else if (a === iT.BIN) {
        const l = Qc + s;
        this.body = e.slice(l, l + o);
      }
      s += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class m9 {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = Ct.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json,
      r = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      o = e.extensions[this.name].attributes,
      a = {},
      l = {},
      c = {};
    for (const h in o) {
      const d = b_[h] || h.toLowerCase();
      a[d] = o[h];
    }
    for (const h in e.attributes) {
      const d = b_[h] || h.toLowerCase();
      if (o[h] !== void 0) {
        const p = i.accessors[e.attributes[h]],
          m = ah[p.componentType];
        (c[d] = m.name), (l[d] = p.normalized === !0);
      }
    }
    return t.getDependency("bufferView", s).then(function (h) {
      return new Promise(function (d) {
        r.decodeDracoFile(
          h,
          function (p) {
            for (const m in p.attributes) {
              const v = p.attributes[m],
                A = l[m];
              A !== void 0 && (v.normalized = A);
            }
            d(p);
          },
          a,
          c
        );
      });
    });
  }
}
class g9 {
  constructor() {
    this.name = Ct.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      t.texCoord !== void 0 &&
        console.warn(
          'THREE.GLTFLoader: Custom UV sets in "' +
            this.name +
            '" extension not yet supported.'
        ),
      (t.offset === void 0 && t.rotation === void 0 && t.scale === void 0) ||
        ((e = e.clone()),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class T_ extends oc {
  constructor(e) {
    super(), (this.isGLTFSpecularGlossinessMaterial = !0);
    const t = [
        "#ifdef USE_SPECULARMAP",
        "	uniform sampler2D specularMap;",
        "#endif",
      ].join(`
`),
      i = [
        "#ifdef USE_GLOSSINESSMAP",
        "	uniform sampler2D glossinessMap;",
        "#endif",
      ].join(`
`),
      r = [
        "vec3 specularFactor = specular;",
        "#ifdef USE_SPECULARMAP",
        "	vec4 texelSpecular = texture2D( specularMap, vUv );",
        "	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	specularFactor *= texelSpecular.rgb;",
        "#endif",
      ].join(`
`),
      s = [
        "float glossinessFactor = glossiness;",
        "#ifdef USE_GLOSSINESSMAP",
        "	vec4 texelGlossiness = texture2D( glossinessMap, vUv );",
        "	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture",
        "	glossinessFactor *= texelGlossiness.a;",
        "#endif",
      ].join(`
`),
      o = [
        "PhysicalMaterial material;",
        "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );",
        "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );",
        "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );",
        "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.",
        "material.roughness += geometryRoughness;",
        "material.roughness = min( material.roughness, 1.0 );",
        "material.specularColor = specularFactor;",
      ].join(`
`),
      a = {
        specular: { value: new Ie().setHex(16777215) },
        glossiness: { value: 1 },
        specularMap: { value: null },
        glossinessMap: { value: null },
      };
    (this._extraUniforms = a),
      (this.onBeforeCompile = function (l) {
        for (const c in a) l.uniforms[c] = a[c];
        l.fragmentShader = l.fragmentShader
          .replace("uniform float roughness;", "uniform vec3 specular;")
          .replace("uniform float metalness;", "uniform float glossiness;")
          .replace("#include <roughnessmap_pars_fragment>", t)
          .replace("#include <metalnessmap_pars_fragment>", i)
          .replace("#include <roughnessmap_fragment>", r)
          .replace("#include <metalnessmap_fragment>", s)
          .replace("#include <lights_physical_fragment>", o);
      }),
      Object.defineProperties(this, {
        specular: {
          get: function () {
            return a.specular.value;
          },
          set: function (l) {
            a.specular.value = l;
          },
        },
        specularMap: {
          get: function () {
            return a.specularMap.value;
          },
          set: function (l) {
            (a.specularMap.value = l),
              l
                ? (this.defines.USE_SPECULARMAP = "")
                : delete this.defines.USE_SPECULARMAP;
          },
        },
        glossiness: {
          get: function () {
            return a.glossiness.value;
          },
          set: function (l) {
            a.glossiness.value = l;
          },
        },
        glossinessMap: {
          get: function () {
            return a.glossinessMap.value;
          },
          set: function (l) {
            (a.glossinessMap.value = l),
              l
                ? ((this.defines.USE_GLOSSINESSMAP = ""),
                  (this.defines.USE_UV = ""))
                : (delete this.defines.USE_GLOSSINESSMAP,
                  delete this.defines.USE_UV);
          },
        },
      }),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.specularMap = e.specularMap),
      this.specular.copy(e.specular),
      (this.glossinessMap = e.glossinessMap),
      (this.glossiness = e.glossiness),
      delete this.metalness,
      delete this.roughness,
      delete this.metalnessMap,
      delete this.roughnessMap,
      this
    );
  }
}
class y9 {
  constructor() {
    (this.name = Ct.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS),
      (this.specularGlossinessParams = [
        "color",
        "map",
        "lightMap",
        "lightMapIntensity",
        "aoMap",
        "aoMapIntensity",
        "emissive",
        "emissiveIntensity",
        "emissiveMap",
        "bumpMap",
        "bumpScale",
        "normalMap",
        "normalMapType",
        "displacementMap",
        "displacementScale",
        "displacementBias",
        "specularMap",
        "specular",
        "glossinessMap",
        "glossiness",
        "alphaMap",
        "envMap",
        "envMapIntensity",
        "refractionRatio",
      ]);
  }
  getMaterialType() {
    return T_;
  }
  extendParams(e, t, i) {
    const r = t.extensions[this.name];
    (e.color = new Ie(1, 1, 1)), (e.opacity = 1);
    const s = [];
    if (Array.isArray(r.diffuseFactor)) {
      const o = r.diffuseFactor;
      e.color.fromArray(o), (e.opacity = o[3]);
    }
    if (
      (r.diffuseTexture !== void 0 &&
        s.push(i.assignTexture(e, "map", r.diffuseTexture, Tt)),
      (e.emissive = new Ie(0, 0, 0)),
      (e.glossiness = r.glossinessFactor !== void 0 ? r.glossinessFactor : 1),
      (e.specular = new Ie(1, 1, 1)),
      Array.isArray(r.specularFactor) && e.specular.fromArray(r.specularFactor),
      r.specularGlossinessTexture !== void 0)
    ) {
      const o = r.specularGlossinessTexture;
      s.push(i.assignTexture(e, "glossinessMap", o)),
        s.push(i.assignTexture(e, "specularMap", o, Tt));
    }
    return Promise.all(s);
  }
  createMaterial(e) {
    const t = new T_(e);
    return (
      (t.fog = !0),
      (t.color = e.color),
      (t.map = e.map === void 0 ? null : e.map),
      (t.lightMap = null),
      (t.lightMapIntensity = 1),
      (t.aoMap = e.aoMap === void 0 ? null : e.aoMap),
      (t.aoMapIntensity = 1),
      (t.emissive = e.emissive),
      (t.emissiveIntensity =
        e.emissiveIntensity === void 0 ? 1 : e.emissiveIntensity),
      (t.emissiveMap = e.emissiveMap === void 0 ? null : e.emissiveMap),
      (t.bumpMap = e.bumpMap === void 0 ? null : e.bumpMap),
      (t.bumpScale = 1),
      (t.normalMap = e.normalMap === void 0 ? null : e.normalMap),
      (t.normalMapType = Zs),
      e.normalScale && (t.normalScale = e.normalScale),
      (t.displacementMap = null),
      (t.displacementScale = 1),
      (t.displacementBias = 0),
      (t.specularMap = e.specularMap === void 0 ? null : e.specularMap),
      (t.specular = e.specular),
      (t.glossinessMap = e.glossinessMap === void 0 ? null : e.glossinessMap),
      (t.glossiness = e.glossiness),
      (t.alphaMap = null),
      (t.envMap = e.envMap === void 0 ? null : e.envMap),
      (t.envMapIntensity = 1),
      (t.refractionRatio = 0.98),
      t
    );
  }
}
class v9 {
  constructor() {
    this.name = Ct.KHR_MESH_QUANTIZATION;
  }
}
class f3 extends ac {
  constructor(e, t, i, r) {
    super(e, t, i, r);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      r = this.valueSize,
      s = e * r * 3 + r;
    for (let o = 0; o !== r; o++) t[o] = i[s + o];
    return t;
  }
  interpolate_(e, t, i, r) {
    const s = this.resultBuffer,
      o = this.sampleValues,
      a = this.valueSize,
      l = a * 2,
      c = a * 3,
      h = r - t,
      d = (i - t) / h,
      p = d * d,
      m = p * d,
      v = e * c,
      A = v - c,
      x = -2 * m + 3 * p,
      g = m - p,
      _ = 1 - x,
      S = g - p + d;
    for (let w = 0; w !== a; w++) {
      const E = o[A + w + a],
        P = o[A + w + l] * h,
        L = o[v + w + a],
        B = o[v + w] * h;
      s[w] = _ * E + S * P + x * L + g * B;
    }
    return s;
  }
}
const x9 = new jn();
class _9 extends f3 {
  interpolate_(e, t, i, r) {
    const s = super.interpolate_(e, t, i, r);
    return x9.fromArray(s).normalize().toArray(s), s;
  }
}
const bs = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  ah = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  rT = { 9728: dn, 9729: rn, 9984: Zf, 9985: Lg, 9986: bu, 9987: fs },
  sT = { 33071: Wn, 33648: Uu, 10497: jo },
  oT = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  b_ = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv2",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  go = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  A9 = { CUBICSPLINE: void 0, LINEAR: sl, STEP: Gu },
  Sv = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function M9(n) {
  return (
    n.DefaultMaterial === void 0 &&
      (n.DefaultMaterial = new oc({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: cs,
      })),
    n.DefaultMaterial
  );
}
function Zc(n, e, t) {
  for (const i in t.extensions)
    n[i] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[i] = t.extensions[i]));
}
function Ba(n, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(n.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function S9(n, e, t) {
  let i = !1,
    r = !1,
    s = !1;
  for (let c = 0, h = e.length; c < h; c++) {
    const d = e[c];
    if (
      (d.POSITION !== void 0 && (i = !0),
      d.NORMAL !== void 0 && (r = !0),
      d.COLOR_0 !== void 0 && (s = !0),
      i && r && s)
    )
      break;
  }
  if (!i && !r && !s) return Promise.resolve(n);
  const o = [],
    a = [],
    l = [];
  for (let c = 0, h = e.length; c < h; c++) {
    const d = e[c];
    if (i) {
      const p =
        d.POSITION !== void 0
          ? t.getDependency("accessor", d.POSITION)
          : n.attributes.position;
      o.push(p);
    }
    if (r) {
      const p =
        d.NORMAL !== void 0
          ? t.getDependency("accessor", d.NORMAL)
          : n.attributes.normal;
      a.push(p);
    }
    if (s) {
      const p =
        d.COLOR_0 !== void 0
          ? t.getDependency("accessor", d.COLOR_0)
          : n.attributes.color;
      l.push(p);
    }
  }
  return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(
    function (c) {
      const h = c[0],
        d = c[1],
        p = c[2];
      return (
        i && (n.morphAttributes.position = h),
        r && (n.morphAttributes.normal = d),
        s && (n.morphAttributes.color = p),
        (n.morphTargetsRelative = !0),
        n
      );
    }
  );
}
function w9(n, e) {
  if ((n.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, i = e.weights.length; t < i; t++)
      n.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (n.morphTargetInfluences.length === t.length) {
      n.morphTargetDictionary = {};
      for (let i = 0, r = t.length; i < r; i++)
        n.morphTargetDictionary[t[i]] = i;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function C9(n) {
  const e = n.extensions && n.extensions[Ct.KHR_DRACO_MESH_COMPRESSION];
  let t;
  return (
    e
      ? (t = "draco:" + e.bufferView + ":" + e.indices + ":" + aT(e.attributes))
      : (t = n.indices + ":" + aT(n.attributes) + ":" + n.mode),
    t
  );
}
function aT(n) {
  let e = "";
  const t = Object.keys(n).sort();
  for (let i = 0, r = t.length; i < r; i++) e += t[i] + ":" + n[t[i]] + ";";
  return e;
}
function P_(n) {
  switch (n) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function E9(n) {
  return n.search(/\.jpe?g($|\?)/i) > 0 || n.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : n.search(/\.webp($|\?)/i) > 0 || n.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
class T9 {
  constructor(e = {}, t = {}) {
    var i, r;
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new e9()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    const s =
        typeof navigator < "u" &&
        /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0,
      o =
        typeof navigator < "u" &&
        ((i = navigator.userAgent) === null || i === void 0
          ? void 0
          : i.indexOf("Firefox")) > -1,
      a =
        typeof navigator < "u" && o
          ? (r = navigator.userAgent) === null || r === void 0
            ? void 0
            : r.match(/Firefox\/([0-9]+)\./)[1]
          : -1;
    typeof createImageBitmap > "u" || s || (o && a < 98)
      ? (this.textureLoader = new Uh(this.options.manager))
      : (this.textureLoader = new FR(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new Ki(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      r = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      this._invokeAll(function (o) {
        return o._markDefs && o._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (o) {
          return o.beforeRoot && o.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (o) {
          const a = {
            scene: o[0][r.scene || 0],
            scenes: o[0],
            animations: o[1],
            cameras: o[2],
            asset: r.asset,
            parser: i,
            userData: {},
          };
          Zc(s, a, r),
            Ba(a, r),
            Promise.all(
              i._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(a);
              })
            ).then(function () {
              e(a);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let r = 0, s = t.length; r < s; r++) {
      const o = t[r].joints;
      for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0;
    }
    for (let r = 0, s = e.length; r < s; r++) {
      const o = e[r];
      o.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, o.mesh),
        o.skin !== void 0 && (i[o.mesh].isSkinnedMesh = !0)),
        o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const r = i.clone(),
      s = (o, a) => {
        const l = this.associations.get(o);
        l != null && this.associations.set(a, l);
        for (const [c, h] of o.children.entries()) s(h, a.children[c]);
      };
    return s(i, r), (r.name += "_instance_" + e.uses[t]++), r;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const r = e(t[i]);
      if (r) return r;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const s = e(t[r]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let r = this.cache.get(i);
    if (!r) {
      switch (e) {
        case "scene":
          r = this.loadScene(t);
          break;
        case "node":
          r = this.loadNode(t);
          break;
        case "mesh":
          r = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          r = this.loadAccessor(t);
          break;
        case "bufferView":
          r = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          r = this.loadBuffer(t);
          break;
        case "material":
          r = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          r = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          r = this.loadSkin(t);
          break;
        case "animation":
          r = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          r = this.loadCamera(t);
          break;
        default:
          throw new Error("Unknown type: " + e);
      }
      this.cache.add(i, r);
    }
    return r;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        r = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        r.map(function (s, o) {
          return i.getDependency(e, o);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[Ct.KHR_BINARY_GLTF].body);
    const r = this.options;
    return new Promise(function (s, o) {
      i.load(ls.resolveURL(t.uri, r.path), s, void 0, function () {
        o(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (i) {
      const r = t.byteLength || 0,
        s = t.byteOffset || 0;
      return i.slice(s, s + r);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      r = this.json.accessors[e];
    if (r.bufferView === void 0 && r.sparse === void 0)
      return Promise.resolve(null);
    const s = [];
    return (
      r.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", r.bufferView))
        : s.push(null),
      r.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", r.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", r.sparse.values.bufferView))),
      Promise.all(s).then(function (o) {
        const a = o[0],
          l = oT[r.type],
          c = ah[r.componentType],
          h = c.BYTES_PER_ELEMENT,
          d = h * l,
          p = r.byteOffset || 0,
          m =
            r.bufferView !== void 0
              ? i.bufferViews[r.bufferView].byteStride
              : void 0,
          v = r.normalized === !0;
        let A, x;
        if (m && m !== d) {
          const g = Math.floor(p / m),
            _ =
              "InterleavedBuffer:" +
              r.bufferView +
              ":" +
              r.componentType +
              ":" +
              g +
              ":" +
              r.count;
          let S = t.cache.get(_);
          S ||
            ((A = new c(a, g * m, (r.count * m) / h)),
            (S = new wh(A, m / h)),
            t.cache.add(_, S)),
            (x = new Xo(S, l, (p % m) / h, v));
        } else a === null ? (A = new c(r.count * l)) : (A = new c(a, p, r.count * l)), (x = new Dt(A, l, v));
        if (r.sparse !== void 0) {
          const g = oT.SCALAR,
            _ = ah[r.sparse.indices.componentType],
            S = r.sparse.indices.byteOffset || 0,
            w = r.sparse.values.byteOffset || 0,
            E = new _(o[1], S, r.sparse.count * g),
            P = new c(o[2], w, r.sparse.count * l);
          a !== null && (x = new Dt(x.array.slice(), x.itemSize, x.normalized));
          for (let L = 0, B = E.length; L < B; L++) {
            const b = E[L];
            if (
              (x.setX(b, P[L * l]),
              l >= 2 && x.setY(b, P[L * l + 1]),
              l >= 3 && x.setZ(b, P[L * l + 2]),
              l >= 4 && x.setW(b, P[L * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return x;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      s = t.textures[e].source,
      o = t.images[s];
    let a = this.textureLoader;
    if (o.uri) {
      const l = i.manager.getHandler(o.uri);
      l !== null && (a = l);
    }
    return this.loadTextureImage(e, s, a);
  }
  loadTextureImage(e, t, i) {
    const r = this,
      s = this.json,
      o = s.textures[e],
      a = s.images[t],
      l = (a.uri || a.bufferView) + ":" + o.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const c = this.loadImageSource(t, i)
      .then(function (h) {
        (h.flipY = !1), o.name && (h.name = o.name);
        const p = (s.samplers || {})[o.sampler] || {};
        return (
          (h.magFilter = rT[p.magFilter] || rn),
          (h.minFilter = rT[p.minFilter] || fs),
          (h.wrapS = sT[p.wrapS] || jo),
          (h.wrapT = sT[p.wrapT] || jo),
          r.associations.set(h, { textures: e }),
          h
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = c), c;
  }
  loadImageSource(e, t) {
    const i = this,
      r = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((d) => d.clone());
    const o = r.images[e],
      a = self.URL || self.webkitURL;
    let l = o.uri || "",
      c = !1;
    if (o.bufferView !== void 0)
      l = i.getDependency("bufferView", o.bufferView).then(function (d) {
        c = !0;
        const p = new Blob([d], { type: o.mimeType });
        return (l = a.createObjectURL(p)), l;
      });
    else if (o.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const h = Promise.resolve(l)
      .then(function (d) {
        return new Promise(function (p, m) {
          let v = p;
          t.isImageBitmapLoader === !0 &&
            (v = function (A) {
              const x = new en(A);
              (x.needsUpdate = !0), p(x);
            }),
            t.load(ls.resolveURL(d, s.path), v, void 0, m);
        });
      })
      .then(function (d) {
        return (
          c === !0 && a.revokeObjectURL(l),
          (d.userData.mimeType = o.mimeType || E9(o.uri)),
          d
        );
      })
      .catch(function (d) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), d);
      });
    return (this.sourceCache[e] = h), h;
  }
  assignTexture(e, t, i, r) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (o) {
      if (
        (i.texCoord !== void 0 &&
          i.texCoord != 0 &&
          !(t === "aoMap" && i.texCoord == 1) &&
          console.warn(
            "THREE.GLTFLoader: Custom UV set " +
              i.texCoord +
              " for texture " +
              t +
              " not yet supported."
          ),
        s.extensions[Ct.KHR_TEXTURE_TRANSFORM])
      ) {
        const a =
          i.extensions !== void 0
            ? i.extensions[Ct.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (a) {
          const l = s.associations.get(o);
          (o = s.extensions[Ct.KHR_TEXTURE_TRANSFORM].extendTexture(o, a)),
            s.associations.set(o, l);
        }
      }
      return r !== void 0 && (o.encoding = r), (e[t] = o), o;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const r = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      o = t.attributes.normal === void 0;
    if (e.isPoints) {
      const a = "PointsMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new Eh()),
        Cn.prototype.copy.call(l, i),
        l.color.copy(i.color),
        (l.map = i.map),
        (l.sizeAttenuation = !1),
        this.cache.add(a, l)),
        (i = l);
    } else if (e.isLine) {
      const a = "LineBasicMaterial:" + i.uuid;
      let l = this.cache.get(a);
      l ||
        ((l = new oi()),
        Cn.prototype.copy.call(l, i),
        l.color.copy(i.color),
        this.cache.add(a, l)),
        (i = l);
    }
    if (r || s || o) {
      let a = "ClonedMaterial:" + i.uuid + ":";
      i.isGLTFSpecularGlossinessMaterial && (a += "specular-glossiness:"),
        r && (a += "derivative-tangents:"),
        s && (a += "vertex-colors:"),
        o && (a += "flat-shading:");
      let l = this.cache.get(a);
      l ||
        ((l = i.clone()),
        s && (l.vertexColors = !0),
        o && (l.flatShading = !0),
        r &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(a, l),
        this.associations.set(l, this.associations.get(i))),
        (i = l);
    }
    i.aoMap &&
      t.attributes.uv2 === void 0 &&
      t.attributes.uv !== void 0 &&
      t.setAttribute("uv2", t.attributes.uv),
      (e.material = i);
  }
  getMaterialType() {
    return oc;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.materials[e];
    let o;
    const a = {},
      l = s.extensions || {},
      c = [];
    if (l[Ct.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const d = r[Ct.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      (o = d.getMaterialType()), c.push(d.extendParams(a, s, t));
    } else if (l[Ct.KHR_MATERIALS_UNLIT]) {
      const d = r[Ct.KHR_MATERIALS_UNLIT];
      (o = d.getMaterialType()), c.push(d.extendParams(a, s, t));
    } else {
      const d = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new Ie(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(d.baseColorFactor))
      ) {
        const p = d.baseColorFactor;
        a.color.fromArray(p), (a.opacity = p[3]);
      }
      d.baseColorTexture !== void 0 &&
        c.push(t.assignTexture(a, "map", d.baseColorTexture, Tt)),
        (a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1),
        (a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1),
        d.metallicRoughnessTexture !== void 0 &&
          (c.push(
            t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)
          ),
          c.push(
            t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture)
          )),
        (o = this._invokeOne(function (p) {
          return p.getMaterialType && p.getMaterialType(e);
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (p) {
              return p.extendMaterialParams && p.extendMaterialParams(e, a);
            })
          )
        );
    }
    s.doubleSided === !0 && (a.side = dr);
    const h = s.alphaMode || Sv.OPAQUE;
    if (
      (h === Sv.BLEND
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          h === Sv.MASK &&
            (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        o !== Wi &&
        (c.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new ge(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const d = s.normalTexture.scale;
      a.normalScale.set(d, d);
    }
    return (
      s.occlusionTexture !== void 0 &&
        o !== Wi &&
        (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 &&
        o !== Wi &&
        (a.emissive = new Ie().fromArray(s.emissiveFactor)),
      s.emissiveTexture !== void 0 &&
        o !== Wi &&
        c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Tt)),
      Promise.all(c).then(function () {
        let d;
        return (
          o === T_
            ? (d =
                r[Ct.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a))
            : (d = new o(a)),
          s.name && (d.name = s.name),
          Ba(d, s),
          t.associations.set(d, { materials: e }),
          s.extensions && Zc(r, d, s),
          d
        );
      })
    );
  }
  createUniqueName(e) {
    const t = bt.sanitizeNodeName(e || "");
    let i = t;
    for (let r = 1; this.nodeNamesUsed[i]; ++r) i = t + "_" + r;
    return (this.nodeNamesUsed[i] = !0), i;
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      r = this.primitiveCache;
    function s(a) {
      return i[Ct.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(a, t)
        .then(function (l) {
          return lT(l, a, t);
        });
    }
    const o = [];
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a],
        h = C9(c),
        d = r[h];
      if (d) o.push(d.promise);
      else {
        let p;
        c.extensions && c.extensions[Ct.KHR_DRACO_MESH_COMPRESSION]
          ? (p = s(c))
          : (p = lT(new ct(), c, t)),
          (r[h] = { primitive: c, promise: p }),
          o.push(p);
      }
    }
    return Promise.all(o);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      r = this.extensions,
      s = i.meshes[e],
      o = s.primitives,
      a = [];
    for (let l = 0, c = o.length; l < c; l++) {
      const h =
        o[l].material === void 0
          ? M9(this.cache)
          : this.getDependency("material", o[l].material);
      a.push(h);
    }
    return (
      a.push(t.loadGeometries(o)),
      Promise.all(a).then(function (l) {
        const c = l.slice(0, l.length - 1),
          h = l[l.length - 1],
          d = [];
        for (let m = 0, v = h.length; m < v; m++) {
          const A = h[m],
            x = o[m];
          let g;
          const _ = c[m];
          if (
            x.mode === bs.TRIANGLES ||
            x.mode === bs.TRIANGLE_STRIP ||
            x.mode === bs.TRIANGLE_FAN ||
            x.mode === void 0
          )
            (g = s.isSkinnedMesh === !0 ? new fA(A, _) : new Pn(A, _)),
              g.isSkinnedMesh === !0 &&
                !g.geometry.attributes.skinWeight.normalized &&
                g.normalizeSkinWeights(),
              x.mode === bs.TRIANGLE_STRIP
                ? (g.geometry = uT(g.geometry, OB))
                : x.mode === bs.TRIANGLE_FAN &&
                  (g.geometry = uT(g.geometry, Q1));
          else if (x.mode === bs.LINES) g = new Wr(A, _);
          else if (x.mode === bs.LINE_STRIP) g = new Ys(A, _);
          else if (x.mode === bs.LINE_LOOP) g = new hA(A, _);
          else if (x.mode === bs.POINTS) g = new dA(A, _);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + x.mode
            );
          Object.keys(g.geometry.morphAttributes).length > 0 && w9(g, s),
            (g.name = t.createUniqueName(s.name || "mesh_" + e)),
            Ba(g, s),
            x.extensions && Zc(r, g, x),
            t.assignFinalMaterial(g),
            d.push(g);
        }
        for (let m = 0, v = d.length; m < v; m++)
          t.associations.set(d[m], { meshes: e, primitives: m });
        if (d.length === 1) return d[0];
        const p = new Os();
        t.associations.set(p, { meshes: e });
        for (let m = 0, v = d.length; m < v; m++) p.add(d[m]);
        return p;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      r = i[i.type];
    if (!r) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      i.type === "perspective"
        ? (t = new Vt(
            $1.radToDeg(r.yfov),
            r.aspectRatio || 1,
            r.znear || 1,
            r.zfar || 2e6
          ))
        : i.type === "orthographic" &&
          (t = new kr(-r.xmag, r.xmag, r.ymag, -r.ymag, r.znear, r.zfar)),
      i.name && (t.name = this.createUniqueName(i.name)),
      Ba(t, i),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = { joints: t.joints };
    return t.inverseBindMatrices === void 0
      ? Promise.resolve(i)
      : this.getDependency("accessor", t.inverseBindMatrices).then(function (
          r
        ) {
          return (i.inverseBindMatrices = r), i;
        });
  }
  loadAnimation(e) {
    const i = this.json.animations[e],
      r = [],
      s = [],
      o = [],
      a = [],
      l = [];
    for (let c = 0, h = i.channels.length; c < h; c++) {
      const d = i.channels[c],
        p = i.samplers[d.sampler],
        m = d.target,
        v = m.node,
        A = i.parameters !== void 0 ? i.parameters[p.input] : p.input,
        x = i.parameters !== void 0 ? i.parameters[p.output] : p.output;
      r.push(this.getDependency("node", v)),
        s.push(this.getDependency("accessor", A)),
        o.push(this.getDependency("accessor", x)),
        a.push(p),
        l.push(m);
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(s),
      Promise.all(o),
      Promise.all(a),
      Promise.all(l),
    ]).then(function (c) {
      const h = c[0],
        d = c[1],
        p = c[2],
        m = c[3],
        v = c[4],
        A = [];
      for (let g = 0, _ = h.length; g < _; g++) {
        const S = h[g],
          w = d[g],
          E = p[g],
          P = m[g],
          L = v[g];
        if (S === void 0) continue;
        S.updateMatrix();
        let B;
        switch (go[L.path]) {
          case go.weights:
            B = ju;
            break;
          case go.rotation:
            B = Ko;
            break;
          case go.position:
          case go.scale:
          default:
            B = Xu;
            break;
        }
        const b = S.name ? S.name : S.uuid,
          R = P.interpolation !== void 0 ? A9[P.interpolation] : sl,
          U = [];
        go[L.path] === go.weights
          ? S.traverse(function (V) {
              V.morphTargetInfluences && U.push(V.name ? V.name : V.uuid);
            })
          : U.push(b);
        let j = E.array;
        if (E.normalized) {
          const V = P_(j.constructor),
            J = new Float32Array(j.length);
          for (let X = 0, oe = j.length; X < oe; X++) J[X] = j[X] * V;
          j = J;
        }
        for (let V = 0, J = U.length; V < J; V++) {
          const X = new B(U[V] + "." + go[L.path], w.array, j, R);
          P.interpolation === "CUBICSPLINE" &&
            ((X.createInterpolant = function (ae) {
              const I = this instanceof Ko ? _9 : f3;
              return new I(
                this.times,
                this.values,
                this.getValueSize() / 3,
                ae
              );
            }),
            (X.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            A.push(X);
        }
      }
      const x = i.name ? i.name : "animation_" + e;
      return new Ku(x, void 0, A);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      r = t.nodes[e];
    return r.mesh === void 0
      ? null
      : i.getDependency("mesh", r.mesh).then(function (s) {
          const o = i._getNodeRef(i.meshCache, r.mesh, s);
          return (
            r.weights !== void 0 &&
              o.traverse(function (a) {
                if (a.isMesh)
                  for (let l = 0, c = r.weights.length; l < c; l++)
                    a.morphTargetInfluences[l] = r.weights[l];
              }),
            o
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      i = this.extensions,
      r = this,
      s = t.nodes[e],
      o = s.name ? r.createUniqueName(s.name) : "";
    return (function () {
      const a = [],
        l = r._invokeOne(function (c) {
          return c.createNodeMesh && c.createNodeMesh(e);
        });
      return (
        l && a.push(l),
        s.camera !== void 0 &&
          a.push(
            r.getDependency("camera", s.camera).then(function (c) {
              return r._getNodeRef(r.cameraCache, s.camera, c);
            })
          ),
        r
          ._invokeAll(function (c) {
            return c.createNodeAttachment && c.createNodeAttachment(e);
          })
          .forEach(function (c) {
            a.push(c);
          }),
        Promise.all(a)
      );
    })().then(function (a) {
      let l;
      if (
        (s.isBone === !0
          ? (l = new Ug())
          : a.length > 1
          ? (l = new Os())
          : a.length === 1
          ? (l = a[0])
          : (l = new Pt()),
        l !== a[0])
      )
        for (let c = 0, h = a.length; c < h; c++) l.add(a[c]);
      if (
        (s.name && ((l.userData.name = s.name), (l.name = o)),
        Ba(l, s),
        s.extensions && Zc(i, l, s),
        s.matrix !== void 0)
      ) {
        const c = new st();
        c.fromArray(s.matrix), l.applyMatrix4(c);
      } else s.translation !== void 0 && l.position.fromArray(s.translation), s.rotation !== void 0 && l.quaternion.fromArray(s.rotation), s.scale !== void 0 && l.scale.fromArray(s.scale);
      return (
        r.associations.has(l) || r.associations.set(l, {}),
        (r.associations.get(l).nodes = e),
        l
      );
    });
  }
  loadScene(e) {
    const t = this.json,
      i = this.extensions,
      r = this.json.scenes[e],
      s = this,
      o = new Os();
    r.name && (o.name = s.createUniqueName(r.name)),
      Ba(o, r),
      r.extensions && Zc(i, o, r);
    const a = r.nodes || [],
      l = [];
    for (let c = 0, h = a.length; c < h; c++) l.push(h3(a[c], o, t, s));
    return Promise.all(l).then(function () {
      const c = (h) => {
        const d = new Map();
        for (const [p, m] of s.associations)
          (p instanceof Cn || p instanceof en) && d.set(p, m);
        return (
          h.traverse((p) => {
            const m = s.associations.get(p);
            m != null && d.set(p, m);
          }),
          d
        );
      };
      return (s.associations = c(o)), o;
    });
  }
}
function h3(n, e, t, i) {
  const r = t.nodes[n];
  return i
    .getDependency("node", n)
    .then(function (s) {
      if (r.skin === void 0) return s;
      let o;
      return i
        .getDependency("skin", r.skin)
        .then(function (a) {
          o = a;
          const l = [];
          for (let c = 0, h = o.joints.length; c < h; c++)
            l.push(i.getDependency("node", o.joints[c]));
          return Promise.all(l);
        })
        .then(function (a) {
          return (
            s.traverse(function (l) {
              if (!l.isMesh) return;
              const c = [],
                h = [];
              for (let d = 0, p = a.length; d < p; d++) {
                const m = a[d];
                if (m) {
                  c.push(m);
                  const v = new st();
                  o.inverseBindMatrices !== void 0 &&
                    v.fromArray(o.inverseBindMatrices.array, d * 16),
                    h.push(v);
                } else
                  console.warn(
                    'THREE.GLTFLoader: Joint "%s" could not be found.',
                    o.joints[d]
                  );
              }
              l.bind(new Ch(c, h), l.matrixWorld);
            }),
            s
          );
        });
    })
    .then(function (s) {
      e.add(s);
      const o = [];
      if (r.children) {
        const a = r.children;
        for (let l = 0, c = a.length; l < c; l++) {
          const h = a[l];
          o.push(h3(h, s, t, i));
        }
      }
      return Promise.all(o);
    });
}
function b9(n, e, t) {
  const i = e.attributes,
    r = new Hr();
  if (i.POSITION !== void 0) {
    const a = t.json.accessors[i.POSITION],
      l = a.min,
      c = a.max;
    if (l !== void 0 && c !== void 0) {
      if (
        (r.set(new F(l[0], l[1], l[2]), new F(c[0], c[1], c[2])), a.normalized)
      ) {
        const h = P_(ah[a.componentType]);
        r.min.multiplyScalar(h), r.max.multiplyScalar(h);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const a = new F(),
      l = new F();
    for (let c = 0, h = s.length; c < h; c++) {
      const d = s[c];
      if (d.POSITION !== void 0) {
        const p = t.json.accessors[d.POSITION],
          m = p.min,
          v = p.max;
        if (m !== void 0 && v !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(m[0]), Math.abs(v[0]))),
            l.setY(Math.max(Math.abs(m[1]), Math.abs(v[1]))),
            l.setZ(Math.max(Math.abs(m[2]), Math.abs(v[2]))),
            p.normalized)
          ) {
            const A = P_(ah[p.componentType]);
            l.multiplyScalar(A);
          }
          a.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    r.expandByVector(a);
  }
  n.boundingBox = r;
  const o = new Vr();
  r.getCenter(o.center),
    (o.radius = r.min.distanceTo(r.max) / 2),
    (n.boundingSphere = o);
}
function lT(n, e, t) {
  const i = e.attributes,
    r = [];
  function s(o, a) {
    return t.getDependency("accessor", o).then(function (l) {
      n.setAttribute(a, l);
    });
  }
  for (const o in i) {
    const a = b_[o] || o.toLowerCase();
    a in n.attributes || r.push(s(i[o], a));
  }
  if (e.indices !== void 0 && !n.index) {
    const o = t.getDependency("accessor", e.indices).then(function (a) {
      n.setIndex(a);
    });
    r.push(o);
  }
  return (
    Ba(n, e),
    b9(n, e, t),
    Promise.all(r).then(function () {
      return e.targets !== void 0 ? S9(n, e.targets, t) : n;
    })
  );
}
function uT(n, e) {
  let t = n.getIndex();
  if (t === null) {
    const o = [],
      a = n.getAttribute("position");
    if (a !== void 0) {
      for (let l = 0; l < a.count; l++) o.push(l);
      n.setIndex(o), (t = n.getIndex());
    } else
      return (
        console.error(
          "THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
        ),
        n
      );
  }
  const i = t.count - 2,
    r = [];
  if (e === Q1)
    for (let o = 1; o <= i; o++)
      r.push(t.getX(0)), r.push(t.getX(o)), r.push(t.getX(o + 1));
  else
    for (let o = 0; o < i; o++)
      o % 2 === 0
        ? (r.push(t.getX(o)), r.push(t.getX(o + 1)), r.push(t.getX(o + 2)))
        : (r.push(t.getX(o + 2)), r.push(t.getX(o + 1)), r.push(t.getX(o)));
  r.length / 3 !== i &&
    console.error(
      "THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
    );
  const s = n.clone();
  return s.setIndex(r), s;
}
class P9 extends ct {
  constructor(e, t, i, r) {
    super();
    const s = [],
      o = [],
      a = [],
      l = new F(),
      c = new st();
    c.makeRotationFromEuler(i), c.setPosition(t);
    const h = new st();
    h.copy(c).invert(),
      d(),
      this.setAttribute("position", new Ve(s, 3)),
      this.setAttribute("normal", new Ve(o, 3)),
      this.setAttribute("uv", new Ve(a, 2));
    function d() {
      let A,
        x = [];
      const g = new F(),
        _ = new F();
      if (e.geometry.isGeometry === !0) {
        console.error(
          "THREE.DecalGeometry no longer supports THREE.Geometry. Use BufferGeometry instead."
        );
        return;
      }
      const S = e.geometry,
        w = S.attributes.position,
        E = S.attributes.normal;
      if (S.index !== null) {
        const P = S.index;
        for (A = 0; A < P.count; A++)
          g.fromBufferAttribute(w, P.getX(A)),
            _.fromBufferAttribute(E, P.getX(A)),
            p(x, g, _);
      } else
        for (A = 0; A < w.count; A++)
          g.fromBufferAttribute(w, A), _.fromBufferAttribute(E, A), p(x, g, _);
      for (
        x = m(x, l.set(1, 0, 0)),
          x = m(x, l.set(-1, 0, 0)),
          x = m(x, l.set(0, 1, 0)),
          x = m(x, l.set(0, -1, 0)),
          x = m(x, l.set(0, 0, 1)),
          x = m(x, l.set(0, 0, -1)),
          A = 0;
        A < x.length;
        A++
      ) {
        const P = x[A];
        a.push(0.5 + P.position.x / r.x, 0.5 + P.position.y / r.y),
          P.position.applyMatrix4(c),
          s.push(P.position.x, P.position.y, P.position.z),
          o.push(P.normal.x, P.normal.y, P.normal.z);
      }
    }
    function p(A, x, g) {
      x.applyMatrix4(e.matrixWorld),
        x.applyMatrix4(h),
        g.transformDirection(e.matrixWorld),
        A.push(new cT(x.clone(), g.clone()));
    }
    function m(A, x) {
      const g = [],
        _ = 0.5 * Math.abs(r.dot(x));
      for (let S = 0; S < A.length; S += 3) {
        let w,
          E,
          P,
          L = 0,
          B,
          b,
          R,
          U;
        const j = A[S + 0].position.dot(x) - _,
          V = A[S + 1].position.dot(x) - _,
          J = A[S + 2].position.dot(x) - _;
        switch (
          ((w = j > 0),
          (E = V > 0),
          (P = J > 0),
          (L = (w ? 1 : 0) + (E ? 1 : 0) + (P ? 1 : 0)),
          L)
        ) {
          case 0: {
            g.push(A[S]), g.push(A[S + 1]), g.push(A[S + 2]);
            break;
          }
          case 1: {
            if (
              (w &&
                ((B = A[S + 1]),
                (b = A[S + 2]),
                (R = v(A[S], B, x, _)),
                (U = v(A[S], b, x, _))),
              E)
            ) {
              (B = A[S]),
                (b = A[S + 2]),
                (R = v(A[S + 1], B, x, _)),
                (U = v(A[S + 1], b, x, _)),
                g.push(R),
                g.push(b.clone()),
                g.push(B.clone()),
                g.push(b.clone()),
                g.push(R.clone()),
                g.push(U);
              break;
            }
            P &&
              ((B = A[S]),
              (b = A[S + 1]),
              (R = v(A[S + 2], B, x, _)),
              (U = v(A[S + 2], b, x, _))),
              g.push(B.clone()),
              g.push(b.clone()),
              g.push(R),
              g.push(U),
              g.push(R.clone()),
              g.push(b.clone());
            break;
          }
          case 2: {
            w ||
              ((B = A[S].clone()),
              (b = v(B, A[S + 1], x, _)),
              (R = v(B, A[S + 2], x, _)),
              g.push(B),
              g.push(b),
              g.push(R)),
              E ||
                ((B = A[S + 1].clone()),
                (b = v(B, A[S + 2], x, _)),
                (R = v(B, A[S], x, _)),
                g.push(B),
                g.push(b),
                g.push(R)),
              P ||
                ((B = A[S + 2].clone()),
                (b = v(B, A[S], x, _)),
                (R = v(B, A[S + 1], x, _)),
                g.push(B),
                g.push(b),
                g.push(R));
            break;
          }
        }
      }
      return g;
    }
    function v(A, x, g, _) {
      const S = A.position.dot(g) - _,
        w = x.position.dot(g) - _,
        E = S / (S - w);
      return new cT(
        new F(
          A.position.x + E * (x.position.x - A.position.x),
          A.position.y + E * (x.position.y - A.position.y),
          A.position.z + E * (x.position.z - A.position.z)
        ),
        new F(
          A.normal.x + E * (x.normal.x - A.normal.x),
          A.normal.y + E * (x.normal.y - A.normal.y),
          A.normal.z + E * (x.normal.z - A.normal.z)
        )
      );
    }
  }
}
class cT {
  constructor(e, t) {
    (this.position = e), (this.normal = t);
  }
  clone() {
    return new this.constructor(this.position.clone(), this.normal.clone());
  }
}
const wv = new WeakMap();
class B9 extends vi {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, i, r) {
    const s = new Ki(this.manager);
    s.setPath(this.path),
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (o) => {
          const a = {
            attributeIDs: this.defaultAttributeIDs,
            attributeTypes: this.defaultAttributeTypes,
            useUniqueIDs: !1,
          };
          this.decodeGeometry(o, a).then(t).catch(r);
        },
        i,
        r
      );
  }
  decodeDracoFile(e, t, i, r) {
    const s = {
      attributeIDs: i || this.defaultAttributeIDs,
      attributeTypes: r || this.defaultAttributeTypes,
      useUniqueIDs: !!i,
    };
    this.decodeGeometry(e, s).then(t);
  }
  decodeGeometry(e, t) {
    for (const l in t.attributeTypes) {
      const c = t.attributeTypes[l];
      c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name);
    }
    const i = JSON.stringify(t);
    if (wv.has(e)) {
      const l = wv.get(e);
      if (l.key === i) return l.promise;
      if (e.byteLength === 0)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let r;
    const s = this.workerNextTaskID++,
      o = e.byteLength,
      a = this._getWorker(s, o)
        .then(
          (l) => (
            (r = l),
            new Promise((c, h) => {
              (r._callbacks[s] = { resolve: c, reject: h }),
                r.postMessage(
                  { type: "decode", id: s, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((l) => this._createGeometry(l.geometry));
    return (
      a
        .catch(() => !0)
        .then(() => {
          r && s && this._releaseTask(r, s);
        }),
      wv.set(e, { key: i, promise: a }),
      a
    );
  }
  _createGeometry(e) {
    const t = new ct();
    e.index && t.setIndex(new Dt(e.index.array, 1));
    for (let i = 0; i < e.attributes.length; i++) {
      const r = e.attributes[i],
        s = r.name,
        o = r.array,
        a = r.itemSize;
      t.setAttribute(s, new Dt(o, a));
    }
    return t;
  }
  _loadLibrary(e, t) {
    const i = new Ki(this.manager);
    return (
      i.setPath(this.decoderPath),
      i.setResponseType(t),
      i.setWithCredentials(this.withCredentials),
      new Promise((r, s) => {
        i.load(e, r, void 0, s);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        typeof WebAssembly != "object" || this.decoderConfig.type === "js",
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((i) => {
        const r = i[0];
        e || (this.decoderConfig.wasmBinary = i[1]);
        const s = R9.toString(),
          o = [
            "/* draco decoder */",
            r,
            "",
            "/* worker */",
            s.substring(s.indexOf("{") + 1, s.lastIndexOf("}")),
          ].join(`
`);
        this.workerSourceURL = URL.createObjectURL(new Blob([o]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const r = new Worker(this.workerSourceURL);
        (r._callbacks = {}),
          (r._taskCosts = {}),
          (r._taskLoad = 0),
          r.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (r.onmessage = function (s) {
            const o = s.data;
            switch (o.type) {
              case "decode":
                r._callbacks[o.id].resolve(o);
                break;
              case "error":
                r._callbacks[o.id].reject(o);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + o.type + '"'
                );
            }
          }),
          this.workerPool.push(r);
      } else
        this.workerPool.sort(function (r, s) {
          return r._taskLoad > s._taskLoad ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return (i._taskCosts[e] = t), (i._taskLoad += t), i;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (this.workerPool.length = 0), this;
  }
}
function R9() {
  let n, e;
  onmessage = function (o) {
    const a = o.data;
    switch (a.type) {
      case "init":
        (n = a.decoderConfig),
          (e = new Promise(function (h) {
            (n.onModuleLoaded = function (d) {
              h({ draco: d });
            }),
              DracoDecoderModule(n);
          }));
        break;
      case "decode":
        const l = a.buffer,
          c = a.taskConfig;
        e.then((h) => {
          const d = h.draco,
            p = new d.Decoder(),
            m = new d.DecoderBuffer();
          m.Init(new Int8Array(l), l.byteLength);
          try {
            const v = t(d, p, m, c),
              A = v.attributes.map((x) => x.array.buffer);
            v.index && A.push(v.index.array.buffer),
              self.postMessage({ type: "decode", id: a.id, geometry: v }, A);
          } catch (v) {
            console.error(v),
              self.postMessage({ type: "error", id: a.id, error: v.message });
          } finally {
            d.destroy(m), d.destroy(p);
          }
        });
        break;
    }
  };
  function t(o, a, l, c) {
    const h = c.attributeIDs,
      d = c.attributeTypes;
    let p, m;
    const v = a.GetEncodedGeometryType(l);
    if (v === o.TRIANGULAR_MESH)
      (p = new o.Mesh()), (m = a.DecodeBufferToMesh(l, p));
    else if (v === o.POINT_CLOUD)
      (p = new o.PointCloud()), (m = a.DecodeBufferToPointCloud(l, p));
    else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
    if (!m.ok() || p.ptr === 0)
      throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
    const A = { index: null, attributes: [] };
    for (const x in h) {
      const g = self[d[x]];
      let _, S;
      if (c.useUniqueIDs) (S = h[x]), (_ = a.GetAttributeByUniqueId(p, S));
      else {
        if (((S = a.GetAttributeId(p, o[h[x]])), S === -1)) continue;
        _ = a.GetAttribute(p, S);
      }
      A.attributes.push(r(o, a, p, x, g, _));
    }
    return v === o.TRIANGULAR_MESH && (A.index = i(o, a, p)), o.destroy(p), A;
  }
  function i(o, a, l) {
    const h = l.num_faces() * 3,
      d = h * 4,
      p = o._malloc(d);
    a.GetTrianglesUInt32Array(l, d, p);
    const m = new Uint32Array(o.HEAPF32.buffer, p, h).slice();
    return o._free(p), { array: m, itemSize: 1 };
  }
  function r(o, a, l, c, h, d) {
    const p = d.num_components(),
      v = l.num_points() * p,
      A = v * h.BYTES_PER_ELEMENT,
      x = s(o, h),
      g = o._malloc(A);
    a.GetAttributeDataArrayForAllPoints(l, d, x, A, g);
    const _ = new h(o.HEAPF32.buffer, g, v).slice();
    return o._free(g), { name: c, array: _, itemSize: p };
  }
  function s(o, a) {
    switch (a) {
      case Float32Array:
        return o.DT_FLOAT32;
      case Int8Array:
        return o.DT_INT8;
      case Int16Array:
        return o.DT_INT16;
      case Int32Array:
        return o.DT_INT32;
      case Uint8Array:
        return o.DT_UINT8;
      case Uint16Array:
        return o.DT_UINT16;
      case Uint32Array:
        return o.DT_UINT32;
    }
  }
}
let Kp;
const Cv = () => {
    if (Kp) return Kp;
    const n =
        "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
      e =
        "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
      t = new Uint8Array([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1,
        0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0,
        11, 7, 0, 65, 0, 253, 15, 26, 11,
      ]),
      i = new Uint8Array([
        32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16,
        128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136,
        107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131,
        44, 45, 74, 156, 154, 70, 167,
      ]);
    if (typeof WebAssembly != "object") return { supported: !1 };
    let r = n;
    WebAssembly.validate(t) && (r = e);
    let s;
    const o = WebAssembly.instantiate(a(r), {}).then((d) => {
      (s = d.instance), s.exports.__wasm_call_ctors();
    });
    function a(d) {
      const p = new Uint8Array(d.length);
      for (let v = 0; v < d.length; ++v) {
        const A = d.charCodeAt(v);
        p[v] =
          A > 96 ? A - 71 : A > 64 ? A - 65 : A > 47 ? A + 4 : A > 46 ? 63 : 62;
      }
      let m = 0;
      for (let v = 0; v < d.length; ++v)
        p[m++] = p[v] < 60 ? i[p[v]] : (p[v] - 60) * 64 + p[++v];
      return p.buffer.slice(0, m);
    }
    function l(d, p, m, v, A, x) {
      const g = s.exports.sbrk,
        _ = (m + 3) & -4,
        S = g(_ * v),
        w = g(A.length),
        E = new Uint8Array(s.exports.memory.buffer);
      E.set(A, w);
      const P = d(S, m, v, w, A.length);
      if (
        (P === 0 && x && x(S, _, v),
        p.set(E.subarray(S, S + m * v)),
        g(S - g(0)),
        P !== 0)
      )
        throw new Error(`Malformed buffer data: ${P}`);
    }
    const c = {
        0: "",
        1: "meshopt_decodeFilterOct",
        2: "meshopt_decodeFilterQuat",
        3: "meshopt_decodeFilterExp",
        NONE: "",
        OCTAHEDRAL: "meshopt_decodeFilterOct",
        QUATERNION: "meshopt_decodeFilterQuat",
        EXPONENTIAL: "meshopt_decodeFilterExp",
      },
      h = {
        0: "meshopt_decodeVertexBuffer",
        1: "meshopt_decodeIndexBuffer",
        2: "meshopt_decodeIndexSequence",
        ATTRIBUTES: "meshopt_decodeVertexBuffer",
        TRIANGLES: "meshopt_decodeIndexBuffer",
        INDICES: "meshopt_decodeIndexSequence",
      };
    return (
      (Kp = {
        ready: o,
        supported: !0,
        decodeVertexBuffer(d, p, m, v, A) {
          l(s.exports.meshopt_decodeVertexBuffer, d, p, m, v, s.exports[c[A]]);
        },
        decodeIndexBuffer(d, p, m, v) {
          l(s.exports.meshopt_decodeIndexBuffer, d, p, m, v);
        },
        decodeIndexSequence(d, p, m, v) {
          l(s.exports.meshopt_decodeIndexSequence, d, p, m, v);
        },
        decodeGltfBuffer(d, p, m, v, A, x) {
          l(s.exports[h[A]], d, p, m, v, s.exports[c[x]]);
        },
      }),
      Kp
    );
  },
  fT = (n) => n === Object(n) && !Array.isArray(n) && typeof n != "function";
function zA(n, e) {
  const t = Gi((r) => r.gl),
    i = ia(Uh, fT(n) ? Object.values(n) : n);
  if (
    (H.useLayoutEffect(() => {
      e == null || e(i);
    }, [e]),
    H.useEffect(() => {
      (Array.isArray(i) ? i : [i]).forEach(t.initTexture);
    }, [t, i]),
    fT(n))
  ) {
    const r = Object.keys(n),
      s = {};
    return r.forEach((o) => Object.assign(s, { [o]: i[r.indexOf(o)] })), s;
  } else return i;
}
zA.preload = (n) => ia.preload(Uh, n);
zA.clear = (n) => ia.clear(Uh, n);
function L9(n) {
  return Array.isArray(n);
}
function Ev(n = [0, 0, 0]) {
  return L9(n)
    ? n
    : n instanceof F || n instanceof fl
    ? [n.x, n.y, n.z]
    : [n, n, n];
}
function I9({
  debug: n,
  mesh: e,
  children: t,
  position: i,
  rotation: r,
  scale: s,
  ...o
}) {
  const a = H.useRef(null),
    l = H.useRef(null);
  return (
    H.useLayoutEffect(() => {
      const c = (e == null ? void 0 : e.current) || a.current.parent,
        h = a.current;
      if (!(c instanceof Pn))
        throw new Error(
          'Decal must have a Mesh as parent or specify its "mesh" prop'
        );
      const d = {
        position: new F(),
        rotation: new fl(),
        scale: new F(1, 1, 1),
      };
      if (c) {
        Is(d, { position: i, scale: s });
        const p = c.matrixWorld.clone();
        if ((c.matrixWorld.identity(), !r || typeof r == "number")) {
          const m = new Pt();
          m.position.copy(d.position),
            m.lookAt(c.position),
            typeof r == "number" && m.rotateZ(r),
            Is(d, { rotation: m.rotation });
        } else Is(d, { rotation: r });
        return (
          (h.geometry = new P9(c, d.position, d.rotation, d.scale)),
          l.current && Is(l.current, d),
          (c.matrixWorld = p),
          () => {
            h.geometry.dispose();
          }
        );
      }
    }, [e, ...Ev(i), ...Ev(s), ...Ev(r)]),
    H.createElement(
      "mesh",
      { ref: a },
      t ||
        H.createElement(
          "meshStandardMaterial",
          vr(
            { transparent: !0, polygonOffset: !0, polygonOffsetFactor: -10 },
            o
          )
        ),
      n &&
        H.createElement(
          "mesh",
          { ref: l },
          H.createElement("boxGeometry", null),
          H.createElement("meshNormalMaterial", { wireframe: !0 }),
          H.createElement("axesHelper", null)
        )
    )
  );
}
let Yp = null;
function d3(n, e, t) {
  return (i) => {
    t && t(i),
      n &&
        (Yp || (Yp = new B9()),
        Yp.setDecoderPath(
          typeof n == "string"
            ? n
            : "https://www.gstatic.com/draco/versioned/decoders/1.5.5/"
        ),
        i.setDRACOLoader(Yp)),
      e && i.setMeshoptDecoder(typeof Cv == "function" ? Cv() : Cv);
  };
}
function jg(n, e = !0, t = !0, i) {
  return ia(UA, n, d3(e, t, i));
}
jg.preload = (n, e = !0, t = !0, i) => ia.preload(UA, n, d3(e, t, i));
jg.clear = (n) => ia.clear(UA, n);
const GA = H.forwardRef(
  (
    {
      makeDefault: n,
      camera: e,
      regress: t,
      domElement: i,
      enableDamping: r = !0,
      onChange: s,
      onStart: o,
      onEnd: a,
      ...l
    },
    c
  ) => {
    const h = Gi((E) => E.invalidate),
      d = Gi((E) => E.camera),
      p = Gi((E) => E.gl),
      m = Gi((E) => E.events),
      v = Gi((E) => E.setEvents),
      A = Gi((E) => E.set),
      x = Gi((E) => E.get),
      g = Gi((E) => E.performance),
      _ = e || d,
      S = i || m.connected || p.domElement,
      w = H.useMemo(() => new $V(_), [_]);
    return (
      lc(() => {
        w.enabled && w.update();
      }, -1),
      H.useEffect(() => (w.connect(S), () => void w.dispose()), [S, t, w, h]),
      H.useEffect(() => {
        const E = (B) => {
            h(), t && g.regress(), s && s(B);
          },
          P = (B) => {
            o && o(B);
          },
          L = (B) => {
            a && a(B);
          };
        return (
          w.addEventListener("change", E),
          w.addEventListener("start", P),
          w.addEventListener("end", L),
          () => {
            w.removeEventListener("start", P),
              w.removeEventListener("end", L),
              w.removeEventListener("change", E);
          }
        );
      }, [s, o, a, w, h, v]),
      H.useEffect(() => {
        if (n) {
          const E = x().controls;
          return A({ controls: w }), () => A({ controls: E });
        }
      }, [n, w]),
      H.createElement(
        "primitive",
        vr({ ref: c, object: w, enableDamping: r }, l)
      )
    );
  }
);
class D9 extends Eh {
  constructor(e) {
    super(e),
      (this.onBeforeCompile = (t, i) => {
        const { isWebGL2: r } = i.capabilities;
        t.fragmentShader = t.fragmentShader.replace(
          "#include <output_fragment>",
          `
        ${
          r
            ? "#include <output_fragment>"
            : `#extension GL_OES_standard_derivatives : enable
#include <output_fragment>`
        }
      vec2 cxy = 2.0 * gl_PointCoord - 1.0;
      float r = dot(cxy, cxy);
      float delta = fwidth(r);     
      float mask = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);
      gl_FragColor = vec4(gl_FragColor.rgb, mask * gl_FragColor.a );
      #include <tonemapping_fragment>
      #include <encodings_fragment>
      `
        );
      });
  }
}
const F9 = H.forwardRef((n, e) => {
    const [t] = H.useState(() => new D9(null));
    return H.createElement(
      "primitive",
      vr({}, n, { object: t, ref: e, attach: "material" })
    );
  }),
  N9 = H.forwardRef(
    (
      {
        children: n,
        speed: e = 1,
        rotationIntensity: t = 1,
        floatIntensity: i = 1,
        floatingRange: r = [-0.1, 0.1],
        ...s
      },
      o
    ) => {
      const a = H.useRef(null),
        l = H.useRef(Math.random() * 1e4);
      return (
        lc((c) => {
          var h, d;
          const p = l.current + c.clock.getElapsedTime();
          (a.current.rotation.x = (Math.cos((p / 4) * e) / 8) * t),
            (a.current.rotation.y = (Math.sin((p / 4) * e) / 8) * t),
            (a.current.rotation.z = (Math.sin((p / 4) * e) / 20) * t);
          let m = Math.sin((p / 4) * e) / 10;
          (m = $1.mapLinear(
            m,
            -0.1,
            0.1,
            (h = r == null ? void 0 : r[0]) !== null && h !== void 0 ? h : -0.1,
            (d = r == null ? void 0 : r[1]) !== null && d !== void 0 ? d : 0.1
          )),
            (a.current.position.y = m * i);
        }),
        H.createElement(
          "group",
          s,
          H.createElement("group", { ref: kA([a, o]) }, n)
        )
      );
    }
  );
let Sa, qc;
const O9 = H.createContext(null),
  hT = new st(),
  dT = new F(),
  k9 = H.forwardRef(({ children: n, range: e, limit: t = 1e3, ...i }, r) => {
    const s = H.useRef(null),
      [o, a] = H.useState([]),
      [[l, c, h]] = H.useState(() => [
        new Float32Array(t * 3),
        Float32Array.from({ length: t * 3 }, () => 1),
        Float32Array.from({ length: t }, () => 1),
      ]);
    H.useEffect(() => {
      s.current.geometry.attributes.position.needsUpdate = !0;
    }),
      lc(() => {
        for (
          s.current.updateMatrix(),
            s.current.updateMatrixWorld(),
            hT.copy(s.current.matrixWorld).invert(),
            s.current.geometry.drawRange.count = Math.min(
              t,
              e !== void 0 ? e : t,
              o.length
            ),
            Sa = 0;
          Sa < o.length;
          Sa++
        )
          (qc = o[Sa].current),
            qc.getWorldPosition(dT).applyMatrix4(hT),
            dT.toArray(l, Sa * 3),
            (s.current.geometry.attributes.position.needsUpdate = !0),
            (qc.matrixWorldNeedsUpdate = !0),
            qc.color.toArray(c, Sa * 3),
            (s.current.geometry.attributes.color.needsUpdate = !0),
            h.set([qc.size], Sa),
            (s.current.geometry.attributes.size.needsUpdate = !0);
      });
    const d = H.useMemo(
      () => ({
        getParent: () => s,
        subscribe: (p) => (
          a((m) => [...m, p]),
          () => a((m) => m.filter((v) => v.current !== p.current))
        ),
      }),
      []
    );
    return H.createElement(
      "points",
      vr(
        {
          userData: { instances: o },
          matrixAutoUpdate: !1,
          ref: kA([r, s]),
          raycast: () => null,
        },
        i
      ),
      H.createElement(
        "bufferGeometry",
        null,
        H.createElement("bufferAttribute", {
          attach: "attributes-position",
          count: l.length / 3,
          array: l,
          itemSize: 3,
          usage: Ya,
        }),
        H.createElement("bufferAttribute", {
          attach: "attributes-color",
          count: c.length / 3,
          array: c,
          itemSize: 3,
          usage: Ya,
        }),
        H.createElement("bufferAttribute", {
          attach: "attributes-size",
          count: h.length,
          array: h,
          itemSize: 1,
          usage: Ya,
        })
      ),
      H.createElement(O9.Provider, { value: d }, n)
    );
  }),
  U9 = H.forwardRef(
    (
      { children: n, positions: e, colors: t, sizes: i, stride: r = 3, ...s },
      o
    ) => {
      const a = H.useRef(null);
      return (
        lc(() => {
          const l = a.current.geometry.attributes;
          (l.position.needsUpdate = !0),
            t && (l.color.needsUpdate = !0),
            i && (l.size.needsUpdate = !0);
        }),
        H.createElement(
          "points",
          vr({ ref: kA([o, a]) }, s),
          H.createElement(
            "bufferGeometry",
            null,
            H.createElement("bufferAttribute", {
              attach: "attributes-position",
              count: e.length / r,
              array: e,
              itemSize: r,
              usage: Ya,
            }),
            t &&
              H.createElement("bufferAttribute", {
                attach: "attributes-color",
                count: t.length / r,
                array: t,
                itemSize: 3,
                usage: Ya,
              }),
            i &&
              H.createElement("bufferAttribute", {
                attach: "attributes-size",
                count: i.length / r,
                array: i,
                itemSize: 1,
                usage: Ya,
              })
          ),
          n
        )
      );
    }
  ),
  z9 = H.forwardRef((n, e) =>
    n.positions instanceof Float32Array
      ? H.createElement(U9, vr({}, n, { ref: e }))
      : H.createElement(k9, vr({}, n, { ref: e }))
  );
var $m = {},
  G9 = {
    get exports() {
      return $m;
    },
    set exports(n) {
      $m = n;
    },
  },
  H9 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",
  V9 = H9,
  W9 = V9;
function p3() {}
function m3() {}
m3.resetWarningCache = p3;
var J9 = function () {
  function n(i, r, s, o, a, l) {
    if (l !== W9) {
      var c = new Error(
        "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
      );
      throw ((c.name = "Invariant Violation"), c);
    }
  }
  n.isRequired = n;
  function e() {
    return n;
  }
  var t = {
    array: n,
    bigint: n,
    bool: n,
    func: n,
    number: n,
    object: n,
    string: n,
    symbol: n,
    any: n,
    arrayOf: e,
    element: n,
    elementType: n,
    instanceOf: e,
    node: n,
    objectOf: e,
    oneOf: e,
    oneOfType: e,
    shape: e,
    exact: e,
    checkPropTypes: m3,
    resetWarningCache: p3,
  };
  return (t.PropTypes = t), t;
};
G9.exports = J9();
function Xg({ all: n, scene: e, camera: t }) {
  const i = Gi(({ gl: o }) => o),
    r = Gi(({ camera: o }) => o),
    s = Gi(({ scene: o }) => o);
  return (
    H.useLayoutEffect(() => {
      const o = [];
      n &&
        (e || s).traverse((c) => {
          c.visible === !1 && (o.push(c), (c.visible = !0));
        }),
        i.compile(e || s, t || r);
      const a = new sA(128);
      new rA(0.01, 1e5, a).update(i, e || s),
        a.dispose(),
        o.forEach((c) => (c.visible = !1));
    }, []),
    null
  );
}
const HA = () => {
    const { progress: n } = VV();
    return St(HV, {
      children: [
        we("span", { className: "canvas-loader" }),
        St("p", {
          style: {
            fontSize: 14,
            color: "#f1f1f1",
            fontWeight: 800,
            marginTop: 40,
          },
          children: [n.toFixed(2), "%"],
        }),
      ],
    });
  },
  j9 = () => {
    const n = jg("./planet/scene.gltf");
    return we("primitive", {
      object: n.scene,
      scale: 2.5,
      "position-y": 0,
      "rotation-y": 0,
    });
  },
  X9 = () =>
    we(Jg, {
      shadows: !0,
      frameloop: "demand",
      dpr: [1, 2],
      gl: { preserveDrawingBuffer: !0 },
      camera: { fov: 45, near: 0.1, far: 200, position: [-4, 3, 6] },
      children: St(H.Suspense, {
        fallback: we(HA, {}),
        children: [
          we(GA, {
            autoRotate: !0,
            enableZoom: !1,
            maxPolarAngle: Math.PI / 2,
            minPolarAngle: Math.PI / 2,
          }),
          we(j9, {}),
          we(Xg, { all: !0 }),
        ],
      }),
    }),
  K9 = (n) => {
    const [e] = zA([n.imgUrl]);
    return St(N9, {
      speed: 1.75,
      rotationIntensity: 1,
      floatIntensity: 2,
      children: [
        we("ambientLight", { intensity: 0.25 }),
        we("directionalLight", { position: [0, 0, 0.05] }),
        St("mesh", {
          castShadow: !0,
          receiveShadow: !0,
          scale: 2.75,
          children: [
            we("icosahedronGeometry", { args: [1, 1] }),
            we("meshStandardMaterial", {
              color: "#fff8eb",
              polygonOffset: !0,
              polygonOffsetFactor: -5,
              flatShading: !0,
            }),
            we(I9, {
              position: [0, 0, 1],
              rotation: [2 * Math.PI, 0, 6.25],
              scale: 1,
              map: e,
              flatShading: !0,
            }),
          ],
        }),
      ],
    });
  },
  Y9 = ({ icon: n }) =>
    St(Jg, {
      frameloop: "demand",
      dpr: [1, 2],
      gl: { preserveDrawingBuffer: !0 },
      children: [
        St(H.Suspense, {
          fallback: we(HA, {}),
          children: [we(GA, { enableZoom: !1 }), we(K9, { imgUrl: n })],
        }),
        we(Xg, { all: !0 }),
      ],
    }),
  Q9 = ({ isMobile: n }) => {
    const e = jg("./desktop_pc/scene.gltf");
    return St("mesh", {
      children: [
        we("hemisphereLight", { intensity: 0.15, groundColor: "black" }),
        we("spotLight", {
          position: [-20, 50, 10],
          angle: 0.12,
          penumbra: 1,
          intensity: 1,
          castShadow: !0,
          "shadow-mapSize": 1024,
        }),
        we("pointLight", { intensity: 1 }),
        we("primitive", {
          object: e.scene,
          scale: n ? 0.7 : 0.75,
          position: n ? [0, -3, -2.2] : [0, -3.25, -1.5],
          rotation: [-0.01, -0.2, -0.1],
        }),
      ],
    });
  },
  Z9 = () => {
    const [n, e] = H.useState(!1);
    return (
      H.useEffect(() => {
        const t = window.matchMedia("(max-width: 500px)");
        e(t.matches);
        const i = (r) => {
          e(r.matches);
        };
        return (
          t.addEventListener("change", i),
          () => {
            t.removeEventListener("change", i);
          }
        );
      }, []),
      St(Jg, {
        frameloop: "demand",
        shadows: !0,
        dpr: [1, 2],
        camera: { position: [20, 3, 5], fov: 25 },
        gl: { preserveDrawingBuffer: !0 },
        children: [
          St(H.Suspense, {
            fallback: we(HA, {}),
            children: [
              we(GA, {
                enableZoom: !1,
                maxPolarAngle: Math.PI / 2,
                minPolarAngle: Math.PI / 2,
              }),
              we(Q9, { isMobile: n }),
            ],
          }),
          we(Xg, { all: !0 }),
        ],
      })
    );
  },
  q9 = (n) => {
    const e = H.useRef(),
      [t] = H.useState(() => QV(new Float32Array(5e3), { radius: 1.2 }));
    return (
      lc((i, r) => {
        (e.current.rotation.x -= r / 10), (e.current.rotation.y -= r / 15);
      }),
      we("group", {
        rotation: [0, 0, Math.PI / 4],
        children: we(z9, {
          ref: e,
          positions: t,
          stride: 3,
          frustumCulled: !0,
          ...n,
          children: we(F9, {
            transparent: !0,
            color: "#f272c8",
            size: 0.002,
            sizeAttenuation: !0,
            depthWrite: !1,
          }),
        }),
      })
    );
  },
  $9 = () =>
    we("div", {
      className: "w-full h-auto absolute inset-0 z-[-1]",
      children: St(Jg, {
        camera: { position: [0, 0, 1] },
        children: [
          we(H.Suspense, { fallback: null, children: we(q9, {}) }),
          we(Xg, { all: !0 }),
        ],
      }),
    }),
  g3 = H.createContext({
    transformPagePoint: (n) => n,
    isStatic: !1,
    reducedMotion: "never",
  }),
  Kg = H.createContext({}),
  VA = H.createContext(null),
  Yg = typeof document < "u",
  pT = Yg ? H.useLayoutEffect : H.useEffect,
  y3 = H.createContext({ strict: !1 });
function e8(n, e, t, i) {
  const { visualElement: r } = H.useContext(Kg),
    s = H.useContext(y3),
    o = H.useContext(VA),
    a = H.useContext(g3).reducedMotion,
    l = H.useRef();
  (i = i || s.renderer),
    !l.current &&
      i &&
      (l.current = i(n, {
        visualState: e,
        parent: r,
        props: t,
        presenceContext: o,
        blockInitialAnimation: o ? o.initial === !1 : !1,
        reducedMotionConfig: a,
      }));
  const c = l.current;
  return (
    H.useInsertionEffect(() => {
      c && c.update(t, o);
    }),
    pT(() => {
      c && c.render();
    }),
    H.useEffect(() => {
      c && c.updateFeatures();
    }),
    (window.HandoffAppearAnimations ? pT : H.useEffect)(() => {
      c && c.animationState && c.animationState.animateChanges();
    }),
    c
  );
}
function xu(n) {
  return (
    typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current")
  );
}
function t8(n, e, t) {
  return H.useCallback(
    (i) => {
      i && n.mount && n.mount(i),
        e && (i ? e.mount(i) : e.unmount()),
        t && (typeof t == "function" ? t(i) : xu(t) && (t.current = i));
    },
    [e]
  );
}
function lh(n) {
  return typeof n == "string" || Array.isArray(n);
}
function Qg(n) {
  return typeof n == "object" && typeof n.start == "function";
}
const WA = [
    "animate",
    "whileInView",
    "whileFocus",
    "whileHover",
    "whileTap",
    "whileDrag",
    "exit",
  ],
  JA = ["initial", ...WA];
function Zg(n) {
  return Qg(n.animate) || JA.some((e) => lh(n[e]));
}
function v3(n) {
  return !!(Zg(n) || n.variants);
}
function n8(n, e) {
  if (Zg(n)) {
    const { initial: t, animate: i } = n;
    return {
      initial: t === !1 || lh(t) ? t : void 0,
      animate: lh(i) ? i : void 0,
    };
  }
  return n.inherit !== !1 ? e : {};
}
function i8(n) {
  const { initial: e, animate: t } = n8(n, H.useContext(Kg));
  return H.useMemo(() => ({ initial: e, animate: t }), [mT(e), mT(t)]);
}
function mT(n) {
  return Array.isArray(n) ? n.join(" ") : n;
}
const gT = {
    animation: [
      "animate",
      "variants",
      "whileHover",
      "whileTap",
      "exit",
      "whileInView",
      "whileFocus",
      "whileDrag",
    ],
    exit: ["exit"],
    drag: ["drag", "dragControls"],
    focus: ["whileFocus"],
    hover: ["whileHover", "onHoverStart", "onHoverEnd"],
    tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
    pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
    inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
    layout: ["layout", "layoutId"],
  },
  uh = {};
for (const n in gT) uh[n] = { isEnabled: (e) => gT[n].some((t) => !!e[t]) };
function r8(n) {
  for (const e in n) uh[e] = { ...uh[e], ...n[e] };
}
function x3(n) {
  const e = H.useRef(null);
  return e.current === null && (e.current = n()), e.current;
}
const wf = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 };
let s8 = 1;
function o8() {
  return x3(() => {
    if (wf.hasEverUpdated) return s8++;
  });
}
const _3 = H.createContext({}),
  A3 = H.createContext({}),
  a8 = Symbol.for("motionComponentSymbol");
function l8({
  preloadedFeatures: n,
  createVisualElement: e,
  useRender: t,
  useVisualState: i,
  Component: r,
}) {
  n && r8(n);
  function s(a, l) {
    let c;
    const h = { ...H.useContext(g3), ...a, layoutId: u8(a) },
      { isStatic: d } = h,
      p = i8(a),
      m = d ? void 0 : o8(),
      v = i(a, d);
    if (!d && Yg) {
      p.visualElement = e8(r, v, h, e);
      const A = H.useContext(A3),
        x = H.useContext(y3).strict;
      p.visualElement && (c = p.visualElement.loadFeatures(h, x, n, m, A));
    }
    return H.createElement(
      Kg.Provider,
      { value: p },
      c && p.visualElement
        ? H.createElement(c, { visualElement: p.visualElement, ...h })
        : null,
      t(r, a, m, t8(v, p.visualElement, l), v, d, p.visualElement)
    );
  }
  const o = H.forwardRef(s);
  return (o[a8] = r), o;
}
function u8({ layoutId: n }) {
  const e = H.useContext(_3).id;
  return e && n !== void 0 ? e + "-" + n : n;
}
function c8(n) {
  function e(i, r = {}) {
    return l8(n(i, r));
  }
  if (typeof Proxy > "u") return e;
  const t = new Map();
  return new Proxy(e, {
    get: (i, r) => (t.has(r) || t.set(r, e(r)), t.get(r)),
  });
}
const f8 = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view",
];
function jA(n) {
  return typeof n != "string" || n.includes("-")
    ? !1
    : !!(f8.indexOf(n) > -1 || /[A-Z]/.test(n));
}
const eg = {};
function h8(n) {
  Object.assign(eg, n);
}
const qg = [
    "transformPerspective",
    "x",
    "y",
    "z",
    "translateX",
    "translateY",
    "translateZ",
    "scale",
    "scaleX",
    "scaleY",
    "rotate",
    "rotateX",
    "rotateY",
    "rotateZ",
    "skew",
    "skewX",
    "skewY",
  ],
  gl = new Set(qg);
function M3(n, { layout: e, layoutId: t }) {
  return (
    gl.has(n) ||
    n.startsWith("origin") ||
    ((e || t !== void 0) && (!!eg[n] || n === "opacity"))
  );
}
const Li = (n) => !!(n && n.getVelocity),
  d8 = {
    x: "translateX",
    y: "translateY",
    z: "translateZ",
    transformPerspective: "perspective",
  },
  p8 = qg.length;
function m8(
  n,
  { enableHardwareAcceleration: e = !0, allowTransformNone: t = !0 },
  i,
  r
) {
  let s = "";
  for (let o = 0; o < p8; o++) {
    const a = qg[o];
    if (n[a] !== void 0) {
      const l = d8[a] || a;
      s += `${l}(${n[a]}) `;
    }
  }
  return (
    e && !n.z && (s += "translateZ(0)"),
    (s = s.trim()),
    r ? (s = r(n, i ? "" : s)) : t && i && (s = "none"),
    s
  );
}
const S3 = (n) => (e) => typeof e == "string" && e.startsWith(n),
  w3 = S3("--"),
  B_ = S3("var(--"),
  g8 = (n, e) => (e && typeof n == "number" ? e.transform(n) : n),
  ll = (n, e, t) => Math.min(Math.max(t, n), e),
  yl = {
    test: (n) => typeof n == "number",
    parse: parseFloat,
    transform: (n) => n,
  },
  Cf = { ...yl, transform: (n) => ll(0, 1, n) },
  Qp = { ...yl, default: 1 },
  Ef = (n) => Math.round(n * 1e5) / 1e5,
  ch = /(-)?([\d]*\.?[\d])+/g,
  R_ =
    /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,
  y8 =
    /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function Hh(n) {
  return typeof n == "string";
}
const Vh = (n) => ({
    test: (e) => Hh(e) && e.endsWith(n) && e.split(" ").length === 1,
    parse: parseFloat,
    transform: (e) => `${e}${n}`,
  }),
  xo = Vh("deg"),
  us = Vh("%"),
  it = Vh("px"),
  v8 = Vh("vh"),
  x8 = Vh("vw"),
  yT = {
    ...us,
    parse: (n) => us.parse(n) / 100,
    transform: (n) => us.transform(n * 100),
  },
  vT = { ...yl, transform: Math.round },
  C3 = {
    borderWidth: it,
    borderTopWidth: it,
    borderRightWidth: it,
    borderBottomWidth: it,
    borderLeftWidth: it,
    borderRadius: it,
    radius: it,
    borderTopLeftRadius: it,
    borderTopRightRadius: it,
    borderBottomRightRadius: it,
    borderBottomLeftRadius: it,
    width: it,
    maxWidth: it,
    height: it,
    maxHeight: it,
    size: it,
    top: it,
    right: it,
    bottom: it,
    left: it,
    padding: it,
    paddingTop: it,
    paddingRight: it,
    paddingBottom: it,
    paddingLeft: it,
    margin: it,
    marginTop: it,
    marginRight: it,
    marginBottom: it,
    marginLeft: it,
    rotate: xo,
    rotateX: xo,
    rotateY: xo,
    rotateZ: xo,
    scale: Qp,
    scaleX: Qp,
    scaleY: Qp,
    scaleZ: Qp,
    skew: xo,
    skewX: xo,
    skewY: xo,
    distance: it,
    translateX: it,
    translateY: it,
    translateZ: it,
    x: it,
    y: it,
    z: it,
    perspective: it,
    transformPerspective: it,
    opacity: Cf,
    originX: yT,
    originY: yT,
    originZ: it,
    zIndex: vT,
    fillOpacity: Cf,
    strokeOpacity: Cf,
    numOctaves: vT,
  };
function XA(n, e, t, i) {
  const { style: r, vars: s, transform: o, transformOrigin: a } = n;
  let l = !1,
    c = !1,
    h = !0;
  for (const d in e) {
    const p = e[d];
    if (w3(d)) {
      s[d] = p;
      continue;
    }
    const m = C3[d],
      v = g8(p, m);
    if (gl.has(d)) {
      if (((l = !0), (o[d] = v), !h)) continue;
      p !== (m.default || 0) && (h = !1);
    } else d.startsWith("origin") ? ((c = !0), (a[d] = v)) : (r[d] = v);
  }
  if (
    (e.transform ||
      (l || i
        ? (r.transform = m8(n.transform, t, h, i))
        : r.transform && (r.transform = "none")),
    c)
  ) {
    const { originX: d = "50%", originY: p = "50%", originZ: m = 0 } = a;
    r.transformOrigin = `${d} ${p} ${m}`;
  }
}
const KA = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} });
function E3(n, e, t) {
  for (const i in e) !Li(e[i]) && !M3(i, t) && (n[i] = e[i]);
}
function _8({ transformTemplate: n }, e, t) {
  return H.useMemo(() => {
    const i = KA();
    return (
      XA(i, e, { enableHardwareAcceleration: !t }, n),
      Object.assign({}, i.vars, i.style)
    );
  }, [e]);
}
function A8(n, e, t) {
  const i = n.style || {},
    r = {};
  return (
    E3(r, i, n),
    Object.assign(r, _8(n, e, t)),
    n.transformValues ? n.transformValues(r) : r
  );
}
function M8(n, e, t) {
  const i = {},
    r = A8(n, e, t);
  return (
    n.drag &&
      n.dragListener !== !1 &&
      ((i.draggable = !1),
      (r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none"),
      (r.touchAction =
        n.drag === !0 ? "none" : `pan-${n.drag === "x" ? "y" : "x"}`)),
    n.tabIndex === void 0 &&
      (n.onTap || n.onTapStart || n.whileTap) &&
      (i.tabIndex = 0),
    (i.style = r),
    i
  );
}
const S8 = new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "ignoreStrict",
  "viewport",
]);
function tg(n) {
  return (
    n.startsWith("while") ||
    (n.startsWith("drag") && n !== "draggable") ||
    n.startsWith("layout") ||
    n.startsWith("onTap") ||
    n.startsWith("onPan") ||
    S8.has(n)
  );
}
let T3 = (n) => !tg(n);
function w8(n) {
  n && (T3 = (e) => (e.startsWith("on") ? !tg(e) : n(e)));
}
try {
  w8(require("@emotion/is-prop-valid").default);
} catch {}
function C8(n, e, t) {
  const i = {};
  for (const r in n)
    (r === "values" && typeof n.values == "object") ||
      ((T3(r) ||
        (t === !0 && tg(r)) ||
        (!e && !tg(r)) ||
        (n.draggable && r.startsWith("onDrag"))) &&
        (i[r] = n[r]));
  return i;
}
function xT(n, e, t) {
  return typeof n == "string" ? n : it.transform(e + t * n);
}
function E8(n, e, t) {
  const i = xT(e, n.x, n.width),
    r = xT(t, n.y, n.height);
  return `${i} ${r}`;
}
const T8 = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
  b8 = { offset: "strokeDashoffset", array: "strokeDasharray" };
function P8(n, e, t = 1, i = 0, r = !0) {
  n.pathLength = 1;
  const s = r ? T8 : b8;
  n[s.offset] = it.transform(-i);
  const o = it.transform(e),
    a = it.transform(t);
  n[s.array] = `${o} ${a}`;
}
function YA(
  n,
  {
    attrX: e,
    attrY: t,
    originX: i,
    originY: r,
    pathLength: s,
    pathSpacing: o = 1,
    pathOffset: a = 0,
    ...l
  },
  c,
  h,
  d
) {
  if ((XA(n, l, c, d), h)) {
    n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
    return;
  }
  (n.attrs = n.style), (n.style = {});
  const { attrs: p, style: m, dimensions: v } = n;
  p.transform && (v && (m.transform = p.transform), delete p.transform),
    v &&
      (i !== void 0 || r !== void 0 || m.transform) &&
      (m.transformOrigin = E8(
        v,
        i !== void 0 ? i : 0.5,
        r !== void 0 ? r : 0.5
      )),
    e !== void 0 && (p.x = e),
    t !== void 0 && (p.y = t),
    s !== void 0 && P8(p, s, o, a, !1);
}
const b3 = () => ({ ...KA(), attrs: {} }),
  QA = (n) => typeof n == "string" && n.toLowerCase() === "svg";
function B8(n, e, t, i) {
  const r = H.useMemo(() => {
    const s = b3();
    return (
      YA(s, e, { enableHardwareAcceleration: !1 }, QA(i), n.transformTemplate),
      { ...s.attrs, style: { ...s.style } }
    );
  }, [e]);
  if (n.style) {
    const s = {};
    E3(s, n.style, n), (r.style = { ...s, ...r.style });
  }
  return r;
}
function R8(n = !1) {
  return (t, i, r, s, { latestValues: o }, a) => {
    const c = (jA(t) ? B8 : M8)(i, o, a, t),
      d = { ...C8(i, typeof t == "string", n), ...c, ref: s },
      { children: p } = i,
      m = H.useMemo(() => (Li(p) ? p.get() : p), [p]);
    return (
      r && (d["data-projection-id"] = r),
      H.createElement(t, { ...d, children: m })
    );
  };
}
const ZA = (n) => n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
function P3(n, { style: e, vars: t }, i, r) {
  Object.assign(n.style, e, r && r.getProjectionStyles(i));
  for (const s in t) n.style.setProperty(s, t[s]);
}
const B3 = new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust",
]);
function R3(n, e, t, i) {
  P3(n, e, void 0, i);
  for (const r in e.attrs) n.setAttribute(B3.has(r) ? r : ZA(r), e.attrs[r]);
}
function qA(n, e) {
  const { style: t } = n,
    i = {};
  for (const r in t)
    (Li(t[r]) || (e.style && Li(e.style[r])) || M3(r, n)) && (i[r] = t[r]);
  return i;
}
function L3(n, e) {
  const t = qA(n, e);
  for (const i in n)
    if (Li(n[i]) || Li(e[i])) {
      const r = i === "x" || i === "y" ? "attr" + i.toUpperCase() : i;
      t[r] = n[i];
    }
  return t;
}
function $A(n, e, t, i = {}, r = {}) {
  return (
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    typeof e == "string" && (e = n.variants && n.variants[e]),
    typeof e == "function" && (e = e(t !== void 0 ? t : n.custom, i, r)),
    e
  );
}
const ng = (n) => Array.isArray(n),
  L8 = (n) => !!(n && typeof n == "object" && n.mix && n.toValue),
  I8 = (n) => (ng(n) ? n[n.length - 1] || 0 : n);
function Am(n) {
  const e = Li(n) ? n.get() : n;
  return L8(e) ? e.toValue() : e;
}
function D8(
  { scrapeMotionValuesFromProps: n, createRenderState: e, onMount: t },
  i,
  r,
  s
) {
  const o = { latestValues: F8(i, r, s, n), renderState: e() };
  return t && (o.mount = (a) => t(i, a, o)), o;
}
const I3 = (n) => (e, t) => {
  const i = H.useContext(Kg),
    r = H.useContext(VA),
    s = () => D8(n, e, i, r);
  return t ? s() : x3(s);
};
function F8(n, e, t, i) {
  const r = {},
    s = i(n, {});
  for (const p in s) r[p] = Am(s[p]);
  let { initial: o, animate: a } = n;
  const l = Zg(n),
    c = v3(n);
  e &&
    c &&
    !l &&
    n.inherit !== !1 &&
    (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
  let h = t ? t.initial === !1 : !1;
  h = h || o === !1;
  const d = h ? a : o;
  return (
    d &&
      typeof d != "boolean" &&
      !Qg(d) &&
      (Array.isArray(d) ? d : [d]).forEach((m) => {
        const v = $A(n, m);
        if (!v) return;
        const { transitionEnd: A, transition: x, ...g } = v;
        for (const _ in g) {
          let S = g[_];
          if (Array.isArray(S)) {
            const w = h ? S.length - 1 : 0;
            S = S[w];
          }
          S !== null && (r[_] = S);
        }
        for (const _ in A) r[_] = A[_];
      }),
    r
  );
}
const N8 = {
    useVisualState: I3({
      scrapeMotionValuesFromProps: L3,
      createRenderState: b3,
      onMount: (n, e, { renderState: t, latestValues: i }) => {
        try {
          t.dimensions =
            typeof e.getBBox == "function"
              ? e.getBBox()
              : e.getBoundingClientRect();
        } catch {
          t.dimensions = { x: 0, y: 0, width: 0, height: 0 };
        }
        YA(
          t,
          i,
          { enableHardwareAcceleration: !1 },
          QA(e.tagName),
          n.transformTemplate
        ),
          R3(e, t);
      },
    }),
  },
  O8 = {
    useVisualState: I3({
      scrapeMotionValuesFromProps: qA,
      createRenderState: KA,
    }),
  };
function k8(n, { forwardMotionProps: e = !1 }, t, i) {
  return {
    ...(jA(n) ? N8 : O8),
    preloadedFeatures: t,
    useRender: R8(e),
    createVisualElement: i,
    Component: n,
  };
}
function ks(n, e, t, i = { passive: !0 }) {
  return n.addEventListener(e, t, i), () => n.removeEventListener(e, t);
}
const D3 = (n) =>
  n.pointerType === "mouse"
    ? typeof n.button != "number" || n.button <= 0
    : n.isPrimary !== !1;
function $g(n, e = "page") {
  return { point: { x: n[e + "X"], y: n[e + "Y"] } };
}
const U8 = (n) => (e) => D3(e) && n(e, $g(e));
function Gs(n, e, t, i) {
  return ks(n, e, U8(t), i);
}
const z8 = (n, e) => (t) => e(n(t)),
  zo = (...n) => n.reduce(z8);
function F3(n) {
  let e = null;
  return () => {
    const t = () => {
      e = null;
    };
    return e === null ? ((e = n), t) : !1;
  };
}
const _T = F3("dragHorizontal"),
  AT = F3("dragVertical");
function N3(n) {
  let e = !1;
  if (n === "y") e = AT();
  else if (n === "x") e = _T();
  else {
    const t = _T(),
      i = AT();
    t && i
      ? (e = () => {
          t(), i();
        })
      : (t && t(), i && i());
  }
  return e;
}
function O3() {
  const n = N3(!0);
  return n ? (n(), !1) : !0;
}
class ra {
  constructor(e) {
    (this.isMounted = !1), (this.node = e);
  }
  update() {}
}
function G8(n) {
  let e = [],
    t = [],
    i = 0,
    r = !1,
    s = !1;
  const o = new WeakSet(),
    a = {
      schedule: (l, c = !1, h = !1) => {
        const d = h && r,
          p = d ? e : t;
        return (
          c && o.add(l),
          p.indexOf(l) === -1 && (p.push(l), d && r && (i = e.length)),
          l
        );
      },
      cancel: (l) => {
        const c = t.indexOf(l);
        c !== -1 && t.splice(c, 1), o.delete(l);
      },
      process: (l) => {
        if (r) {
          s = !0;
          return;
        }
        if (((r = !0), ([e, t] = [t, e]), (t.length = 0), (i = e.length), i))
          for (let c = 0; c < i; c++) {
            const h = e[c];
            h(l), o.has(h) && (a.schedule(h), n());
          }
        (r = !1), s && ((s = !1), a.process(l));
      },
    };
  return a;
}
const ri = { delta: 0, timestamp: 0, isProcessing: !1 },
  H8 = 40;
let L_ = !0,
  fh = !1;
const Wh = ["read", "update", "preRender", "render", "postRender"],
  e0 = Wh.reduce((n, e) => ((n[e] = G8(() => (fh = !0))), n), {}),
  an = Wh.reduce((n, e) => {
    const t = e0[e];
    return (n[e] = (i, r = !1, s = !1) => (fh || W8(), t.schedule(i, r, s))), n;
  }, {}),
  Yo = Wh.reduce((n, e) => ((n[e] = e0[e].cancel), n), {}),
  Tv = Wh.reduce((n, e) => ((n[e] = () => e0[e].process(ri)), n), {}),
  V8 = (n) => e0[n].process(ri),
  k3 = (n) => {
    (fh = !1),
      (ri.delta = L_ ? 1e3 / 60 : Math.max(Math.min(n - ri.timestamp, H8), 1)),
      (ri.timestamp = n),
      (ri.isProcessing = !0),
      Wh.forEach(V8),
      (ri.isProcessing = !1),
      fh && ((L_ = !1), requestAnimationFrame(k3));
  },
  W8 = () => {
    (fh = !0), (L_ = !0), ri.isProcessing || requestAnimationFrame(k3);
  };
function MT(n, e) {
  const t = "pointer" + (e ? "enter" : "leave"),
    i = "onHover" + (e ? "Start" : "End"),
    r = (s, o) => {
      if (s.type === "touch" || O3()) return;
      const a = n.getProps();
      n.animationState &&
        a.whileHover &&
        n.animationState.setActive("whileHover", e),
        a[i] && an.update(() => a[i](s, o));
    };
  return Gs(n.current, t, r, { passive: !n.getProps()[i] });
}
class J8 extends ra {
  mount() {
    this.unmount = zo(MT(this.node, !0), MT(this.node, !1));
  }
  unmount() {}
}
class j8 extends ra {
  constructor() {
    super(...arguments), (this.isActive = !1);
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !0),
      (this.isActive = !0));
  }
  onBlur() {
    !this.isActive ||
      !this.node.animationState ||
      (this.node.animationState.setActive("whileFocus", !1),
      (this.isActive = !1));
  }
  mount() {
    this.unmount = zo(
      ks(this.node.current, "focus", () => this.onFocus()),
      ks(this.node.current, "blur", () => this.onBlur())
    );
  }
  unmount() {}
}
const U3 = (n, e) => (e ? (n === e ? !0 : U3(n, e.parentElement)) : !1),
  kn = (n) => n;
function bv(n, e) {
  if (!e) return;
  const t = new PointerEvent("pointer" + n);
  e(t, $g(t));
}
class X8 extends ra {
  constructor() {
    super(...arguments),
      (this.removeStartListeners = kn),
      (this.removeEndListeners = kn),
      (this.removeAccessibleListeners = kn),
      (this.startPointerPress = (e, t) => {
        if ((this.removeEndListeners(), this.isPressing)) return;
        const i = this.node.getProps(),
          s = Gs(
            window,
            "pointerup",
            (a, l) => {
              if (!this.checkPressEnd()) return;
              const { onTap: c, onTapCancel: h } = this.node.getProps();
              an.update(() => {
                U3(this.node.current, a.target) ? c && c(a, l) : h && h(a, l);
              });
            },
            { passive: !(i.onTap || i.onPointerUp) }
          ),
          o = Gs(window, "pointercancel", (a, l) => this.cancelPress(a, l), {
            passive: !(i.onTapCancel || i.onPointerCancel),
          });
        (this.removeEndListeners = zo(s, o)), this.startPress(e, t);
      }),
      (this.startAccessiblePress = () => {
        const e = (s) => {
            if (s.key !== "Enter" || this.isPressing) return;
            const o = (a) => {
              a.key !== "Enter" ||
                !this.checkPressEnd() ||
                bv("up", (l, c) => {
                  const { onTap: h } = this.node.getProps();
                  h && an.update(() => h(l, c));
                });
            };
            this.removeEndListeners(),
              (this.removeEndListeners = ks(this.node.current, "keyup", o)),
              bv("down", (a, l) => {
                this.startPress(a, l);
              });
          },
          t = ks(this.node.current, "keydown", e),
          i = () => {
            this.isPressing && bv("cancel", (s, o) => this.cancelPress(s, o));
          },
          r = ks(this.node.current, "blur", i);
        this.removeAccessibleListeners = zo(t, r);
      });
  }
  startPress(e, t) {
    this.isPressing = !0;
    const { onTapStart: i, whileTap: r } = this.node.getProps();
    r &&
      this.node.animationState &&
      this.node.animationState.setActive("whileTap", !0),
      i && an.update(() => i(e, t));
  }
  checkPressEnd() {
    return (
      this.removeEndListeners(),
      (this.isPressing = !1),
      this.node.getProps().whileTap &&
        this.node.animationState &&
        this.node.animationState.setActive("whileTap", !1),
      !O3()
    );
  }
  cancelPress(e, t) {
    if (!this.checkPressEnd()) return;
    const { onTapCancel: i } = this.node.getProps();
    i && an.update(() => i(e, t));
  }
  mount() {
    const e = this.node.getProps(),
      t = Gs(this.node.current, "pointerdown", this.startPointerPress, {
        passive: !(e.onTapStart || e.onPointerStart),
      }),
      i = ks(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = zo(t, i);
  }
  unmount() {
    this.removeStartListeners(),
      this.removeEndListeners(),
      this.removeAccessibleListeners();
  }
}
const I_ = new WeakMap(),
  Pv = new WeakMap(),
  K8 = (n) => {
    const e = I_.get(n.target);
    e && e(n);
  },
  Y8 = (n) => {
    n.forEach(K8);
  };
function Q8({ root: n, ...e }) {
  const t = n || document;
  Pv.has(t) || Pv.set(t, {});
  const i = Pv.get(t),
    r = JSON.stringify(e);
  return i[r] || (i[r] = new IntersectionObserver(Y8, { root: n, ...e })), i[r];
}
function Z8(n, e, t) {
  const i = Q8(e);
  return (
    I_.set(n, t),
    i.observe(n),
    () => {
      I_.delete(n), i.unobserve(n);
    }
  );
}
const q8 = { some: 0, all: 1 };
class $8 extends ra {
  constructor() {
    super(...arguments), (this.hasEnteredView = !1), (this.isInView = !1);
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(),
      { root: t, margin: i, amount: r = "some", once: s } = e,
      o = {
        root: t ? t.current : void 0,
        rootMargin: i,
        threshold: typeof r == "number" ? r : q8[r],
      },
      a = (l) => {
        const { isIntersecting: c } = l;
        if (
          this.isInView === c ||
          ((this.isInView = c), s && !c && this.hasEnteredView)
        )
          return;
        c && (this.hasEnteredView = !0),
          this.node.animationState &&
            this.node.animationState.setActive("whileInView", c);
        const { onViewportEnter: h, onViewportLeave: d } = this.node.getProps(),
          p = c ? h : d;
        p && p(l);
      };
    return Z8(this.node.current, o, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u") return;
    const { props: e, prevProps: t } = this.node;
    ["amount", "margin", "root"].some(e6(e, t)) && this.startObserver();
  }
  unmount() {}
}
function e6({ viewport: n = {} }, { viewport: e = {} } = {}) {
  return (t) => n[t] !== e[t];
}
const t6 = {
  inView: { Feature: $8 },
  tap: { Feature: X8 },
  focus: { Feature: j8 },
  hover: { Feature: J8 },
};
function z3(n, e) {
  if (!Array.isArray(e)) return !1;
  const t = e.length;
  if (t !== n.length) return !1;
  for (let i = 0; i < t; i++) if (e[i] !== n[i]) return !1;
  return !0;
}
function n6(n) {
  const e = {};
  return n.values.forEach((t, i) => (e[i] = t.get())), e;
}
function i6(n) {
  const e = {};
  return n.values.forEach((t, i) => (e[i] = t.getVelocity())), e;
}
function t0(n, e, t) {
  const i = n.getProps();
  return $A(i, e, t !== void 0 ? t : i.custom, n6(n), i6(n));
}
const r6 = "framerAppearId",
  s6 = "data-" + ZA(r6);
let o6 = kn,
  eM = kn;
const Go = (n) => n * 1e3,
  Hs = (n) => n / 1e3,
  a6 = { current: !1 },
  G3 = (n) => Array.isArray(n) && typeof n[0] == "number";
function H3(n) {
  return !!(
    !n ||
    (typeof n == "string" && V3[n]) ||
    G3(n) ||
    (Array.isArray(n) && n.every(H3))
  );
}
const cf = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
  V3 = {
    linear: "linear",
    ease: "ease",
    easeIn: "ease-in",
    easeOut: "ease-out",
    easeInOut: "ease-in-out",
    circIn: cf([0, 0.65, 0.55, 1]),
    circOut: cf([0.55, 0, 1, 0.45]),
    backIn: cf([0.31, 0.01, 0.66, -0.59]),
    backOut: cf([0.33, 1.53, 0.69, 0.99]),
  };
function W3(n) {
  if (n) return G3(n) ? cf(n) : Array.isArray(n) ? n.map(W3) : V3[n];
}
function l6(
  n,
  e,
  t,
  {
    delay: i = 0,
    duration: r,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a,
    times: l,
  } = {}
) {
  const c = { [e]: t };
  l && (c.offset = l);
  const h = W3(a);
  return (
    Array.isArray(h) && (c.easing = h),
    n.animate(c, {
      delay: i,
      duration: r,
      easing: Array.isArray(h) ? "linear" : h,
      fill: "both",
      iterations: s + 1,
      direction: o === "reverse" ? "alternate" : "normal",
    })
  );
}
const ST = {
    waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
  },
  Bv = {},
  J3 = {};
for (const n in ST)
  J3[n] = () => (Bv[n] === void 0 && (Bv[n] = ST[n]()), Bv[n]);
function u6(n, { repeat: e, repeatType: t = "loop" }) {
  const i = e && t !== "loop" && e % 2 === 1 ? 0 : n.length - 1;
  return n[i];
}
const j3 = (n, e, t) =>
    (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
  c6 = 1e-7,
  f6 = 12;
function h6(n, e, t, i, r) {
  let s,
    o,
    a = 0;
  do (o = e + (t - e) / 2), (s = j3(o, i, r) - n), s > 0 ? (t = o) : (e = o);
  while (Math.abs(s) > c6 && ++a < f6);
  return o;
}
function Jh(n, e, t, i) {
  if (n === e && t === i) return kn;
  const r = (s) => h6(s, 0, 1, n, t);
  return (s) => (s === 0 || s === 1 ? s : j3(r(s), e, i));
}
const d6 = Jh(0.42, 0, 1, 1),
  p6 = Jh(0, 0, 0.58, 1),
  X3 = Jh(0.42, 0, 0.58, 1),
  m6 = (n) => Array.isArray(n) && typeof n[0] != "number",
  K3 = (n) => (e) => e <= 0.5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
  Y3 = (n) => (e) => 1 - n(1 - e),
  Q3 = (n) => 1 - Math.sin(Math.acos(n)),
  tM = Y3(Q3),
  g6 = K3(tM),
  Z3 = Jh(0.33, 1.53, 0.69, 0.99),
  nM = Y3(Z3),
  y6 = K3(nM),
  v6 = (n) =>
    (n *= 2) < 1 ? 0.5 * nM(n) : 0.5 * (2 - Math.pow(2, -10 * (n - 1))),
  x6 = {
    linear: kn,
    easeIn: d6,
    easeInOut: X3,
    easeOut: p6,
    circIn: Q3,
    circInOut: g6,
    circOut: tM,
    backIn: nM,
    backInOut: y6,
    backOut: Z3,
    anticipate: v6,
  },
  wT = (n) => {
    if (Array.isArray(n)) {
      eM(n.length === 4);
      const [e, t, i, r] = n;
      return Jh(e, t, i, r);
    } else if (typeof n == "string") return x6[n];
    return n;
  },
  iM = (n, e) => (t) =>
    !!(
      (Hh(t) && y8.test(t) && t.startsWith(n)) ||
      (e && Object.prototype.hasOwnProperty.call(t, e))
    ),
  q3 = (n, e, t) => (i) => {
    if (!Hh(i)) return i;
    const [r, s, o, a] = i.match(ch);
    return {
      [n]: parseFloat(r),
      [e]: parseFloat(s),
      [t]: parseFloat(o),
      alpha: a !== void 0 ? parseFloat(a) : 1,
    };
  },
  _6 = (n) => ll(0, 255, n),
  Rv = { ...yl, transform: (n) => Math.round(_6(n)) },
  Wa = {
    test: iM("rgb", "red"),
    parse: q3("red", "green", "blue"),
    transform: ({ red: n, green: e, blue: t, alpha: i = 1 }) =>
      "rgba(" +
      Rv.transform(n) +
      ", " +
      Rv.transform(e) +
      ", " +
      Rv.transform(t) +
      ", " +
      Ef(Cf.transform(i)) +
      ")",
  };
function A6(n) {
  let e = "",
    t = "",
    i = "",
    r = "";
  return (
    n.length > 5
      ? ((e = n.substring(1, 3)),
        (t = n.substring(3, 5)),
        (i = n.substring(5, 7)),
        (r = n.substring(7, 9)))
      : ((e = n.substring(1, 2)),
        (t = n.substring(2, 3)),
        (i = n.substring(3, 4)),
        (r = n.substring(4, 5)),
        (e += e),
        (t += t),
        (i += i),
        (r += r)),
    {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(i, 16),
      alpha: r ? parseInt(r, 16) / 255 : 1,
    }
  );
}
const D_ = { test: iM("#"), parse: A6, transform: Wa.transform },
  _u = {
    test: iM("hsl", "hue"),
    parse: q3("hue", "saturation", "lightness"),
    transform: ({ hue: n, saturation: e, lightness: t, alpha: i = 1 }) =>
      "hsla(" +
      Math.round(n) +
      ", " +
      us.transform(Ef(e)) +
      ", " +
      us.transform(Ef(t)) +
      ", " +
      Ef(Cf.transform(i)) +
      ")",
  },
  hi = {
    test: (n) => Wa.test(n) || D_.test(n) || _u.test(n),
    parse: (n) =>
      Wa.test(n) ? Wa.parse(n) : _u.test(n) ? _u.parse(n) : D_.parse(n),
    transform: (n) =>
      Hh(n) ? n : n.hasOwnProperty("red") ? Wa.transform(n) : _u.transform(n),
  },
  on = (n, e, t) => -t * n + t * e + n;
function Lv(n, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? n + (e - n) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? n + (e - n) * (2 / 3 - t) * 6
      : n
  );
}
function M6({ hue: n, saturation: e, lightness: t, alpha: i }) {
  (n /= 360), (e /= 100), (t /= 100);
  let r = 0,
    s = 0,
    o = 0;
  if (!e) r = s = o = t;
  else {
    const a = t < 0.5 ? t * (1 + e) : t + e - t * e,
      l = 2 * t - a;
    (r = Lv(l, a, n + 1 / 3)), (s = Lv(l, a, n)), (o = Lv(l, a, n - 1 / 3));
  }
  return {
    red: Math.round(r * 255),
    green: Math.round(s * 255),
    blue: Math.round(o * 255),
    alpha: i,
  };
}
const Iv = (n, e, t) => {
    const i = n * n;
    return Math.sqrt(Math.max(0, t * (e * e - i) + i));
  },
  S6 = [D_, Wa, _u],
  w6 = (n) => S6.find((e) => e.test(n));
function CT(n) {
  const e = w6(n);
  let t = e.parse(n);
  return e === _u && (t = M6(t)), t;
}
const $3 = (n, e) => {
    const t = CT(n),
      i = CT(e),
      r = { ...t };
    return (s) => (
      (r.red = Iv(t.red, i.red, s)),
      (r.green = Iv(t.green, i.green, s)),
      (r.blue = Iv(t.blue, i.blue, s)),
      (r.alpha = on(t.alpha, i.alpha, s)),
      Wa.transform(r)
    );
  },
  eL = "${c}",
  tL = "${n}";
function C6(n) {
  var e, t;
  return (
    isNaN(n) &&
    Hh(n) &&
    (((e = n.match(ch)) === null || e === void 0 ? void 0 : e.length) || 0) +
      (((t = n.match(R_)) === null || t === void 0 ? void 0 : t.length) || 0) >
      0
  );
}
function ig(n) {
  typeof n == "number" && (n = `${n}`);
  const e = [];
  let t = 0,
    i = 0;
  const r = n.match(R_);
  r && ((t = r.length), (n = n.replace(R_, eL)), e.push(...r.map(hi.parse)));
  const s = n.match(ch);
  return (
    s && ((i = s.length), (n = n.replace(ch, tL)), e.push(...s.map(yl.parse))),
    { values: e, numColors: t, numNumbers: i, tokenised: n }
  );
}
function nL(n) {
  return ig(n).values;
}
function iL(n) {
  const { values: e, numColors: t, tokenised: i } = ig(n),
    r = e.length;
  return (s) => {
    let o = i;
    for (let a = 0; a < r; a++)
      o = o.replace(a < t ? eL : tL, a < t ? hi.transform(s[a]) : Ef(s[a]));
    return o;
  };
}
const E6 = (n) => (typeof n == "number" ? 0 : n);
function T6(n) {
  const e = nL(n);
  return iL(n)(e.map(E6));
}
const Qo = {
  test: C6,
  parse: nL,
  createTransformer: iL,
  getAnimatableNone: T6,
};
function rL(n, e) {
  return typeof n == "number"
    ? (t) => on(n, e, t)
    : hi.test(n)
    ? $3(n, e)
    : oL(n, e);
}
const sL = (n, e) => {
    const t = [...n],
      i = t.length,
      r = n.map((s, o) => rL(s, e[o]));
    return (s) => {
      for (let o = 0; o < i; o++) t[o] = r[o](s);
      return t;
    };
  },
  b6 = (n, e) => {
    const t = { ...n, ...e },
      i = {};
    for (const r in t)
      n[r] !== void 0 && e[r] !== void 0 && (i[r] = rL(n[r], e[r]));
    return (r) => {
      for (const s in i) t[s] = i[s](r);
      return t;
    };
  },
  oL = (n, e) => {
    const t = Qo.createTransformer(e),
      i = ig(n),
      r = ig(e);
    return i.numColors === r.numColors && i.numNumbers >= r.numNumbers
      ? zo(sL(i.values, r.values), t)
      : (o) => `${o > 0 ? e : n}`;
  },
  hh = (n, e, t) => {
    const i = e - n;
    return i === 0 ? 1 : (t - n) / i;
  },
  ET = (n, e) => (t) => on(n, e, t);
function P6(n) {
  return typeof n == "number"
    ? ET
    : typeof n == "string"
    ? hi.test(n)
      ? $3
      : oL
    : Array.isArray(n)
    ? sL
    : typeof n == "object"
    ? b6
    : ET;
}
function B6(n, e, t) {
  const i = [],
    r = t || P6(n[0]),
    s = n.length - 1;
  for (let o = 0; o < s; o++) {
    let a = r(n[o], n[o + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[o] || kn : e;
      a = zo(l, a);
    }
    i.push(a);
  }
  return i;
}
function aL(n, e, { clamp: t = !0, ease: i, mixer: r } = {}) {
  const s = n.length;
  if ((eM(s === e.length), s === 1)) return () => e[0];
  n[0] > n[s - 1] && ((n = [...n].reverse()), (e = [...e].reverse()));
  const o = B6(e, i, r),
    a = o.length,
    l = (c) => {
      let h = 0;
      if (a > 1) for (; h < n.length - 2 && !(c < n[h + 1]); h++);
      const d = hh(n[h], n[h + 1], c);
      return o[h](d);
    };
  return t ? (c) => l(ll(n[0], n[s - 1], c)) : l;
}
function R6(n, e) {
  const t = n[n.length - 1];
  for (let i = 1; i <= e; i++) {
    const r = hh(0, e, i);
    n.push(on(t, 1, r));
  }
}
function L6(n) {
  const e = [0];
  return R6(e, n.length - 1), e;
}
function I6(n, e) {
  return n.map((t) => t * e);
}
function D6(n, e) {
  return n.map(() => e || X3).splice(0, n.length - 1);
}
function rg({
  duration: n = 300,
  keyframes: e,
  times: t,
  ease: i = "easeInOut",
}) {
  const r = m6(i) ? i.map(wT) : wT(i),
    s = { done: !1, value: e[0] },
    o = I6(t && t.length === e.length ? t : L6(e), n),
    a = aL(o, e, { ease: Array.isArray(r) ? r : D6(e, r) });
  return {
    calculatedDuration: n,
    next: (l) => ((s.value = a(l)), (s.done = l >= n), s),
  };
}
function lL(n, e) {
  return e ? n * (1e3 / e) : 0;
}
const F6 = 5;
function uL(n, e, t) {
  const i = Math.max(e - F6, 0);
  return lL(t - n(i), e - i);
}
const Dv = 0.001,
  N6 = 0.01,
  TT = 10,
  O6 = 0.05,
  k6 = 1;
function U6({
  duration: n = 800,
  bounce: e = 0.25,
  velocity: t = 0,
  mass: i = 1,
}) {
  let r, s;
  o6(n <= Go(TT));
  let o = 1 - e;
  (o = ll(O6, k6, o)),
    (n = ll(N6, TT, Hs(n))),
    o < 1
      ? ((r = (c) => {
          const h = c * o,
            d = h * n,
            p = h - t,
            m = F_(c, o),
            v = Math.exp(-d);
          return Dv - (p / m) * v;
        }),
        (s = (c) => {
          const d = c * o * n,
            p = d * t + t,
            m = Math.pow(o, 2) * Math.pow(c, 2) * n,
            v = Math.exp(-d),
            A = F_(Math.pow(c, 2), o);
          return ((-r(c) + Dv > 0 ? -1 : 1) * ((p - m) * v)) / A;
        }))
      : ((r = (c) => {
          const h = Math.exp(-c * n),
            d = (c - t) * n + 1;
          return -Dv + h * d;
        }),
        (s = (c) => {
          const h = Math.exp(-c * n),
            d = (t - c) * (n * n);
          return h * d;
        }));
  const a = 5 / n,
    l = G6(r, s, a);
  if (((n = Go(n)), isNaN(l)))
    return { stiffness: 100, damping: 10, duration: n };
  {
    const c = Math.pow(l, 2) * i;
    return { stiffness: c, damping: o * 2 * Math.sqrt(i * c), duration: n };
  }
}
const z6 = 12;
function G6(n, e, t) {
  let i = t;
  for (let r = 1; r < z6; r++) i = i - n(i) / e(i);
  return i;
}
function F_(n, e) {
  return n * Math.sqrt(1 - e * e);
}
const H6 = ["duration", "bounce"],
  V6 = ["stiffness", "damping", "mass"];
function bT(n, e) {
  return e.some((t) => n[t] !== void 0);
}
function W6(n) {
  let e = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...n,
  };
  if (!bT(n, V6) && bT(n, H6)) {
    const t = U6(n);
    (e = { ...e, ...t, velocity: 0, mass: 1 }), (e.isResolvedFromDuration = !0);
  }
  return e;
}
function cL({ keyframes: n, restDelta: e, restSpeed: t, ...i }) {
  const r = n[0],
    s = n[n.length - 1],
    o = { done: !1, value: r },
    {
      stiffness: a,
      damping: l,
      mass: c,
      velocity: h,
      duration: d,
      isResolvedFromDuration: p,
    } = W6(i),
    m = h ? -Hs(h) : 0,
    v = l / (2 * Math.sqrt(a * c)),
    A = s - r,
    x = Hs(Math.sqrt(a / c)),
    g = Math.abs(A) < 5;
  t || (t = g ? 0.01 : 2), e || (e = g ? 0.005 : 0.5);
  let _;
  if (v < 1) {
    const S = F_(x, v);
    _ = (w) => {
      const E = Math.exp(-v * x * w);
      return (
        s - E * (((m + v * x * A) / S) * Math.sin(S * w) + A * Math.cos(S * w))
      );
    };
  } else if (v === 1) _ = (S) => s - Math.exp(-x * S) * (A + (m + x * A) * S);
  else {
    const S = x * Math.sqrt(v * v - 1);
    _ = (w) => {
      const E = Math.exp(-v * x * w),
        P = Math.min(S * w, 300);
      return (
        s - (E * ((m + v * x * A) * Math.sinh(P) + S * A * Math.cosh(P))) / S
      );
    };
  }
  return {
    calculatedDuration: (p && d) || null,
    next: (S) => {
      const w = _(S);
      if (p) o.done = S >= d;
      else {
        let E = m;
        S !== 0 && (v < 1 ? (E = uL(_, S, w)) : (E = 0));
        const P = Math.abs(E) <= t,
          L = Math.abs(s - w) <= e;
        o.done = P && L;
      }
      return (o.value = o.done ? s : w), o;
    },
  };
}
function PT({
  keyframes: n,
  velocity: e = 0,
  power: t = 0.8,
  timeConstant: i = 325,
  bounceDamping: r = 10,
  bounceStiffness: s = 500,
  modifyTarget: o,
  min: a,
  max: l,
  restDelta: c = 0.5,
  restSpeed: h,
}) {
  const d = n[0],
    p = { done: !1, value: d },
    m = (B) => (a !== void 0 && B < a) || (l !== void 0 && B > l),
    v = (B) =>
      a === void 0
        ? l
        : l === void 0 || Math.abs(a - B) < Math.abs(l - B)
        ? a
        : l;
  let A = t * e;
  const x = d + A,
    g = o === void 0 ? x : o(x);
  g !== x && (A = g - d);
  const _ = (B) => -A * Math.exp(-B / i),
    S = (B) => g + _(B),
    w = (B) => {
      const b = _(B),
        R = S(B);
      (p.done = Math.abs(b) <= c), (p.value = p.done ? g : R);
    };
  let E, P;
  const L = (B) => {
    m(p.value) &&
      ((E = B),
      (P = cL({
        keyframes: [p.value, v(p.value)],
        velocity: uL(S, B, p.value),
        damping: r,
        stiffness: s,
        restDelta: c,
        restSpeed: h,
      })));
  };
  return (
    L(0),
    {
      calculatedDuration: null,
      next: (B) => {
        let b = !1;
        return (
          !P && E === void 0 && ((b = !0), w(B), L(B)),
          E !== void 0 && B > E ? P.next(B - E) : (!b && w(B), p)
        );
      },
    }
  );
}
const J6 = (n) => {
    const e = ({ timestamp: t }) => n(t);
    return {
      start: () => an.update(e, !0),
      stop: () => Yo.update(e),
      now: () => (ri.isProcessing ? ri.timestamp : performance.now()),
    };
  },
  j6 = { decay: PT, inertia: PT, tween: rg, keyframes: rg, spring: cL },
  BT = 2e4;
function RT(n) {
  let e = 0;
  const t = 50;
  let i = n.next(e);
  for (; !i.done && e < BT; ) (e += t), (i = n.next(e));
  return e >= BT ? 1 / 0 : e;
}
function sg({
  autoplay: n = !0,
  delay: e = 0,
  driver: t = J6,
  keyframes: i,
  type: r = "keyframes",
  repeat: s = 0,
  repeatDelay: o = 0,
  repeatType: a = "loop",
  onPlay: l,
  onStop: c,
  onComplete: h,
  onUpdate: d,
  ...p
}) {
  let m = 1,
    v = !1,
    A,
    x;
  const g = () => {
    A && A(),
      (x = new Promise((q) => {
        A = q;
      }));
  };
  g();
  let _;
  const S = j6[r] || rg;
  let w;
  S !== rg &&
    typeof i[0] != "number" &&
    ((w = aL([0, 100], i, { clamp: !1 })), (i = [0, 100]));
  const E = S({ ...p, keyframes: i });
  let P;
  a === "mirror" &&
    (P = S({
      ...p,
      keyframes: [...i].reverse(),
      velocity: -(p.velocity || 0),
    }));
  let L = "idle",
    B = null,
    b = null,
    R = null;
  E.calculatedDuration === null && s && (E.calculatedDuration = RT(E));
  const { calculatedDuration: U } = E;
  let j = 1 / 0,
    V = 1 / 0;
  U !== null && ((j = U + o), (V = j * (s + 1) - o));
  let J = 0;
  const X = (q) => {
      if (b === null) return;
      m > 0 && (b = Math.min(b, q)), B !== null ? (J = B) : (J = (q - b) * m);
      const Q = J - e,
        ee = Q < 0;
      (J = Math.max(Q, 0)), L === "finished" && B === null && (J = V);
      let ne = J,
        Ce = E;
      if (s) {
        const Xe = J / j;
        let ve = Math.floor(Xe),
          Me = Xe % 1;
        !Me && Xe >= 1 && (Me = 1),
          Me === 1 && ve--,
          (ve = Math.min(ve, s + 1));
        const me = !!(ve % 2);
        me &&
          (a === "reverse"
            ? ((Me = 1 - Me), o && (Me -= o / j))
            : a === "mirror" && (Ce = P));
        let se = ll(0, 1, Me);
        J > V && (se = a === "reverse" && me ? 1 : 0), (ne = se * j);
      }
      const _e = ee ? { done: !1, value: i[0] } : Ce.next(ne);
      w && (_e.value = w(_e.value));
      let { done: $ } = _e;
      !ee && U !== null && ($ = J >= V);
      const je =
        B === null &&
        (L === "finished" || (L === "running" && $) || (m < 0 && J <= 0));
      return d && d(_e.value), je && I(), _e;
    },
    oe = () => {
      _ && _.stop(), (_ = void 0);
    },
    ae = () => {
      (L = "idle"), oe(), g(), (b = R = null);
    },
    I = () => {
      (L = "finished"), h && h(), oe(), g();
    },
    G = () => {
      if (v) return;
      _ || (_ = t(X));
      const q = _.now();
      l && l(),
        (L = "running"),
        B !== null ? (b = q - B) : b || (b = q),
        (R = b),
        (B = null),
        _.start();
    };
  n && G();
  const z = {
    then(q, Q) {
      return x.then(q, Q);
    },
    get time() {
      return Hs(J);
    },
    set time(q) {
      (q = Go(q)),
        (J = q),
        B !== null || !_ || m === 0 ? (B = q) : (b = _.now() - q / m);
    },
    get duration() {
      const q = E.calculatedDuration === null ? RT(E) : E.calculatedDuration;
      return Hs(q);
    },
    get speed() {
      return m;
    },
    set speed(q) {
      q === m || !_ || ((m = q), (z.time = Hs(J)));
    },
    get state() {
      return L;
    },
    play: G,
    pause: () => {
      (L = "paused"), (B = J);
    },
    stop: () => {
      (v = !0), L !== "idle" && ((L = "idle"), c && c(), ae());
    },
    cancel: () => {
      R !== null && X(R), ae();
    },
    complete: () => {
      L = "finished";
    },
    sample: (q) => ((b = 0), X(q)),
  };
  return z;
}
const X6 = new Set([
    "opacity",
    "clipPath",
    "filter",
    "transform",
    "backgroundColor",
  ]),
  Zp = 10,
  K6 = 2e4,
  Y6 = (n, e) => e.type === "spring" || n === "backgroundColor" || !H3(e.ease);
function Q6(n, e, { onUpdate: t, onComplete: i, ...r }) {
  if (
    !(
      J3.waapi() &&
      X6.has(e) &&
      !r.repeatDelay &&
      r.repeatType !== "mirror" &&
      r.damping !== 0 &&
      r.type !== "inertia"
    )
  )
    return !1;
  let o = !1,
    a,
    l;
  const c = () => {
    l = new Promise((A) => {
      a = A;
    });
  };
  c();
  let { keyframes: h, duration: d = 300, ease: p } = r;
  if (Y6(e, r)) {
    const A = sg({ ...r, repeat: 0, delay: 0 });
    let x = { done: !1, value: h[0] };
    const g = [];
    let _ = 0;
    for (; !x.done && _ < K6; ) (x = A.sample(_)), g.push(x.value), (_ += Zp);
    (h = g), (d = _ - Zp), (p = "linear");
  }
  const m = l6(n.owner.current, e, h, { ...r, duration: d, ease: p }),
    v = () => {
      an.update(() => m.cancel()), a(), c();
    };
  return (
    (m.onfinish = () => {
      n.set(u6(h, r)), i && i(), v();
    }),
    {
      then(A, x) {
        return l.then(A, x);
      },
      get time() {
        return Hs(m.currentTime || 0);
      },
      set time(A) {
        m.currentTime = Go(A);
      },
      get speed() {
        return m.playbackRate;
      },
      set speed(A) {
        m.playbackRate = A;
      },
      get duration() {
        return Hs(d);
      },
      play: () => {
        o || m.play();
      },
      pause: () => m.pause(),
      stop: () => {
        if (((o = !0), m.playState === "idle")) return;
        const { currentTime: A } = m;
        if (A) {
          const x = sg({ ...r, autoplay: !1 });
          n.setWithVelocity(x.sample(A - Zp).value, x.sample(A).value, Zp);
        }
        v();
      },
      complete: () => m.finish(),
      cancel: v,
    }
  );
}
function Z6({ keyframes: n, delay: e, onUpdate: t, onComplete: i }) {
  const r = () => (
    t && t(n[n.length - 1]),
    i && i(),
    {
      time: 0,
      speed: 1,
      duration: 0,
      play: kn,
      pause: kn,
      stop: kn,
      then: (s) => (s(), Promise.resolve()),
      cancel: kn,
      complete: kn,
    }
  );
  return e
    ? sg({ keyframes: [0, 1], duration: 0, delay: e, onComplete: r })
    : r();
}
const q6 = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
  $6 = (n) => ({
    type: "spring",
    stiffness: 550,
    damping: n === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10,
  }),
  eW = { type: "keyframes", duration: 0.8 },
  tW = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
  nW = (n, { keyframes: e }) =>
    e.length > 2
      ? eW
      : gl.has(n)
      ? n.startsWith("scale")
        ? $6(e[1])
        : q6
      : tW,
  N_ = (n, e) =>
    n === "zIndex"
      ? !1
      : !!(
          typeof e == "number" ||
          Array.isArray(e) ||
          (typeof e == "string" && Qo.test(e) && !e.startsWith("url("))
        ),
  iW = new Set(["brightness", "contrast", "saturate", "opacity"]);
function rW(n) {
  const [e, t] = n.slice(0, -1).split("(");
  if (e === "drop-shadow") return n;
  const [i] = t.match(ch) || [];
  if (!i) return n;
  const r = t.replace(i, "");
  let s = iW.has(e) ? 1 : 0;
  return i !== t && (s *= 100), e + "(" + s + r + ")";
}
const sW = /([a-z-]*)\(.*?\)/g,
  O_ = {
    ...Qo,
    getAnimatableNone: (n) => {
      const e = n.match(sW);
      return e ? e.map(rW).join(" ") : n;
    },
  },
  oW = {
    ...C3,
    color: hi,
    backgroundColor: hi,
    outlineColor: hi,
    fill: hi,
    stroke: hi,
    borderColor: hi,
    borderTopColor: hi,
    borderRightColor: hi,
    borderBottomColor: hi,
    borderLeftColor: hi,
    filter: O_,
    WebkitFilter: O_,
  },
  rM = (n) => oW[n];
function sM(n, e) {
  let t = rM(n);
  return (
    t !== O_ && (t = Qo), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
  );
}
function aW({
  when: n,
  delay: e,
  delayChildren: t,
  staggerChildren: i,
  staggerDirection: r,
  repeat: s,
  repeatType: o,
  repeatDelay: a,
  from: l,
  elapsed: c,
  ...h
}) {
  return !!Object.keys(h).length;
}
function LT(n) {
  return (
    n === 0 ||
    (typeof n == "string" && parseFloat(n) === 0 && n.indexOf(" ") === -1)
  );
}
function IT(n) {
  return typeof n == "number" ? 0 : sM("", n);
}
function fL(n, e) {
  return n[e] || n.default || n;
}
function lW(n, e, t, i) {
  const r = N_(e, t);
  let s = i.from !== void 0 ? i.from : n.get();
  if (
    (s === "none" && r && typeof t == "string"
      ? (s = sM(e, t))
      : LT(s) && typeof t == "string"
      ? (s = IT(t))
      : !Array.isArray(t) && LT(t) && typeof s == "string" && (t = IT(s)),
    Array.isArray(t))
  ) {
    for (let o = 0; o < t.length; o++)
      t[o] === null && (t[o] = o === 0 ? s : t[o - 1]);
    return t;
  } else return [s, t];
}
const oM =
  (n, e, t, i = {}) =>
  (r) => {
    const s = fL(i, n) || {},
      o = s.delay || i.delay || 0;
    let { elapsed: a = 0 } = i;
    a = a - Go(o);
    const l = lW(e, n, t, s),
      c = l[0],
      h = l[l.length - 1],
      d = N_(n, c),
      p = N_(n, h);
    let m = {
      keyframes: l,
      velocity: e.getVelocity(),
      ease: "easeOut",
      ...s,
      delay: -a,
      onUpdate: (v) => {
        e.set(v), s.onUpdate && s.onUpdate(v);
      },
      onComplete: () => {
        r(), s.onComplete && s.onComplete();
      },
    };
    if (
      (aW(s) || (m = { ...m, ...nW(n, m) }),
      m.duration && (m.duration = Go(m.duration)),
      m.repeatDelay && (m.repeatDelay = Go(m.repeatDelay)),
      !d || !p || a6.current || s.type === !1)
    )
      return Z6(m);
    if (
      e.owner &&
      e.owner.current instanceof HTMLElement &&
      !e.owner.getProps().onUpdate
    ) {
      const v = Q6(e, n, m);
      if (v) return v;
    }
    return sg(m);
  };
function og(n) {
  return !!(Li(n) && n.add);
}
const uW = (n) => /^\-?\d*\.?\d+$/.test(n),
  cW = (n) => /^0[^.\s]+$/.test(n);
function aM(n, e) {
  n.indexOf(e) === -1 && n.push(e);
}
function lM(n, e) {
  const t = n.indexOf(e);
  t > -1 && n.splice(t, 1);
}
class uM {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return aM(this.subscriptions, e), () => lM(this.subscriptions, e);
  }
  notify(e, t, i) {
    const r = this.subscriptions.length;
    if (r)
      if (r === 1) this.subscriptions[0](e, t, i);
      else
        for (let s = 0; s < r; s++) {
          const o = this.subscriptions[s];
          o && o(e, t, i);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const fW = (n) => !isNaN(parseFloat(n));
class hW {
  constructor(e, t = {}) {
    (this.version = "10.10.0"),
      (this.timeDelta = 0),
      (this.lastUpdated = 0),
      (this.canTrackVelocity = !1),
      (this.events = {}),
      (this.updateAndNotify = (i, r = !0) => {
        (this.prev = this.current), (this.current = i);
        const { delta: s, timestamp: o } = ri;
        this.lastUpdated !== o &&
          ((this.timeDelta = s),
          (this.lastUpdated = o),
          an.postRender(this.scheduleVelocityCheck)),
          this.prev !== this.current &&
            this.events.change &&
            this.events.change.notify(this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()),
          r &&
            this.events.renderRequest &&
            this.events.renderRequest.notify(this.current);
      }),
      (this.scheduleVelocityCheck = () => an.postRender(this.velocityCheck)),
      (this.velocityCheck = ({ timestamp: i }) => {
        i !== this.lastUpdated &&
          ((this.prev = this.current),
          this.events.velocityChange &&
            this.events.velocityChange.notify(this.getVelocity()));
      }),
      (this.hasAnimated = !1),
      (this.prev = this.current = e),
      (this.canTrackVelocity = fW(this.current)),
      (this.owner = t.owner);
  }
  onChange(e) {
    return this.on("change", e);
  }
  on(e, t) {
    this.events[e] || (this.events[e] = new uM());
    const i = this.events[e].add(t);
    return e === "change"
      ? () => {
          i(),
            an.read(() => {
              this.events.change.getSize() || this.stop();
            });
        }
      : i;
  }
  clearListeners() {
    for (const e in this.events) this.events[e].clear();
  }
  attach(e, t) {
    (this.passiveEffect = e), (this.stopPassiveEffect = t);
  }
  set(e, t = !0) {
    !t || !this.passiveEffect
      ? this.updateAndNotify(e, t)
      : this.passiveEffect(e, this.updateAndNotify);
  }
  setWithVelocity(e, t, i) {
    this.set(t), (this.prev = e), (this.timeDelta = i);
  }
  jump(e) {
    this.updateAndNotify(e),
      (this.prev = e),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
  get() {
    return this.current;
  }
  getPrevious() {
    return this.prev;
  }
  getVelocity() {
    return this.canTrackVelocity
      ? lL(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      : 0;
  }
  start(e) {
    return (
      this.stop(),
      new Promise((t) => {
        (this.hasAnimated = !0),
          (this.animation = e(t)),
          this.events.animationStart && this.events.animationStart.notify();
      }).then(() => {
        this.events.animationComplete && this.events.animationComplete.notify(),
          this.clearAnimation();
      })
    );
  }
  stop() {
    this.animation &&
      (this.animation.stop(),
      this.events.animationCancel && this.events.animationCancel.notify()),
      this.clearAnimation();
  }
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  destroy() {
    this.clearListeners(),
      this.stop(),
      this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function Qu(n, e) {
  return new hW(n, e);
}
const hL = (n) => (e) => e.test(n),
  dW = { test: (n) => n === "auto", parse: (n) => n },
  dL = [yl, it, us, xo, x8, v8, dW],
  $c = (n) => dL.find(hL(n)),
  pW = [...dL, hi, Qo],
  mW = (n) => pW.find(hL(n));
function gW(n, e, t) {
  n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, Qu(t));
}
function yW(n, e) {
  const t = t0(n, e);
  let {
    transitionEnd: i = {},
    transition: r = {},
    ...s
  } = t ? n.makeTargetAnimatable(t, !1) : {};
  s = { ...s, ...i };
  for (const o in s) {
    const a = I8(s[o]);
    gW(n, o, a);
  }
}
function vW(n, e, t) {
  var i, r;
  const s = Object.keys(e).filter((a) => !n.hasValue(a)),
    o = s.length;
  if (o)
    for (let a = 0; a < o; a++) {
      const l = s[a],
        c = e[l];
      let h = null;
      Array.isArray(c) && (h = c[0]),
        h === null &&
          (h =
            (r = (i = t[l]) !== null && i !== void 0 ? i : n.readValue(l)) !==
              null && r !== void 0
              ? r
              : e[l]),
        h != null &&
          (typeof h == "string" && (uW(h) || cW(h))
            ? (h = parseFloat(h))
            : !mW(h) && Qo.test(c) && (h = sM(l, c)),
          n.addValue(l, Qu(h, { owner: n })),
          t[l] === void 0 && (t[l] = h),
          h !== null && n.setBaseTarget(l, h));
    }
}
function xW(n, e) {
  return e ? (e[n] || e.default || e).from : void 0;
}
function _W(n, e, t) {
  const i = {};
  for (const r in n) {
    const s = xW(r, e);
    if (s !== void 0) i[r] = s;
    else {
      const o = t.getValue(r);
      o && (i[r] = o.get());
    }
  }
  return i;
}
function AW({ protectedKeys: n, needsAnimating: e }, t) {
  const i = n.hasOwnProperty(t) && e[t] !== !0;
  return (e[t] = !1), i;
}
function pL(n, e, { delay: t = 0, transitionOverride: i, type: r } = {}) {
  let {
    transition: s = n.getDefaultTransition(),
    transitionEnd: o,
    ...a
  } = n.makeTargetAnimatable(e);
  const l = n.getValue("willChange");
  i && (s = i);
  const c = [],
    h = r && n.animationState && n.animationState.getState()[r];
  for (const d in a) {
    const p = n.getValue(d),
      m = a[d];
    if (!p || m === void 0 || (h && AW(h, d))) continue;
    const v = { delay: t, elapsed: 0, ...s };
    if (window.HandoffAppearAnimations && !p.hasAnimated) {
      const x = n.getProps()[s6];
      x && (v.elapsed = window.HandoffAppearAnimations(x, d, p, an));
    }
    p.start(oM(d, p, m, n.shouldReduceMotion && gl.has(d) ? { type: !1 } : v));
    const A = p.animation;
    og(l) && (l.add(d), A.then(() => l.remove(d))), c.push(A);
  }
  return (
    o &&
      Promise.all(c).then(() => {
        o && yW(n, o);
      }),
    c
  );
}
function k_(n, e, t = {}) {
  const i = t0(n, e, t.custom);
  let { transition: r = n.getDefaultTransition() || {} } = i || {};
  t.transitionOverride && (r = t.transitionOverride);
  const s = i ? () => Promise.all(pL(n, i, t)) : () => Promise.resolve(),
    o =
      n.variantChildren && n.variantChildren.size
        ? (l = 0) => {
            const {
              delayChildren: c = 0,
              staggerChildren: h,
              staggerDirection: d,
            } = r;
            return MW(n, e, c + l, h, d, t);
          }
        : () => Promise.resolve(),
    { when: a } = r;
  if (a) {
    const [l, c] = a === "beforeChildren" ? [s, o] : [o, s];
    return l().then(() => c());
  } else return Promise.all([s(), o(t.delay)]);
}
function MW(n, e, t = 0, i = 0, r = 1, s) {
  const o = [],
    a = (n.variantChildren.size - 1) * i,
    l = r === 1 ? (c = 0) => c * i : (c = 0) => a - c * i;
  return (
    Array.from(n.variantChildren)
      .sort(SW)
      .forEach((c, h) => {
        c.notify("AnimationStart", e),
          o.push(
            k_(c, e, { ...s, delay: t + l(h) }).then(() =>
              c.notify("AnimationComplete", e)
            )
          );
      }),
    Promise.all(o)
  );
}
function SW(n, e) {
  return n.sortNodePosition(e);
}
function wW(n, e, t = {}) {
  n.notify("AnimationStart", e);
  let i;
  if (Array.isArray(e)) {
    const r = e.map((s) => k_(n, s, t));
    i = Promise.all(r);
  } else if (typeof e == "string") i = k_(n, e, t);
  else {
    const r = typeof e == "function" ? t0(n, e, t.custom) : e;
    i = Promise.all(pL(n, r, t));
  }
  return i.then(() => n.notify("AnimationComplete", e));
}
const CW = [...WA].reverse(),
  EW = WA.length;
function TW(n) {
  return (e) =>
    Promise.all(e.map(({ animation: t, options: i }) => wW(n, t, i)));
}
function bW(n) {
  let e = TW(n);
  const t = BW();
  let i = !0;
  const r = (l, c) => {
    const h = t0(n, c);
    if (h) {
      const { transition: d, transitionEnd: p, ...m } = h;
      l = { ...l, ...m, ...p };
    }
    return l;
  };
  function s(l) {
    e = l(n);
  }
  function o(l, c) {
    const h = n.getProps(),
      d = n.getVariantContext(!0) || {},
      p = [],
      m = new Set();
    let v = {},
      A = 1 / 0;
    for (let g = 0; g < EW; g++) {
      const _ = CW[g],
        S = t[_],
        w = h[_] !== void 0 ? h[_] : d[_],
        E = lh(w),
        P = _ === c ? S.isActive : null;
      P === !1 && (A = g);
      let L = w === d[_] && w !== h[_] && E;
      if (
        (L && i && n.manuallyAnimateOnMount && (L = !1),
        (S.protectedKeys = { ...v }),
        (!S.isActive && P === null) ||
          (!w && !S.prevProp) ||
          Qg(w) ||
          typeof w == "boolean")
      )
        continue;
      const B = PW(S.prevProp, w);
      let b = B || (_ === c && S.isActive && !L && E) || (g > A && E);
      const R = Array.isArray(w) ? w : [w];
      let U = R.reduce(r, {});
      P === !1 && (U = {});
      const { prevResolvedValues: j = {} } = S,
        V = { ...j, ...U },
        J = (X) => {
          (b = !0), m.delete(X), (S.needsAnimating[X] = !0);
        };
      for (const X in V) {
        const oe = U[X],
          ae = j[X];
        v.hasOwnProperty(X) ||
          (oe !== ae
            ? ng(oe) && ng(ae)
              ? !z3(oe, ae) || B
                ? J(X)
                : (S.protectedKeys[X] = !0)
              : oe !== void 0
              ? J(X)
              : m.add(X)
            : oe !== void 0 && m.has(X)
            ? J(X)
            : (S.protectedKeys[X] = !0));
      }
      (S.prevProp = w),
        (S.prevResolvedValues = U),
        S.isActive && (v = { ...v, ...U }),
        i && n.blockInitialAnimation && (b = !1),
        b &&
          !L &&
          p.push(
            ...R.map((X) => ({ animation: X, options: { type: _, ...l } }))
          );
    }
    if (m.size) {
      const g = {};
      m.forEach((_) => {
        const S = n.getBaseTarget(_);
        S !== void 0 && (g[_] = S);
      }),
        p.push({ animation: g });
    }
    let x = !!p.length;
    return (
      i && h.initial === !1 && !n.manuallyAnimateOnMount && (x = !1),
      (i = !1),
      x ? e(p) : Promise.resolve()
    );
  }
  function a(l, c, h) {
    var d;
    if (t[l].isActive === c) return Promise.resolve();
    (d = n.variantChildren) === null ||
      d === void 0 ||
      d.forEach((m) => {
        var v;
        return (v = m.animationState) === null || v === void 0
          ? void 0
          : v.setActive(l, c);
      }),
      (t[l].isActive = c);
    const p = o(h, l);
    for (const m in t) t[m].protectedKeys = {};
    return p;
  }
  return {
    animateChanges: o,
    setActive: a,
    setAnimateFunction: s,
    getState: () => t,
  };
}
function PW(n, e) {
  return typeof e == "string" ? e !== n : Array.isArray(e) ? !z3(e, n) : !1;
}
function wa(n = !1) {
  return {
    isActive: n,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {},
  };
}
function BW() {
  return {
    animate: wa(!0),
    whileInView: wa(),
    whileHover: wa(),
    whileTap: wa(),
    whileDrag: wa(),
    whileFocus: wa(),
    exit: wa(),
  };
}
class RW extends ra {
  constructor(e) {
    super(e), e.animationState || (e.animationState = bW(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    this.unmount(), Qg(e) && (this.unmount = e.subscribe(this.node));
  }
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(),
      { animate: t } = this.node.prevProps || {};
    e !== t && this.updateAnimationControlsSubscription();
  }
  unmount() {}
}
let LW = 0;
class IW extends ra {
  constructor() {
    super(...arguments), (this.id = LW++);
  }
  update() {
    if (!this.node.presenceContext) return;
    const {
        isPresent: e,
        onExitComplete: t,
        custom: i,
      } = this.node.presenceContext,
      { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === r) return;
    const s = this.node.animationState.setActive("exit", !e, {
      custom: i ?? this.node.getProps().custom,
    });
    t && !e && s.then(() => t(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {}
}
const DW = { animation: { Feature: RW }, exit: { Feature: IW } },
  DT = (n, e) => Math.abs(n - e);
function FW(n, e) {
  const t = DT(n.x, e.x),
    i = DT(n.y, e.y);
  return Math.sqrt(t ** 2 + i ** 2);
}
class mL {
  constructor(e, t, { transformPagePoint: i } = {}) {
    if (
      ((this.startEvent = null),
      (this.lastMoveEvent = null),
      (this.lastMoveEventInfo = null),
      (this.handlers = {}),
      (this.updatePoint = () => {
        if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
        const c = Nv(this.lastMoveEventInfo, this.history),
          h = this.startEvent !== null,
          d = FW(c.offset, { x: 0, y: 0 }) >= 3;
        if (!h && !d) return;
        const { point: p } = c,
          { timestamp: m } = ri;
        this.history.push({ ...p, timestamp: m });
        const { onStart: v, onMove: A } = this.handlers;
        h ||
          (v && v(this.lastMoveEvent, c),
          (this.startEvent = this.lastMoveEvent)),
          A && A(this.lastMoveEvent, c);
      }),
      (this.handlePointerMove = (c, h) => {
        (this.lastMoveEvent = c),
          (this.lastMoveEventInfo = Fv(h, this.transformPagePoint)),
          an.update(this.updatePoint, !0);
      }),
      (this.handlePointerUp = (c, h) => {
        if ((this.end(), !(this.lastMoveEvent && this.lastMoveEventInfo)))
          return;
        const { onEnd: d, onSessionEnd: p } = this.handlers,
          m = Nv(
            c.type === "pointercancel"
              ? this.lastMoveEventInfo
              : Fv(h, this.transformPagePoint),
            this.history
          );
        this.startEvent && d && d(c, m), p && p(c, m);
      }),
      !D3(e))
    )
      return;
    (this.handlers = t), (this.transformPagePoint = i);
    const r = $g(e),
      s = Fv(r, this.transformPagePoint),
      { point: o } = s,
      { timestamp: a } = ri;
    this.history = [{ ...o, timestamp: a }];
    const { onSessionStart: l } = t;
    l && l(e, Nv(s, this.history)),
      (this.removeListeners = zo(
        Gs(window, "pointermove", this.handlePointerMove),
        Gs(window, "pointerup", this.handlePointerUp),
        Gs(window, "pointercancel", this.handlePointerUp)
      ));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), Yo.update(this.updatePoint);
  }
}
function Fv(n, e) {
  return e ? { point: e(n.point) } : n;
}
function FT(n, e) {
  return { x: n.x - e.x, y: n.y - e.y };
}
function Nv({ point: n }, e) {
  return {
    point: n,
    delta: FT(n, gL(e)),
    offset: FT(n, NW(e)),
    velocity: OW(e, 0.1),
  };
}
function NW(n) {
  return n[0];
}
function gL(n) {
  return n[n.length - 1];
}
function OW(n, e) {
  if (n.length < 2) return { x: 0, y: 0 };
  let t = n.length - 1,
    i = null;
  const r = gL(n);
  for (; t >= 0 && ((i = n[t]), !(r.timestamp - i.timestamp > Go(e))); ) t--;
  if (!i) return { x: 0, y: 0 };
  const s = Hs(r.timestamp - i.timestamp);
  if (s === 0) return { x: 0, y: 0 };
  const o = { x: (r.x - i.x) / s, y: (r.y - i.y) / s };
  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;
}
function Yi(n) {
  return n.max - n.min;
}
function U_(n, e = 0, t = 0.01) {
  return Math.abs(n - e) <= t;
}
function NT(n, e, t, i = 0.5) {
  (n.origin = i),
    (n.originPoint = on(e.min, e.max, n.origin)),
    (n.scale = Yi(t) / Yi(e)),
    (U_(n.scale, 1, 1e-4) || isNaN(n.scale)) && (n.scale = 1),
    (n.translate = on(t.min, t.max, n.origin) - n.originPoint),
    (U_(n.translate) || isNaN(n.translate)) && (n.translate = 0);
}
function Tf(n, e, t, i) {
  NT(n.x, e.x, t.x, i ? i.originX : void 0),
    NT(n.y, e.y, t.y, i ? i.originY : void 0);
}
function OT(n, e, t) {
  (n.min = t.min + e.min), (n.max = n.min + Yi(e));
}
function kW(n, e, t) {
  OT(n.x, e.x, t.x), OT(n.y, e.y, t.y);
}
function kT(n, e, t) {
  (n.min = e.min - t.min), (n.max = n.min + Yi(e));
}
function bf(n, e, t) {
  kT(n.x, e.x, t.x), kT(n.y, e.y, t.y);
}
function UW(n, { min: e, max: t }, i) {
  return (
    e !== void 0 && n < e
      ? (n = i ? on(e, n, i.min) : Math.max(n, e))
      : t !== void 0 && n > t && (n = i ? on(t, n, i.max) : Math.min(n, t)),
    n
  );
}
function UT(n, e, t) {
  return {
    min: e !== void 0 ? n.min + e : void 0,
    max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0,
  };
}
function zW(n, { top: e, left: t, bottom: i, right: r }) {
  return { x: UT(n.x, t, r), y: UT(n.y, e, i) };
}
function zT(n, e) {
  let t = e.min - n.min,
    i = e.max - n.max;
  return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), { min: t, max: i };
}
function GW(n, e) {
  return { x: zT(n.x, e.x), y: zT(n.y, e.y) };
}
function HW(n, e) {
  let t = 0.5;
  const i = Yi(n),
    r = Yi(e);
  return (
    r > i
      ? (t = hh(e.min, e.max - i, n.min))
      : i > r && (t = hh(n.min, n.max - r, e.min)),
    ll(0, 1, t)
  );
}
function VW(n, e) {
  const t = {};
  return (
    e.min !== void 0 && (t.min = e.min - n.min),
    e.max !== void 0 && (t.max = e.max - n.min),
    t
  );
}
const z_ = 0.35;
function WW(n = z_) {
  return (
    n === !1 ? (n = 0) : n === !0 && (n = z_),
    { x: GT(n, "left", "right"), y: GT(n, "top", "bottom") }
  );
}
function GT(n, e, t) {
  return { min: HT(n, e), max: HT(n, t) };
}
function HT(n, e) {
  return typeof n == "number" ? n : n[e] || 0;
}
const VT = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }),
  Pf = () => ({ x: VT(), y: VT() }),
  WT = () => ({ min: 0, max: 0 }),
  Sn = () => ({ x: WT(), y: WT() });
function is(n) {
  return [n("x"), n("y")];
}
function yL({ top: n, left: e, right: t, bottom: i }) {
  return { x: { min: e, max: t }, y: { min: n, max: i } };
}
function JW({ x: n, y: e }) {
  return { top: e.min, right: n.max, bottom: e.max, left: n.min };
}
function jW(n, e) {
  if (!e) return n;
  const t = e({ x: n.left, y: n.top }),
    i = e({ x: n.right, y: n.bottom });
  return { top: t.y, left: t.x, bottom: i.y, right: i.x };
}
function Ov(n) {
  return n === void 0 || n === 1;
}
function G_({ scale: n, scaleX: e, scaleY: t }) {
  return !Ov(n) || !Ov(e) || !Ov(t);
}
function Ra(n) {
  return G_(n) || vL(n) || n.z || n.rotate || n.rotateX || n.rotateY;
}
function vL(n) {
  return JT(n.x) || JT(n.y);
}
function JT(n) {
  return n && n !== "0%";
}
function ag(n, e, t) {
  const i = n - t,
    r = e * i;
  return t + r;
}
function jT(n, e, t, i, r) {
  return r !== void 0 && (n = ag(n, r, i)), ag(n, t, i) + e;
}
function H_(n, e = 0, t = 1, i, r) {
  (n.min = jT(n.min, e, t, i, r)), (n.max = jT(n.max, e, t, i, r));
}
function xL(n, { x: e, y: t }) {
  H_(n.x, e.translate, e.scale, e.originPoint),
    H_(n.y, t.translate, t.scale, t.originPoint);
}
function XW(n, e, t, i = !1) {
  const r = t.length;
  if (!r) return;
  e.x = e.y = 1;
  let s, o;
  for (let a = 0; a < r; a++) {
    (s = t[a]), (o = s.projectionDelta);
    const l = s.instance;
    (l && l.style && l.style.display === "contents") ||
      (i &&
        s.options.layoutScroll &&
        s.scroll &&
        s !== s.root &&
        Au(n, { x: -s.scroll.offset.x, y: -s.scroll.offset.y }),
      o && ((e.x *= o.x.scale), (e.y *= o.y.scale), xL(n, o)),
      i && Ra(s.latestValues) && Au(n, s.latestValues));
  }
  (e.x = XT(e.x)), (e.y = XT(e.y));
}
function XT(n) {
  return Number.isInteger(n) || n > 1.0000000000001 || n < 0.999999999999
    ? n
    : 1;
}
function So(n, e) {
  (n.min = n.min + e), (n.max = n.max + e);
}
function KT(n, e, [t, i, r]) {
  const s = e[r] !== void 0 ? e[r] : 0.5,
    o = on(n.min, n.max, s);
  H_(n, e[t], e[i], o, e.scale);
}
const KW = ["x", "scaleX", "originX"],
  YW = ["y", "scaleY", "originY"];
function Au(n, e) {
  KT(n.x, e, KW), KT(n.y, e, YW);
}
function _L(n, e) {
  return yL(jW(n.getBoundingClientRect(), e));
}
function QW(n, e, t) {
  const i = _L(n, t),
    { scroll: r } = e;
  return r && (So(i.x, r.offset.x), So(i.y, r.offset.y)), i;
}
const ZW = new WeakMap();
class qW {
  constructor(e) {
    (this.openGlobalLock = null),
      (this.isDragging = !1),
      (this.currentDirection = null),
      (this.originPoint = { x: 0, y: 0 }),
      (this.constraints = !1),
      (this.hasMutatedConstraints = !1),
      (this.elastic = Sn()),
      (this.visualElement = e);
  }
  start(e, { snapToCursor: t = !1 } = {}) {
    const { presenceContext: i } = this.visualElement;
    if (i && i.isPresent === !1) return;
    const r = (l) => {
        this.stopAnimation(), t && this.snapToCursor($g(l, "page").point);
      },
      s = (l, c) => {
        const { drag: h, dragPropagation: d, onDragStart: p } = this.getProps();
        if (
          h &&
          !d &&
          (this.openGlobalLock && this.openGlobalLock(),
          (this.openGlobalLock = N3(h)),
          !this.openGlobalLock)
        )
          return;
        (this.isDragging = !0),
          (this.currentDirection = null),
          this.resolveConstraints(),
          this.visualElement.projection &&
            ((this.visualElement.projection.isAnimationBlocked = !0),
            (this.visualElement.projection.target = void 0)),
          is((v) => {
            let A = this.getAxisMotionValue(v).get() || 0;
            if (us.test(A)) {
              const { projection: x } = this.visualElement;
              if (x && x.layout) {
                const g = x.layout.layoutBox[v];
                g && (A = Yi(g) * (parseFloat(A) / 100));
              }
            }
            this.originPoint[v] = A;
          }),
          p && an.update(() => p(l, c));
        const { animationState: m } = this.visualElement;
        m && m.setActive("whileDrag", !0);
      },
      o = (l, c) => {
        const {
          dragPropagation: h,
          dragDirectionLock: d,
          onDirectionLock: p,
          onDrag: m,
        } = this.getProps();
        if (!h && !this.openGlobalLock) return;
        const { offset: v } = c;
        if (d && this.currentDirection === null) {
          (this.currentDirection = $W(v)),
            this.currentDirection !== null && p && p(this.currentDirection);
          return;
        }
        this.updateAxis("x", c.point, v),
          this.updateAxis("y", c.point, v),
          this.visualElement.render(),
          m && m(l, c);
      },
      a = (l, c) => this.stop(l, c);
    this.panSession = new mL(
      e,
      { onSessionStart: r, onStart: s, onMove: o, onSessionEnd: a },
      { transformPagePoint: this.visualElement.getTransformPagePoint() }
    );
  }
  stop(e, t) {
    const i = this.isDragging;
    if ((this.cancel(), !i)) return;
    const { velocity: r } = t;
    this.startAnimation(r);
    const { onDragEnd: s } = this.getProps();
    s && an.update(() => s(e, t));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: t } = this.visualElement;
    e && (e.isAnimationBlocked = !1),
      this.panSession && this.panSession.end(),
      (this.panSession = void 0);
    const { dragPropagation: i } = this.getProps();
    !i &&
      this.openGlobalLock &&
      (this.openGlobalLock(), (this.openGlobalLock = null)),
      t && t.setActive("whileDrag", !1);
  }
  updateAxis(e, t, i) {
    const { drag: r } = this.getProps();
    if (!i || !qp(e, r, this.currentDirection)) return;
    const s = this.getAxisMotionValue(e);
    let o = this.originPoint[e] + i[e];
    this.constraints &&
      this.constraints[e] &&
      (o = UW(o, this.constraints[e], this.elastic[e])),
      s.set(o);
  }
  resolveConstraints() {
    const { dragConstraints: e, dragElastic: t } = this.getProps(),
      { layout: i } = this.visualElement.projection || {},
      r = this.constraints;
    e && xu(e)
      ? this.constraints || (this.constraints = this.resolveRefConstraints())
      : e && i
      ? (this.constraints = zW(i.layoutBox, e))
      : (this.constraints = !1),
      (this.elastic = WW(t)),
      r !== this.constraints &&
        i &&
        this.constraints &&
        !this.hasMutatedConstraints &&
        is((s) => {
          this.getAxisMotionValue(s) &&
            (this.constraints[s] = VW(i.layoutBox[s], this.constraints[s]));
        });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: t } = this.getProps();
    if (!e || !xu(e)) return !1;
    const i = e.current,
      { projection: r } = this.visualElement;
    if (!r || !r.layout) return !1;
    const s = QW(i, r.root, this.visualElement.getTransformPagePoint());
    let o = GW(r.layout.layoutBox, s);
    if (t) {
      const a = t(JW(o));
      (this.hasMutatedConstraints = !!a), a && (o = yL(a));
    }
    return o;
  }
  startAnimation(e) {
    const {
        drag: t,
        dragMomentum: i,
        dragElastic: r,
        dragTransition: s,
        dragSnapToOrigin: o,
        onDragTransitionEnd: a,
      } = this.getProps(),
      l = this.constraints || {},
      c = is((h) => {
        if (!qp(h, t, this.currentDirection)) return;
        let d = (l && l[h]) || {};
        o && (d = { min: 0, max: 0 });
        const p = r ? 200 : 1e6,
          m = r ? 40 : 1e7,
          v = {
            type: "inertia",
            velocity: i ? e[h] : 0,
            bounceStiffness: p,
            bounceDamping: m,
            timeConstant: 750,
            restDelta: 1,
            restSpeed: 10,
            ...s,
            ...d,
          };
        return this.startAxisValueAnimation(h, v);
      });
    return Promise.all(c).then(a);
  }
  startAxisValueAnimation(e, t) {
    const i = this.getAxisMotionValue(e);
    return i.start(oM(e, i, 0, t));
  }
  stopAnimation() {
    is((e) => this.getAxisMotionValue(e).stop());
  }
  getAxisMotionValue(e) {
    const t = "_drag" + e.toUpperCase(),
      i = this.visualElement.getProps(),
      r = i[t];
    return (
      r ||
      this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
    );
  }
  snapToCursor(e) {
    is((t) => {
      const { drag: i } = this.getProps();
      if (!qp(t, i, this.currentDirection)) return;
      const { projection: r } = this.visualElement,
        s = this.getAxisMotionValue(t);
      if (r && r.layout) {
        const { min: o, max: a } = r.layout.layoutBox[t];
        s.set(e[t] - on(o, a, 0.5));
      }
    });
  }
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const { drag: e, dragConstraints: t } = this.getProps(),
      { projection: i } = this.visualElement;
    if (!xu(t) || !i || !this.constraints) return;
    this.stopAnimation();
    const r = { x: 0, y: 0 };
    is((o) => {
      const a = this.getAxisMotionValue(o);
      if (a) {
        const l = a.get();
        r[o] = HW({ min: l, max: l }, this.constraints[o]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    (this.visualElement.current.style.transform = s ? s({}, "") : "none"),
      i.root && i.root.updateScroll(),
      i.updateLayout(),
      this.resolveConstraints(),
      is((o) => {
        if (!qp(o, e, null)) return;
        const a = this.getAxisMotionValue(o),
          { min: l, max: c } = this.constraints[o];
        a.set(on(l, c, r[o]));
      });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    ZW.set(this.visualElement, this);
    const e = this.visualElement.current,
      t = Gs(e, "pointerdown", (l) => {
        const { drag: c, dragListener: h = !0 } = this.getProps();
        c && h && this.start(l);
      }),
      i = () => {
        const { dragConstraints: l } = this.getProps();
        xu(l) && (this.constraints = this.resolveRefConstraints());
      },
      { projection: r } = this.visualElement,
      s = r.addEventListener("measure", i);
    r && !r.layout && (r.root && r.root.updateScroll(), r.updateLayout()), i();
    const o = ks(window, "resize", () => this.scalePositionWithinConstraints()),
      a = r.addEventListener(
        "didUpdate",
        ({ delta: l, hasLayoutChanged: c }) => {
          this.isDragging &&
            c &&
            (is((h) => {
              const d = this.getAxisMotionValue(h);
              d &&
                ((this.originPoint[h] += l[h].translate),
                d.set(d.get() + l[h].translate));
            }),
            this.visualElement.render());
        }
      );
    return () => {
      o(), t(), s(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(),
      {
        drag: t = !1,
        dragDirectionLock: i = !1,
        dragPropagation: r = !1,
        dragConstraints: s = !1,
        dragElastic: o = z_,
        dragMomentum: a = !0,
      } = e;
    return {
      ...e,
      drag: t,
      dragDirectionLock: i,
      dragPropagation: r,
      dragConstraints: s,
      dragElastic: o,
      dragMomentum: a,
    };
  }
}
function qp(n, e, t) {
  return (e === !0 || e === n) && (t === null || t === n);
}
function $W(n, e = 10) {
  let t = null;
  return Math.abs(n.y) > e ? (t = "y") : Math.abs(n.x) > e && (t = "x"), t;
}
class e7 extends ra {
  constructor(e) {
    super(e),
      (this.removeGroupControls = kn),
      (this.removeListeners = kn),
      (this.controls = new qW(e));
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)),
      (this.removeListeners = this.controls.addListeners() || kn);
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const YT = (n) => (e, t) => {
  n && an.update(() => n(e, t));
};
class t7 extends ra {
  constructor() {
    super(...arguments), (this.removePointerDownListener = kn);
  }
  onPointerDown(e) {
    this.session = new mL(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart: e,
      onPanStart: t,
      onPan: i,
      onPanEnd: r,
    } = this.node.getProps();
    return {
      onSessionStart: YT(e),
      onStart: YT(t),
      onMove: i,
      onEnd: (s, o) => {
        delete this.session, r && an.update(() => r(s, o));
      },
    };
  }
  mount() {
    this.removePointerDownListener = Gs(this.node.current, "pointerdown", (e) =>
      this.onPointerDown(e)
    );
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function n7() {
  const n = H.useContext(VA);
  if (n === null) return [!0, null];
  const { isPresent: e, onExitComplete: t, register: i } = n,
    r = H.useId();
  return H.useEffect(() => i(r), []), !e && t ? [!1, () => t && t(r)] : [!0];
}
function QT(n, e) {
  return e.max === e.min ? 0 : (n / (e.max - e.min)) * 100;
}
const ef = {
    correct: (n, e) => {
      if (!e.target) return n;
      if (typeof n == "string")
        if (it.test(n)) n = parseFloat(n);
        else return n;
      const t = QT(n, e.target.x),
        i = QT(n, e.target.y);
      return `${t}% ${i}%`;
    },
  },
  AL = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function i7(n) {
  const e = AL.exec(n);
  if (!e) return [,];
  const [, t, i] = e;
  return [t, i];
}
function V_(n, e, t = 1) {
  const [i, r] = i7(n);
  if (!i) return;
  const s = window.getComputedStyle(e).getPropertyValue(i);
  return s ? s.trim() : B_(r) ? V_(r, e, t + 1) : r;
}
function r7(n, { ...e }, t) {
  const i = n.current;
  if (!(i instanceof Element)) return { target: e, transitionEnd: t };
  t && (t = { ...t }),
    n.values.forEach((r) => {
      const s = r.get();
      if (!B_(s)) return;
      const o = V_(s, i);
      o && r.set(o);
    });
  for (const r in e) {
    const s = e[r];
    if (!B_(s)) continue;
    const o = V_(s, i);
    o && ((e[r] = o), t || (t = {}), t[r] === void 0 && (t[r] = s));
  }
  return { target: e, transitionEnd: t };
}
const ZT = "_$css",
  s7 = {
    correct: (n, { treeScale: e, projectionDelta: t }) => {
      const i = n,
        r = n.includes("var("),
        s = [];
      r && (n = n.replace(AL, (m) => (s.push(m), ZT)));
      const o = Qo.parse(n);
      if (o.length > 5) return i;
      const a = Qo.createTransformer(n),
        l = typeof o[0] != "number" ? 1 : 0,
        c = t.x.scale * e.x,
        h = t.y.scale * e.y;
      (o[0 + l] /= c), (o[1 + l] /= h);
      const d = on(c, h, 0.5);
      typeof o[2 + l] == "number" && (o[2 + l] /= d),
        typeof o[3 + l] == "number" && (o[3 + l] /= d);
      let p = a(o);
      if (r) {
        let m = 0;
        p = p.replace(ZT, () => {
          const v = s[m];
          return m++, v;
        });
      }
      return p;
    },
  };
class o7 extends mh.Component {
  componentDidMount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
        layoutId: r,
      } = this.props,
      { projection: s } = e;
    h8(a7),
      s &&
        (t.group && t.group.add(s),
        i && i.register && r && i.register(s),
        s.root.didUpdate(),
        s.addEventListener("animationComplete", () => {
          this.safeToRemove();
        }),
        s.setOptions({
          ...s.options,
          onExitComplete: () => this.safeToRemove(),
        })),
      (wf.hasEverUpdated = !0);
  }
  getSnapshotBeforeUpdate(e) {
    const {
        layoutDependency: t,
        visualElement: i,
        drag: r,
        isPresent: s,
      } = this.props,
      o = i.projection;
    return (
      o &&
        ((o.isPresent = s),
        r || e.layoutDependency !== t || t === void 0
          ? o.willUpdate()
          : this.safeToRemove(),
        e.isPresent !== s &&
          (s
            ? o.promote()
            : o.relegate() ||
              an.postRender(() => {
                const a = o.getStack();
                (!a || !a.members.length) && this.safeToRemove();
              }))),
      null
    );
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e &&
      (e.root.didUpdate(),
      !e.currentAnimation && e.isLead() && this.safeToRemove());
  }
  componentWillUnmount() {
    const {
        visualElement: e,
        layoutGroup: t,
        switchLayoutGroup: i,
      } = this.props,
      { projection: r } = e;
    r &&
      (r.scheduleCheckAfterUnmount(),
      t && t.group && t.group.remove(r),
      i && i.deregister && i.deregister(r));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function ML(n) {
  const [e, t] = n7(),
    i = H.useContext(_3);
  return mh.createElement(o7, {
    ...n,
    layoutGroup: i,
    switchLayoutGroup: H.useContext(A3),
    isPresent: e,
    safeToRemove: t,
  });
}
const a7 = {
    borderRadius: {
      ...ef,
      applyTo: [
        "borderTopLeftRadius",
        "borderTopRightRadius",
        "borderBottomLeftRadius",
        "borderBottomRightRadius",
      ],
    },
    borderTopLeftRadius: ef,
    borderTopRightRadius: ef,
    borderBottomLeftRadius: ef,
    borderBottomRightRadius: ef,
    boxShadow: s7,
  },
  SL = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
  l7 = SL.length,
  qT = (n) => (typeof n == "string" ? parseFloat(n) : n),
  $T = (n) => typeof n == "number" || it.test(n);
function u7(n, e, t, i, r, s) {
  r
    ? ((n.opacity = on(0, t.opacity !== void 0 ? t.opacity : 1, c7(i))),
      (n.opacityExit = on(e.opacity !== void 0 ? e.opacity : 1, 0, f7(i))))
    : s &&
      (n.opacity = on(
        e.opacity !== void 0 ? e.opacity : 1,
        t.opacity !== void 0 ? t.opacity : 1,
        i
      ));
  for (let o = 0; o < l7; o++) {
    const a = `border${SL[o]}Radius`;
    let l = eb(e, a),
      c = eb(t, a);
    if (l === void 0 && c === void 0) continue;
    l || (l = 0),
      c || (c = 0),
      l === 0 || c === 0 || $T(l) === $T(c)
        ? ((n[a] = Math.max(on(qT(l), qT(c), i), 0)),
          (us.test(c) || us.test(l)) && (n[a] += "%"))
        : (n[a] = c);
  }
  (e.rotate || t.rotate) && (n.rotate = on(e.rotate || 0, t.rotate || 0, i));
}
function eb(n, e) {
  return n[e] !== void 0 ? n[e] : n.borderRadius;
}
const c7 = wL(0, 0.5, tM),
  f7 = wL(0.5, 0.95, kn);
function wL(n, e, t) {
  return (i) => (i < n ? 0 : i > e ? 1 : t(hh(n, e, i)));
}
function tb(n, e) {
  (n.min = e.min), (n.max = e.max);
}
function ur(n, e) {
  tb(n.x, e.x), tb(n.y, e.y);
}
function nb(n, e, t, i, r) {
  return (
    (n -= e), (n = ag(n, 1 / t, i)), r !== void 0 && (n = ag(n, 1 / r, i)), n
  );
}
function h7(n, e = 0, t = 1, i = 0.5, r, s = n, o = n) {
  if (
    (us.test(e) &&
      ((e = parseFloat(e)), (e = on(o.min, o.max, e / 100) - o.min)),
    typeof e != "number")
  )
    return;
  let a = on(s.min, s.max, i);
  n === s && (a -= e),
    (n.min = nb(n.min, e, t, a, r)),
    (n.max = nb(n.max, e, t, a, r));
}
function ib(n, e, [t, i, r], s, o) {
  h7(n, e[t], e[i], e[r], e.scale, s, o);
}
const d7 = ["x", "scaleX", "originX"],
  p7 = ["y", "scaleY", "originY"];
function rb(n, e, t, i) {
  ib(n.x, e, d7, t ? t.x : void 0, i ? i.x : void 0),
    ib(n.y, e, p7, t ? t.y : void 0, i ? i.y : void 0);
}
function sb(n) {
  return n.translate === 0 && n.scale === 1;
}
function CL(n) {
  return sb(n.x) && sb(n.y);
}
function W_(n, e) {
  return (
    n.x.min === e.x.min &&
    n.x.max === e.x.max &&
    n.y.min === e.y.min &&
    n.y.max === e.y.max
  );
}
function ob(n) {
  return Yi(n.x) / Yi(n.y);
}
class m7 {
  constructor() {
    this.members = [];
  }
  add(e) {
    aM(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (
      (lM(this.members, e),
      e === this.prevLead && (this.prevLead = void 0),
      e === this.lead)
    ) {
      const t = this.members[this.members.length - 1];
      t && this.promote(t);
    }
  }
  relegate(e) {
    const t = this.members.findIndex((r) => e === r);
    if (t === 0) return !1;
    let i;
    for (let r = t; r >= 0; r--) {
      const s = this.members[r];
      if (s.isPresent !== !1) {
        i = s;
        break;
      }
    }
    return i ? (this.promote(i), !0) : !1;
  }
  promote(e, t) {
    const i = this.lead;
    if (e !== i && ((this.prevLead = i), (this.lead = e), e.show(), i)) {
      i.instance && i.scheduleRender(),
        e.scheduleRender(),
        (e.resumeFrom = i),
        t && (e.resumeFrom.preserveOpacity = !0),
        i.snapshot &&
          ((e.snapshot = i.snapshot),
          (e.snapshot.latestValues = i.animationValues || i.latestValues)),
        e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
      const { crossfade: r } = e.options;
      r === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: t, resumingFrom: i } = e;
      t.onExitComplete && t.onExitComplete(),
        i && i.options.onExitComplete && i.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function ab(n, e, t) {
  let i = "";
  const r = n.x.translate / e.x,
    s = n.y.translate / e.y;
  if (
    ((r || s) && (i = `translate3d(${r}px, ${s}px, 0) `),
    (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `),
    t)
  ) {
    const { rotate: l, rotateX: c, rotateY: h } = t;
    l && (i += `rotate(${l}deg) `),
      c && (i += `rotateX(${c}deg) `),
      h && (i += `rotateY(${h}deg) `);
  }
  const o = n.x.scale * e.x,
    a = n.y.scale * e.y;
  return (o !== 1 || a !== 1) && (i += `scale(${o}, ${a})`), i || "none";
}
const g7 = (n, e) => n.depth - e.depth;
class y7 {
  constructor() {
    (this.children = []), (this.isDirty = !1);
  }
  add(e) {
    aM(this.children, e), (this.isDirty = !0);
  }
  remove(e) {
    lM(this.children, e), (this.isDirty = !0);
  }
  forEach(e) {
    this.isDirty && this.children.sort(g7),
      (this.isDirty = !1),
      this.children.forEach(e);
  }
}
function v7(n, e) {
  const t = performance.now(),
    i = ({ timestamp: r }) => {
      const s = r - t;
      s >= e && (Yo.read(i), n(s - e));
    };
  return an.read(i, !0), () => Yo.read(i);
}
function x7(n) {
  window.MotionDebug && window.MotionDebug.record(n);
}
function _7(n) {
  return n instanceof SVGElement && n.tagName !== "svg";
}
function A7(n, e, t) {
  const i = Li(n) ? n : Qu(n);
  return i.start(oM("", i, e, t)), i.animation;
}
const lb = ["", "X", "Y", "Z"],
  ub = 1e3;
let M7 = 0;
const La = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0,
};
function EL({
  attachResizeListener: n,
  defaultParent: e,
  measureScroll: t,
  checkIsScrollRoot: i,
  resetTransform: r,
}) {
  return class {
    constructor(o, a = {}, l = e == null ? void 0 : e()) {
      (this.id = M7++),
        (this.animationId = 0),
        (this.children = new Set()),
        (this.options = {}),
        (this.isTreeAnimating = !1),
        (this.isAnimationBlocked = !1),
        (this.isLayoutDirty = !1),
        (this.isProjectionDirty = !1),
        (this.isSharedProjectionDirty = !1),
        (this.isTransformDirty = !1),
        (this.updateManuallyBlocked = !1),
        (this.updateBlockedByResize = !1),
        (this.isUpdating = !1),
        (this.isSVG = !1),
        (this.needsReset = !1),
        (this.shouldResetTransform = !1),
        (this.treeScale = { x: 1, y: 1 }),
        (this.eventHandlers = new Map()),
        (this.potentialNodes = new Map()),
        (this.checkUpdateFailed = () => {
          this.isUpdating && ((this.isUpdating = !1), this.clearAllSnapshots());
        }),
        (this.updateProjection = () => {
          (La.totalNodes =
            La.resolvedTargetDeltas =
            La.recalculatedProjection =
              0),
            this.nodes.forEach(C7),
            this.nodes.forEach(P7),
            this.nodes.forEach(B7),
            this.nodes.forEach(E7),
            x7(La);
        }),
        (this.hasProjected = !1),
        (this.isVisible = !0),
        (this.animationProgress = 0),
        (this.sharedNodes = new Map()),
        (this.elementId = o),
        (this.latestValues = a),
        (this.root = l ? l.root || l : this),
        (this.path = l ? [...l.path, l] : []),
        (this.parent = l),
        (this.depth = l ? l.depth + 1 : 0),
        o && this.root.registerPotentialNode(o, this);
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0;
      this.root === this && (this.nodes = new y7());
    }
    addEventListener(o, a) {
      return (
        this.eventHandlers.has(o) || this.eventHandlers.set(o, new uM()),
        this.eventHandlers.get(o).add(a)
      );
    }
    notifyListeners(o, ...a) {
      const l = this.eventHandlers.get(o);
      l && l.notify(...a);
    }
    hasListeners(o) {
      return this.eventHandlers.has(o);
    }
    registerPotentialNode(o, a) {
      this.potentialNodes.set(o, a);
    }
    mount(o, a = !1) {
      if (this.instance) return;
      (this.isSVG = _7(o)), (this.instance = o);
      const { layoutId: l, layout: c, visualElement: h } = this.options;
      if (
        (h && !h.current && h.mount(o),
        this.root.nodes.add(this),
        this.parent && this.parent.children.add(this),
        this.elementId && this.root.potentialNodes.delete(this.elementId),
        a && (c || l) && (this.isLayoutDirty = !0),
        n)
      ) {
        let d;
        const p = () => (this.root.updateBlockedByResize = !1);
        n(o, () => {
          (this.root.updateBlockedByResize = !0),
            d && d(),
            (d = v7(p, 250)),
            wf.hasAnimatedSinceResize &&
              ((wf.hasAnimatedSinceResize = !1), this.nodes.forEach(fb));
        });
      }
      l && this.root.registerSharedNode(l, this),
        this.options.animate !== !1 &&
          h &&
          (l || c) &&
          this.addEventListener(
            "didUpdate",
            ({
              delta: d,
              hasLayoutChanged: p,
              hasRelativeTargetChanged: m,
              layout: v,
            }) => {
              if (this.isTreeAnimationBlocked()) {
                (this.target = void 0), (this.relativeTarget = void 0);
                return;
              }
              const A =
                  this.options.transition || h.getDefaultTransition() || F7,
                { onLayoutAnimationStart: x, onLayoutAnimationComplete: g } =
                  h.getProps(),
                _ = !this.targetLayout || !W_(this.targetLayout, v) || m,
                S = !p && m;
              if (
                this.options.layoutRoot ||
                (this.resumeFrom && this.resumeFrom.instance) ||
                S ||
                (p && (_ || !this.currentAnimation))
              ) {
                this.resumeFrom &&
                  ((this.resumingFrom = this.resumeFrom),
                  (this.resumingFrom.resumingFrom = void 0)),
                  this.setAnimationOrigin(d, S);
                const w = { ...fL(A, "layout"), onPlay: x, onComplete: g };
                (h.shouldReduceMotion || this.options.layoutRoot) &&
                  ((w.delay = 0), (w.type = !1)),
                  this.startAnimation(w);
              } else
                !p && this.animationProgress === 0 && fb(this),
                  this.isLead() &&
                    this.options.onExitComplete &&
                    this.options.onExitComplete();
              this.targetLayout = v;
            }
          );
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const o = this.getStack();
      o && o.remove(this),
        this.parent && this.parent.children.delete(this),
        (this.instance = void 0),
        Yo.preRender(this.updateProjection);
    }
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return (
        this.isAnimationBlocked ||
        (this.parent && this.parent.isTreeAnimationBlocked()) ||
        !1
      );
    }
    startUpdate() {
      this.isUpdateBlocked() ||
        ((this.isUpdating = !0),
        this.nodes && this.nodes.forEach(R7),
        this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: o } = this.options;
      return o && o.getProps().transformTemplate;
    }
    willUpdate(o = !0) {
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (
        (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
      )
        return;
      this.isLayoutDirty = !0;
      for (let h = 0; h < this.path.length; h++) {
        const d = this.path[h];
        (d.shouldResetTransform = !0),
          d.updateScroll("snapshot"),
          d.options.layoutRoot && d.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l) return;
      const c = this.getTransformTemplate();
      (this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0),
        this.updateSnapshot(),
        o && this.notifyListeners("willUpdate");
    }
    didUpdate() {
      if (this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(cb);
        return;
      }
      this.isUpdating &&
        ((this.isUpdating = !1),
        this.potentialNodes.size &&
          (this.potentialNodes.forEach(N7), this.potentialNodes.clear()),
        this.nodes.forEach(b7),
        this.nodes.forEach(S7),
        this.nodes.forEach(w7),
        this.clearAllSnapshots(),
        Tv.update(),
        Tv.preRender(),
        Tv.render());
    }
    clearAllSnapshots() {
      this.nodes.forEach(T7), this.sharedNodes.forEach(L7);
    }
    scheduleUpdateProjection() {
      an.preRender(this.updateProjection, !1, !0);
    }
    scheduleCheckAfterUnmount() {
      an.postRender(() => {
        this.isLayoutDirty
          ? this.root.didUpdate()
          : this.root.checkUpdateFailed();
      });
    }
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (
        !this.instance ||
        (this.updateScroll(),
        !(this.options.alwaysMeasureLayout && this.isLead()) &&
          !this.isLayoutDirty)
      )
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
      const o = this.layout;
      (this.layout = this.measure(!1)),
        (this.layoutCorrected = Sn()),
        (this.isLayoutDirty = !1),
        (this.projectionDelta = void 0),
        this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a &&
        a.notify(
          "LayoutMeasure",
          this.layout.layoutBox,
          o ? o.layoutBox : void 0
        );
    }
    updateScroll(o = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      this.scroll &&
        this.scroll.animationId === this.root.animationId &&
        this.scroll.phase === o &&
        (a = !1),
        a &&
          (this.scroll = {
            animationId: this.root.animationId,
            phase: o,
            isRoot: i(this.instance),
            offset: t(this.instance),
          });
    }
    resetTransform() {
      if (!r) return;
      const o = this.isLayoutDirty || this.shouldResetTransform,
        a = this.projectionDelta && !CL(this.projectionDelta),
        l = this.getTransformTemplate(),
        c = l ? l(this.latestValues, "") : void 0,
        h = c !== this.prevTransformTemplateValue;
      o &&
        (a || Ra(this.latestValues) || h) &&
        (r(this.instance, c),
        (this.shouldResetTransform = !1),
        this.scheduleRender());
    }
    measure(o = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return (
        o && (l = this.removeTransform(l)),
        O7(l),
        {
          animationId: this.root.animationId,
          measuredBox: a,
          layoutBox: l,
          latestValues: {},
          source: this.id,
        }
      );
    }
    measurePageBox() {
      const { visualElement: o } = this.options;
      if (!o) return Sn();
      const a = o.measureViewportBox(),
        { scroll: l } = this.root;
      return l && (So(a.x, l.offset.x), So(a.y, l.offset.y)), a;
    }
    removeElementScroll(o) {
      const a = Sn();
      ur(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l],
          { scroll: h, options: d } = c;
        if (c !== this.root && h && d.layoutScroll) {
          if (h.isRoot) {
            ur(a, o);
            const { scroll: p } = this.root;
            p && (So(a.x, -p.offset.x), So(a.y, -p.offset.y));
          }
          So(a.x, h.offset.x), So(a.y, h.offset.y);
        }
      }
      return a;
    }
    applyTransform(o, a = !1) {
      const l = Sn();
      ur(l, o);
      for (let c = 0; c < this.path.length; c++) {
        const h = this.path[c];
        !a &&
          h.options.layoutScroll &&
          h.scroll &&
          h !== h.root &&
          Au(l, { x: -h.scroll.offset.x, y: -h.scroll.offset.y }),
          Ra(h.latestValues) && Au(l, h.latestValues);
      }
      return Ra(this.latestValues) && Au(l, this.latestValues), l;
    }
    removeTransform(o) {
      const a = Sn();
      ur(a, o);
      for (let l = 0; l < this.path.length; l++) {
        const c = this.path[l];
        if (!c.instance || !Ra(c.latestValues)) continue;
        G_(c.latestValues) && c.updateSnapshot();
        const h = Sn(),
          d = c.measurePageBox();
        ur(h, d),
          rb(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, h);
      }
      return Ra(this.latestValues) && rb(a, this.latestValues), a;
    }
    setTargetDelta(o) {
      (this.targetDelta = o),
        this.root.scheduleUpdateProjection(),
        (this.isProjectionDirty = !0);
    }
    setOptions(o) {
      this.options = {
        ...this.options,
        ...o,
        crossfade: o.crossfade !== void 0 ? o.crossfade : !0,
      };
    }
    clearMeasurements() {
      (this.scroll = void 0),
        (this.layout = void 0),
        (this.snapshot = void 0),
        (this.prevTransformTemplateValue = void 0),
        (this.targetDelta = void 0),
        (this.target = void 0),
        (this.isLayoutDirty = !1);
    }
    resolveTargetDelta(o = !1) {
      var a;
      const l = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty),
        this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty),
        this.isSharedProjectionDirty ||
          (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
      const c = !!this.resumingFrom || this !== l;
      if (
        !(
          o ||
          (c && this.isSharedProjectionDirty) ||
          this.isProjectionDirty ||
          (!((a = this.parent) === null || a === void 0) &&
            a.isProjectionDirty) ||
          this.attemptToResolveRelativeTarget
        )
      )
        return;
      const { layout: d, layoutId: p } = this.options;
      if (!(!this.layout || !(d || p))) {
        if (
          ((this.resolvedRelativeTargetAt = ri.timestamp),
          !this.targetDelta && !this.relativeTarget)
        ) {
          const m = this.getClosestProjectingParent();
          m && m.layout
            ? ((this.relativeParent = m),
              (this.relativeTarget = Sn()),
              (this.relativeTargetOrigin = Sn()),
              bf(
                this.relativeTargetOrigin,
                this.layout.layoutBox,
                m.layout.layoutBox
              ),
              ur(this.relativeTarget, this.relativeTargetOrigin))
            : (this.relativeParent = this.relativeTarget = void 0);
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (
            (this.target ||
              ((this.target = Sn()), (this.targetWithTransforms = Sn())),
            this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.relativeParent &&
            this.relativeParent.target
              ? (this.relativeParent.resolvedRelativeTargetAt !==
                  ri.timestamp && this.relativeParent.resolveTargetDelta(!0),
                kW(
                  this.target,
                  this.relativeTarget,
                  this.relativeParent.target
                ))
              : this.targetDelta
              ? (this.resumingFrom
                  ? (this.target = this.applyTransform(this.layout.layoutBox))
                  : ur(this.target, this.layout.layoutBox),
                xL(this.target, this.targetDelta))
              : ur(this.target, this.layout.layoutBox),
            this.attemptToResolveRelativeTarget)
          ) {
            this.attemptToResolveRelativeTarget = !1;
            const m = this.getClosestProjectingParent();
            m &&
            !!m.resumingFrom == !!this.resumingFrom &&
            !m.options.layoutScroll &&
            m.target
              ? ((this.relativeParent = m),
                (this.relativeTarget = Sn()),
                (this.relativeTargetOrigin = Sn()),
                bf(this.relativeTargetOrigin, this.target, m.target),
                ur(this.relativeTarget, this.relativeTargetOrigin))
              : (this.relativeParent = this.relativeTarget = void 0);
          }
          La.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (
        !(
          !this.parent ||
          G_(this.parent.latestValues) ||
          vL(this.parent.latestValues)
        )
      )
        return this.parent.isProjecting()
          ? this.parent
          : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!(
        (this.relativeTarget || this.targetDelta || this.options.layoutRoot) &&
        this.layout
      );
    }
    calcProjection() {
      var o;
      const a = this.getLead(),
        l = !!this.resumingFrom || this !== a;
      let c = !0;
      if (
        ((this.isProjectionDirty ||
          (!((o = this.parent) === null || o === void 0) &&
            o.isProjectionDirty)) &&
          (c = !1),
        l &&
          (this.isSharedProjectionDirty || this.isTransformDirty) &&
          (c = !1),
        this.resolvedRelativeTargetAt === ri.timestamp && (c = !1),
        c)
      )
        return;
      const { layout: h, layoutId: d } = this.options;
      if (
        ((this.isTreeAnimating = !!(
          (this.parent && this.parent.isTreeAnimating) ||
          this.currentAnimation ||
          this.pendingAnimation
        )),
        this.isTreeAnimating ||
          (this.targetDelta = this.relativeTarget = void 0),
        !this.layout || !(h || d))
      )
        return;
      ur(this.layoutCorrected, this.layout.layoutBox),
        XW(this.layoutCorrected, this.treeScale, this.path, l);
      const { target: p } = a;
      if (!p) return;
      this.projectionDelta ||
        ((this.projectionDelta = Pf()),
        (this.projectionDeltaWithTransform = Pf()));
      const m = this.treeScale.x,
        v = this.treeScale.y,
        A = this.projectionTransform;
      Tf(this.projectionDelta, this.layoutCorrected, p, this.latestValues),
        (this.projectionTransform = ab(this.projectionDelta, this.treeScale)),
        (this.projectionTransform !== A ||
          this.treeScale.x !== m ||
          this.treeScale.y !== v) &&
          ((this.hasProjected = !0),
          this.scheduleRender(),
          this.notifyListeners("projectionUpdate", p)),
        La.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(o = !0) {
      if ((this.options.scheduleRender && this.options.scheduleRender(), o)) {
        const a = this.getStack();
        a && a.scheduleRender();
      }
      this.resumingFrom &&
        !this.resumingFrom.instance &&
        (this.resumingFrom = void 0);
    }
    setAnimationOrigin(o, a = !1) {
      const l = this.snapshot,
        c = l ? l.latestValues : {},
        h = { ...this.latestValues },
        d = Pf();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) &&
        (this.relativeTarget = this.relativeTargetOrigin = void 0),
        (this.attemptToResolveRelativeTarget = !a);
      const p = Sn(),
        m = l ? l.source : void 0,
        v = this.layout ? this.layout.source : void 0,
        A = m !== v,
        x = this.getStack(),
        g = !x || x.members.length <= 1,
        _ = !!(A && !g && this.options.crossfade === !0 && !this.path.some(D7));
      this.animationProgress = 0;
      let S;
      (this.mixTargetDelta = (w) => {
        const E = w / 1e3;
        hb(d.x, o.x, E),
          hb(d.y, o.y, E),
          this.setTargetDelta(d),
          this.relativeTarget &&
            this.relativeTargetOrigin &&
            this.layout &&
            this.relativeParent &&
            this.relativeParent.layout &&
            (bf(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox),
            I7(this.relativeTarget, this.relativeTargetOrigin, p, E),
            S && W_(this.relativeTarget, S) && (this.isProjectionDirty = !1),
            S || (S = Sn()),
            ur(S, this.relativeTarget)),
          A &&
            ((this.animationValues = h), u7(h, c, this.latestValues, E, _, g)),
          this.root.scheduleUpdateProjection(),
          this.scheduleRender(),
          (this.animationProgress = E);
      }),
        this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(o) {
      this.notifyListeners("animationStart"),
        this.currentAnimation && this.currentAnimation.stop(),
        this.resumingFrom &&
          this.resumingFrom.currentAnimation &&
          this.resumingFrom.currentAnimation.stop(),
        this.pendingAnimation &&
          (Yo.update(this.pendingAnimation), (this.pendingAnimation = void 0)),
        (this.pendingAnimation = an.update(() => {
          (wf.hasAnimatedSinceResize = !0),
            (this.currentAnimation = A7(0, ub, {
              ...o,
              onUpdate: (a) => {
                this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);
              },
              onComplete: () => {
                o.onComplete && o.onComplete(), this.completeAnimation();
              },
            })),
            this.resumingFrom &&
              (this.resumingFrom.currentAnimation = this.currentAnimation),
            (this.pendingAnimation = void 0);
        }));
    }
    completeAnimation() {
      this.resumingFrom &&
        ((this.resumingFrom.currentAnimation = void 0),
        (this.resumingFrom.preserveOpacity = void 0));
      const o = this.getStack();
      o && o.exitAnimationComplete(),
        (this.resumingFrom =
          this.currentAnimation =
          this.animationValues =
            void 0),
        this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation &&
        (this.mixTargetDelta && this.mixTargetDelta(ub),
        this.currentAnimation.stop()),
        this.completeAnimation();
    }
    applyTransformsToTarget() {
      const o = this.getLead();
      let {
        targetWithTransforms: a,
        target: l,
        layout: c,
        latestValues: h,
      } = o;
      if (!(!a || !l || !c)) {
        if (
          this !== o &&
          this.layout &&
          c &&
          TL(this.options.animationType, this.layout.layoutBox, c.layoutBox)
        ) {
          l = this.target || Sn();
          const d = Yi(this.layout.layoutBox.x);
          (l.x.min = o.target.x.min), (l.x.max = l.x.min + d);
          const p = Yi(this.layout.layoutBox.y);
          (l.y.min = o.target.y.min), (l.y.max = l.y.min + p);
        }
        ur(a, l),
          Au(a, h),
          Tf(this.projectionDeltaWithTransform, this.layoutCorrected, a, h);
      }
    }
    registerSharedNode(o, a) {
      this.sharedNodes.has(o) || this.sharedNodes.set(o, new m7()),
        this.sharedNodes.get(o).add(a);
      const c = a.options.initialPromotionConfig;
      a.promote({
        transition: c ? c.transition : void 0,
        preserveFollowOpacity:
          c && c.shouldPreserveFollowOpacity
            ? c.shouldPreserveFollowOpacity(a)
            : void 0,
      });
    }
    isLead() {
      const o = this.getStack();
      return o ? o.lead === this : !0;
    }
    getLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) ||
            this
        : this;
    }
    getPrevLead() {
      var o;
      const { layoutId: a } = this.options;
      return a
        ? (o = this.getStack()) === null || o === void 0
          ? void 0
          : o.prevLead
        : void 0;
    }
    getStack() {
      const { layoutId: o } = this.options;
      if (o) return this.root.sharedNodes.get(o);
    }
    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {
      const c = this.getStack();
      c && c.promote(this, l),
        o && ((this.projectionDelta = void 0), (this.needsReset = !0)),
        a && this.setOptions({ transition: a });
    }
    relegate() {
      const o = this.getStack();
      return o ? o.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement: o } = this.options;
      if (!o) return;
      let a = !1;
      const { latestValues: l } = o;
      if (((l.rotate || l.rotateX || l.rotateY || l.rotateZ) && (a = !0), !a))
        return;
      const c = {};
      for (let h = 0; h < lb.length; h++) {
        const d = "rotate" + lb[h];
        l[d] && ((c[d] = l[d]), o.setStaticValue(d, 0));
      }
      o.render();
      for (const h in c) o.setStaticValue(h, c[h]);
      o.scheduleRender();
    }
    getProjectionStyles(o = {}) {
      var a, l;
      const c = {};
      if (!this.instance || this.isSVG) return c;
      if (this.isVisible) c.visibility = "";
      else return { visibility: "hidden" };
      const h = this.getTransformTemplate();
      if (this.needsReset)
        return (
          (this.needsReset = !1),
          (c.opacity = ""),
          (c.pointerEvents = Am(o.pointerEvents) || ""),
          (c.transform = h ? h(this.latestValues, "") : "none"),
          c
        );
      const d = this.getLead();
      if (!this.projectionDelta || !this.layout || !d.target) {
        const A = {};
        return (
          this.options.layoutId &&
            ((A.opacity =
              this.latestValues.opacity !== void 0
                ? this.latestValues.opacity
                : 1),
            (A.pointerEvents = Am(o.pointerEvents) || "")),
          this.hasProjected &&
            !Ra(this.latestValues) &&
            ((A.transform = h ? h({}, "") : "none"), (this.hasProjected = !1)),
          A
        );
      }
      const p = d.animationValues || d.latestValues;
      this.applyTransformsToTarget(),
        (c.transform = ab(
          this.projectionDeltaWithTransform,
          this.treeScale,
          p
        )),
        h && (c.transform = h(p, c.transform));
      const { x: m, y: v } = this.projectionDelta;
      (c.transformOrigin = `${m.origin * 100}% ${v.origin * 100}% 0`),
        d.animationValues
          ? (c.opacity =
              d === this
                ? (l =
                    (a = p.opacity) !== null && a !== void 0
                      ? a
                      : this.latestValues.opacity) !== null && l !== void 0
                  ? l
                  : 1
                : this.preserveOpacity
                ? this.latestValues.opacity
                : p.opacityExit)
          : (c.opacity =
              d === this
                ? p.opacity !== void 0
                  ? p.opacity
                  : ""
                : p.opacityExit !== void 0
                ? p.opacityExit
                : 0);
      for (const A in eg) {
        if (p[A] === void 0) continue;
        const { correct: x, applyTo: g } = eg[A],
          _ = c.transform === "none" ? p[A] : x(p[A], d);
        if (g) {
          const S = g.length;
          for (let w = 0; w < S; w++) c[g[w]] = _;
        } else c[A] = _;
      }
      return (
        this.options.layoutId &&
          (c.pointerEvents = d === this ? Am(o.pointerEvents) || "" : "none"),
        c
      );
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    resetTree() {
      this.root.nodes.forEach((o) => {
        var a;
        return (a = o.currentAnimation) === null || a === void 0
          ? void 0
          : a.stop();
      }),
        this.root.nodes.forEach(cb),
        this.root.sharedNodes.clear();
    }
  };
}
function S7(n) {
  n.updateLayout();
}
function w7(n) {
  var e;
  const t =
    ((e = n.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) ||
    n.snapshot;
  if (n.isLead() && n.layout && t && n.hasListeners("didUpdate")) {
    const { layoutBox: i, measuredBox: r } = n.layout,
      { animationType: s } = n.options,
      o = t.source !== n.layout.source;
    s === "size"
      ? is((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            m = Yi(p);
          (p.min = i[d].min), (p.max = p.min + m);
        })
      : TL(s, t.layoutBox, i) &&
        is((d) => {
          const p = o ? t.measuredBox[d] : t.layoutBox[d],
            m = Yi(i[d]);
          (p.max = p.min + m),
            n.relativeTarget &&
              !n.currentAnimation &&
              ((n.isProjectionDirty = !0),
              (n.relativeTarget[d].max = n.relativeTarget[d].min + m));
        });
    const a = Pf();
    Tf(a, i, t.layoutBox);
    const l = Pf();
    o ? Tf(l, n.applyTransform(r, !0), t.measuredBox) : Tf(l, i, t.layoutBox);
    const c = !CL(a);
    let h = !1;
    if (!n.resumeFrom) {
      const d = n.getClosestProjectingParent();
      if (d && !d.resumeFrom) {
        const { snapshot: p, layout: m } = d;
        if (p && m) {
          const v = Sn();
          bf(v, t.layoutBox, p.layoutBox);
          const A = Sn();
          bf(A, i, m.layoutBox),
            W_(v, A) || (h = !0),
            d.options.layoutRoot &&
              ((n.relativeTarget = A),
              (n.relativeTargetOrigin = v),
              (n.relativeParent = d));
        }
      }
    }
    n.notifyListeners("didUpdate", {
      layout: i,
      snapshot: t,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: c,
      hasRelativeTargetChanged: h,
    });
  } else if (n.isLead()) {
    const { onExitComplete: i } = n.options;
    i && i();
  }
  n.options.transition = void 0;
}
function C7(n) {
  La.totalNodes++,
    n.parent &&
      (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty),
      n.isSharedProjectionDirty ||
        (n.isSharedProjectionDirty = !!(
          n.isProjectionDirty ||
          n.parent.isProjectionDirty ||
          n.parent.isSharedProjectionDirty
        )),
      n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty));
}
function E7(n) {
  n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1;
}
function T7(n) {
  n.clearSnapshot();
}
function cb(n) {
  n.clearMeasurements();
}
function b7(n) {
  const { visualElement: e } = n.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"),
    n.resetTransform();
}
function fb(n) {
  n.finishAnimation(), (n.targetDelta = n.relativeTarget = n.target = void 0);
}
function P7(n) {
  n.resolveTargetDelta();
}
function B7(n) {
  n.calcProjection();
}
function R7(n) {
  n.resetRotation();
}
function L7(n) {
  n.removeLeadSnapshot();
}
function hb(n, e, t) {
  (n.translate = on(e.translate, 0, t)),
    (n.scale = on(e.scale, 1, t)),
    (n.origin = e.origin),
    (n.originPoint = e.originPoint);
}
function db(n, e, t, i) {
  (n.min = on(e.min, t.min, i)), (n.max = on(e.max, t.max, i));
}
function I7(n, e, t, i) {
  db(n.x, e.x, t.x, i), db(n.y, e.y, t.y, i);
}
function D7(n) {
  return n.animationValues && n.animationValues.opacityExit !== void 0;
}
const F7 = { duration: 0.45, ease: [0.4, 0, 0.1, 1] };
function N7(n, e) {
  let t = n.root;
  for (let s = n.path.length - 1; s >= 0; s--)
    if (n.path[s].instance) {
      t = n.path[s];
      break;
    }
  const r = (t && t !== n.root ? t.instance : document).querySelector(
    `[data-projection-id="${e}"]`
  );
  r && n.mount(r, !0);
}
function pb(n) {
  (n.min = Math.round(n.min)), (n.max = Math.round(n.max));
}
function O7(n) {
  pb(n.x), pb(n.y);
}
function TL(n, e, t) {
  return (
    n === "position" || (n === "preserve-aspect" && !U_(ob(e), ob(t), 0.2))
  );
}
const k7 = EL({
    attachResizeListener: (n, e) => ks(n, "resize", e),
    measureScroll: () => ({
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop,
    }),
    checkIsScrollRoot: () => !0,
  }),
  kv = { current: void 0 },
  bL = EL({
    measureScroll: (n) => ({ x: n.scrollLeft, y: n.scrollTop }),
    defaultParent: () => {
      if (!kv.current) {
        const n = new k7(0, {});
        n.mount(window), n.setOptions({ layoutScroll: !0 }), (kv.current = n);
      }
      return kv.current;
    },
    resetTransform: (n, e) => {
      n.style.transform = e !== void 0 ? e : "none";
    },
    checkIsScrollRoot: (n) => window.getComputedStyle(n).position === "fixed",
  }),
  U7 = {
    pan: { Feature: t7 },
    drag: { Feature: e7, ProjectionNode: bL, MeasureLayout: ML },
  },
  z7 = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y"]),
  PL = (n) => z7.has(n),
  G7 = (n) => Object.keys(n).some(PL),
  mb = (n) => n === yl || n === it,
  gb = (n, e) => parseFloat(n.split(", ")[e]),
  yb =
    (n, e) =>
    (t, { transform: i }) => {
      if (i === "none" || !i) return 0;
      const r = i.match(/^matrix3d\((.+)\)$/);
      if (r) return gb(r[1], e);
      {
        const s = i.match(/^matrix\((.+)\)$/);
        return s ? gb(s[1], n) : 0;
      }
    },
  H7 = new Set(["x", "y", "z"]),
  V7 = qg.filter((n) => !H7.has(n));
function W7(n) {
  const e = [];
  return (
    V7.forEach((t) => {
      const i = n.getValue(t);
      i !== void 0 &&
        (e.push([t, i.get()]), i.set(t.startsWith("scale") ? 1 : 0));
    }),
    e.length && n.render(),
    e
  );
}
const vb = {
    width: ({ x: n }, { paddingLeft: e = "0", paddingRight: t = "0" }) =>
      n.max - n.min - parseFloat(e) - parseFloat(t),
    height: ({ y: n }, { paddingTop: e = "0", paddingBottom: t = "0" }) =>
      n.max - n.min - parseFloat(e) - parseFloat(t),
    top: (n, { top: e }) => parseFloat(e),
    left: (n, { left: e }) => parseFloat(e),
    bottom: ({ y: n }, { top: e }) => parseFloat(e) + (n.max - n.min),
    right: ({ x: n }, { left: e }) => parseFloat(e) + (n.max - n.min),
    x: yb(4, 13),
    y: yb(5, 14),
  },
  J7 = (n, e, t) => {
    const i = e.measureViewportBox(),
      r = e.current,
      s = getComputedStyle(r),
      { display: o } = s,
      a = {};
    o === "none" && e.setStaticValue("display", n.display || "block"),
      t.forEach((c) => {
        a[c] = vb[c](i, s);
      }),
      e.render();
    const l = e.measureViewportBox();
    return (
      t.forEach((c) => {
        const h = e.getValue(c);
        h && h.jump(a[c]), (n[c] = vb[c](l, s));
      }),
      n
    );
  },
  j7 = (n, e, t = {}, i = {}) => {
    (e = { ...e }), (i = { ...i });
    const r = Object.keys(e).filter(PL);
    let s = [],
      o = !1;
    const a = [];
    if (
      (r.forEach((l) => {
        const c = n.getValue(l);
        if (!n.hasValue(l)) return;
        let h = t[l],
          d = $c(h);
        const p = e[l];
        let m;
        if (ng(p)) {
          const v = p.length,
            A = p[0] === null ? 1 : 0;
          (h = p[A]), (d = $c(h));
          for (let x = A; x < v; x++) m ? eM($c(p[x]) === m) : (m = $c(p[x]));
        } else m = $c(p);
        if (d !== m)
          if (mb(d) && mb(m)) {
            const v = c.get();
            typeof v == "string" && c.set(parseFloat(v)),
              typeof p == "string"
                ? (e[l] = parseFloat(p))
                : Array.isArray(p) && m === it && (e[l] = p.map(parseFloat));
          } else
            d != null &&
            d.transform &&
            m != null &&
            m.transform &&
            (h === 0 || p === 0)
              ? h === 0
                ? c.set(m.transform(h))
                : (e[l] = d.transform(p))
              : (o || ((s = W7(n)), (o = !0)),
                a.push(l),
                (i[l] = i[l] !== void 0 ? i[l] : e[l]),
                c.jump(p));
      }),
      a.length)
    ) {
      const l = a.indexOf("height") >= 0 ? window.pageYOffset : null,
        c = J7(e, n, a);
      return (
        s.length &&
          s.forEach(([h, d]) => {
            n.getValue(h).set(d);
          }),
        n.render(),
        Yg && l !== null && window.scrollTo({ top: l }),
        { target: c, transitionEnd: i }
      );
    } else return { target: e, transitionEnd: i };
  };
function X7(n, e, t, i) {
  return G7(e) ? j7(n, e, t, i) : { target: e, transitionEnd: i };
}
const K7 = (n, e, t, i) => {
    const r = r7(n, e, i);
    return (e = r.target), (i = r.transitionEnd), X7(n, e, t, i);
  },
  J_ = { current: null },
  BL = { current: !1 };
function Y7() {
  if (((BL.current = !0), !!Yg))
    if (window.matchMedia) {
      const n = window.matchMedia("(prefers-reduced-motion)"),
        e = () => (J_.current = n.matches);
      n.addListener(e), e();
    } else J_.current = !1;
}
function Q7(n, e, t) {
  const { willChange: i } = e;
  for (const r in e) {
    const s = e[r],
      o = t[r];
    if (Li(s)) n.addValue(r, s), og(i) && i.add(r);
    else if (Li(o)) n.addValue(r, Qu(s, { owner: n })), og(i) && i.remove(r);
    else if (o !== s)
      if (n.hasValue(r)) {
        const a = n.getValue(r);
        !a.hasAnimated && a.set(s);
      } else {
        const a = n.getStaticValue(r);
        n.addValue(r, Qu(a !== void 0 ? a : s, { owner: n }));
      }
  }
  for (const r in t) e[r] === void 0 && n.removeValue(r);
  return e;
}
const xb = new WeakMap(),
  RL = Object.keys(uh),
  Z7 = RL.length,
  _b = [
    "AnimationStart",
    "AnimationComplete",
    "Update",
    "BeforeLayoutMeasure",
    "LayoutMeasure",
    "LayoutAnimationStart",
    "LayoutAnimationComplete",
  ],
  q7 = JA.length;
class $7 {
  constructor(
    {
      parent: e,
      props: t,
      presenceContext: i,
      reducedMotionConfig: r,
      visualState: s,
    },
    o = {}
  ) {
    (this.current = null),
      (this.children = new Set()),
      (this.isVariantNode = !1),
      (this.isControllingVariants = !1),
      (this.shouldReduceMotion = null),
      (this.values = new Map()),
      (this.features = {}),
      (this.valueSubscriptions = new Map()),
      (this.prevMotionValues = {}),
      (this.events = {}),
      (this.propEventSubscriptions = {}),
      (this.notifyUpdate = () => this.notify("Update", this.latestValues)),
      (this.render = () => {
        this.current &&
          (this.triggerBuild(),
          this.renderInstance(
            this.current,
            this.renderState,
            this.props.style,
            this.projection
          ));
      }),
      (this.scheduleRender = () => an.render(this.render, !1, !0));
    const { latestValues: a, renderState: l } = s;
    (this.latestValues = a),
      (this.baseTarget = { ...a }),
      (this.initialValues = t.initial ? { ...a } : {}),
      (this.renderState = l),
      (this.parent = e),
      (this.props = t),
      (this.presenceContext = i),
      (this.depth = e ? e.depth + 1 : 0),
      (this.reducedMotionConfig = r),
      (this.options = o),
      (this.isControllingVariants = Zg(t)),
      (this.isVariantNode = v3(t)),
      this.isVariantNode && (this.variantChildren = new Set()),
      (this.manuallyAnimateOnMount = !!(e && e.current));
    const { willChange: c, ...h } = this.scrapeMotionValuesFromProps(t, {});
    for (const d in h) {
      const p = h[d];
      a[d] !== void 0 && Li(p) && (p.set(a[d], !1), og(c) && c.add(d));
    }
  }
  scrapeMotionValuesFromProps(e, t) {
    return {};
  }
  mount(e) {
    (this.current = e),
      xb.set(e, this),
      this.projection && this.projection.mount(e),
      this.parent &&
        this.isVariantNode &&
        !this.isControllingVariants &&
        (this.removeFromVariantTree = this.parent.addVariantChild(this)),
      this.values.forEach((t, i) => this.bindToMotionValue(i, t)),
      BL.current || Y7(),
      (this.shouldReduceMotion =
        this.reducedMotionConfig === "never"
          ? !1
          : this.reducedMotionConfig === "always"
          ? !0
          : J_.current),
      this.parent && this.parent.children.add(this),
      this.update(this.props, this.presenceContext);
  }
  unmount() {
    xb.delete(this.current),
      this.projection && this.projection.unmount(),
      Yo.update(this.notifyUpdate),
      Yo.render(this.render),
      this.valueSubscriptions.forEach((e) => e()),
      this.removeFromVariantTree && this.removeFromVariantTree(),
      this.parent && this.parent.children.delete(this);
    for (const e in this.events) this.events[e].clear();
    for (const e in this.features) this.features[e].unmount();
    this.current = null;
  }
  bindToMotionValue(e, t) {
    const i = gl.has(e),
      r = t.on("change", (o) => {
        (this.latestValues[e] = o),
          this.props.onUpdate && an.update(this.notifyUpdate, !1, !0),
          i && this.projection && (this.projection.isTransformDirty = !0);
      }),
      s = t.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(e, () => {
      r(), s();
    });
  }
  sortNodePosition(e) {
    return !this.current ||
      !this.sortInstanceNodePosition ||
      this.type !== e.type
      ? 0
      : this.sortInstanceNodePosition(this.current, e.current);
  }
  loadFeatures({ children: e, ...t }, i, r, s, o) {
    let a, l;
    for (let c = 0; c < Z7; c++) {
      const h = RL[c],
        {
          isEnabled: d,
          Feature: p,
          ProjectionNode: m,
          MeasureLayout: v,
        } = uh[h];
      m && (a = m),
        d(t) &&
          (!this.features[h] && p && (this.features[h] = new p(this)),
          v && (l = v));
    }
    if (!this.projection && a) {
      this.projection = new a(
        s,
        this.latestValues,
        this.parent && this.parent.projection
      );
      const {
        layoutId: c,
        layout: h,
        drag: d,
        dragConstraints: p,
        layoutScroll: m,
        layoutRoot: v,
      } = t;
      this.projection.setOptions({
        layoutId: c,
        layout: h,
        alwaysMeasureLayout: !!d || (p && xu(p)),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        animationType: typeof h == "string" ? h : "both",
        initialPromotionConfig: o,
        layoutScroll: m,
        layoutRoot: v,
      });
    }
    return l;
  }
  updateFeatures() {
    for (const e in this.features) {
      const t = this.features[e];
      t.isMounted
        ? t.update(this.props, this.prevProps)
        : (t.mount(), (t.isMounted = !0));
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  measureViewportBox() {
    return this.current
      ? this.measureInstanceViewportBox(this.current, this.props)
      : Sn();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, t) {
    this.latestValues[e] = t;
  }
  makeTargetAnimatable(e, t = !0) {
    return this.makeTargetAnimatableFromInstance(e, this.props, t);
  }
  update(e, t) {
    (e.transformTemplate || this.props.transformTemplate) &&
      this.scheduleRender(),
      (this.prevProps = this.props),
      (this.props = e),
      (this.prevPresenceContext = this.presenceContext),
      (this.presenceContext = t);
    for (let i = 0; i < _b.length; i++) {
      const r = _b[i];
      this.propEventSubscriptions[r] &&
        (this.propEventSubscriptions[r](),
        delete this.propEventSubscriptions[r]);
      const s = e["on" + r];
      s && (this.propEventSubscriptions[r] = this.on(r, s));
    }
    (this.prevMotionValues = Q7(
      this,
      this.scrapeMotionValuesFromProps(e, this.prevProps),
      this.prevMotionValues
    )),
      this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode
      ? this
      : this.parent
      ? this.parent.getClosestVariantNode()
      : void 0;
  }
  getVariantContext(e = !1) {
    if (e) return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const i = this.parent ? this.parent.getVariantContext() || {} : {};
      return (
        this.props.initial !== void 0 && (i.initial = this.props.initial), i
      );
    }
    const t = {};
    for (let i = 0; i < q7; i++) {
      const r = JA[i],
        s = this.props[r];
      (lh(s) || s === !1) && (t[r] = s);
    }
    return t;
  }
  addVariantChild(e) {
    const t = this.getClosestVariantNode();
    if (t)
      return (
        t.variantChildren && t.variantChildren.add(e),
        () => t.variantChildren.delete(e)
      );
  }
  addValue(e, t) {
    t !== this.values.get(e) &&
      (this.removeValue(e), this.bindToMotionValue(e, t)),
      this.values.set(e, t),
      (this.latestValues[e] = t.get());
  }
  removeValue(e) {
    this.values.delete(e);
    const t = this.valueSubscriptions.get(e);
    t && (t(), this.valueSubscriptions.delete(e)),
      delete this.latestValues[e],
      this.removeValueFromRenderState(e, this.renderState);
  }
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, t) {
    if (this.props.values && this.props.values[e]) return this.props.values[e];
    let i = this.values.get(e);
    return (
      i === void 0 &&
        t !== void 0 &&
        ((i = Qu(t, { owner: this })), this.addValue(e, i)),
      i
    );
  }
  readValue(e) {
    return this.latestValues[e] !== void 0 || !this.current
      ? this.latestValues[e]
      : this.readValueFromInstance(this.current, e, this.options);
  }
  setBaseTarget(e, t) {
    this.baseTarget[e] = t;
  }
  getBaseTarget(e) {
    var t;
    const { initial: i } = this.props,
      r =
        typeof i == "string" || typeof i == "object"
          ? (t = $A(this.props, i)) === null || t === void 0
            ? void 0
            : t[e]
          : void 0;
    if (i && r !== void 0) return r;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !Li(s)
      ? s
      : this.initialValues[e] !== void 0 && r === void 0
      ? void 0
      : this.baseTarget[e];
  }
  on(e, t) {
    return this.events[e] || (this.events[e] = new uM()), this.events[e].add(t);
  }
  notify(e, ...t) {
    this.events[e] && this.events[e].notify(...t);
  }
}
class LL extends $7 {
  sortInstanceNodePosition(e, t) {
    return e.compareDocumentPosition(t) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, t) {
    return e.style ? e.style[t] : void 0;
  }
  removeValueFromRenderState(e, { vars: t, style: i }) {
    delete t[e], delete i[e];
  }
  makeTargetAnimatableFromInstance(
    { transition: e, transitionEnd: t, ...i },
    { transformValues: r },
    s
  ) {
    let o = _W(i, e || {}, this);
    if ((r && (t && (t = r(t)), i && (i = r(i)), o && (o = r(o))), s)) {
      vW(this, i, o);
      const a = K7(this, i, o, t);
      (t = a.transitionEnd), (i = a.target);
    }
    return { transition: e, transitionEnd: t, ...i };
  }
}
function eJ(n) {
  return window.getComputedStyle(n);
}
class tJ extends LL {
  readValueFromInstance(e, t) {
    if (gl.has(t)) {
      const i = rM(t);
      return (i && i.default) || 0;
    } else {
      const i = eJ(e),
        r = (w3(t) ? i.getPropertyValue(t) : i[t]) || 0;
      return typeof r == "string" ? r.trim() : r;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: t }) {
    return _L(e, t);
  }
  build(e, t, i, r) {
    XA(e, t, i, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, t) {
    return qA(e, t);
  }
  handleChildMotionValue() {
    this.childSubscription &&
      (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    Li(e) &&
      (this.childSubscription = e.on("change", (t) => {
        this.current && (this.current.textContent = `${t}`);
      }));
  }
  renderInstance(e, t, i, r) {
    P3(e, t, i, r);
  }
}
class nJ extends LL {
  constructor() {
    super(...arguments), (this.isSVGTag = !1);
  }
  getBaseTargetFromProps(e, t) {
    return e[t];
  }
  readValueFromInstance(e, t) {
    if (gl.has(t)) {
      const i = rM(t);
      return (i && i.default) || 0;
    }
    return (t = B3.has(t) ? t : ZA(t)), e.getAttribute(t);
  }
  measureInstanceViewportBox() {
    return Sn();
  }
  scrapeMotionValuesFromProps(e, t) {
    return L3(e, t);
  }
  build(e, t, i, r) {
    YA(e, t, i, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(e, t, i, r) {
    R3(e, t, i, r);
  }
  mount(e) {
    (this.isSVGTag = QA(e.tagName)), super.mount(e);
  }
}
const iJ = (n, e) =>
    jA(n)
      ? new nJ(e, { enableHardwareAcceleration: !1 })
      : new tJ(e, { enableHardwareAcceleration: !0 }),
  rJ = { layout: { ProjectionNode: bL, MeasureLayout: ML } },
  sJ = { ...DW, ...t6, ...U7, ...rJ },
  Zo = c8((n, e) => k8(n, e, sJ, iJ)),
  Ur = {
    paddingX: "sm:px-16 px-6",
    paddingY: "sm:py-16 py-6",
    padding: "sm:px-16 px-6 sm:py-16 py-10",
    heroHeadText:
      "font-black text-white lg:text-[80px] sm:text-[60px] xs:text-[50px] text-[40px] lg:leading-[98px] mt-2",
    heroSubText:
      "text-[#dfd9ff] font-medium lg:text-[30px] sm:text-[26px] xs:text-[20px] text-[16px] lg:leading-[40px]",
    sectionHeadText:
      "text-white font-black md:text-[60px] sm:text-[50px] xs:text-[40px] text-[30px]",
    sectionSubText:
      "sm:text-[18px] text-[14px] text-secondary uppercase tracking-wider",
  },
  oJ = () =>
    St("section", {
      className: "relative w-full h-screen mx-auto",
      children: [
        St("div", {
          className: `${Ur.paddingX} absolute inset-0 top-[120px] max-w-7xl mx-auto flex flex-row items-start gap-5`,
          children: [
            St("div", {
              className: "flex flex-col justify-center items-center mt-5",
              children: [
                we("div", { className: "w-5 h-5 rounded-full bg-[#915eff]" }),
                we("div", { className: "w-1 sm:h-80 h-40 violet-gradient" }),
              ],
            }),
            St("div", {
              children: [
                St("h1", {
                  className: `${Ur.heroHeadText} text-white`,
                  children: [
                    "Hi, I'm ",
                    we("span", {
                      className: "text-[#915eff]",
                      children: "Moeez",
                    }),
                  ],
                }),
                St("p", {
                  className: `${Ur.heroSubText} mt-2 text-white-100`,
                  children: [
                    "I am a Full Stack developer,",
                    we("br", { className: "sm:block hidden" }),
                    " building cutting edge applications",
                  ],
                }),
              ],
            }),
          ],
        }),
        we(Z9, {}),
        we("div", {
          className:
            "absolute xs:bottom-10 bottom-32 w-full flex justify-center items-center",
          children: we("a", {
            href: "#about",
            children: we("div", {
              className:
                "w-[35px] h-[64px] rounded-3xl border-4 border-secondary flex justify-center items-start p-2",
              children: we(Zo.div, {
                animate: { y: [0, 24, 0] },
                transition: {
                  duration: 1.5,
                  repeat: 1 / 0,
                  repeatType: "loop",
                },
                className: "w-3 h-3 rounded-full bg-secondary mb-1",
              }),
            }),
          }),
        }),
      ],
    }),
  aJ = "/assets/logo-ac4bb3f6.svg",
  lJ = "/assets/backend-565fc01f.png",
  uJ = "/assets/creator-dbbffaec.png",
  cJ = "/assets/mobile-896ef2f5.png",
  fJ = "/assets/web-0d05165f.png",
  hJ = "/assets/menu-242d80a8.svg",
  dJ = "/assets/close-ad0e0ca6.svg",
  pJ = "/assets/css-79a7f026.png",
  mJ = "/assets/figma-184a11e6.png",
  IL =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAANG0lEQVR4nO2dX6xcRR2AD9QYgpYElEDv3fltqdUSHtSISNWIiIE09vbuzMKa+GBq4p/4hoIGEx/qSxOiL1T62Adj4kN90gegSXnQxAdCIiYkloQKSKKQpo3c7szeikrXzPZCW3r39uzdc2bOzPm+5Jc0t7t7dn4z386cc+bMFAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQFs415cdVqtHrJZjzqgTToudhFEn/N/8//nXxP6eAHAJIy13Oi3HnZFxqdBy3L+HJAJEZLy/e5016og1cr60vGvh3+Pf6z+DSgQIzGhZLVgjz80q7hUia/XC6mCHUIEAgfDCWS2vzCvvJRK/zrkxQILyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMUDi8iIxQOLyIjFA4vIiMbSe1OVFYmgtuciLxNBKnJE/xJaucomNeu1cr7s9dm4Baie3HpieGFoHEgMkDhIDJA4SAyQOEgMkDhIDNASn5YDV8vis70NigMg4LT++eFsFibnFBMngjPzoynujSIzE0Hhsv/vo9AkOSIzE0Fj8vrtXn6WExEgMjcMa9cPyUw2RGImhMVijfjD7fGEkRmKIjtXq4c1P+kdiJIZojLR8z+9wP9+TO0iMxBAcp+W788qLxDyKCBFwRr5TlbxIjMQQENeTb1st71QpLxIjMSQ2bJ4qsVE/m/V7+SVs/FI2l/8YqDeslmecVof9ebYPp9Uhq9VTTqtTdZahwlywPA80v+etSmJn5EVn5Aln5DPjorhm2mvHB4prR8uLd1stB61Wb8YWFYmhVlxPfSuUvPNcnd4M46Vt1zsjjzmj3oot6/RcqNfP9WVHiHxAZjit9oeWN7TEntGgs2i1PB9bViSGynB9+WYseecZTs/ZGx+NLesGueCcGMphtfq6NfLfRjTcgD3xeFBssUY9HbvM03PBcBqugjUyaIq8MSRe2Ss3Oi0vxy4zEsPMDI081DR5Y0g87KkvxS4vEkOyw+ZpMdTdfqhqndxHbkCZp/6gcU4MKfS8lzTYf9t9t90SqtZGpnNX7DIjMVwV36tZrf7T/MYqvwtdnc7IycbnRXNhq7WMTNekIK+PkVbfD50fp9UvY5e73I+b4hZT2xhp1bNavR278ZUWeHnx7tA5clqWYpcbieEKRj21LyV5fQwHt94cuipX9nV2xi43EsNlONPZY7U6F7uxzRrjwR0fDF2Vp5d3bY1d7pkl1pwTZ4vrd7/mr+bGbmSbEnhp2/Wh8+VnZsUu96YkNpwTZ4fT6oEUe953Y7W3oELn7MyenTfELvemJdb0xNmQurwTgXX386Hz5h/ji13uuSQ29MTJY42632pZjd2Y5m6MWj0S42Jf7HIjcYuxPflqDvJeEFh+Hzx/Wv0idrmRuKXYfvcr1sgoduOpTmD1dsiplH5ZnhRmYrmy+WM4nQ621703J3nfC61+GvJ2W/TyInH7GPbli06Ljd1Y6gl11hnZFiKPq4MdYrW8Er/M1Ybl6nRzmTzHmq28a6HVb0Llc70la3MIy3C6eZztyRecUcPYjSNIA9Tq4VB5pSeG2mmTvBcElv9Z3flGqKZFTwy1MTLd3WvnhtHFCiqx3yVCq59stIh7lSAxVI7fhcAZ+VdsmaKGlj8Ol+WOEM2L4TRUvORLc3cUCH6PWKtfj3Tnc3U3MXpimJvRg+qzyLu+zGVz6Iz81hn1Vy/krPlHYtg0rtf9tDNyJnav19Qoncc59x5iOA0zg7zVC4zEst4pCRuqVY0z2z9Fz1uPwEgsSFwn9sHFTzojp2MPT3MWGIkFietg2O/e3vSNqHMRGIkFiZE3bYGRWJC4Cs4ub99ltXojdo/WRoGRWJAYedMWGIkFiTfV8+qFT1gj/4zdk6UaVQqMxILEM8nbX/w48jZLYCQWJEbedHvgeR+CX2/apb+2Mdl/WKvDfuNyH06rQ1arp5xWp2KPYlyN+cgSvweP1fKP2JWSQ5TNechG69/jjLzojDzhnyDb6BHI8YHiWr+Rm9VysOm3Dy0SF8Vqf3s3x2VbchQ49DRDv52MM/JYkx9csW2edom86Qkco9GOBp1Fq+X52LK6huSjEZzbJ7f5gsdOfm5RNv+pDR/XeuOjsfPrGpKPqIyW1QLD5rQFjiLxl4sPOC3HY8vqNsiHb9tFzoz3d6+zRp6Lnexco2w9pDp8XNkrNzotL8fOs5uejz/H2Ao2GNaoI7GTnHOUrYdKG23gntjvvBE7z27jfBwpcn0g32p5J3aCc47SdVF1ow3cE0/uIzcg3269XBg5P9JyZ5EbTT5/ySVK10Utx+/sKYIuahg/31NDy/EiJ1LfLDqVKFsfNRz7ZKg1qt/FGvVq7HxvFFndWrL97qOxE9qGKFsfVR/XGvXzelvQOmXQ6lDsfDdtU/basFqOxU5oG6JsfVR93FFP7au3Ba1TBi1LsfO9Ufg2X+SC0+ql2AltQ5SujwyGi34OvWtAzqeGVi8VudCmzcdiRvn6qPa4p5d3bS0C44/pGpDz6aGGRS4gcN4CjwfFliIw/pguuqRtEZghdN4C33/Lh4rAJNADnyhygYtYeQvMObDkfRHLX1KP/4uYf5StjxqOvbfeFpTiVWiVz22ktVUZoic19yhbH5UfW6tD9bag9cqgnoyd79ZM5PAwlTJfgf2sqCIwjZ6JpTObSunxE7z9RO/oyc04ytZFHcf285OLQDR5LrTN9WEGD48T5iuwf0KoCESzn0ZSeT5O6OGB/nwFXut97qt/w7vOPbEldW19oN/Dkjr5CuyfSloZdG6qq+34z3ZG/hZbVNfWJXXeZXWwQ6yWV2InPbcom/96v4d61q9fVcfMK2vU07Fz7NaJdq5Muc6q/UQOAk/iaJVDySavSmnbtCLl+6EnrrYxlc17oIb9F7/2d87rQts29rzvB4nzFHgSWqzf++jMnp03zNou/PzqJu/MYJH3IgynMxX4YmN/0+93NDLd3X7/ow33RjLd3U3fG8m2edg8DSTOV+DLQqtTk4tRl+9OeHjtb43fndAi73QYTrdA4ITDMmy+OkiMwLFFdcg7H0hMDxxbWEfPi8ShG1rZjMcWIqWwDJvpiRE4vogOeePAcJoeGHkTB4kZQtPzJg4Scw7MsDlxkJiLWJzzJg4ScxWaC1aJw7TL99/qkHesVk+VzZ9/LZuty8X8MT0yPEh8YQE1a+RXK1p9bNb8+ff497Z9oUGLvPFos8RWq7/bXvfeeXPoP8N/VuzyIG9LaeM58eQB90H31qpyOFza9lGn1Z/alUPFw/hNoU09sV/p4tTg5g9XnUP/mf6zW5LD13iet2G0QWL/kPtqb0HVlUP/2U1+kB55Myf34fTQyEN159AaGWQrr2bY3Hiy7YkD7reT4z5WlmFzOuTYE1uj7g+VP6fVA1nlTtPzJkdmPfHJcVFcEyp3/lj+mFnIa7hglSwZ9cRPhM6d3/M3eXk1PW/y5CDxsCcPhs6bv2AWu9zIC1kMp4f97u2hq9IfM3a5NxuWYXN+pNwTn9ULHwmdr8nsrBTl1QybsyXVnriO3f6uhj9mcvIaLlhlT4o9sd8nKHSeTi/v2pqUvJqetzWk1hPH2AFvZV9nZzLyGnre1pGYxHtD58dpWWpAuZEXMhhOa3UodD06o56MXu6rhGXYDClI7B+4D11T1qhXY5cbeSGb4fTIdO4KVZ3+WI2Wl3NeSK0ntlqeCVVrVsux5uaBq82QqsRG7qu78ob9zj2xy4m8kKXE/rzUz5Cqq3pXBp2bmvoUEj0vZCGxM+rZOmZmjQfFFmvU0/HLh7yQ/4Wto+OlbddXVdH+s/xnNqBcVwQXrCDLntivILna396dt3pHg87iZJnaJpaRC1aQs8ROi7VaHj+zZ+cNs5bLz692Rh5zRr0VvRzICy0eTk+Wm7VaDo5Md/f4QHHttHL4//Ov8a9t8vKxDJuhdRK/F1qdmlyM0uqw7519TP594W+non8/5IVYNHo4nUFwzgu1g8TIC4mDxPS8kDhIzLAZEgeJOeeFxEFiLlhB4iAxV5shcZCYW0WQOEjMfV5IHCRmkgYkDhIzwwoSB4mZHgmJ03aJmdsMydNWiZEXsqFtEiMvZEdbJEZeyJbcJUZeyJ5cJUZeaA25SYy80DpykRh5obWkLjHyQutJVWLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFSFRi5AVIVGLkBUhUYuQFCMxoWS1YI89VIO8L/geBCgQIzHh/9zpr1BFr5PzM4ho579/rP4OKA4jISMudTsvx0gJrOe7fQ6UBNIhzfdlhtXrEajnmjDrhtNhJGHXC/83/n39N7O8JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFCE4v/t8177cNMPugAAAABJRU5ErkJggg==",
  gJ = "/assets/html-92b76a73.png",
  yJ =
    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPAAAADwCAYAAAA+VemSAAAACXBIWXMAAAsTAAALEwEAmpwYAAAOgElEQVR4nO2dCdCVZRXHz8Pnwi4groElmijuK6m4YCqJpZmJqJla40qGWjgYZZQL5p4GJZlboKKTGzoouWSAiQsuqONY42Q1LVrZYlpZnebcy51B6uO7977LeZ/7/H4z/wGGmfve5zznf577vu+ziAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtIW+JIqIQafkgKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyBKQQUAmUEJgkoBHHngKSGd8ARMVAMjIEpBBQCZQQmCSgEceeApIZ3wBExUAyMgSkEFAJlBCYJKARx54CkhnfAETFQDIyB/Sp+yKQJHwmlft+3l4kumiN62dmixx8WdJ9dg246LOjggUH79A4aQv3v79sg6Oab1P//pAlBL50iev9s0b8tq3bBkdTwDnjsisHA7zwj+v1viB62f9C+vbN9395rBx03JuhV00TfXFrF/kgM74DHriob+A8/EZ16YtChg7N9x+40oF/QyccGfXVhlfojMbwDHruqaOB3l4teMkV00IBijLuq1loz6PRJov94rgr9kRjeAY9dVTPwy/eJ7rZtOcZdVVtvHvSp2737IzG8DRC7qmTghdeWN+p2p769g94zEwNj4AqYMyYDz7tcdI0uX/PKCtn3mP01r/5IDG8DxK4qGPjumdUxr6yQvY6aezEGxsAVMGmVDWz3vAP7+xtWunnltGRu2f2RGN4GiF2eBranvttu4W9UWY3WHxL0tYcwMAaugFmrZuDzJ2e/fhkaN6a82WaSGt4GiF1eBv79Y6L9+/qbs1ndcCEGxsAVMGxVDDztZH9TtqIh64Ra0Sm+PxLD2wCxy8PANtNqw6H+pmxWgwcGvWZ6Wf2RGN4GiF0eBr732/nd+24/MugVU0WfuUP09cX11Ub259J5oldPE917l/oroXY//9hDgr6xpMz+SAxvA8QuDwNPOjq7cfv1qd+X/ufFnq9nr4J22LK1z990WKgtPyy/PxLD2wCxy8PANuc46/vZR29qfR3xxPE9f3ZXV9Azjwv61tNe/ZEY3gaIXWUb+O/PSs0kWa553ufba+u/losefuDqf44/eZt3fySGtwFiV9kGfnF+tmvarht/far99trIOmqz//3MGWeK/vP5KvRHYngHPHaVbeAHr8t2zQP2yD6pwh54NeZejx0d9JUFVeqPxPAOeOwq28C2cCHL9T57eD6zor46SfTa85p7CKal9kdieAc8dpVt4NuvzHZN28ius/sjMbwDHrvKNnDWd8AH7omBOwpvA8Susg38yA2S+f2v7VLZuf2RGN4Bj11lG9geGGW95qxzO7k/EsM74LGrbAPb6NmrV7Zrrjso6E/v79T+SAzvgMeusg1s2nJEtmuaRgwPtd08Oq8/EsM74LHLw8C2QCDrdU22Fc+NM6r3Kkgz9UdieAc8dnkY+KaL8t2Jw1YcPXZzp/RHYngHPHZ5GNiOTFlzjfwM3JAdZLZgduz9kRjeAY9dHgY2fXI1iwqyasetgt5yaTXmNmvL/ZEY3gGPXV4GtuWARRm4ITti1FYu/XZRTP2RGN4Bj11eBjbZrKqiTWxae62gnz406LN3xtAfieEd8NjlaeDn75LayYBlmHjl1UwPfLe6T64lNbwDHrs8DWz6+uk+e0NvNzLozZeI/vsF/z54b38khnfAY5e3gc1AB+9TvoEbsu19bruiSv2RGN4Bj13eBja9uVRqI6KXiUWCfvhD/mcDY+AKGCI2VcHApt8tzr7ZXVZ1dQX94gm+q50kNbwNELuqYmDTHx+X2mQMTxOLBN1qRNAnnDa3k9TwNkDsqpKBGycW2iiYdcVSVq3RFfSCM8p/Wi2p4W2A2FU1Azf0w+9JbSKG92h81MGhthUuBsbA7maNycAmO0zshMP8R+OD9irvvlhSw9sAsavKBl55G9j9Rvua+JCxobYxPAbGwO6mjc3ADc2fJbrLNn4mPuv44tsqqeFtgNgVk4EbWjRH9KP7Zjt1sB2FEGq7ahbbH4nhbYDYFaOBG3ruzvo9sh12VpaJN14/29EuPfdHYngbIHbFbOCVZ3JdeY7o+zcux8TnnlZcmyU1vJMndnWCgRt6d7norZeJ7jSqWAMP7B/0z08U1R+J4Z00sauTDLyyFl4rtfnNRZn4m18qqj8SwztRYlenGrghO+93/93zN/Do7Yppt6SGd4LErk43cEN3Xi26wbr5GbhXr6C/frSI/kgM78SIXakY2GR7Y+21c34mnnd5Ef2RGN5JEbtSMrDpradF99gxHwN/4YT82y6p4Z0QMcvm96ZmYNNrD0ntlMOsbT94HwyMgR0T+fXF1TSwLWIouu02LTJr27f5IAbGwE0m3M8flNrWqLboPa8kthP+sibxkQeFXN/jXnhGfXRcOq9YAy+Zm73t6w3BwBi4h0Sz0wVmnCnat3c9aU6ekF/S3Ped7El83Mfz+T7L737vQoVRmxW7DtemQ2Zte78+GBgD93CavW3vsuqE+rtn5pPENtplTeJTJ4bMo+75k6W2+fqqn33OScXeX2e9D+7qwsAYuJvXHXYEZ3erbQYPDPri/OwJvOdO2e8Dp3wm28buq5v2aNva2ESMIsxra3vt87O0vX9fDIyBV9kjeda5UjNoT8lj281kOaX+hXvy2VDdFhG0c1tgG7o3cyrDpsOCvrEkfwO/ujB7+zdaDwNj4BUJZXsS79riYvWhg4P+6Mb2Rp8xOYy+pjuuau3adj6RnR7YyjXGjs7/fvjqadkNvN1IDJy8gf+0VPRzx9Tvp9qd0jfp6FA7c7eZxH17mdQ2asvDvCZbk9vsqDt9UvvnAo/fO799qexzNt8ke9uPGIeBkzbw3ItFNxyaj5HsKfVJE0LtyfJfnnzvdWxr1JfvE71iqtR+kuZlXrumPYTqqZ3LfiC6fQ4nL9i+WLYBfNa4n35MddcFS2p4m7Bd/eyB7A9RVie7jx4xPOjwDetGK+Ia9hCsmbbuvkN+17T7zgWz24u5/QyffGx+3+XB6/LPC0kNbyNmkY2YRRm4DH3l1OYMvHiO5L5/1d671I8JbWanSNss/pZLpfZuOa/r9+1dzHtqSQ1vE2aRLUfLY06ul1o5DGzi+OJ+adi9qE12ue4CqW06d89M0RtnSO1khUP3C7ruoPyvO3E864GTN7Al9mVn+5yPm1X287yVY0dsAYFtReP9vfPSw9cXU9QlNbxH0awyE4wb45+QrcoKT6tttZ+x3t87D+00qrXihYE72MCm3/xYdP0h/onZrGwktddf7bT1xCP8v38VH17pCklqeJsvz3nPZe5vnEUXndV+O+09dB6vlLw0oeD1z5Ia3sbLU3d9q9hXS3nIJkBkffpqvzi2+IB/W1rVsA3yXc6JgTvMwCZ7elr2kSHNymZR5bVO95cP5zuppGj171vOod+SGt6GK0L2sKdPQZMvsuiqafkvKLCn2d7tkh5kSx3vb3PyCAZO0MAmq/Z2Do938jY07eRi7v1spZFNyvBun3SjQQPaWzCCgRMegRv61SP5rNnNIvs5bxMiimynzaf+8intL+goStuPDPrSveX2uaSGt8nKWCN8zfTm1gjnLZvBZBuil9XWx28t/lyjZrTWmkGnnljslj4YOBEDr7xLx6c+Vl8+WMaoa69L7Jplt9PmNl9/gc+9ca9eQT9xQNBXFvj1s6SGt7HKlu2kYdvt/L89pLLKfsIeMra1Oc5FydYP28O8Mu6P1xkQ9JQjQ23JpXe7JTW8A+4l2zvZTsjbd7f63lFZRh3bCcS2uPnFw/7t6u5p9SVT6mbOa7KLvdO1bXptR5F3ctooIA9JangHvAqyA65tIf9XJ4kefmDQnbcOtamZNrJYstpobffQm2xUX8NrezmbYefPqm/u7v39W5GZbdGc+t5hpx1VPx1hhy1DbWMEa2OjmA3oV//3ZsNDbfsgWz1kC/Bvv7K+Ftu7HdqNJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBAoIzBJQCGIOwckNbwDjoiBYmAMTCGgECgjMElAIYg7ByQ1vAOOiIFiYAxMIaAQKCMwSUAhiDsHJDW8A46IgWJgDEwhoBBoiiMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEg+/BceiofdqS/+vQAAAABJRU5ErkJggg==",
  vJ = "/assets/mongodb-54000b2b.png",
  DL = "/assets/nodejs-d83eb6dd.png",
  FL = "/assets/reactjs-966214a8.png",
  xJ = "/assets/redux-171787ca.png",
  _J = "/assets/tailwind-6ece120d.png",
  Ab = [
    { id: "about", title: "About" },
    { id: "work", title: "Work" },
    { id: "contact", title: "Contact" },
  ],
  AJ = [
    { title: "Web App", icon: fJ },
    { title: "Mobile App", icon: cJ },
    { title: "Python", icon: lJ },
    { title: "Google Cloud", icon: uJ },
  ],
  MJ = [
    { name: "HTML 5", icon: gJ },
    { name: "CSS 3", icon: pJ },
    { name: "JavaScript", icon: yJ },
    { name: "React JS", icon: FL },
    { name: "Redux Toolkit", icon: xJ },
    { name: "Tailwind CSS", icon: _J },
    { name: "Node JS", icon: DL },
    { name: "MongoDB", icon: vJ },
    { name: "git", icon: IL },
    { name: "figma", icon: mJ },
  ],
  SJ = [
    {
      title: "AI Companion App",
      company_name: "OpenAI",
      icon: FL,
      iconBg: "#383E56",
      points: [
        "Coordinated with my team to develop a cutting edge OpenAI custom model",
        "The Application generates a tailored fit Infographic depending on your interest",
        "Created the figma designs and implement it in flutter as frontend",
      ],
    },
    {
      title: "Vehicle Information Bot",
      company_name: "Python",
      icon: DL,
      iconBg: "#E6DEDD",
      points: [
        "Developed a custom web scrapper that feteches from the provided sites",
        "This bot is able to break country restrictions protocol and evade bot detection",
      ],
    },
    {
      title: "Chat Application",
      company_name: "MERN Stack",
      icon: IL,
      iconBg: "#383E56",
      points: [
        "Developed a chat application with MERN Stack and python.",
        "Collaborated with cross-functional team including other developers.",
        "Works in real-time, send and recieve messages in an instant.",
        "Github: https://github.com/moeezramay/chatApp",
      ],
    },
  ],
  wJ = () => {
    const [n, e] = H.useState(""),
      [t, i] = H.useState(!1);
    return we("nav", {
      className: `${Ur.paddingX} w-full flex items-center py-5 fixed top-0 z-20 bg-primary`,
      children: St("div", {
        className: "w-full flex justify-between items-center max-w-7xl mx-auto",
        children: [
          St(kN, {
            to: "/",
            className: "flex items-center gap-4 ",
            onClick: () => {
              e(""), window.scrollTo(0, 0);
            },
            children: [
              we("img", {
                src: aJ,
                alt: "logo",
                className: "w-9 h-9 object-contain",
              }),
              St("p", {
                className:
                  "text-white text-[18px] font-bold cursor-pointer flex ",
                children: [
                  "Moeez  ",
                  we("span", {
                    className: "sm:block hidden",
                    children: " | React Developer",
                  }),
                ],
              }),
            ],
          }),
          we("ul", {
            className: "list-none hidden sm:flex flex-row gap-10",
            children: Ab.map((r) =>
              we(
                "li",
                {
                  className: `${
                    n === r.title ? "text-white" : "text-secondary"
                  } hover:text-white text-[18px] font-medium cursor-pointer`,
                  onClick: () => e(r.title),
                  children: we("a", { href: `#${r.id}`, children: r.title }),
                },
                r.id
              )
            ),
          }),
          St("div", {
            className: "sm:hidden flex flex-1 justify-end items-center",
            children: [
              we("img", {
                src: t ? dJ : hJ,
                alt: "menu",
                className: "w-[28px] h-[28px] object-contain curosr-pointer",
                onClick: () => i(!t),
              }),
              we("div", {
                className: `${
                  t ? "flex" : "hidden"
                } p-6 black-gradient absolute top-20 right-0 mx-4 my-2 min-w-[140px] z-10 rounded-xl`,
                children: we("ul", {
                  className:
                    "list-none flex justify-end items-start flex-1 flex-col gap-4",
                  children: Ab.map((r) =>
                    we(
                      "li",
                      {
                        className: `font-poppins font-medium cursor-pointer text-[16px] ${
                          n === r.title ? "text-white" : "text-secondary"
                        }`,
                        onClick: () => {
                          i(!t), e(r.title);
                        },
                        children: we("a", {
                          href: `#${r.id}`,
                          children: r.title,
                        }),
                      },
                      r.id
                    )
                  ),
                }),
              }),
            ],
          }),
        ],
      }),
    });
  };
var CJ = Object.defineProperty,
  EJ = Object.defineProperties,
  TJ = Object.getOwnPropertyDescriptors,
  Mb = Object.getOwnPropertySymbols,
  bJ = Object.prototype.hasOwnProperty,
  PJ = Object.prototype.propertyIsEnumerable,
  Sb = (n, e, t) =>
    e in n
      ? CJ(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
      : (n[e] = t),
  tf = (n, e) => {
    for (var t in e || (e = {})) bJ.call(e, t) && Sb(n, t, e[t]);
    if (Mb) for (var t of Mb(e)) PJ.call(e, t) && Sb(n, t, e[t]);
    return n;
  },
  nf = (n, e) => EJ(n, TJ(e)),
  BJ = class extends H.Component {
    constructor(n) {
      super(n), (this.ref = mh.createRef()), (this.state = { style: {} });
      const e = {
        reverse: !1,
        max: 35,
        perspective: 1e3,
        easing: "cubic-bezier(.03,.98,.52,.99)",
        scale: "1.1",
        speed: "1000",
        transition: !0,
        axis: null,
        reset: !0,
      };
      (this.width = null),
        (this.height = null),
        (this.left = null),
        (this.top = null),
        (this.transitionTimeout = null),
        (this.updateCall = null),
        (this.element = null),
        (this.settings = Object.assign({}, e, this.props.options)),
        (this.reverse = this.settings.reverse ? -1 : 1),
        (this.onMouseEnter = this.onMouseEnter.bind(
          this,
          this.props.onMouseEnter
        )),
        (this.onMouseMove = this.onMouseMove.bind(
          this,
          this.props.onMouseMove
        )),
        (this.onMouseLeave = this.onMouseLeave.bind(
          this,
          this.props.onMouseLeave
        ));
    }
    componentDidMount() {
      (this.element = this.ref.current),
        setTimeout(() => {
          this.element.parentElement.querySelector(":hover") === this.element &&
            this.onMouseEnter();
        }, 0);
    }
    componentWillUnmount() {
      clearTimeout(this.transitionTimeout),
        cancelAnimationFrame(this.updateCall);
    }
    onMouseEnter(n = () => {}, e) {
      return (
        this.updateElementPosition(),
        this.setState(
          Object.assign({}, this.state, {
            style: nf(tf({}, this.state.style), { willChange: "transform" }),
          })
        ),
        this.setTransition(),
        n(e)
      );
    }
    reset() {
      window.requestAnimationFrame(() => {
        this.setState(
          Object.assign({}, this.state, {
            style: nf(tf({}, this.state.style), {
              transform: `perspective(${this.settings.perspective}px) rotateX(0deg) rotateY(0deg) scale3d(1, 1, 1)`,
            }),
          })
        );
      });
    }
    onMouseMove(n = () => {}, e) {
      return (
        e.persist(),
        this.updateCall !== null &&
          window.cancelAnimationFrame(this.updateCall),
        (this.event = e),
        (this.updateCall = requestAnimationFrame(this.update.bind(this, e))),
        n(e)
      );
    }
    setTransition() {
      clearTimeout(this.transitionTimeout),
        this.setState(
          Object.assign({}, this.state, {
            style: nf(tf({}, this.state.style), {
              transition: `${this.settings.speed}ms ${this.settings.easing}`,
            }),
          })
        ),
        (this.transitionTimeout = setTimeout(() => {
          this.setState(
            Object.assign({}, this.state, {
              style: nf(tf({}, this.state.style), { transition: "" }),
            })
          );
        }, this.settings.speed));
    }
    onMouseLeave(n = () => {}, e) {
      return this.setTransition(), this.settings.reset && this.reset(), n(e);
    }
    getValues(n) {
      const e = (n.nativeEvent.clientX - this.left) / this.width,
        t = (n.nativeEvent.clientY - this.top) / this.height,
        i = Math.min(Math.max(e, 0), 1),
        r = Math.min(Math.max(t, 0), 1),
        s = (
          this.reverse *
          (this.settings.max / 2 - i * this.settings.max)
        ).toFixed(2),
        o = (
          this.reverse *
          (r * this.settings.max - this.settings.max / 2)
        ).toFixed(2),
        a = i * 100,
        l = r * 100;
      return { tiltX: s, tiltY: o, percentageX: a, percentageY: l };
    }
    updateElementPosition() {
      const n = this.element.getBoundingClientRect();
      (this.width = this.element.offsetWidth),
        (this.height = this.element.offsetHeight),
        (this.left = n.left),
        (this.top = n.top);
    }
    update(n) {
      const e = this.getValues(n);
      this.setState(
        Object.assign({}, this.state, {
          style: nf(tf({}, this.state.style), {
            transform: `perspective(${this.settings.perspective}px) rotateX(${
              this.settings.axis === "x" ? 0 : e.tiltY
            }deg) rotateY(${
              this.settings.axis === "y" ? 0 : e.tiltX
            }deg) scale3d(${this.settings.scale}, ${this.settings.scale}, ${
              this.settings.scale
            })`,
          }),
        })
      ),
        (this.updateCall = null);
    }
    render() {
      const n = Object.assign({}, this.props.style, this.state.style);
      return we("div", {
        style: n,
        ref: this.ref,
        className: this.props.className,
        onMouseEnter: this.onMouseEnter,
        onMouseMove: this.onMouseMove,
        onMouseLeave: this.onMouseLeave,
        children: this.props.children,
      });
    }
  };
const NL = (n) => ({
    hidden: { y: -50, opacity: 0 },
    show: {
      y: 0,
      opacity: 1,
      transition: { type: "spring", duration: 1.25, delay: n },
    },
  }),
  OL = (n, e, t, i) => ({
    hidden: {
      x: n === "left" ? 100 : n === "right" ? -100 : 0,
      y: n === "up" ? 100 : n === "down" ? -100 : 0,
      opacity: 0,
    },
    show: {
      x: 0,
      y: 0,
      opacity: 1,
      transition: { type: e, delay: t, duration: i, ease: "easeOut" },
    },
  }),
  wb = (n, e, t, i) => ({
    hidden: {
      x: n === "left" ? "-100%" : n === "right" ? "100%" : 0,
      y: n === "up" || n === "down" ? "100%" : 0,
    },
    show: {
      x: 0,
      y: 0,
      transition: { type: e, delay: t, duration: i, ease: "easeOut" },
    },
  }),
  RJ = (n, e) => ({
    hidden: {},
    show: { transition: { staggerChildren: n, delayChildren: e || 0 } },
  }),
  n0 = (n, e) =>
    function () {
      return St(Zo.section, {
        variants: RJ(),
        initial: "hidden",
        whileInView: "show",
        viewport: { once: !0, amount: 0.25 },
        className: `${Ur.padding} max-w-7xl mx-auto relative z-0`,
        children: [
          we("span", { className: "hash-span", id: e, children: " " }),
          we(n, {}),
        ],
      });
    },
  LJ = ({ index: n, title: e, icon: t }) =>
    we(BJ, {
      className: "xs:w-[250px] w-full",
      children: we(Zo.div, {
        variants: OL("right", "spring", n * 0.5, 0.75),
        className:
          "w-full green-pink-gradient p-[1px] rounded-[20px] shadow-card",
        children: St("div", {
          options: { max: 45, scale: 1, speed: 450 },
          className:
            "bg-tertiary rounded-[20px] py-5 px-12 min-h-[280px] flex justify-evenly items-center flex-col",
          children: [
            we("img", {
              src: t,
              alt: "web-development",
              className: "w-16 h-16 object-contain",
            }),
            we("h3", {
              className: "text-white text-[20px] font-bold text-center",
              children: e,
            }),
          ],
        }),
      }),
    }),
  IJ = () =>
    St(Ob, {
      children: [
        St(Zo.div, {
          variants: NL(),
          children: [
            we("p", { className: Ur.sectionSubText, children: "Introduction" }),
            we("h2", { className: Ur.sectionHeadText, children: "Overview." }),
          ],
        }),
        we(Zo.p, {
          variants: OL("", "", 0.1, 1),
          className: "mt-4 text-secondary text-[17px] max-w-3xl leading-[30px]",
          children:
            "I'm a skilled software developer with experience in Javascript and Python, and expertise in frameworks like React, Node.js, and Next.js. I'm a quick learner and collaborate closely with clients to create efficient, scalable, and user-friendly solutions that solve real-world problems. Let's work together to bring your ideas to life!",
        }),
        we("div", {
          className: "mt-20 flex flex-wrap gap-10",
          children: AJ.map((n, e) => we(LJ, { index: e, ...n }, n.title)),
        }),
      ],
    }),
  DJ = n0(IJ, "about"),
  FJ = () =>
    we("div", {
      className: "flex flex-row flex-wrap justify-center gap-10",
      children: MJ.map((n) =>
        we(
          "div",
          { className: "w-28 h-28", children: we(Y9, { icon: n.icon }) },
          n.name
        )
      ),
    }),
  NJ = n0(FJ, "");
var i0 = {},
  lg = {},
  OJ = {
    get exports() {
      return lg;
    },
    set exports(n) {
      lg = n;
    },
  };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/ (function (n) {
  (function () {
    var e = {}.hasOwnProperty;
    function t() {
      for (var i = [], r = 0; r < arguments.length; r++) {
        var s = arguments[r];
        if (s) {
          var o = typeof s;
          if (o === "string" || o === "number") i.push(s);
          else if (Array.isArray(s)) {
            if (s.length) {
              var a = t.apply(null, s);
              a && i.push(a);
            }
          } else if (o === "object") {
            if (
              s.toString !== Object.prototype.toString &&
              !s.toString.toString().includes("[native code]")
            ) {
              i.push(s.toString());
              continue;
            }
            for (var l in s) e.call(s, l) && s[l] && i.push(l);
          }
        }
      }
      return i.join(" ");
    }
    n.exports ? ((t.default = t), (n.exports = t)) : (window.classNames = t);
  })();
})(OJ);
i0.__esModule = !0;
i0.default = void 0;
var kJ = cM(H),
  yo = cM($m),
  UJ = cM(lg);
function cM(n) {
  return n && n.__esModule ? n : { default: n };
}
const kL = ({
  animate: n = !0,
  className: e = "",
  layout: t = "2-columns",
  lineColor: i = "#FFF",
  children: r,
}) => (
  typeof window == "object" &&
    document.documentElement.style.setProperty("--line-color", i),
  kJ.default.createElement(
    "div",
    {
      className: (0, UJ.default)(e, "vertical-timeline", {
        "vertical-timeline--animate": n,
        "vertical-timeline--two-columns": t === "2-columns",
        "vertical-timeline--one-column-left":
          t === "1-column" || t === "1-column-left",
        "vertical-timeline--one-column-right": t === "1-column-right",
      }),
    },
    r
  )
);
kL.propTypes = {
  children: yo.default.oneOfType([
    yo.default.arrayOf(yo.default.node),
    yo.default.node,
  ]).isRequired,
  className: yo.default.string,
  animate: yo.default.bool,
  layout: yo.default.oneOf([
    "1-column-left",
    "1-column",
    "2-columns",
    "1-column-right",
  ]),
  lineColor: yo.default.string,
};
var zJ = kL;
i0.default = zJ;
var r0 = {};
function j_() {
  return (
    (j_ =
      Object.assign ||
      function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var i in t)
            Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i]);
        }
        return n;
      }),
    j_.apply(this, arguments)
  );
}
function GJ(n, e) {
  (n.prototype = Object.create(e.prototype)),
    (n.prototype.constructor = n),
    X_(n, e);
}
function X_(n, e) {
  return (
    (X_ =
      Object.setPrototypeOf ||
      function (i, r) {
        return (i.__proto__ = r), i;
      }),
    X_(n, e)
  );
}
function HJ(n, e) {
  if (n == null) return {};
  var t = {},
    i = Object.keys(n),
    r,
    s;
  for (s = 0; s < i.length; s++)
    (r = i[s]), !(e.indexOf(r) >= 0) && (t[r] = n[r]);
  return t;
}
var K_ = new Map(),
  $p = new WeakMap(),
  Cb = 0,
  UL = void 0;
function VJ(n) {
  UL = n;
}
function WJ(n) {
  return n
    ? ($p.has(n) || ((Cb += 1), $p.set(n, Cb.toString())), $p.get(n))
    : "0";
}
function JJ(n) {
  return Object.keys(n)
    .sort()
    .filter(function (e) {
      return n[e] !== void 0;
    })
    .map(function (e) {
      return e + "_" + (e === "root" ? WJ(n.root) : n[e]);
    })
    .toString();
}
function jJ(n) {
  var e = JJ(n),
    t = K_.get(e);
  if (!t) {
    var i = new Map(),
      r,
      s = new IntersectionObserver(function (o) {
        o.forEach(function (a) {
          var l,
            c =
              a.isIntersecting &&
              r.some(function (h) {
                return a.intersectionRatio >= h;
              });
          n.trackVisibility && typeof a.isVisible > "u" && (a.isVisible = c),
            (l = i.get(a.target)) == null ||
              l.forEach(function (h) {
                h(c, a);
              });
        });
      }, n);
    (r =
      s.thresholds ||
      (Array.isArray(n.threshold) ? n.threshold : [n.threshold || 0])),
      (t = { id: e, observer: s, elements: i }),
      K_.set(e, t);
  }
  return t;
}
function fM(n, e, t, i) {
  if (
    (t === void 0 && (t = {}),
    i === void 0 && (i = UL),
    typeof window.IntersectionObserver > "u" && i !== void 0)
  ) {
    var r = n.getBoundingClientRect();
    return (
      e(i, {
        isIntersecting: i,
        target: n,
        intersectionRatio: typeof t.threshold == "number" ? t.threshold : 0,
        time: 0,
        boundingClientRect: r,
        intersectionRect: r,
        rootBounds: r,
      }),
      function () {}
    );
  }
  var s = jJ(t),
    o = s.id,
    a = s.observer,
    l = s.elements,
    c = l.get(n) || [];
  return (
    l.has(n) || l.set(n, c),
    c.push(e),
    a.observe(n),
    function () {
      c.splice(c.indexOf(e), 1),
        c.length === 0 && (l.delete(n), a.unobserve(n)),
        l.size === 0 && (a.disconnect(), K_.delete(o));
    }
  );
}
var XJ = [
  "children",
  "as",
  "triggerOnce",
  "threshold",
  "root",
  "rootMargin",
  "onChange",
  "skip",
  "trackVisibility",
  "delay",
  "initialInView",
  "fallbackInView",
];
function Eb(n) {
  return typeof n.children != "function";
}
var ug = (function (n) {
  GJ(e, n);
  function e(i) {
    var r;
    return (
      (r = n.call(this, i) || this),
      (r.node = null),
      (r._unobserveCb = null),
      (r.handleNode = function (s) {
        r.node &&
          (r.unobserve(),
          !s &&
            !r.props.triggerOnce &&
            !r.props.skip &&
            r.setState({ inView: !!r.props.initialInView, entry: void 0 })),
          (r.node = s || null),
          r.observeNode();
      }),
      (r.handleChange = function (s, o) {
        s && r.props.triggerOnce && r.unobserve(),
          Eb(r.props) || r.setState({ inView: s, entry: o }),
          r.props.onChange && r.props.onChange(s, o);
      }),
      (r.state = { inView: !!i.initialInView, entry: void 0 }),
      r
    );
  }
  var t = e.prototype;
  return (
    (t.componentDidUpdate = function (r) {
      (r.rootMargin !== this.props.rootMargin ||
        r.root !== this.props.root ||
        r.threshold !== this.props.threshold ||
        r.skip !== this.props.skip ||
        r.trackVisibility !== this.props.trackVisibility ||
        r.delay !== this.props.delay) &&
        (this.unobserve(), this.observeNode());
    }),
    (t.componentWillUnmount = function () {
      this.unobserve(), (this.node = null);
    }),
    (t.observeNode = function () {
      if (!(!this.node || this.props.skip)) {
        var r = this.props,
          s = r.threshold,
          o = r.root,
          a = r.rootMargin,
          l = r.trackVisibility,
          c = r.delay,
          h = r.fallbackInView;
        this._unobserveCb = fM(
          this.node,
          this.handleChange,
          {
            threshold: s,
            root: o,
            rootMargin: a,
            trackVisibility: l,
            delay: c,
          },
          h
        );
      }
    }),
    (t.unobserve = function () {
      this._unobserveCb && (this._unobserveCb(), (this._unobserveCb = null));
    }),
    (t.render = function () {
      if (!Eb(this.props)) {
        var r = this.state,
          s = r.inView,
          o = r.entry;
        return this.props.children({
          inView: s,
          entry: o,
          ref: this.handleNode,
        });
      }
      var a = this.props,
        l = a.children,
        c = a.as,
        h = HJ(a, XJ);
      return H.createElement(c || "div", j_({ ref: this.handleNode }, h), l);
    }),
    e
  );
})(H.Component);
ug.displayName = "InView";
ug.defaultProps = { threshold: 0, triggerOnce: !1, initialInView: !1 };
function KJ(n) {
  var e = n === void 0 ? {} : n,
    t = e.threshold,
    i = e.delay,
    r = e.trackVisibility,
    s = e.rootMargin,
    o = e.root,
    a = e.triggerOnce,
    l = e.skip,
    c = e.initialInView,
    h = e.fallbackInView,
    d = H.useRef(),
    p = H.useState({ inView: !!c }),
    m = p[0],
    v = p[1],
    A = H.useCallback(
      function (g) {
        d.current !== void 0 && (d.current(), (d.current = void 0)),
          !l &&
            g &&
            (d.current = fM(
              g,
              function (_, S) {
                v({ inView: _, entry: S }),
                  S.isIntersecting &&
                    a &&
                    d.current &&
                    (d.current(), (d.current = void 0));
              },
              {
                root: o,
                rootMargin: s,
                threshold: t,
                trackVisibility: r,
                delay: i,
              },
              h
            ));
      },
      [Array.isArray(t) ? t.toString() : t, o, s, a, l, r, h, i]
    );
  H.useEffect(function () {
    !d.current && m.entry && !a && !l && v({ inView: !!c });
  });
  var x = [A, m.inView, m.entry];
  return (x.ref = x[0]), (x.inView = x[1]), (x.entry = x[2]), x;
}
const YJ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        InView: ug,
        default: ug,
        defaultFallbackInView: VJ,
        observe: fM,
        useInView: KJ,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  QJ = NI(YJ);
r0.__esModule = !0;
r0.default = void 0;
var vo = hM(H),
  qt = hM($m),
  em = hM(lg),
  ZJ = QJ;
function hM(n) {
  return n && n.__esModule ? n : { default: n };
}
const zL = ({
  children: n = "",
  className: e = "",
  contentArrowStyle: t = null,
  contentStyle: i = null,
  date: r = "",
  dateClassName: s = "",
  icon: o = null,
  iconClassName: a = "",
  iconOnClick: l = null,
  onTimelineElementClick: c = null,
  iconStyle: h = null,
  id: d = "",
  position: p = "",
  style: m = null,
  textClassName: v = "",
  intersectionObserverProps: A = {
    rootMargin: "0px 0px -40px 0px",
    triggerOnce: !0,
  },
  visible: x = !1,
}) =>
  vo.default.createElement(ZJ.InView, A, ({ inView: g, ref: _ }) =>
    vo.default.createElement(
      "div",
      {
        ref: _,
        id: d,
        className: (0, em.default)(e, "vertical-timeline-element", {
          "vertical-timeline-element--left": p === "left",
          "vertical-timeline-element--right": p === "right",
          "vertical-timeline-element--no-children": n === "",
        }),
        style: m,
      },
      vo.default.createElement(
        vo.default.Fragment,
        null,
        vo.default.createElement(
          "span",
          {
            style: h,
            onClick: l,
            className: (0, em.default)(a, "vertical-timeline-element-icon", {
              "bounce-in": g || x,
              "is-hidden": !(g || x),
            }),
          },
          o
        ),
        vo.default.createElement(
          "div",
          {
            style: i,
            onClick: c,
            className: (0, em.default)(v, "vertical-timeline-element-content", {
              "bounce-in": g || x,
              "is-hidden": !(g || x),
            }),
          },
          vo.default.createElement("div", {
            style: t,
            className: "vertical-timeline-element-content-arrow",
          }),
          n,
          vo.default.createElement(
            "span",
            { className: (0, em.default)(s, "vertical-timeline-element-date") },
            r
          )
        )
      )
    )
  );
zL.propTypes = {
  children: qt.default.oneOfType([
    qt.default.arrayOf(qt.default.node),
    qt.default.node,
  ]),
  className: qt.default.string,
  contentArrowStyle: qt.default.shape({}),
  contentStyle: qt.default.shape({}),
  date: qt.default.node,
  dateClassName: qt.default.string,
  icon: qt.default.element,
  iconClassName: qt.default.string,
  iconStyle: qt.default.shape({}),
  iconOnClick: qt.default.func,
  onTimelineElementClick: qt.default.func,
  id: qt.default.string,
  position: qt.default.string,
  style: qt.default.shape({}),
  textClassName: qt.default.string,
  visible: qt.default.bool,
  intersectionObserverProps: qt.default.shape({
    root: qt.default.object,
    rootMargin: qt.default.string,
    threshold: qt.default.number,
    triggerOnce: qt.default.bool,
  }),
};
var qJ = zL;
r0.default = qJ;
var GL = { VerticalTimeline: i0.default, VerticalTimelineElement: r0.default };
const $J = ({ experience: n }) =>
    St(GL.VerticalTimelineElement, {
      contentStyle: { background: "#1d1836", color: "#fff" },
      contentArrowStyle: { borderRight: "7px solid  #232631" },
      date: n.date,
      iconStyle: { background: n.iconBg },
      icon: we("div", {
        className: "flex justify-center items-center w-full h-full",
        children: we("img", {
          src: n.icon,
          alt: n.company_name,
          className: "w-[60%] h-[60%] object-contain",
        }),
      }),
      children: [
        St("div", {
          children: [
            we("h3", {
              className: "text-white text-[24px] font-bold",
              children: n.title,
            }),
            we("p", {
              className: "text-secondary text-[16px] font-semibold",
              style: { margin: 0 },
              children: n.company_name,
            }),
          ],
        }),
        we("ul", {
          className: "mt-5 list-disc ml-5 space-y-2",
          children: n.points.map((e, t) =>
            we(
              "li",
              {
                className: "text-white-100 text-[14px] pl-1 tracking-wider",
                children: e,
              },
              `experience-point-${t}`
            )
          ),
        }),
      ],
    }),
  ej = () =>
    St(Ob, {
      children: [
        St(Zo.div, {
          variants: NL(),
          children: [
            we("p", {
              className: `${Ur.sectionSubText} text-center`,
              children: "What I have done so far",
            }),
            we("h2", {
              className: `${Ur.sectionHeadText} text-center`,
              children: "Work Experience.",
            }),
          ],
        }),
        we("div", {
          className: "mt-20 flex flex-col",
          children: we(GL.VerticalTimeline, {
            children: SJ.map((n, e) =>
              we($J, { experience: n }, `experience-${e}`)
            ),
          }),
        }),
      ],
    }),
  tj = n0(ej, "work"),
  nj = () => we("div", {}),
  ij = () => we("div", {}),
  dh = { _origin: "https://api.emailjs.com" },
  rj = (n, e = "https://api.emailjs.com") => {
    (dh._userID = n), (dh._origin = e);
  },
  HL = (n, e, t) => {
    if (!n)
      throw "The public key is required. Visit https://dashboard.emailjs.com/admin/account";
    if (!e)
      throw "The service ID is required. Visit https://dashboard.emailjs.com/admin";
    if (!t)
      throw "The template ID is required. Visit https://dashboard.emailjs.com/admin/templates";
    return !0;
  };
class Tb {
  constructor(e) {
    (this.status = e ? e.status : 0),
      (this.text = e ? e.responseText : "Network Error");
  }
}
const VL = (n, e, t = {}) =>
    new Promise((i, r) => {
      const s = new XMLHttpRequest();
      s.addEventListener("load", ({ target: o }) => {
        const a = new Tb(o);
        a.status === 200 || a.text === "OK" ? i(a) : r(a);
      }),
        s.addEventListener("error", ({ target: o }) => {
          r(new Tb(o));
        }),
        s.open("POST", dh._origin + n, !0),
        Object.keys(t).forEach((o) => {
          s.setRequestHeader(o, t[o]);
        }),
        s.send(e);
    }),
  sj = (n, e, t, i) => {
    const r = i || dh._userID;
    return (
      HL(r, n, e),
      VL(
        "/api/v1.0/email/send",
        JSON.stringify({
          lib_version: "3.10.0",
          user_id: r,
          service_id: n,
          template_id: e,
          template_params: t,
        }),
        { "Content-type": "application/json" }
      )
    );
  },
  oj = (n) => {
    let e;
    if (
      (typeof n == "string" ? (e = document.querySelector(n)) : (e = n),
      !e || e.nodeName !== "FORM")
    )
      throw "The 3rd parameter is expected to be the HTML form element or the style selector of form";
    return e;
  },
  aj = (n, e, t, i) => {
    const r = i || dh._userID,
      s = oj(t);
    HL(r, n, e);
    const o = new FormData(s);
    return (
      o.append("lib_version", "3.10.0"),
      o.append("service_id", n),
      o.append("template_id", e),
      o.append("user_id", r),
      VL("/api/v1.0/email/send-form", o)
    );
  },
  lj = { init: rj, send: sj, sendForm: aj },
  uj = () => {
    const n = H.useRef(),
      [e, t] = H.useState({ name: "", email: "", message: "" }),
      [i, r] = H.useState(!1),
      s = (a) => {
        const { target: l } = a,
          { name: c, value: h } = l;
        t({ ...e, [c]: h });
      },
      o = (a) => {
        a.preventDefault(),
          r(!0),
          lj
            .send(
              {}.VITE_APP_EMAILJS_SERVICE_ID,
              {}.VITE_APP_EMAILJS_TEMPLATE_ID,
              {
                from_name: e.name,
                to_name: "Moeez Ramay",
                from_email: e.email,
                to_email: "ashermotaaaaa@gmail.com",
                message: e.message,
              },
              {}.VITE_APP_EMAILJS_PUBLIC_KEY
            )
            .then(
              () => {
                r(!1),
                  alert(
                    "Thank you. I will get back to you as soon as possible."
                  ),
                  t({ name: "", email: "", message: "" });
              },
              (l) => {
                r(!1),
                  console.error(l),
                  alert("Ahh, something went wrong. Please try again.");
              }
            );
      };
    return St("div", {
      className:
        "xl:mt-12 flex xl:flex-row flex-col-reverse gap-10 overflow-hidden",
      children: [
        St(Zo.div, {
          variants: wb("left", "tween", 0.2, 1),
          className: "flex-[0.75] bg-black-100 p-8 rounded-2xl",
          children: [
            we("p", { className: Ur.sectionSubText, children: "Get in touch" }),
            we("h3", { className: Ur.sectionHeadText, children: "Contact." }),
            St("form", {
              ref: n,
              onSubmit: o,
              className: "mt-12 flex flex-col gap-8",
              children: [
                St("label", {
                  className: "flex flex-col",
                  children: [
                    we("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your Name",
                    }),
                    we("input", {
                      type: "text",
                      name: "name",
                      value: e.name,
                      onChange: s,
                      placeholder: "What's your good name?",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                  ],
                }),
                St("label", {
                  className: "flex flex-col",
                  children: [
                    we("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your email",
                    }),
                    we("input", {
                      type: "email",
                      name: "email",
                      value: e.email,
                      onChange: s,
                      placeholder: "What's your web address?",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                  ],
                }),
                St("label", {
                  className: "flex flex-col",
                  children: [
                    we("span", {
                      className: "text-white font-medium mb-4",
                      children: "Your Message",
                    }),
                    we("textarea", {
                      rows: 7,
                      name: "message",
                      value: e.message,
                      onChange: s,
                      placeholder: "What you want to say?",
                      className:
                        "bg-tertiary py-4 px-6 placeholder:text-secondary text-white rounded-lg outline-none border-none font-medium",
                    }),
                  ],
                }),
                we("button", {
                  type: "submit",
                  className:
                    "bg-tertiary py-3 px-8 rounded-xl outline-none w-fit text-white font-bold shadow-md shadow-primary",
                  children: i ? "Sending..." : "Send",
                }),
              ],
            }),
          ],
        }),
        we(Zo.div, {
          variants: wb("right", "tween", 0.2, 1),
          className: "xl:flex-1 xl:h-auto md:h-[550px] h-[350px]",
          children: we(X9, {}),
        }),
      ],
    });
  },
  cj = n0(uj, "contact"),
  fj = () =>
    we(FN, {
      children: St("div", {
        className: "relative z-0 bg-primary",
        children: [
          St("div", {
            className: "bg-hero-pattern bg-cover bg-no-repeat bg-center",
            children: [we(wJ, {}), we(oJ, {})],
          }),
          we(DJ, {}),
          we(tj, {}),
          we(NJ, {}),
          we(nj, {}),
          we(ij, {}),
          St("div", {
            className: "relative z-0",
            children: [we(cj, {}), we($9, {})],
          }),
        ],
      }),
    });
zv.createRoot(document.getElementById("root")).render(
  we(mh.StrictMode, { children: we(fj, {}) })
);
